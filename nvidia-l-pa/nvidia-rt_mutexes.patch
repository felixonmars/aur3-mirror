diff -Naur a/nv.c b/nv.c
--- a/nv.c	2012-12-04 23:42:53.000000000 +0100
+++ b/nv.c	2012-12-04 20:57:00.000000000 +0100
@@ -1288,7 +1288,7 @@
 
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_open on device "
               "bearing minor number %d\n", minor_num);
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
 
     NV_CHECK_PCI_CONFIG_SPACE(sp, nv, TRUE, TRUE, NV_MAY_SLEEP());
 
@@ -1455,7 +1455,7 @@
     NV_ATOMIC_INC(nvl->usage_count);
 
 failed:
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
     if (rc != 0)
     {
@@ -1524,7 +1524,7 @@
 
     rm_free_unused_clients(sp, nv, nvfp);
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
     if (NV_ATOMIC_DEC_AND_TEST(nvl->usage_count))
     {
         if (NV_IS_GVI_DEVICE(nv))
@@ -1565,7 +1565,7 @@
         /* leave INIT flag alone so we don't reinit every time */
         nv->flags &= ~NV_FLAG_OPEN;
     }
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
     for (i = 0; i < NV_FOPS_STACK_INDEX_COUNT; ++i)
     {
@@ -1637,7 +1637,7 @@
     nv_printf(NV_DBG_INFO, "NVRM: ioctl(0x%x, 0x%x, 0x%x)\n",
         _IOC_NR(cmd), (unsigned int) i_arg, _IOC_SIZE(cmd));
 
-    down(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
+    mutex_lock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
     sp = nvfp->fops_sp[NV_FOPS_STACK_INDEX_IOCTL];
 
     NV_CHECK_PCI_CONFIG_SPACE(sp, nv, TRUE, TRUE, NV_MAY_SLEEP());
@@ -1789,7 +1789,7 @@
     }
 
 done:
-    up(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
+    mutex_unlock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_IOCTL]);
 
     if (arg_copy != NULL)
     {
@@ -1907,7 +1907,7 @@
 
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_ctl_open\n");
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
 
     /* save the nv away in file->private_data */
     nvfp->nvptr = nvl;
@@ -1927,7 +1927,7 @@
     }
 
     NV_ATOMIC_INC(nvl->usage_count);
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
     return 0;
 }
@@ -1952,7 +1952,7 @@
 
     nv_printf(NV_DBG_INFO, "NVRM: nvidia_ctl_close\n");
 
-    down(&nvl->ldata_lock);
+    mutex_lock(&nvl->ldata_lock);
     if (NV_ATOMIC_DEC_AND_TEST(nvl->usage_count))
     {
         nv->flags &= ~NV_FLAG_OPEN;
@@ -1964,7 +1964,7 @@
                 "NVRM: failed to unregister from the ACPI subsystem!\n");
         }
     }
-    up(&nvl->ldata_lock);
+    mutex_unlock(&nvl->ldata_lock);
 
     rm_free_unused_clients(sp, nv, nvfp);
 
@@ -2341,9 +2341,9 @@
     }
 
     nvfp->event_pending = TRUE;
-    wake_up_interruptible(&nvfp->waitqueue);
-
     NV_SPIN_UNLOCK_IRQRESTORE(&nvfp->fp_lock, eflags);
+
+    wake_up_interruptible(&nvfp->waitqueue);
 }
 
 int NV_API_CALL nv_get_event(
diff -Naur a/nv-linux.h b/nv-linux.h
--- a/nv-linux.h	2013-12-04 23:42:53.000000000 +0100
+++ b/nv-linux.h	2013-12-04 20:57:00.000000000 +0100
@@ -139,11 +139,6 @@
 #endif
 
 #include <linux/spinlock.h>
-#if defined(NV_LINUX_SEMAPHORE_H_PRESENT)
-#include <linux/semaphore.h>
-#else
-#include <asm/semaphore.h>
-#endif
 #include <linux/completion.h>
 #include <linux/highmem.h>
 
@@ -947,19 +942,7 @@
     return ret;
 }
 
-#if defined(CONFIG_PREEMPT_RT_FULL)
-#define NV_INIT_MUTEX(mutex) sema_init(mutex,1)
-#else
-#if !defined(__SEMAPHORE_INITIALIZER) && defined(__COMPAT_SEMAPHORE_INITIALIZER)
-#define __SEMAPHORE_INITIALIZER __COMPAT_SEMAPHORE_INITIALIZER
-#endif
-#define NV_INIT_MUTEX(mutex)                       \
-    {                                              \
-        struct semaphore __mutex =                 \
-            __SEMAPHORE_INITIALIZER(*(mutex), 1);  \
-        *(mutex) = __mutex;                        \
-    }
-#endif
+#define NV_INIT_MUTEX(mutex) mutex_init(mutex)
 
 #if !defined(NV_VMWARE)
 #if defined(NV_GET_NUM_PHYSPAGES_PRESENT)
@@ -1506,7 +1489,7 @@
     struct timer_list rc_timer;
 
     /* lock for linux-specific data, not used by core rm */
-    struct semaphore ldata_lock;
+    struct mutex ldata_lock;
 
     NvU32 minor_num;
     struct nv_linux_state_s *next;
@@ -1569,7 +1552,7 @@
 {
     nv_stack_t *sp;
     nv_stack_t *fops_sp[NV_FOPS_STACK_INDEX_COUNT];
-    struct semaphore fops_sp_lock[NV_FOPS_STACK_INDEX_COUNT];
+    struct mutex fops_sp_lock[NV_FOPS_STACK_INDEX_COUNT];
     nv_alloc_t *free_list;
     void *nvptr;
     void *proc_data;
diff -Naur a/nv-mmap.c b/nv-mmap.c
--- a/nv-mmap.c	2013-12-04 23:42:53.000000000 +0100
+++ b/nv-mmap.c	2013-03-04 20:57:00.000000000 +0100
@@ -233,7 +233,7 @@
 
     NV_PRINT_VMA(NV_DBG_MEMINFO, vma);
 
-    down(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
+    mutex_lock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
     sp = nvfp->fops_sp[NV_FOPS_STACK_INDEX_MMAP];
 
     NV_CHECK_PCI_CONFIG_SPACE(sp, nv, TRUE, TRUE, NV_MAY_SLEEP());
@@ -366,6 +366,6 @@
         rm_release_api_lock(sp);
 
 done:
-    up(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
+    mutex_unlock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_MMAP]);
     return status;
 }
diff -Naur a/os-interface.c b/os-interface.c
--- a/os-interface.c	2012-03-19 23:42:53.000000000 +0100
+++ b/os-interface.c	2012-03-20 21:06:25.000000000 +0100
@@ -26,7 +26,7 @@
     return RM_OK;
 }
 
-typedef struct semaphore os_mutex_t;
+typedef struct mutex os_mutex_t;
 
 //
 // os_alloc_mutex - Allocate the RM mutex
@@ -87,7 +87,7 @@
     {
         return RM_ERR_INVALID_REQUEST;
     }
-    down(os_mutex);
+    mutex_lock(os_mutex);
 
     return RM_OK;
 }
@@ -118,7 +118,7 @@
 )
 {
     os_mutex_t *os_mutex = (os_mutex_t *)pMutex;
-    up(os_mutex);
+    mutex_unlock(os_mutex);
 }
 
 typedef struct os_semaphore_s
--- a/nv-frontend.c	2013-12-03 23:27:15.289577015 -0500
+++ b/nv-frontend.c	2013-12-03 23:26:58.658576157 -0500
@@ -31,7 +31,7 @@
 static NvU32 nv_num_instances;
 
 // lock required to protect table.
-struct semaphore nv_module_table_lock;
+struct mutex nv_module_table_lock;
 
 // minor number table
 nvidia_module_t *nv_minor_num_table[NV_FRONTEND_CONTROL_DEVICE_MINOR_MAX + 1];
@@ -83,7 +83,7 @@
     NvU32 i, ctrl_minor_num;
     nv_linux_state_t *device = NULL;
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
 
     if (module->instance >= NV_MAX_MODULE_INSTANCES)
     {
@@ -111,7 +111,7 @@
     nv_num_instances++;
     rc = 0;
 done:
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
 
     return rc;
 }
@@ -122,7 +122,7 @@
     NvU32 ctrl_minor_num;
     nv_linux_state_t *device = module->nv_linux_devices;
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
 
     ctrl_minor_num = NV_FRONTEND_CONTROL_DEVICE_MINOR_MAX - module->instance;
     if (nv_minor_num_table[ctrl_minor_num] == NULL)
@@ -146,7 +146,7 @@
         nv_num_instances--;
     }
 
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
 
     return rc;
 }
@@ -164,7 +164,7 @@
 
     NvU32 minor_num = NV_FRONTEND_MINOR_NUMBER(inode);
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
     module = nv_minor_num_table[minor_num];
 
     if ((module != NULL) && (module->open != NULL))
@@ -173,7 +173,7 @@
         // nvidia-frontend.ko does not get unloaded before the nvidiaN.ko modules.
         if (NV_BUILD_MODULE_INSTANCES != 0 && !try_module_get(module->owner))
         {
-            up(&nv_module_table_lock);
+            mutex_unlock(&nv_module_table_lock);
             return -ENODEV;
         }
         rc = module->open(inode, file);
@@ -182,7 +182,7 @@
                     __FUNCTION__, minor_num, rc);
     }
 
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
     return rc;
 }
 
@@ -196,7 +196,7 @@
 
     NvU32 minor_num = NV_FRONTEND_MINOR_NUMBER(inode);
 
-    down(&nv_module_table_lock);
+    mutex_lock(&nv_module_table_lock);
     module = nv_minor_num_table[minor_num];
 
     if ((module != NULL) && (module->close != NULL))
@@ -213,7 +213,7 @@
         }
     }
 
-    up(&nv_module_table_lock);
+    mutex_unlock(&nv_module_table_lock);
     return rc;
 }
 
--- a/nv-procfs.c	2013-10-30 20:15:05.000000000 -0400
+++ b/nv-procfs.c	2013-12-04 11:56:03.067894803 -0500
@@ -354,7 +354,7 @@
     char *proc_buffer;
     unsigned long bytes_left;
 
-    down(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
+    mutex_lock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
 
     bytes_left = (NV_PROC_WRITE_BUFFER_SIZE - nvfp->off - 1);
 
@@ -384,7 +384,7 @@
     *pos = nvfp->off;
 
 done:
-    up(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
+    mutex_unlock(&nvfp->fops_sp_lock[NV_FOPS_STACK_INDEX_PROCFS]);
 
     return ((status < 0) ? status : (int)count);
 }
