From 62b3f820cb371a6fe71172a542d79abb43b3020a Mon Sep 17 00:00:00 2001
From: Marc Dionne <marc.c.dionne@gmail.com>
Date: Wed, 9 Jan 2013 19:26:54 -0500
Subject: [PATCH] Linux 3.8: session_keyring changes

The session_keyring is now attached directly to the cred structure
and the thread_group_cred structure (cred->tgcred) no longer exists.

Adapt code that makes use of tgcred, and use the standard rcu based
mechanism to update session_keyring.

Reviewed-on: http://gerrit.openafs.org/8905
Reviewed-by: Andrew Deason <adeason@sinenomine.net>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Derrick Brashear <shadow@your-file-system.com>
(cherry picked from commit c6d27e322a8d3b352554650473a048235a9c763a)

Change-Id: If0998ee777ab0d196e19162499eb3ee60c5ff85d

Linux 3.8: vmtruncate removal

vmtruncate had been deprecated for a while and has now been
removed.  Do things the new way based on truncate_setsize.

Reviewed-on: http://gerrit.openafs.org/8906
Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Derrick Brashear <shadow@your-file-system.com>
(cherry picked from commit d0479bbaf43900d6733c3f7517926ee9813c9610)

Change-Id: Iafc64e19544dec9fcaefad5ad274eac4133f4083

Linux: setpag() may replace credentials

For recent Linux. setpag() may replace the current process' cred
structure with a new one.  This is not a problem for most callers,
but in the case of processing a SetTokens2 pioctl with the setpag
option, the new credentials should be used to determine the target
for the token.

Reviewed-on: http://gerrit.openafs.org/8924
Reviewed-by: Chas Williams - CONTRACTOR <chas@cmf.nrl.navy.mil>
Tested-by: BuildBot <buildbot@rampaginggeek.com>
Reviewed-by: Derrick Brashear <shadow@your-file-system.com>
(cherry picked from commit b61eac783e8c092cd4ba9f53a2b5ca7d43e08b1b)

Change-Id: I66b5f171318964ff40fe78be24e75519183c3a82
---
 acinclude.m4                |  2 ++
 src/afs/LINUX/osi_compat.h  | 48 +++++++++++++++++++++++++++++++++++++++++++--
 src/afs/LINUX/osi_groups.c  |  9 ++-------
 src/afs/LINUX/osi_machdep.h |  9 +++++++--
 src/afs/LINUX/osi_vm.c      |  5 ++---
 src/afs/afs_pioctl.c        |  8 ++++++++
 6 files changed, 67 insertions(+), 14 deletions(-)

diff --git a/acinclude.m4 b/acinclude.m4
index 8c57779..4223bb1 100644
--- a/acinclude.m4
+++ b/acinclude.m4
@@ -812,6 +812,7 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 				       [write_begin], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([backing_dev_info], [name],
 				       [backing-dev.h])
+		 AC_CHECK_LINUX_STRUCT([cred], [session_keyring], [cred.h])
 		 AC_CHECK_LINUX_STRUCT([ctl_table], [ctl_name], [sysctl.h])
 		 AC_CHECK_LINUX_STRUCT([dentry_operations], [d_automount], [dcache.h])
 		 AC_CHECK_LINUX_STRUCT([inode], [i_alloc_sem], [fs.h])
@@ -823,6 +824,7 @@ case $AFS_SYSNAME in *_linux* | *_umlinux*)
 		 AC_CHECK_LINUX_STRUCT([file_operations], [sendfile], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([file_system_type], [mount], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([filename], [name], [fs.h])
+		 AC_CHECK_LINUX_STRUCT([inode_operations], [truncate], [fs.h])
 		 AC_CHECK_LINUX_STRUCT([key_type], [preparse], [key-type.h])
 		 AC_CHECK_LINUX_STRUCT([nameidata], [path], [namei.h])
 		 AC_CHECK_LINUX_STRUCT([proc_dir_entry], [owner], [proc_fs.h])
diff --git a/src/afs/LINUX/osi_compat.h b/src/afs/LINUX/osi_compat.h
index 2dda136..e8bf003 100644
--- a/src/afs/LINUX/osi_compat.h
+++ b/src/afs/LINUX/osi_compat.h
@@ -186,14 +186,24 @@ afs_linux_key_alloc(struct key_type *type, const char *desc, uid_t uid,
 }
 
 # if defined(STRUCT_TASK_STRUCT_HAS_CRED)
+static inline struct key *
+afs_session_keyring(afs_ucred_t *cred)
+{
+#  if defined(STRUCT_CRED_HAS_SESSION_KEYRING)
+    return cred->session_keyring;
+#  else
+    return cred->tgcred->session_keyring;
+#  endif
+}
+
 static inline struct key*
 afs_linux_search_keyring(afs_ucred_t *cred, struct key_type *type)
 {
     key_ref_t key_ref;
 
-    if (cred->tgcred->session_keyring) {
+    if (afs_session_keyring(cred)) {
 	key_ref = keyring_search(
-		      make_key_ref(cred->tgcred->session_keyring, 1),
+		      make_key_ref(afs_session_keyring(cred), 1),
 		      type, "_pag");
 	if (IS_ERR(key_ref))
 	    return ERR_CAST(key_ref);
@@ -507,4 +517,38 @@ afs_set_name(afs_name_t aname, char *string) {
 }
 #endif
 
+static_inline struct key *
+afs_set_session_keyring(struct key *keyring)
+{
+    struct key *old;
+#if defined(STRUCT_CRED_HAS_SESSION_KEYRING)
+    struct cred *new_creds;
+    old = current_session_keyring();
+    new_creds = prepare_creds();
+    rcu_assign_pointer(new_creds->session_keyring, keyring);
+    commit_creds(new_creds);
+#else
+    spin_lock_irq(&current->sighand->siglock);
+    old = task_session_keyring(current);
+    smp_wmb();
+    task_session_keyring(current) = keyring;
+    spin_unlock_irq(&current->sighand->siglock);
+#endif
+    return old;
+}
+
+static inline int
+afs_truncate(struct inode *inode, int len)
+{
+    int code;
+#if defined(STRUCT_INODE_OPERATIONS_HAS_TRUNCATE)
+    code = vmtruncate(inode, len);
+#else
+    code = inode_newsize_ok(inode, len);
+    if (!code)
+        truncate_setsize(inode, len);
+#endif
+    return code;
+}
+
 #endif /* AFS_LINUX_OSI_COMPAT_H */
diff --git a/src/afs/LINUX/osi_groups.c b/src/afs/LINUX/osi_groups.c
index c2a0308..e351344 100644
--- a/src/afs/LINUX/osi_groups.c
+++ b/src/afs/LINUX/osi_groups.c
@@ -214,14 +214,9 @@ install_session_keyring(struct key *keyring)
     }
 
     /* install the keyring */
-    spin_lock_irq(&current->sighand->siglock);
-    old = task_session_keyring(current);
-    smp_wmb();
-    task_session_keyring(current) = keyring;
-    spin_unlock_irq(&current->sighand->siglock);
-
+    old = afs_set_session_keyring(keyring);
     if (old)
-	    key_put(old);
+	key_put(old);
 
 out:
     return code;
diff --git a/src/afs/LINUX/osi_machdep.h b/src/afs/LINUX/osi_machdep.h
index a2c16f5..4a02208 100644
--- a/src/afs/LINUX/osi_machdep.h
+++ b/src/afs/LINUX/osi_machdep.h
@@ -179,8 +179,13 @@ afs_set_cr_group_info(cred_t *cred, struct group_info *group_info) {
 #define current_group_info() (current->cred->group_info)
 #define task_gid(task) (task->cred->gid)
 #define task_user(task) (task->cred->user)
-#define task_session_keyring(task) (task->cred->tgcred->session_keyring)
-#define current_session_keyring() (current->cred->tgcred->session_keyring)
+#if defined(STRUCT_CRED_HAS_SESSION_KEYRING)
+# define task_session_keyring(task) (task->cred->session_keyring)
+# define current_session_keyring() (current->cred->session_keyring)
+#else
+# define task_session_keyring(task) (task->cred->tgcred->session_keyring)
+# define current_session_keyring() (current->cred->tgcred->session_keyring)
+#endif
 
 #else
 
diff --git a/src/afs/LINUX/osi_vm.c b/src/afs/LINUX/osi_vm.c
index 2cd34f9..8bc792e 100644
--- a/src/afs/LINUX/osi_vm.c
+++ b/src/afs/LINUX/osi_vm.c
@@ -51,8 +51,7 @@ osi_VM_FlushVCache(struct vcache *avc, int *slept)
     if (avc->opens != 0)
 	return EBUSY;
 
-    return vmtruncate(ip, 0);
-    return 0;
+    return afs_truncate(ip, 0);
 }
 
 /* Try to invalidate pages, for "fs flush" or "fs flushv"; or
@@ -132,5 +131,5 @@ osi_VM_FlushPages(struct vcache *avc, afs_ucred_t *credp)
 void
 osi_VM_Truncate(struct vcache *avc, int alen, afs_ucred_t *acred)
 {
-    vmtruncate(AFSTOV(avc), alen);
+    afs_truncate(AFSTOV(avc), alen);
 }
diff --git a/src/afs/afs_pioctl.c b/src/afs/afs_pioctl.c
index 3c01be5..98919a3 100644
--- a/src/afs/afs_pioctl.c
+++ b/src/afs/afs_pioctl.c
@@ -1859,6 +1859,9 @@ DECL_PIOCTL(PSetTokens)
     afs_PutCell(tcell, READ_LOCK);
     if (set_parent_pag) {
 	afs_uint32 pag;
+#if defined(AFS_LINUX26_ENV)
+	afs_ucred_t *old_cred = *acred;
+#endif
 #if defined(AFS_DARWIN_ENV) || defined(AFS_XBSD_ENV)
 	char procname[256];
 	osi_procname(procname, 256);
@@ -1868,6 +1871,11 @@ DECL_PIOCTL(PSetTokens)
 #else
 	if (!setpag(acred, -1, &pag, 1)) {
 #endif
+#if defined(AFS_LINUX26_ENV)
+	    /* setpag() may have changed our credentials */
+	    *acred = crref();
+	    crfree(old_cred);
+#endif
 	    afs_InitReq(&treq, *acred);
 	    areq = &treq;
 	}
-- 
1.8.1.5

