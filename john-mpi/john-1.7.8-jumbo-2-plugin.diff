diff -rupN john-1.7.8/README-jumbo john-1.7.8-jumbo-2/README-jumbo
--- john-1.7.8/README-jumbo	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/README-jumbo	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,17 @@
+The jumbo patch, which has been applied to this source tree of John the
+Ripper, adds a lot of code, documentation, and data contributed by the
+user community.  This is not "official" John the Ripper code.  It is
+very easy for new code to be added to the jumbo patch: the quality
+requirements are low.  This means that you get a lot of functionality
+that is not "mature" enough or is otherwise inappropriate for the
+official JtR, which in turn also means that bugs in this code are to be
+expected, etc.
+
+If you have any comments on this release or on JtR in general, please
+join the john-users mailing list and post in there.
+
+Licensing info:
+http://openwall.info/wiki/john/licensing
+
+How to contribute more code:
+http://openwall.info/wiki/how-to-make-patches
diff -rupN john-1.7.8/doc/EPi.patch.README john-1.7.8-jumbo-2/doc/EPi.patch.README
--- john-1.7.8/doc/EPi.patch.README	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/EPi.patch.README	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,33 @@
+= Intro
+=======
+
+EPiServer is a popular webbased content management system from Elektropost (http://www.episerver.com).
+You can dump the password hashes using the SQL syntax "select name, salt, hash from tblSID". The tblSID
+tabel stores interesting things such as usernames, salt and password hashes, but also passwords in cleartext.
+If a password can be found in cleartext it is found in the password column of tblSID.
+
+= Install
+=========
+
+Copy the epibf_X.Y-john_1.7.2.patch (where X and Y needs to be replaced with the version you downloaded)
+to your john source directory, e.g. john-1.7.2/src and then run "patch -p2 < epibf_X.Y-john_1.7.2.patch" (remember the X and Y).
+The patch will create a file called EPI_fmt.c, some files for SHA1 support as well as update some of johns
+files in order to incorporate the patch with john.
+
+= Usage
+=======
+
+This patch needs the format of the password file to be: <user>:<salt> <hash>. (Currently you need to include
+an inital 0x of both salt and hash.)
+
+--- Contents of an example epipasswd file ---
+
+webadmin:0x6631F625DEC28716FC24FA3CC1B3E2055E4281F4465226905C10D3456035 0x4F25D9BD24B81D85B1F2D106037C71CD2C828168
+epiuser:0x48F9BA13F54CE7AF669C76EEBC6BEA4564EBB77F1866CA5F2B297F7159C1 0xDA4260812C195025B4442C5C84E0F890122B285A
+
+-------------- End --------------------------
+
+You can then run "john epipasswd", the format will be autodetected.
+In case you'd like to check the performance of the patch try "john --test --format:epi".
+
+-johannes
diff -rupN john-1.7.8/doc/HDAA_README john-1.7.8-jumbo-2/doc/HDAA_README
--- john-1.7.8/doc/HDAA_README	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/HDAA_README	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,38 @@
+                  HTTP Digest access authentication
+                  ---------------------------------
+
+
+
+- How to create the password string :
+-------------------------------------
+
+
+user:$MAGIC$response$user$realm$method$uri$nonce$nonceCount$ClientNonce$qop
+
+'$' is use as separator, you can change it in HDAA_fmt.c
+
+
+Example of password string :
+
+user:$response$679066476e67b5c7c4e88f04be567f8b$user$myrealm$GET$/$8c12bd8f728afe56d45a0ce846b70e5a$00000001$4b61913cec32e2c9$auth
+
+Here the magic is '$response$'
+
+
+
+
+
+- Demonstration :
+-----------------
+
+Tested on a : AMD Athlon(tm) 64 Processor 3000+
+
+$ cat ./htdigest
+moi:$response$faa6cb7d676e5b7c17fcbf966436aa0c$moi$myrealm$GET$/$af32592775d27b1cd06356b3a0db9ddf$00000001$8e1d49754a25aea7$auth
+user:$response$679066476e67b5c7c4e88f04be567f8b$user$myrealm$GET$/$8c12bd8f728afe56d45a0ce846b70e5a$00000001$4b61913cec32e2c9$auth
+
+$ ./john ./htdigest
+Loaded 2 password hashes with 2 different salts (HTTP Digest access authentication [HDAA-MD5])
+kikou            (moi)
+nocode           (user)
+guesses: 2  time: 0:00:01:27 (3)  c/s: 670223  trying: nocode
diff -rupN john-1.7.8/doc/LICENSE.mpi john-1.7.8-jumbo-2/doc/LICENSE.mpi
--- john-1.7.8/doc/LICENSE.mpi	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/LICENSE.mpi	2011-06-02 17:25:28.000000000 +0200
@@ -0,0 +1,4 @@
+This patch for John the Ripper MPI implementation is a continuation of
+Ryan Lim's original patch against 1.6.x, later maintained by John
+Anderson at bindshell.net, and modified by AoZ and magnum.  It is
+licensed under the same terms as John the Ripper itself.
diff -rupN john-1.7.8/doc/MARKOV john-1.7.8-jumbo-2/doc/MARKOV
--- john-1.7.8/doc/MARKOV	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/MARKOV	2011-06-02 17:25:28.000000000 +0200
@@ -0,0 +1,122 @@
+BASIC USAGE
+The Markov mode is based from [1], tested and applied to "classical" password
+cracking in [2]. This mode similar to the "wordlist" mode because it will only
+crack a fixed quantity of passwords. Its parameters are:
+
+--markov:LEVEL:START:END:LENGTH
+
+Where:
+* LEVEL is the "Markov level". This value is the maximum strength of passwords
+that are going to be cracked. When LEVEL increases, the quantity of passwords
+that are going to be tested increases exponentially.
+* START is the index of the first password that is going to be tested, starting
+with 0.
+* END is the index of the last password that is going to be tested. When it is
+set to 0, it will represent the last possible password.
+* LENGTH is the maximum length of the tested passwords.
+
+using --markov:100:0:0:12 will let john check every password whose length is 12
+or less and whose "Markov strength" is 100 or less.
+
+
+SELECTING THE PARAMETERS
+The "LEVEL" parameter should be selected based on the desired maximum running
+time. In order to select the appropriate LEVEL, the following steps should be
+followed:
+1/ Run the -single and -wordlist modes of john, as they will find many passwords
+for a low price
+2/ Run john with a low markov level on the file, using the time utility. For
+example:
+*******************************************************************************
+time john -markov:180 test
+Loaded 156 password hashes with no different salts (NT LM DES [128/128 BS SSE2])
+Warning: MaxLen = 12 is too large for the current hash type, reduced to 7
+MKV start (lvl=180 len=7 pwd=30449568)
+guesses: 0  time: 0:00:00:10 99%  c/s: 475013K  trying:
+
+real    0m10.707s
+user    0m10.621s
+sys     0m0.012s
+*******************************************************************************
+This means that john can test 2.8M (30449568/10.707) passwords / seconds. It
+should be noted that with salted passwords the cracking speed will increase with
+every cracked password. This number should be corrected based on the experience
+of the user.
+3/ Evaluate the quantity of passwords that could be cracked during the selected
+time. Using the previous example, a cracking time of 3 hours will lead to a
+quantity of passwords of 30714M passwords (30449568/10.707*3600*3).
+4/ Use the genmkpwd command to find the corresponding level. Using the previous
+example, with a maximum password length of 12 (stupid because LM has a maximum
+length of 7 ...):
+*******************************************************************************
+genmkvpwd stats 0 12
+[...]
+lvl=245 (5904 Kb for nbparts) 26 G possible passwords (26528306250)
+lvl=246 (5928 Kb for nbparts) 29 G possible passwords (29373638087)
+lvl=247 (5952 Kb for nbparts) 32 G possible passwords (32524537496)
+[...]
+*******************************************************************************
+Here, the selected level will be 246 (the higher level where the number of
+possible passwords is less than 30714M).
+5/ Run john:
+*******************************************************************************
+john -markov:246:0:0:12 test
+*******************************************************************************
+
+
+DISTRIBUTING WORK
+The START and END parameter could be used to distribute work among many CPUs.
+The preferred method is to evaluate the combined cracking speed of all CPUs
+(adding the step 2 result for every CPUs available) and follow the previous
+method.
+At step 5, share the cracking space among all CPUs, where is share is
+proportionnal with the CPU's cracking speed.
+
+
+CONFIGURATION OPTIONS
+New options are available in the john.conf file:
+Statsfile - This is the path of the "stat" file.
+MkvLvl - the default level
+MkvMaxLen - the default length
+
+
+WHAT IS THE STAT FILE?
+The markov mode is based on statistical data from real passwords. This data is
+stored in the "stat" file. In order to generate a custom stat file, it is
+recommanded to use the new calc_stat command:
+
+./calc_stat "dictionnary file" stats
+
+
+MKVCALCPROBA USAGE
+This program is used to generate statistics about cracked passwords. It accepts
+as input the "stat" file and a file with a single cracked password per line.
+Here is a sample output:
+
+*******************************************************************************
+./mkvcalcproba stats /tmp/passwordlist
+test    33+16+28+20     97      4       40030907        45
+password        29+16+30+22+51+25+24+30 227     8       2698006565378672        177
+32'[[!  55+24+98+1000+23+29     1229    6       39949021871     1169
+charsetsize = 92
+*******************************************************************************
+
+Its output is tab separated and should open nicely in spreadsheets. Here is the
+meaning of the column:
+1/ Cracked password, reprinted from the file
+2/ Sum of all "markov probabilities" of every letter of the word. This is
+supposed to help identify which parts of the password makes them strong. The
+number "1000" is written when no 1st/2nd letter combinations were found in the
+stat file (for exemple ' then [ here).
+3/ Markov strength
+4/ Password length
+5/ Rank when bruteforced "stupidly" (a, b, c, ..., aa, ab, ac ...) considering
+that letters are ordered given their appearance probability and the given
+charsetsize (92)
+6/ Markov strength of the password where the two first letters are removed
+
+
+REFERENCES
+
+[1] http://www.cs.utexas.edu/~shmat/shmat_ccs05pwd.ps
+[2] http://actes.sstic.org/SSTIC07/Password_Cracking/
diff -rupN john-1.7.8/doc/MD5_GENERIC john-1.7.8-jumbo-2/doc/MD5_GENERIC
--- john-1.7.8/doc/MD5_GENERIC	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/MD5_GENERIC	2011-06-02 17:25:28.000000000 +0200
@@ -0,0 +1,2540 @@
+How to use the 'generic' MD5.
+
+John has been enhanced to be able to handle MANY md5 variants easily.
+
+'variants' of MD5 are things like:
+
+md5($p)      (Note, $p is the password, $s will be the salt, etc)
+md5(md5($p)) (Note, this is md5 of the 32 byte result of a prior md5)
+md5($p.$s)   (Note, . is the concatenate operator, so $p.$s is
+              password with salt appended)
+...
+
+Most of the above rules are php 'style' rules, but I think in php,
+$pass is used, and $salt is used.  In this document, they have been
+simplified to $p and $s.
+
+This is done by using a new file format string:  md5_gen(#)   where
+the # is a number.  John reserves numbers from md5_gen(0) up to
+md5_gen(999) for 'built-in' formats.  Not all are defined at this
+time, but those have been reserved.
+
+The format of the input file lines will be:
+
+userID:md5_gen(#)base_16_hash[$salt]
+
+There may be a 2nd salt added in the near future, but not sure how it
+will be implemented.
+
+Here is an 'example' of the format required:
+
+userID:md5_gen(0)28fc2782ea7ef51c1104ccf7b9bea13d
+
+which is 'raw' md5, with a password of 1402
+
+userID:md5_gen(6)8d8cac84f234f42e32daeb94e7cd49e8$*.*
+
+which is in the vBulletin format:  md5(md5($p).$s), and which has a
+fixed 3 byte salt (the $*.* above is the salt signature, and the
+salt is *.*), solomon1 is the password for the above hash.  NOTE
+vBulletin is actually md5_gen(7). It is the expression format, but
+puts to additional constraints on input. md5_gen(7) forces a 3 byte
+salt, and it will NOT allow ':' character to be used as a separator,
+since vBulletin salts can contain that character.  However, the
+above md5_gen(6) works for this document, since *.* salt does not
+have a ':'
+
+Expressions can be added to john.conf (john.ini) to allow an end
+user to add a new format type, without having to do ANY coding
+at all.  The end user would have to learn the generic md5
+primitives, and how the data is used (input data, key data,
+encryption data, etc).  Also, the user would have to build
+properly formatted SAMPLE test values (john requires this).
+For the full 'HOW TO USE' documentation, see the john.conf.
+
+
+How to build the 'test' value is beyond the scope of this readme,
+but a trivial example might help.
+Expression format:  md5(md5($p).md5($p))
+Password test1
+md5(test1) == 5a105e8b9d40e1329780d62ea2265d8a
+so we want to md5 that result concatenated
+so md5(md5(test1).md5(test1)) is the same as
+md5(5a105e8b9d40e1329780d62ea2265d8a5a105e8b9d40e1329780d62ea2265d8a)
+which equals 478b10974f15e7295883224fd286ccba
+so a proper 'test' line is:
+Test=md5_gen(1003)478b10974f15e7295883224fd286ccba:test1
+( as can be seen in john.conf for md5_gen(1003) )
+
+The builtiin formats that john has right now are:
+
+------------+-------------------------+-------+------------------
+Signature   | expression              | Salt  | notes
+------------+-------------------------+-------+------------------
+md5_gen(0)  | md5($p)                 | No    | raw-md5
+md5_gen(1)  | md5($p.$s)              | Yes   | (joomla)
+md5_gen(2)  | md5(md5($p))            | No    | double md5 (e107)
+md5_gen(3)  | md5(md5(md5($p)))       | No    | triple md5
+md5_gen(4)  | md5($s.$p)              | Yes   | (OS Commerce)
+md5_gen(5)  | md5($s.$p.$s)           | Yes   |
+md5_gen(6)  | md5(md5($p).$s)         | Yes   |
+md5_gen(7)  | md5(md5($p).$s)         | Yes   | vBulletin. 3 byte salt, salt uses ':' char
+md5_gen(8)  | md5(md5($s).$p)         | Yes   |
+md5_gen(9)  | md5($s.md5($p))         | Yes   |
+md5_gen(10) | md5($s.md5($s.$p))      | Yes   |
+md5_gen(11) | md5($s.md5($p.$s))      | Yes   |
+md5_gen(12) | md5(md5($s).md5($p))    | Yes   | (IPB)
+md5_gen(13) | md5(md5($p).md5($s))    | Yes   |
+md5_gen(14) | md5($s.md5($p).$s)      | Yes   |
+md5_gen(15) | md5($u.md5($p).$s)      | Yes   |
+md5_gen(16) | md5(md5(md5($p).$s).$s2)| Yes   |
+md5_gen(17) | phpass ($H$ and $P$)    | Yes   | phpass and PHPbb-v3 hashes
+md5_gen(18) | PostOffice MD5 (PO)     | Yes   | md5($s.Y.$p.\xF7.$s) (Post.Office MD5)
+md5_gen(19) | Cisco PIX               | No    |
+md5_gen(20) | Cisco PIX (salted)      | Yes   |
+md5_gen(21) | HTTP Digest Access Auth | Yes   | Contains a 'special' salt function.
+md5_gen(22) | md5(sha1($p))           | No    | Use sha1 internally, but sill md5 hash (32 byte hex number)
+md5_gen(23) | sha1(md5($p))           | No    | Requires a 40 byte hex number (valid sha1 input)
+md5_gen(24) | sha1($p.$s)             | Yes   | Requires a 40 byte hex number (valid sha1 input)
+md5_gen(25) | sha1($s.$p)             | Yes   | Requires a 40 byte hex number (valid sha1 input)
+md5_gen(26) | sha1($p) (raw-sha1)     | No    | Requires a 40 byte hex number (valid sha1 input)
+md5_gen(27) } FreeBSD md5             | Yes   |
+md5_gen(28) | Apache MD5              | Yes   |
+
+........    | RESERVED                | UNK   |
+md5_gen(999)| RESERVED                | UNK   |
+
+The 'samples' stored in john.conf (to be used as is, or as examples) are:
+
+md5_gen(1001) md5(md5(md5(md5($p))))
+md5_gen(1002) md5(md5(md5(md5(md5($p)))))
+md5_gen(1003) md5(md5($p).md5($p))
+md5_gen(1004) md5(md5(md5(md5(md5(md5($p))))))
+md5_gen(1005) md5(md5(md5(md5(md5(md5(md5($p)))))))
+md5_gen(1006) md5(md5(md5(md5(md5(md5(md5(md5($p))))))))
+md5_gen(1007) md5(md5($p).$s) [vBulletin]
+md5_gen(1008) md5($p.$s) [joomla]
+
+
+
+NOTE the documentation section of john.conf is listed here.  It shows
+how to setup md5_generic functions (above 1000).  All of the primitives
+are defined, the data structures are defined, the expression, flags,
+saltlen, etc.  Following the 'howto use' section, are some working
+examples (this whole list is also found in john.conf).
+
+####################################################################
+####################################################################
+# here are some examples of GENERIC-MD5
+####################################################################
+####################################################################
+
+####################################################################
+# Documenation of how to 'setup' GENERIC-MD5
+####################################################################
+#
+#   Variables / workspaces:
+#
+# keys[]     -  Array Used to stored keys (optionally used, we 'may' be able to use input field 1 array)
+# input1[]   -  Array used for encryption, key appending, salt appending, etc happens to/from these
+#                   NOTE if MD5GenBaseFunc__InitialLoadKeysToInput then this is used to store the keys
+#                   and MUST NOT be damaged, since any later key retrieval will come from this buffer.
+#                   This is done as an optimization. Thus input2 is required for additional scratch buffer work.
+# output1[]  -  Array encryption happens and output is put here.
+#                   NOTE final result MUST be put here. This is what the 'hash' array is checked against.
+# salt       -  the salt is put here
+# salt2      -  2nd salt ($$2)
+# input2[]   -  Array same as input 1, but a totally different array
+# output2[]  -  Array same as output 2, but totally different array  (can not be used as 'final' result)
+# userid     -  User name (fld1). Can be done normal, upper or lower case
+# fld0 to fld9 - data from fld1 to fld9 of the input file.
+#
+#   NOTE within the scratch work spaces (input1[] and input2[] arrays), we can only do things like append_keys
+#   append_salt or other things.  Thus, each work space keeps track of each array element (knowing it's contents),
+#   and keeps track of the length.  In the way the scripting works, we can clear them (sets lengths of all
+#   elements to 0, and 'might' clear out the actual memory).  We can append to them (keys, output conversions,
+#   salt, etc) or we can force set their length to 32 ('special' optimization used in conjunction with
+#   MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1).
+#
+#   NOTE there is NO length validation done, other than input keys are reduced to the max allowable length.
+#   Thus, if building, and you attempt something like: clear_keys append_keys append_keys append_keys append_keys
+#   append_keys append_keys and the keys are too long, then they will overflow.  The maximal sizes of the
+#   input arrays are 95 bytes for x86 and 54 bytes for SSE/MMX.   Above this will simply give invalid results
+#   (garbage in, garbage out).
+#
+#####################################################################################
+#
+#   Flags= values. These flags are 'special' loader flags. They are optional. If used,
+#   then only ONE of them can be used.
+#
+#################
+#
+#    Special input flags (all flags listed later).  They have certain 'side-effects', and some have special
+#    rules that MUST be maintained within the script, and thus may not be usable for all scripts.
+#    These are here mostly for optimization.  They do NOT have to be used.  If not used, then when
+#    john adds keys one at a time, they are placed into the array of keys.  Then, when loading keys
+#    the keys are copied from the keys array, into the input1 (2) as needed.
+#
+#  MGF_KEYS_INPUT
+#     It will not use the keys[] array, but put the keys right
+#     into the input1[] array.  This buffer must not be destroyed. john will NOT use the keys[]
+#     array, and later retrieval of the key will happen from here (if there are any hashes broken).
+#     For this to be able to be used.
+#        $pass must be at the START of the expression.  expressions like md5($s.$p) would not work, since
+#             $pass is not the 'start' of the expression.
+#        the $pass expression 'may' have to be all by itself.  Thus md5($p.$s) would not work (such as joomla)
+#             but md5(md5($p).$s) can be made to work.
+#        The input1[] array must NOT be touched (after it is loaded).  Thus the below set of functions can NOT
+#        be used in the script.
+#               MD5GenBaseFunc__append_keys
+#               MD5GenBaseFunc__append_keys2
+#               MD5GenBaseFunc__clean_input
+#               MD5GenBaseFunc__append_salt
+#               MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+#               MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix
+#               MD5GenBaseFunc__append_from_last_output_as_base16
+#               MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix
+#               MD5GenBaseFunc__append_2nd_salt MD5GenBaseFunc__append_userid
+#               MD5GenBaseFunc__append_2nd_salt
+#               MD5GenBaseFunc__set_input_len_32
+#               MD5GenBaseFunc__set_input_len_64
+#               MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix
+#               MD5GenBaseFunc__append_input_from_input2
+#               and the flag MGF_KEYS_UNICODE_B4_CRYPT
+#
+#  MGF_KEYS_CRYPT_IN2
+#     This will load keys into the keys[] array.  It will then perform a md5() and put the ouput
+#     into output2.   This was done a signficant enhancement for forms like md5(md5($p).$s) so that we
+#     load ALL of the inner md5($p) only once, then re-used them over and over again for each new salt.
+#
+#  MGF_KEYS_BASE16_IN1
+#     This is like the above flag, but it takes the extra step of storing the base16 conversion
+#     of the md5 into input1[] array.  Due to this function, we have md5(md5($p).$s) actually working
+#     FASTER than simple md5($p)  (if there are many salts).  This is a significant optimization if it can
+#     be used properly.
+#  MGF_KEYS_BASE16_X86_IN1
+#     same as MGF_KEYS_BASE16_IN1, however, if running in SSE mode, the loader will switch to X86 mode,
+#     prior to outputting the base-16 back to input1.  NOTE, the initial crypt IS done in SSE mode.
+#
+#  MGF_KEYS_BASE16_IN1_Offset32
+#     This flag is a not valid for SSE2 (will build a 64 byte password, and 54 bytes is max SSE2 size)
+#     Psudo function that does the same work as MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1
+#     however, it loaded the hext to offset 32 (instead of the 'start' of the buffer). When done, the
+#     input1[] buffers will have 64 byte passwords.  The first 32 bytes are null, and the last
+#     32 bytes are the hex values.  This function is for md5(md5($s).md5($p)) (but certainly could
+#     be used for other formats.
+#  MGF_KEYS_BASE16_X86_IN1_Offset32
+#     Same as MGF_KEYS_BASE16_IN1_Offset32, but the output is in x86.  NOTE, if running in SSE mode, then
+#     both MGF_KEYS_BASE16_IN1_Offset32 and MGF_KEYS_BASE16_X86_IN1_Offset32 perform exactly the same. Neither
+#     one of them 'work' in SSE mode, since we will end up with a 64 byte input string (not SSE valid).
+#
+#  MGF_KEYS_UNICODE_B4_CRYPT
+#     Switch into 'unicode' converstion mode, prior to doing the 'early' MGF_KEYS* flags. The flags which
+#     can be used with this are: MGF_KEYS_CRYPT_IN2, MGF_KEYS_BASE16_IN1, MGF_KEYS_BASE16_X86_IN1,
+#     MGF_KEYS_BASE16_IN1_Offset32 (and the x86 versions).    Note, that MGF_KEYS_INPUT can NOT be used
+#     with this flag.
+#
+#  MGF_PHPassSetup
+#     Special flag used to link the salt, set_salt and set_hash members of the format object to the 'special'
+#     functions for phpass encryption.
+#
+#  MGF_POSetup
+#     Special flag used for the special "Post Office" Crypt function.
+#
+#  Depricated 'pseudo' functions (must be first function).  These functions still work, but have been depricated.
+#  md5-gen simply 'transforms' them into the current flag, at script loading time.  It is best to NOT use
+#  these functions in any new scripts, and to remove any usage of them.
+#	  MD5GenBaseFunc__PHPassSetup   == MGF_PHPassSetup
+#	  MD5GenBaseFunc__InitialLoadKeysToInput  ==  MGF_KEYS_INPUT
+#	  MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2  ==  MGF_KEYS_CRYPT_IN2
+#	  MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1  == MGF_KEYS_BASE16_IN1
+#	  MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1_offset32  ==  MGF_KEYS_BASE16_IN1_Offset32
+#
+####################################################################
+#
+#   Flag= line(s)   Optional, but required IF the format needs them.
+#                   Multiple flags ARE allowed.
+#
+#################
+#
+#  Flags are just that, switches that tell the generic md5 parser that
+#  certain things need to be handled.  One common used flag is MGF_SALTED
+#  If the format is a salted hash, then this flag must be present.
+#  Here is the list of flags, and what they mean, and when you should
+#  use them
+#
+#  Flag=MGF_SALTED
+#     Use this for any salted format
+#
+#  Flag=MGF_SALTED2
+#     If there are 2 salts in the format, use this flag.  NOTE 2 salts
+#     is defined, but has not be implemented yet in john.
+#
+#  Flag=MGF_ColonNOTValid
+#     If there is some reason why the : char should not be used by john
+#     (such as the : is a valid character in the salt.  If this is
+#     set, then the character to be used should be put into the Test=
+#     lines, AND the user should use that on the command line
+#
+#  Flag=MGF_NOTSSE2Safe
+#     The max encryption the SSE2 code can handle is 54 bytes.  The max
+#     size encryption for the 'generic' is 125 bytes.  So, if it is
+#     OBVIOUS that sse2 can not be used, due to encryption lengths,
+#     then set this flag.  An example is md5(md5($p).md5($s))  In this
+#     case, will be 3 md5's.  2 of them will be over the salt, and
+#     one over the password.  Thus, if the password and salt are each
+#     under 54 bytes, then sse2 could be used.  HOWEVER, the 3rd md5
+#     (the final one), is done against the concatenation of 2 32 byte
+#     strings (the md5 results of the first 2 encryptions).  THUS we
+#     KNOW this is a 64 byte string. That will not work in the current
+#     SSE2 (or mmx) code, and thus, the SSE2/MMX builds can NOT be used
+#     to test that format.
+#
+#  Flag=MGF_INPBASE64
+#     If the hashes are in base-64 (such as phpass), then use this
+#     flag.  Note, the base 64 'format' used is that of phpass.  If there
+#     are other orderings, then this will not work.  I know of no formats
+#     in use, other than phpass (phpbb, wordpress, etc) which use base-64
+#     for md5.
+#
+#  Flag=MGF_INPBASE64_4x6
+#     If this flag is set, then the input will be base-64, where 4 bytes are
+#     loaded 6 bits at a time (i.e. 16 bytes of hash).  Used in Cisco PIX-MD5
+#     Thus, only the lowest 24 bits of each part of the MD5 hash are used.
+#     This has to happen on the binary loader and comparison functions.
+#
+#  Flag=MGF_USERNAME
+#     If there is a Username used in the format, use this flag.
+#
+#  Flag=MGF_USERNAME_UPCASE User name, but it is forced to uppercase
+#  Flag=MGF_USERNAME_LOCASE User name, but it is forced to lowercase
+#
+#  Flag=MGF_SALT_AS_HEX
+#     This flag is for formats such as md5(md5($p).md5($s))  What this
+#     does, is to return the md5($s) to john as the salt, and not simply
+#     return the 'original' salt. Thus, we run md5's for the salt at
+#     initialization, and never MD5 them again.  DO NOT use this for a
+#     format like md5($s.md5($p).md5($s))  In that format, you NEED
+#     the salt (along with the md5 of that salt).  This flag can not
+#     be used in that instance.
+#
+#  Flag=MGF_SALT_AS_HEX_TO_SALT2
+#     This is 'similar' to MGF_SALT_AS_HEX.  It will perform the
+#     base16 crypt of the salt.  However, it stores both the original
+#     salt, and creates a 'salt2' which is the base16  This is so a
+#     format like,  md5($p.$s.md5($s)) could have both the salt
+#     and still have the base-16 of the salt.  So in this case
+#     using append_salt would append the original salt, and
+#     append_2nd_salt would append the base-16 hash of the salt.
+#
+#  Flag=MGF_StartInX86Mode
+#     This flag will case the format to 'start' in X86 mode, so that
+#     any initial key loading will also be done to the X86 buffers.
+#
+#  Flag=MGF_SALT_UNICODE_B4_CRYPT
+#     This flag will case the format to 'start' in Unicode conversion
+#     mode, so that any initial key loading will also be done to the
+#     using unicode conversions.
+#
+#  Flag=MGF_BASE_16_OUTPUT_UPCASE
+#     This flag will case the format to 'start' in uppercase base-16
+#     conversion mode, so that any initial key loading will also be
+#     done to the using unicode conversions.
+#
+#  Flag=MGF_HDAA_SALT
+#     Special salt loading for the HDAA format md5_gen(21).
+#     Not useful for anything else.
+#
+#  MGF_FLD0, MGF_FLD1, MGF_FLD2, ... ,MGF_FLD9
+#     If any of the fields of the file are part of the format (and
+#     used within the script), then they either must be part of
+#     the hash value, or the field must be present on the line.
+#     If a field IS used, then you also MUST have the proper
+#     flag set, or the prepare function will NOT load it.
+#
+# MGF_SHA1_40_BYTE_FINISH
+#     Tell md5-gen that the 'final' crypt is an SHA1 (still experimental
+#     code, so 'caveat emptor' ).  What this will do, is cause john to
+#     only load hashes that are 40 hex digits (md5 is 32 hex digits).
+#     NOTE, when the 'final' crypt is done (in SHA1), it will only have
+#     the first 16 bytes compared against (vs the full 20 bytes which
+#     sha1 generates).  This 'should' be more than adequate to know
+#     you have cracked the hash.
+#
+########################################################
+#
+#   Function primitives, and what they do  (REQUIRED in each format section)
+#
+#################
+#  MD5GenBaseFunc__clean_input
+#     Sets lengths of all input1[] array to ZERO, and sets the memory null (memory only set in SSE2, since it does
+#     not matter in x86 builds)
+#
+#  MD5GenBaseFunc__clean_input2
+#     Same as MD5GenBaseFunc__clean_input but this one works on input2[] array.
+#
+#  MD5GenBaseFunc__clean_input_kwik
+#     Sets lengths of all input1[] array to ZERO. Memory not cleared.  Optimization that can be used when you KNOW
+#     that the length of any of the input1 strings will never be less than they once were.  So if you load keys,
+#     crypt, clean_input, then repeatedly append_base16 to input and crypt, then during that repeated set of work
+#     you can call clean_kwik since ALL things being crypted, would be 32 bytes, and the single 'deep' clean would
+#     get the buffers read to go, and they would not need fully cleaning again.
+#
+#  MD5GenBaseFunc__clean_input2_kwik
+#     Same as MD5GenBaseFunc__clean_input_kwik but this one works on input2[] array.
+#
+#  MD5GenBaseFunc__clean_input_full
+#     This makes sure that the entire keys are set with NULL's prior to running.  This is a full 'deep' clean.
+#     In x86 builds, it will fully null out the entire input buffer.  In SSE mode, it nulls out both the
+#     x86 and SSE input buffers (fully).
+#
+#  MD5GenBaseFunc__clean_input2_full
+#     Same as MD5GenBaseFunc__clean_input_kwik but this one works on input2[] array.
+#
+#  MD5GenBaseFunc__append_keys
+#     append the array of keys to the array input1[]
+#
+#  MD5GenBaseFunc__append_keys2
+#     append the array of keys to the array input2[]
+#
+#  MD5GenBaseFunc__append_salt
+#     Appends the salt to each element of input1[], and adjusts the length of each element.
+#     NOTE, the MGF_SALT flag must be used in the format.
+#
+#  MD5GenBaseFunc__append_salt2
+#     Appends the salt to each element of input2[], and adjusts the length of each element.
+#
+#  MD5GenBaseFunc__append_2nd_salt
+#     append the salt2 (second salt value) to the array input1[]
+#     NOTE, the MGF_SALT2 flag must be used in the format.
+#
+#  MD5GenBaseFunc__append_2nd_salt2
+#     append the salt2 to the array input2[]
+#
+#  MD5GenBaseFunc__append_userid
+#  MD5GenBaseFunc__append_userid2
+#     appends the username into either input1 or input2 fields.
+#
+#  MD5GenBaseFunc__crypt
+#     performs a md5 on all elements of input1[] and places the results into output1[]  The output will be the
+#     16 byte BINARY blob of the 'raw' md5.
+#
+#  MD5GenBaseFunc__crypt2
+#     Same as MD5GenBaseFunc__crypt but this one works on input2[] -> output2[] arrays.
+#
+#  MD5GenBaseFunc__crypt_in1_to_out2
+#     Takes the data from input1, performs the MD5 crypts, and stores this data into Output2
+#
+#  MD5GenBaseFunc__crypt_in2_to_out1
+#     Takes the data from input2, performs the MD5 crypts, and stores this data into Output1
+#
+#  MD5GenBaseFunc__append_from_last_output_as_base16
+#     Takes the 16 byte binary values from each output1[] array, and does a base-16 conversion, appending the
+#     results to the same 'index' of the input1[] array.  ALL of the lengths of the array1[] elements will be
+#     32 bytes more than they were (the base-16 of each 16 byte binary value is 32 bytes long).
+#
+#  MD5GenBaseFunc__append_from_last_output2_as_base16
+#     Same as MD5GenBaseFunc__append_from_last_output_as_base16 but this one works on output2[] -> input2[] arrays.
+#
+#  MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+#     output1[] append -> input2[] arrays.  (note, output #1 appending to input #2, base-16)
+#
+#  MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+#     output2[] append -> input1[] arrays.  (note, output #2 appending to input #1, base-16)
+#
+#  MD5GenBaseFunc__append_input_from_input2
+#     Appends input2 to input   input += input2.  Note, the inputX -> inputY copying in SSE2 is slower than
+#     doing output -> input.
+#
+#  MD5GenBaseFunc__append_input2_from_input
+#     Appends input1 to input2   input2 += input
+#
+#  MD5GenBaseFunc__append_from_last_output2_as_raw
+#     Appends the 'raw' output data from output2 to input1.  Length of input1 grows by 16 bytes.
+#
+#  MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix
+#     NOT IMPLEMENTED:
+#     Takes the 16 byte binary values from the output1[] array, and overwrites from byte 0 to byte 31 of each
+#     element of the input1[] array.  This is used as an optimizations for formats such as:  md5(md5($s).$p)
+#     in this format, we can place the keys into input1[] at 32 bytes past the start of the buffer, and set
+#     the lengths to be the length of each key + 32, and then simply call this function for each salt, to
+#     drop the 32 bytes of md5 data to the start of the strings, without touching the passwords that were
+#     already stored, or the lengths of the strings.
+#
+#  MD5GenBaseFunc__overwrite_from_last_output2_as_base16_no_size_fix
+#     NOT IMPLEMENTED:
+#     Same as MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix but this one works on output2[] -> input2[] arrays.
+#
+#  MD5GenBaseFunc__overwrite_from_last_output_to_input2_as_base16_no_size_fix
+#     NOT IMPLEMENTED:
+#     output1[] overwrite start of input2[] arrays.  (note, output #1 going to start of input #2, base-16, no size 'fix')
+#     like MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix but different input output vars.
+#
+#  MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix
+#     NOT IMPLEMENTED:
+#     output2[] overwrite start of input1[] arrays.  (note, output #2 going to start of input #1, base-16, no size 'fix')
+#     like MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix but different input output vars.
+#
+#  MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix
+#     Inserts the salt to the start of the first input buffer.  DOES NOT append null bytes, nor does it
+#     adjust the length of the strings.  Used if the 'top' part of input buffer 1 stays constant, and
+#     the salt gets inserted to the start of input buffer (but lengths never change).
+#
+#  MD5GenBaseFunc__overwrite_salt_to_input2_no_size_fix
+#     Same as MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix but this one works on salt -> input2[] arrays.
+#
+#  MD5GenBaseFunc__append2_from_last_output2_as_raw
+#  NOT IMPLEMENTED
+#  MD5GenBaseFunc__append_from_last_output1_as_raw
+#  NOT IMPLEMENTED
+#  MD5GenBaseFunc__append2_from_last_output1_as_raw
+#  NOT IMPLEMENTED
+#
+#  MD5GenBaseFunc__set_input_len_16
+#     Sets the length of each element of input1[] to 16.  In SSE2 mode, if the length of the input buffer
+#     was less than 16, then that 0x80 end of marker is removed, and a new one is 'added' at offset 16.
+#
+#  MD5GenBaseFunc__set_input2_len_16
+#     Sets the length of each element of input2[] to 16.
+#
+#  MD5GenBaseFunc__set_input_len_32
+#     Sets the length of each element of input1[] to 32.  This was designed as is used in conjunction with
+#     the funtion overwrite_from_last_output_as_base16_no_size_fix in mind, but would not
+#     be the 'only' reason to use it (but is the only reason I have at this time).  This function does NOT
+#     clean the input[] items prior to this.  Usually a call to clean_input would be required priot to
+#     calling this function, to make sure the buffer is 'clean'.
+#
+#  MD5GenBaseFunc__set_input2_len_32
+#     Same as MD5GenBaseFunc__set_input_len_32 but this one works on input2[] array.
+#
+#  MD5GenBaseFunc__set_input_len_64
+#     Like the above function, but sets lengths to 64 bytes.  NOTE valid to use in SSE2 mode.
+#
+#  MD5GenBaseFunc__set_input2_len_64
+#     Same as MD5GenBaseFunc__set_input2_len_64 but this one works on input2[] array.
+#
+#  SSE 'switching' functions.  SSE is only valid for 54 byte or less input strings.
+#  This is due to optimizations which place a 'single' md5 limb restriction on the
+#  crypts.  Thus, for some formats, we have to be in x86 mode only, but for others,
+#  we can jump in and out of SSE mode.  However, to do this, we likely will have
+#  to convert a buffer (or more).  The input buffers, and output buffers are NOT
+#  compatible between x86 and SSE2.  If possible, convert the output buffers, they
+#  are smaller, and faster (usually).
+#
+#  MD5GenBaseFunc__SSEtoX86_switch_input1
+#    Copies the SSE Input1 buffer to x86 Input1.  Changes 'mode' to non-SSE for any
+#    functions that are done after this call.
+#  MD5GenBaseFunc__SSEtoX86_switch_input2
+#    Copies the SSE Input2 buffer to x86 Input2.  and changes to non-SSE mode.
+#  MD5GenBaseFunc__SSEtoX86_switch_output1
+#    Copies the SSE Output1 buffer to x86 Output1.  and changes to non-SSE mode.
+#  MD5GenBaseFunc__SSEtoX86_switch_output2
+#    Copies the SSE Output2 buffer to x86 Output2.  and changes to non-SSE mode.
+#
+#  MD5GenBaseFunc__X86toSSE_switch_input1
+#    Copies the x86 Input1 buffer to SSE Input1.  Changes 'mode' to SSE for any
+#    functions that are done after this call.
+#  MD5GenBaseFunc__X86toSSE_switch_input2
+#    Copies the x86 Input2 buffer to SSE Input2.  and changes to SSE mode.
+#  MD5GenBaseFunc__X86toSSE_switch_output1
+#    Copies the x86 Output1 buffer to SSE Output1.  and changes to SSE mode.
+#  MD5GenBaseFunc__X86toSSE_switch_output2
+#    Copies the x86 Output2 buffer to SSE Output2.  and changes to SSE mode.
+#
+#  MD5GenBaseFunc__ToSSE
+#    Simply switches mode to SSE. No data buffers copied. Usually, used as first
+#    or last command in a script
+#  MD5GenBaseFunc__ToX86
+#    Simply switches mode to x86. No data buffers copied. Usually, used as first
+#    or last command in a script
+#
+#
+#  Unicode mode.  This allows md5-gen to do unicode coversion when doing string
+#  append (overwrite) operations.  Thus, a format such as md5(unicode($p).$s) can
+#  be generated.
+#
+#  MD5GenBaseFunc__setmode_unicode
+#    All string ops do Unicode conversions. These are MD5GenBaseFunc__append_keys,
+#    append_keys2, append_salt, append_salt2, overwrite_salt_to_input1_no_size_fix,
+#    overwrite_salt_to_input2_no_size_fix, append_2nd_salt, append_2nd_salt2,
+#    append_userid, append_userid2, append_input1_from_CONST1  (and ALL other const
+#    append functions)    If -utf8 switch is set, then a utf8-to-unicode conversion
+#    is done.  If -utf8 is not there, then a simple ascii-to-unicode (which is simply
+#    appending a null byte after each byte of string).  The -utf8 conversion is
+#    considerably slower, but is required for many Unicode or utf8 systems.  The
+#    -utf8 stuff is still in development.
+#
+#  MD5GenBaseFunc__setmode_normal
+#    This is the 'normal' run for john.  Back to ascii (or utf8, if -utf8 switch
+#    set).  But there will be NO Unicode conversions done.
+#
+#
+#  Upper/Lowercase of md5 - base16 conversions.  Normally, this is done to lower
+#  case.  However, there may be systems which do md5 to base 16 in upper case.
+#  thus, if a hash is md5(upper(md5($p))  this is different than md5(md5($p))
+#  These functions turn on or off the upper/lower case conversions.
+#
+#  MD5GenBaseFunc__base16_convert_locase
+#    This is the 'normal' lowercase. Thus, md5(md5($p)) is assumed to have the
+#    base-16 done in lower case.
+#
+#  MD5GenBaseFunc__base16_convert_upcase
+#    Perform base-16 converts in upper case base-16.
+#
+#  MD5GenBaseFunc__append_input1_from_CONST1
+#     This will append the first constant value to the input1[] array
+#  MD5GenBaseFunc__append_input1_from_CONST2
+#  MD5GenBaseFunc__append_input1_from_CONST3
+#  MD5GenBaseFunc__append_input1_from_CONST4
+#  MD5GenBaseFunc__append_input1_from_CONST5
+#  MD5GenBaseFunc__append_input1_from_CONST6
+#  MD5GenBaseFunc__append_input1_from_CONST7
+#  MD5GenBaseFunc__append_input1_from_CONST8
+#     Same as MD5GenBaseFunc__append_input1_from_CONST1 but they load the other constant
+#     values into input1.
+#
+#  MD5GenBaseFunc__append_input2_from_CONST1
+#     This loads the first constant value into the input2[] array
+#  MD5GenBaseFunc__append_input2_from_CONST2
+#  MD5GenBaseFunc__append_input2_from_CONST3
+#  MD5GenBaseFunc__append_input2_from_CONST4
+#  MD5GenBaseFunc__append_input2_from_CONST5
+#  MD5GenBaseFunc__append_input2_from_CONST6
+#  MD5GenBaseFunc__append_input2_from_CONST7
+#  MD5GenBaseFunc__append_input2_from_CONST8
+#     Same as MD5GenBaseFunc__append_input2_from_CONST1 but they load the other constant
+#     values into input2.
+#
+#  MD5GenBaseFunc__append_fld0
+#     This will append the data from $$F0 (field 0 of the line, or 'username', to input 1.
+#  MD5GenBaseFunc__append_fld1
+#  MD5GenBaseFunc__append_fld2
+#  ....
+#  MD5GenBaseFunc__append_fld9
+#     Will append data from the other fields (from 1 to 9).  NOTE, 1 is the 'hash' line, and
+#     almost certainly should NOT be used.
+#
+#  MD5GenBaseFunc__append2_fld0  -- to -- MD5GenBaseFunc__append2_fld9
+#     Loads data from $$F0 to $$F9 (field 0 to field 9) into input buffer 2.
+#
+# MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16
+# MD5GenBaseFunc__SHA1_crypt_input2_append_input1_base16
+# MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input1_base16
+# MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16
+# MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input2_base16
+# MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input1_base16
+# MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL
+# MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL
+#    Currently 'experimental' addition of SHA1 into the md5() syntax.  Still much work to
+#    do.  Not for general use (yet). Hopefully, will be able to get things like
+#    md5(sha1(md5($p))) working (sort of works now, but again, still experimental).
+#    The 2 '_FINAL' functions should ONLY be used as the last call. This allows
+#    for support of sha1(sha1(m5($p).$s)) type hashes.  NOTE, if you use on of the
+#    *_FINAL calls, then you have to use the MGF_SHA1_40_BYTE_FINISH flag, and notes
+#    that only the first 16 bytes of the final hash are evaluated. Also, only 40 bytes
+#    long hex string hashes will be loaded (base-64? needed?).
+#    At this time, ALL sha1 is done in non-SSE code (x86, OpenSSL). Also note, that
+#    ALL output from the SHA1 functions is directly appended or overwritten, right into
+#    an input buffer.
+#
+####################
+#  These are special functions written SPECIFCALLY for usage by phpass code, in builtin
+#  function md5_gen(17).  These are likely NOT useful.  However, they 'are' open to be used.
+####################
+#
+#  MD5GenBaseFunc__crypt_to_input_raw
+#     Used as 'first' step of phpass crypt.  it will put 16 binary bytes of md5 encryption
+#     into array1[].  It will write this to the beginning of the arrays (does not append), and
+#     when done, sets ALL lengths of array1[] to 16.  Once this function is called, the keys
+#     are appended (see spec for phpass encryption), which sets the length of input1[] elements
+#     to 16 + strlen(keys).  Then there is a loop that calls the next function.
+#
+#  MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#     This function will encrypt input1[] and drop the 16 bytes of MD5 binary right back over
+#     the first 16 bytes of input1[]  The length of each input1[] item is NOT touched, thus
+#     whatever the length was before is what it is now.
+#
+#  MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen_but_setlen_in_SSE
+#     This is the very first call.  It DOES set the length up properly. From that point on,
+#     the other (1000's) of calls are done using MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#
+#  MD5GenBaseFunc__PHPassCrypt
+#     Special function for phpass, probably not useful in john.conf scripting
+#
+#  MD5GenBaseFunc__POCrypt
+#     This is the 'special' crypt call for MD5-PO md5_gen(18).  It was done as a 'special', because
+#     there was about 20% overhead, doing the individual calls.  It was much faster to hammer in
+#     values in a special crypt call.
+#
+####################################################################
+#
+#   Test= line(s)   (REQUIRED in each format section)
+#
+#    NOTE within these lines, if there are binary values which need to
+#    be inserted, then use the format of \xHH  (2 hex digits which will
+#    be converted into the 1 byte).  So, \xF7 will output the single
+#    byte "\xF7" which in some ASCII formats, it is the squiggly
+#    'about' equals sign.  To output some UNICODE or 'wide' type
+#    characters, you will need to know the exact bytes that are used
+#    and place a \xHH for each byte.  To output the actual \ character
+#    use \\   So, to output \\ use \\\\  (2 \\ which each get replaced
+#    with a single \ character).
+#    NOTE that HH MUST be uppercased for the A to F values, and the 'x'
+#    MUST be lowercase.
+#    NOTE, you MUST use \xHH.  So, to put a ASCII(1) value, you would
+#    use \x01  (not \x1 ).
+#    ALL conversions are done prior to the line being 'looked at' within
+#    the parser.
+#
+#################
+#
+# The testing line is simply of this format:
+#
+#  test=md5_gen(#)hash[$salt]:password
+#
+#  the hash listed, MUST be the hash generated for this password (and
+#  salt) for the expression.  John uses this at startup to validate
+#  that the format is 'valid'.  If this Test= line(s) are not right
+#  john will not work.  NOTE if the format does not allow a colon
+#  in the format (such as md5_gen(1007), then the exact same field
+#  separator must be used in the Test= line, as what is specified
+#  in the --field-separator-char=c used on the command line
+#
+####################################################################
+#
+#   Expression= line   (Optional)
+#
+#################
+#
+#  If the Expression= line is there, then the value shown there will
+#  also be used on the startup line of john.  If missing, john will
+#  output md5_gen(1001)  (or whatever number was used), and if
+#  Expression=, then the md5_gen(1001) will be followed by the
+#  expression line.
+#
+####################################################################
+#
+#   SaltLen=# line   (Optional, but required IF the format needs it)
+#
+#################
+#
+#  If this is a salted hash, and ALL valid salts must be a specific
+#  length (vBulletin is an example, where 3 byte salts are specified
+#  and OSCommerce is another with 2 byte hashes).  If this is the
+#  case, add a SaltLen=# line and john will validate, and only test
+#  lines which have valid salts (i.e. right length salt is part of
+#  the initial validation of the line)
+#
+####################################################################
+#
+#   MaxInputLen=# line   (Optional, but required IF the format needs it)
+#
+#################
+#
+#  If a format has a 'max' length of password (such as Cisco PIX has
+#  a max length of 16 byte PW), then this must be set.
+#
+####################################################################
+#
+#   CONST#=str    line   (Optional, but required IF the format needs it)
+#
+#   These lines will also use the \xHH  (or \\ for a \ ) same as the
+#   'Test=' lines.
+#
+#################
+#
+#  This will allow a constant value to be 'set' and then later used
+#  in the format.  So a format such as md5($p.CONSTANT.$s) can be
+#  done by setting const 1 to 'CONSTANT' (whatever that string is)
+#  and then calling MD5GenBaseFunc__append_input1_from_CONST1 at the
+#  proper time to insert it into the string.
+#  CONST1=str   to CONST8=str   are valid (8 constant values.)  NOTE
+#  if you have 3 constants, then use CONST1, CONST2 and CONST3 (i.e.
+#  pack them into the first X number constants).
+#
+####################################################################
+
+
+
+####################################################################
+####################################################################
+####################################################################
+#  Here are some additional 'test' formats.  To use these, simply
+#  cut them and place them at the bottom of john.ini (john.conf).
+#  These require john-1.7.7 jumbo2 + to work properly
+####################################################################
+####################################################################
+####################################################################
+
+
+####################################################################
+# Simple GENERIC-MD5 type for PostOffice-MD5 md5($s.Y.$p.\xF7.$s)
+#    Included here to 'exercise' the script parser (constants)
+#    NOTE, the internal md5_gen(18) has a specialized crypt
+#          function.  It does the same as what this script does
+#          but does not have the overhead of this script work, and
+#          runs 10-15% faster.
+####################################################################
+[List.Generic:md5_gen(1009)]
+Expression=md5_gen(1009): md5($s.Y.$p.\xF7.$s) [Post.Office MD5]
+Flag=MGF_SALTED
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_input1_from_CONST2
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1009)550c41c11bab48f9dbd8203ed313eef0$aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:abc123
+Test=md5_gen(1009)0c78bdef7d5448105cfbbc9aaa490a44$550c41c11bab48f9dbd8203ed313eef0:abc123
+Test=md5_gen(1009)9be296cf73d2f548dae3cccafaff1dd9$82916963c701200625cba2acd40d6569:FRED
+Test=md5_gen(1009)a0e2078f0354846ec5bc4c7d7be08a46$82916963c701200625cba2acd40d6569:
+CONST1=Y
+CONST2=\xF7
+SaltLen=32
+
+####################################################################
+# Simple GENERIC-MD5 type for Cisco PIX hash (same as pixMD5_fmt.c
+####################################################################
+[List.Generic:md5_gen(1010)]
+Expression=md5_gen(1010): pixMD5
+Flag=MGF_INPBASE64_4x6
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__set_input_len_16
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1010)2KFQnbNIdI.2KYOU:cisco
+Test=md5_gen(1010)TRPEas6f/aa6JSPL:test1
+Test=md5_gen(1010)OMT6mXmAvGyzrCtp:test2
+Test=md5_gen(1010)gTC7RIy1XJzagmLm:test3
+Test=md5_gen(1010)oWC1WRwqlBlbpf/O:test4
+Test=md5_gen(1010)NuLKvvWGg.x9HEKO:password
+Test=md5_gen(1010)8Ry2YjIyt7RRXU24:
+Test=md5_gen(1010).7nfVBEIEu4KbF/1:0123456789abcdef
+#Test=md5_gen(1010).7nfVBEIEu4KbF/1:0123456789abcdefxxxxxx
+MaxInputLen=16
+
+####################################################################
+# Simple GENERIC-MD5 type for Cisco PIX hash with a salt.  The salt
+# is the first 4 bytes of the user name.  I have made an assumption
+# about PW len. I assume it maxes at 12 chars, so the full salt is
+# allowed.
+####################################################################
+[List.Generic:md5_gen(1011)]
+Expression=md5_gen(1011): pixMD5-salted
+Flag=MGF_INPBASE64_4x6
+Flag=MGF_SALTED
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__set_input_len_16
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1011)h3mJrcH0901pqX/m$alex:ripper
+Test=md5_gen(1011)3USUcOPFUiMCO4Jk$cisc:cisco
+Test=md5_gen(1011)lZt7HSIXw3.QP7.R$admc:CscFw-ITC!
+Test=md5_gen(1011)hN7LzeyYjw12FSIU$john:cisco
+Test=md5_gen(1011)7DrfeZ7cyOj/PslD$jack:cisco
+MaxInputLen=12
+SaltLen=4
+
+####################################################################
+# Simple GENERIC-MD5 type for PostOffice-MD5 md5($s.Y.$p.\xF7.$s)
+#    Included here to 'exercise' the script parser (constants)
+#    NOTE, the internal md5_gen(18) has a specialized crypt
+#          function, as does this version.  This is same as md5_gen(18)
+####################################################################
+[List.Generic:md5_gen(1012)]
+Expression=md5_gen(1012): md5($s.Y.$p.\xF7.$s) [Post.Office MD5]
+Flag=MGF_SALTED
+Flag=MGF_NOTSSE2Safe
+Flag=MGF_POSetup
+Func=MD5GenBaseFunc__POCrypt
+Test=md5_gen(1012)550c41c11bab48f9dbd8203ed313eef0$aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa:abc123
+Test=md5_gen(1012)0c78bdef7d5448105cfbbc9aaa490a44$550c41c11bab48f9dbd8203ed313eef0:abc123
+Test=md5_gen(1012)9be296cf73d2f548dae3cccafaff1dd9$82916963c701200625cba2acd40d6569:FRED
+Test=md5_gen(1012)a0e2078f0354846ec5bc4c7d7be08a46$82916963c701200625cba2acd40d6569:
+Test=md5_gen(1012)eddfe6493d7e692994cf3526c71f8c84$aabbccddeeffgghhlksjflksjlfkdjsl:test1
+SaltLen=32
+
+####################################################################
+# Simple GENERIC-MD5 type for phpass-MD5.  Same as md5_gen(17)
+####################################################################
+[List.Generic:md5_gen(1013)]
+Expression=md5_gen(1013): phpass ($P$ or $H$)
+Flag=MGF_SALTED
+Flag=MGF_PHPassSetup
+Flag=MGF_INPBASE64
+Func=MD5GenBaseFunc__PHPassCrypt
+Test=md5_gen(1013)jgypwqm.JsMssPLiS8YQ00$9aaaaaSXB:test1
+Test=md5_gen(1013)5R3ueot5zwV.7MyzAItyg/$912345678:thatsworking
+Test=md5_gen(1013)yhzfTrJXcouTpLleLSbnY/$7aaaaaSXB:test1
+Test=md5_gen(1013)mwulIMWPGe6RPXG1/R8l50$712345678:thatsworking
+Test=md5_gen(1013)nfKm8qpXa88RVUjLgjY/u1$7555555hh:test3
+Test=md5_gen(1013)JSe8S8ufpLrsNE7utOpWc/$BaaaaaSXB:test1
+Test=md5_gen(1013)aqkw6carDzQ67zCLOvVp60$B12345678:thatsworking
+Test=md5_gen(1013)o2j.1E7X1NvVyEJ/QY9hX0$B555555hh:test3
+Test=md5_gen(1013)Y5RwgMij0xFsUIrr33lM1/$9555555hh:test3
+SaltLen=9
+
+
+####################################################################
+# Simple GENERIC-MD5 type for phpass-MD5.  Same as md5_gen(17)
+#  This format shows what happens under the hood, INSIDE of the
+#  MD5GenBaseFunc__PHPassCrypt() function.  We ONLY do $P$7, since
+#  it is the 'smallest' of the set. To do this WITHOUT the
+#  MD5GenBaseFunc__PHPassCrypt() function, we would have to have a
+#  special format for EACH type.  NOTE the timings will 'appear' to
+#  be MUCH faster than normal phpass. This is due to ONLY checking
+#  a version of phpass that uses 512 crypts.  In the phpass testing
+#  we select a version that tests 2048 of them.  So in other words
+#  if this format was same 'speed', it would be 4x faster.  NOTE it
+#  is a little slower than that, due to added overhead.
+####################################################################
+[List.Generic:md5_gen(1014)]
+Expression=md5_gen(1014): phpass(512 crypt version) ($P$7 or $H$7 )
+Flag=MGF_SALTED
+Flag=MGF_INPBASE64
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt_to_input_raw
+Func=MD5GenBaseFunc__append_keys
+# for type 7, we perform 512 crypts
+# 1 crypt here
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen_but_setlen_in_SSE
+# Now, perform 254 crypts
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#8 done
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#16 done
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#32 done
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#64 done
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#128 done
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#256 done
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#Func=MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen
+#512 done, but we did not test last 2
+# last crypt (makes 512 crypts TOTAL).
+# This will FAIL for big endian machines.  We have special code
+# inside our phpass to correctly deal with this.  In this format
+# there is NO way to do that.  Sorry, It simply can not be done
+# right now on BE systems.
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1014)yhzfTrJXcouTpLleLSbnY/$aaaaaSXB:test1
+Test=md5_gen(1014)mwulIMWPGe6RPXG1/R8l50$12345678:thatsworking
+Test=md5_gen(1014)nfKm8qpXa88RVUjLgjY/u1$555555hh:test3
+SaltLen=8
+
+[List.Generic:md5_gen(1015)]
+# same as 15, the user id format
+Expression=md5($u.md5($p).$s)
+Flag=MGF_SALTED
+Flag=MGF_USERNAME
+Flag=MGF_KEYS_CRYPT_IN2
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_userid
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1015)6093d5cb3e2f99d9110eb9c4bbca5f8c$aaaSXB$$Ujoeblow:test1
+Test=md5_gen(1015)6a2dc4a6637bc5c2488f27faeead8720$123456$$Uadmin:thatsworking
+Test=md5_gen(1015)63aea4b8fe491df8545cc0099ac668d4$5555hh$$Uralph:test3
+# to test 'like' we would see from an 'input file' where user name would be first field
+Test=md5_gen(1015)6093d5cb3e2f99d9110eb9c4bbca5f8c$aaaSXB:test1:joeblow
+Test=md5_gen(1015)6a2dc4a6637bc5c2488f27faeead8720$123456:thatsworking:admin
+Test=md5_gen(1015)63aea4b8fe491df8545cc0099ac668d4$5555hh:test3:ralph
+
+
+####################################################################
+# md5(upper(md5($p)))   Included here to 'exercise' the script parser
+####################################################################
+[List.Generic:md5_gen(1016)]
+Expression=md5(upper(md5($p)))
+# Flag needed here, is Salt.  There is no 'fixed' saltlen.
+Flag=MGF_KEYS_INPUT
+Flag=MGF_BASE_16_OUTPUT_UPCASE
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1016)42b01e6aebac08b1d481990c77e93206:test1
+Test=md5_gen(1016)11d382887431b076d540c4d3e37fe89a:Thatsworking
+Test=md5_gen(1016)9ed1f40dffbb84dadc33138958e927b2:test3
+
+[List.Generic:md5_gen(1017)]
+Expression=md5(upper(md5(upper(md5($p)))))
+# Flag needed here, is Salt.  There is no 'fixed' saltlen.
+Flag=MGF_KEYS_INPUT
+Flag=MGF_BASE_16_OUTPUT_UPCASE
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1017)9D55D308E01806EF0227CF5A3AC90F4E:test1
+Test=md5_gen(1017)1E80483A2F51520646542CCDC657E476:Thatsworking
+Test=md5_gen(1017)0E8851B6B060F9A5A101F540C3E3D669:test3
+
+[List.Generic:md5_gen(1018)]
+Expression=md5(upper(md5(upper(md5(upper(md5($p)))))))
+# Flag needed here, is Salt.  There is no 'fixed' saltlen.
+Flag=MGF_KEYS_INPUT
+Flag=MGF_BASE_16_OUTPUT_UPCASE
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1018)CDA798A1D3B4ED11BCA6C0A3D9747B9A:test1
+Test=md5_gen(1018)98D346A7C2079BC2D6F49882E4847CDB:Thatsworking
+Test=md5_gen(1018)82262EE9D6DF9E1138F602737A9F897E:test3
+
+
+[List.Generic:md5_gen(1021)]
+Expression=md5(md5(md5(md5($p))))
+# here is the optimized 'script' to perform the md5 4 times on itself
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input_kwik
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input_kwik
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1021)57200e13b490d4ae47d5e19be026b057:test1
+Test=md5_gen(1021)c6cc44f9e7fb7efcde62ba2e627a49c6:thatsworking
+Test=md5_gen(1021)0ae9549604e539a249c1fa9f5e5fb73b:test3
+
+[List.Generic:md5_gen(1022)]
+# expression shown will be the string:   md5_gen(1022) md5(md5($s.md5($p.md5($p.md5($s.md5($p.$p).$s)))).md5($s.md5($p.md5($p.md5($s.$p)))).md5($s.md5($s.md5($p.md5($p.$s)))))
+Expression=md5(md5($s.md5($p.md5($p.md5($s.md5($p.$p).$s)))).md5($s.md5($p.md5($p.md5($s.$p)))).md5($s.md5($s.md5($p.md5($p.$s)))))
+Flag=MGF_SALTED
+#
+#md5(md5($s.md5($p.md5($p.md5($s.C1.$s)))).md5($s.md5($p.md5($p.md5($s.$p)))).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C1=md5($p.$p)
+#md5(md5($s.md5($p.md5($p.C2))).md5($s.md5($p.md5($p.md5($s.$p)))).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C2=md5($s.C1.$s) (32+len_s2)
+#md5(md5($s.md5($p.C3)).md5($s.md5($p.md5($p.md5($s.$p)))).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C3 = md5($p.C2)
+#md5(md5($s.C4).md5($s.md5($p.md5($p.md5($s.$p)))).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C4 = md5($p.C3)
+#md5(C5.md5($s.md5($p.md5($p.md5($s.$p)))).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C5 = md5($s.C4)
+#md5(C5.md5($s.md5($p.md5($p.C6))).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C6=md5($s.$p)
+#md5(C5.md5($s.md5($p.C7)).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C7=md5($p.C6)
+#md5(C5.md5($s.C8).md5($s.md5($s.md5($p.md5($p.$s)))))
+#C8=md5($p.C7)
+#md5(C5.C9.md5($s.md5($s.md5($p.md5($p.$s)))))
+#C9=md5($s.C8)
+#md5(C5.C9.md5($s.md5($s.md5($p.C10))))
+#C10=md5($p.$s)
+#md5(C5.C9.md5($s.md5($s.C11)))
+#C11=md5($p.C11)
+#md5(C5.C9.md5($s.C12))
+#C12=md5($s.C11)
+#md5(C5.C9.C13)
+#C13=md5($s.C12)
+#C5.C9.C13 is NOT SSE safe.
+#
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+#C1 in Out    Inp, Inp2, Out2 free
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+#C2 in Out    Inp, Inp2, Out2 free
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+#C3 in Out    Inp, Inp2, Out2 free
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+#C4 in Out    Inp, Inp2, Out2 free
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+#C5 in Out    Inp, Inp2, Out2 free
+
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+##Func=MD5GenBaseFunc__SSEtoX86_switch_input1
+#C5 in Inp[x86]     Out, Inp2, Out2 free
+Func=MD5GenBaseFunc__ToSSE
+
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+##Func=MD5GenBaseFunc__SSEtoX86_switch_input2
+Func=MD5GenBaseFunc__append_keys2
+##Func=MD5GenBaseFunc__X86toSSE_switch_input2
+Func=MD5GenBaseFunc__crypt2
+
+#C5 in Inp - C6 in Out2   Out, Inp2 free
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+#C5 in Inp - C7 in Out2   Out, Inp2 free
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+#C5 in Inp - C8 in Out2   Out, Inp2 free
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+#C5 in Inp - C9 in Out2   Out, Inp2 free
+
+Func=MD5GenBaseFunc__SSEtoX86_switch_output2
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+#C5.C9 in Inp[x86]   Out, Inp2 Out2 free
+Func=MD5GenBaseFunc__ToSSE
+
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__crypt2
+#C5.C9 in Inp - C10 in Out2   Out, Inp2 free
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+#C5.C9 in Inp - C11 in Out2   Out, Inp2 free
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+#C5.C9 in Inp - C12 in Out2   Out, Inp2 free
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+#C5.C9 in Inp - C13 in Out2   Out, Inp2 free
+
+Func=MD5GenBaseFunc__SSEtoX86_switch_output2
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+#C5.C9.C13 Inp[x86]          Out, Inp2, Out2 free
+Func=MD5GenBaseFunc__crypt
+#Final answer in Out    Inp, Inp2, Out2 free
+Func=MD5GenBaseFunc__X86toSSE_switch_output1
+
+
+Test=md5_gen(1022)c901de937291c6232e789d70dde2cd7f$aabbccdd:test1
+
+
+####################################################################
+# mkmd5gen generated GENERIC-MD5 type for md5(md5($p).md5($p.md5($p.$s).md5($s.$p)))
+####################################################################
+[List.Generic:md5_gen(1023)]
+Expression=md5_gen(1023): md5(md5($p).md5($p.md5($p.$s).md5($s.$p)))
+Flag=MGF_SALTED
+Flag=MGF_NOTSSE2Safe
+#
+#md5(md5($p).md5($p.md5($p.$s).md5($s.$p)))
+#md5(C1.md5($p.md5($p.$s).md5($s.$p)))
+#md5(C1.md5($p.C2.md5($s.$p)))
+#md5(C1.md5($p.C2.C3))
+#md5(C1.C4)
+#
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+#C1 in Out    Inp, Inp2, Out2 free
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+#C1 in Inp    Out, Inp2 Out2 free
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__crypt2
+#C1 in Inp C2 in Out2    Free: Out, Inp2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+#C1 in Inp C2 in Out2 C3 in Out1    Free: Inp2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+#C1 in Inp C4 in Out2 Free: Out1, Inp2
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+#C1.C4 in Inp  Free: Out1, Inp2 Out2
+Func=MD5GenBaseFunc__crypt
+#Result in Out1
+#
+Test=md5_gen(1023)529f4a3600b1ed4af606a5fbc80f58ee$aabbccdd:test1
+Test=md5_gen(1023)aa8dbd8512be7a045ba602ddc2cab64b$zzyyxxww:test3
+Test=md5_gen(1023)bd0d60add4315f6d0b13c63226d7111e$01234567:ThisisWorking
+Test=md5_gen(1023)7174c2398175d2cb1d86e463cb6c8edd$98765432:abc
+Test=md5_gen(1023)cef72db811843bd37f1121f714c32752$65432198:Longer Pass Here
+Test=md5_gen(1023)8b0131c839db57eb6410ad84076f2fa2$32165498:Junk
+Test=md5_gen(1023)736d738772ae81411d96f56d0edc95c9$74185296:Junk1
+Test=md5_gen(1023)d66166897605b76f276e76b5596834f3$96325874:Junky3
+SaltLen=8
+
+
+####################################################################
+# mkmd5gen generated GENERIC-MD5 type for md5(md5($p).md5($p.md5($p.$s).md5($s.$p).md5($p.$p)))
+
+####################################################################
+# mkmd5gen generated GENERIC-MD5 type for md5($p)
+####################################################################
+[List.Generic:md5_gen(1024)]
+Expression=md5_gen(1024): md5($p)
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1024)5a105e8b9d40e1329780d62ea2265d8a:test1
+Test=md5_gen(1024)8ad8757baa8564dc136c1e07507f4a98:test3
+Test=md5_gen(1024)abbd6ffd1e10de751a20f97436a50dde:ThisisWorking
+Test=md5_gen(1024)900150983cd24fb0d6963f7d28e17f72:abc
+Test=md5_gen(1024)ffb756913c91d25a7094d3fa3d1206dd:Longer Pass Here
+Test=md5_gen(1024)50a16f415160a7132a86a551fc34bdc9:Junk
+Test=md5_gen(1024)1d5615d1e07f2554970cb4a93d776ca3:Junk1
+Test=md5_gen(1024)778f5c751de2d5a32faf89626c786103:Junky3
+
+####################################################################
+# mkmd5gen generated GENERIC-MD5 type for md5($p)
+####################################################################
+[List.Generic:md5_gen(1025)]
+Expression=md5_gen(1025): md5($p)
+Flag=MGF_KEYS_INPUT
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1025)5a105e8b9d40e1329780d62ea2265d8a:test1
+Test=md5_gen(1025)8ad8757baa8564dc136c1e07507f4a98:test3
+Test=md5_gen(1025)900150983cd24fb0d6963f7d28e17f72:abc
+
+[List.Generic:md5_gen(1030)]
+Expression=md5_gen(1030): md5($p.$p)
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1030)42b72f913c3201fc62660d512f5ac746:test1
+
+[List.Generic:md5_gen(1031)]
+Expression=md5_gen(1031): md5($s.md5($p).$p)
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__SSEtoX86_switch_input1
+Func=MD5GenBaseFunc__ToSSE
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input_kwik
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__SSEtoX86_switch_input1
+Func=MD5GenBaseFunc__ToSSE
+Func=MD5GenBaseFunc__clean_input_kwik
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__SSEtoX86_switch_input1
+Func=MD5GenBaseFunc__ToSSE
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1031)a459f60614498dbdd9a79dcc9c538749$aabbccdd:test1
+
+[List.Generic:md5_gen(1032)]
+Expression=md5_gen(1032): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1032)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+
+[List.Generic:md5_gen(1042)]
+Expression=md5_gen(1042): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Flag=MGF_SALT_AS_HEX
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1042)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+
+[List.Generic:md5_gen(1052)]
+Expression=md5_gen(1052): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Flag=MGF_SALT_AS_HEX
+Flag=MGF_KEYS_BASE16_IN1_Offset32
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix
+Func=MD5GenBaseFunc__set_input_len_64
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1052)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+[List.Generic:md5_gen(1062)]
+Expression=md5_gen(1062): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Flag=MGF_SALT_AS_HEX
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__X86toSSE_switch_output1
+Test=md5_gen(1062)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+[List.Generic:md5_gen(1033)]
+Expression=md5_gen(1033): md5(md5($p).$s)
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1033)e9fb44106edf60419d26a10b5439d0c7$aabbccddeeff:test1
+SaltLen=12
+
+[List.Generic:md5_gen(1043)]
+Expression=md5_gen(1043): md5(md5($p).$s)
+Flag=MGF_SALTED
+Flag=MGF_KEYS_BASE16_IN1
+Func=MD5GenBaseFunc__set_input_len_32
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1043)e9fb44106edf60419d26a10b5439d0c7$aabbccddeeff:test1
+SaltLen=12
+
+
+[List.Generic:md5_gen(1044)]
+Expression=md5_gen(1044): md5(md5($p.md5($p.md5($s.$p))).$s)
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1044)e4f0714e3e616ed7647dbd44aaff3c00$aabbccdd:test1
+
+
+
+####################################################################
+# Simple GENERIC-MD5 type for md5(md5($p).md5($p))
+####################################################################
+[List.Generic:md5_gen(1063)]
+# expression shown will be the string:   md5_gen(1063) md5(md5($p).md5($p))
+Expression=md5(md5($p).md5($p))
+# NOTE, this format does NOT work on SSE2.  It requires a md5() of a 64 byte string.
+# SSE (or MMX) is limtited to 54 byte max password, due to 'enhancements'
+# Thus, we need a non-sse2 safe flag.
+#Flag=MGF_NOTSSE2Safe
+Flag=MGF_KEYS_INPUT
+# here is the optimized 'script' to perform hash 'like' IPB but salt replaced with password.
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__X86toSSE_switch_output1
+# These are test strings for this format.
+Test=md5_gen(1063)478b10974f15e7295883224fd286ccba:test1
+Test=md5_gen(1063)18a59101e6c6fb38260d542a394ecb22:thatsworking
+Test=md5_gen(1063)630b01b68b6db6fd43a751f8147d1faf:test3
+
+
+####################################################################
+# mkmd5gen generated GENERIC-MD5 type for md5($s.md5($p.$s.md5(md5($s2)).$c1.$c3.$c4.$c5.$c7.$c6.$c8).$c2)
+####################################################################
+[List.Generic:md5_gen(5001)]
+Expression=md5_gen(5001): md5($s.md5($p.$s.md5(md5($s2)).$c1.$c3.$c4.$c5.$c7.$c6.$c8).$c2)
+Flag=MGF_SALTED
+Flag=MGF_SALTED2
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_2nd_salt
+Func=MD5GenBaseFunc__crypt_in1_to_out2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST1
+Func=MD5GenBaseFunc__append_input2_from_CONST3
+Func=MD5GenBaseFunc__append_input2_from_CONST4
+Func=MD5GenBaseFunc__append_input2_from_CONST5
+Func=MD5GenBaseFunc__append_input2_from_CONST7
+Func=MD5GenBaseFunc__append_input2_from_CONST6
+Func=MD5GenBaseFunc__append_input2_from_CONST8
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST2
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(5001)6d1a31e525633013d52bc065328ecd7c$aabbccdd$$2xszef:test1
+Test=md5_gen(5001)1ad6b42d7f22fcafbf9609c3efbea182$zzyyxxww$$2ER#^s:test3
+Test=md5_gen(5001)5eeeca352107c1b565af4a249a8452ee$01234567$$2hhhas:ThisisWorking
+Test=md5_gen(5001)fdb9c4702c7f82e3431d64f3b9d06136$98765432$$2hrhas:abc
+Test=md5_gen(5001)4b1fce298a29af07a8d66542222fb36e$65432198$$2ksjas:Longer Pass Here
+Test=md5_gen(5001)20d8de9d5a19e44181b0a8102e9345e4$32165498$$2Zhbbb:Junk
+Test=md5_gen(5001)9dfb9c3259dfc316a098d6d45fc77f54$74185296$$2Thxyz:Junk1
+Test=md5_gen(5001)7ea6b7fa2c1f0e2baee1792b0234034d$96325874$$2ABCDEF:Junky3
+CONST1=c1
+CONST2=2
+CONST3=333
+CONST4=4444
+CONST5=c5
+CONST6=666666
+CONST7=const_7
+CONST8=c8
+SaltLen=8
+
+[List.Generic:md5_gen(5002)]
+Expression=md5_gen(5002): md5(md5($p))
+Flag=MGF_KEYS_INPUT
+Func=MD5GenBaseFunc__crypt_in1_to_out2
+Func=MD5GenBaseFunc__SSEtoX86_switch_output2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+#sFunc=MD5GenBaseFunc__X86toSsE_switch_output1
+Test=md5_gen(5002)418d89a45edadb8ce4da17e07f72536c:test1
+Test=md5_gen(5002)ccd3c4231a072b5e13856a2059d04fad:thatsworking
+Test=md5_gen(5002)9992295627e7e7162bdf77f14734acf8:test3
+
+[List.Generic:md5_gen(5003)]
+Expression=md5_gen(5003): md5($c1.md5($c2.md5($c3.md5($c4.md5($c5.md5($c6.md5($c7.md5($c8.$p).$c1).$c2).$c3).$c4).$c5).$c6).$c7)
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST8
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST7
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST1
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST6
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST2
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST5
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST3
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST4
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST4
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST3
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST5
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST6
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST1
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST7
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(5003)116475e5dcb0f34933dad42ba23f1c5d:test1
+Test=md5_gen(5003)78a24cda1176ee0a361204ad523e84db:test3
+Test=md5_gen(5003)33dd28264da1606c681d883947e1dc69:ThisisWorking
+Test=md5_gen(5003)7ee41d938e2711ec317f2b6bebd27438:abc
+Test=md5_gen(5003)31a334471399b2fe1ed00badc36d3163:Longer Pass Here
+Test=md5_gen(5003)1a4eda9b6cd32febe9f9aa5d0a7f53ec:Junk
+Test=md5_gen(5003)c3c4959e6cde82d9035fbc55608a53ef:Junk1
+Test=md5_gen(5003)75242eca2f979739a1b047f74f9b6851:Junky3
+CONST1=1
+CONST2=c2
+CONST3=333
+CONST4=4..4
+CONST5=5---5
+CONST6=6,,,,6
+CONST7=7!!!!!7
+CONST8=88888888
+
+[List.Generic:md5_gen(5004)]
+Expression=md5_gen(5004): md5($c1.md5($c2.md5($c3.md5($c4.md5($c5.md5($c6.md5($c7.md5($c8.$p).$c1).$c2).$c3).$c4).$c5).$c6).$c7)
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST8
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST7
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST6
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST2
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST5
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST3
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST4
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST4
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST3
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST5
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST2
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST6
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST7
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(5004)116475e5dcb0f34933dad42ba23f1c5d:test1
+Test=md5_gen(5004)78a24cda1176ee0a361204ad523e84db:test3
+Test=md5_gen(5004)33dd28264da1606c681d883947e1dc69:ThisisWorking
+Test=md5_gen(5004)7ee41d938e2711ec317f2b6bebd27438:abc
+Test=md5_gen(5004)31a334471399b2fe1ed00badc36d3163:Longer Pass Here
+Test=md5_gen(5004)1a4eda9b6cd32febe9f9aa5d0a7f53ec:Junk
+Test=md5_gen(5004)c3c4959e6cde82d9035fbc55608a53ef:Junk1
+Test=md5_gen(5004)75242eca2f979739a1b047f74f9b6851:Junky3
+CONST1=1
+CONST2=c2
+CONST3=333
+CONST4=4..4
+CONST5=5---5
+CONST6=6,,,,6
+CONST7=7!!!!!7
+CONST8=88888888
+
+[List.Generic:md5_gen(5005)]
+Expression=md5_gen(5005): md5($c1.md5($c2.md5($c3.md5($c4.md5($c5.md5($c6.md5($c7.md5($c8.$p).$c1).$c2).$c3).$c4).$c5).$c6).$c7)
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input1_from_CONST8
+Func=MD5GenBaseFunc__append_input2_from_input
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST7
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__append_input2_from_CONST1
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_input2_from_CONST6
+Func=MD5GenBaseFunc__append_input_from_input2
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST2
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST5
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST3
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST4
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST4
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST3
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST5
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST2
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST6
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_input1_from_CONST7
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(5005)116475e5dcb0f34933dad42ba23f1c5d:test1
+Test=md5_gen(5005)78a24cda1176ee0a361204ad523e84db:test3
+Test=md5_gen(5005)33dd28264da1606c681d883947e1dc69:ThisisWorking
+Test=md5_gen(5005)7ee41d938e2711ec317f2b6bebd27438:abc
+Test=md5_gen(5005)31a334471399b2fe1ed00badc36d3163:Longer Pass Here
+Test=md5_gen(5005)1a4eda9b6cd32febe9f9aa5d0a7f53ec:Junk
+Test=md5_gen(5005)c3c4959e6cde82d9035fbc55608a53ef:Junk1
+Test=md5_gen(5005)75242eca2f979739a1b047f74f9b6851:Junky3
+CONST1=1
+CONST2=c2
+CONST3=333
+CONST4=4..4
+CONST5=5---5
+CONST6=6,,,,6
+CONST7=7!!!!!7
+CONST8=88888888
+
+# -num=5003 -const1=1 -const2=c2 -const3=333 -const4-4..4 -const5-5---5 -const6=6,,,,6 -const7=7!!!!!7 -const8=88888888  md5($c1.md5($c2.md5($c3.md5($c4.md5($c5.md5($c6.md5($c7.md5($c8.$p).$c1).$c2).$c3).$c4).$c5).$c6).$c7)
+
+[List.Generic:md5_gen(1053)]
+Expression=md5_gen(1053): md5($s.md5($s).$p)
+Flag=MGF_SALTED
+Flag=MGF_SALT_AS_HEX_TO_SALT2
+Func=MD5GenBaseFunc__clean_input
+#Func=MD5GenBaseFunc__append_salt
+#Func=MD5GenBaseFunc__crypt
+#Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+#Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_2nd_salt
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1053)94eead61c1c07bb832ff855dd6115702$aabbccdd:test1
+Test=md5_gen(1053)0c6253b0b82dc81bc5f5de0dcb59ee80$zzyyxxww:test3
+Test=md5_gen(1053)86d00c5383bbdaf1661d7729160766ed$01234567:ThisisWorking
+Test=md5_gen(1053)22c4c1568720e6db338d672c8241d0e4$98765432:abc
+Test=md5_gen(1053)f55723bdf8e577bf691b079aeadffe1f$32165498:Junk
+Test=md5_gen(1053)133857938ba2921bb079b3eca170bc77$74185296:Junk1
+Test=md5_gen(1053)b24df1c9f98699a99e492a591bdf1241$96325874:Junky3
+
+
+[List.Generic:md5_gen(1054)]
+Expression=md5_gen(1054): md5($s.md5(unicode($p)))
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__setmode_unicode
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__setmode_normal
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1054)2e233d5102d2be03307ec5490075121d$aabbccdd:test1
+Test=md5_gen(1054)0474efd4022743c1113636fc1f34d88a$zzyyxxww:test3
+Test=md5_gen(1054)e3ab32d7db8521616781f13919bb17bc$01234567:ThisisWorking
+Test=md5_gen(1054)9bc5270127c0a61c031ede0a61a79d98$98765432:abc
+Test=md5_gen(1054)e3546ff029afaba5977ed1db0da8b467$32165498:Junk
+Test=md5_gen(1054)e7c1a5215b06a7ee4048d70b50d086dd$74185296:Junk1
+Test=md5_gen(1054)66d4e0e951d5f064538b9b2db3bdf41d$96325874:Junky3
+
+
+[List.Generic:md5_gen(1055)]
+Expression=md5_gen(1055): md5($s.md5(unicode($p)))
+Flag=MGF_SALTED
+Flag=MGF_KEYS_UNICODE_B4_CRYPT
+Flag=MGF_KEYS_CRYPT_IN2
+Func=MD5GenBaseFunc__setmode_normal
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1055)2e233d5102d2be03307ec5490075121d$aabbccdd:test1
+Test=md5_gen(1055)0474efd4022743c1113636fc1f34d88a$zzyyxxww:test3
+Test=md5_gen(1055)e3ab32d7db8521616781f13919bb17bc$01234567:ThisisWorking
+Test=md5_gen(1055)9bc5270127c0a61c031ede0a61a79d98$98765432:abc
+Test=md5_gen(1055)e3546ff029afaba5977ed1db0da8b467$32165498:Junk
+Test=md5_gen(1055)e7c1a5215b06a7ee4048d70b50d086dd$74185296:Junk1
+Test=md5_gen(1055)66d4e0e951d5f064538b9b2db3bdf41d$96325874:Junky3
+
+
+[List.Generic:md5_gen(1056)]
+Expression=md5_gen(1056): md5(unicode($p).md5(unicode($s)))
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__setmode_unicode
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__setmode_normal
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1056)34ba9cf3d8f61e6eb21942feb1164261$aabbccdd:test1
+Test=md5_gen(1056)7b4fdbaab27929e18808c96e41b846f0$zzyyxxww:test3
+
+
+[List.Generic:md5_gen(1057)]
+Expression=md5_gen(1057): md5(unicode($p).md5(unicode($s)))
+Flag=MGF_SALTED
+Flag=MGF_SALT_UNICODE_B4_CRYPT
+Flag=MGF_SALT_AS_HEX
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__setmode_unicode
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__setmode_normal
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1057)34ba9cf3d8f61e6eb21942feb1164261$aabbccdd:test1
+Test=md5_gen(1057)7b4fdbaab27929e18808c96e41b846f0$zzyyxxww:test3
+
+[List.Generic:md5_gen(1058)]
+Expression=md5_gen(1058): md5(unicode($p))
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__setmode_unicode
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1058)16c47151c18ac087cd12b3a70746c790:test1
+Test=md5_gen(1058)537e738b1ac5551f65106368dc301ece:thatsworking
+Test=md5_gen(1058)849ee1b88b5d887bdb058180a666b450:test3
+
+[List.Generic:md5_gen(1059)]
+Expression=md5_gen(1059): md5(md5(unicode($p)))
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__setmode_unicode
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__setmode_normal
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1059)ef1b8ee3ad8690fd1678093588727529:test1
+Test=md5_gen(1059)18a7e5f289730525111f7b65cb223506:thatsworking
+Test=md5_gen(1059)01a0359d0cabbf49a0b0a8a941c7f5ab:test3
+
+
+
+##############################################################################
+# digest authentication scheme :
+#  h1 = md5(user:realm:password)
+#  h2 = md5(method:digestURI)
+#  response = h3 = md5(h1:nonce:nonceCount:ClientNonce:qop:h2)
+#
+# the 'special' salt sets 32space:nonce:nonceCount:ClientNonce:qop:h2
+# Also, this salt sets the first 5 bytes to be a growing text number,
+# so that salt_hash works properly.
+##############################################################################
+[List.Generic:md5_gen(1060)]
+Expression=md5_gen(1060): HDAA )
+Flag=MGF_HDAA_SALT
+Flag=MGF_FLD2
+Flag=MGF_FLD3
+Flag=MGF_FLD4
+Flag=MGF_USERNAME
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_userid
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__append_fld2
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input_kwik
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1060)679066476e67b5c7c4e88f04be567f8b$8c12bd8f728afe56d45a0ce846b70e5a$$Uuser$$F2myrealm$$F3GET$/$$F400000001$4b61913cec32e2c9$auth:nocode
+Test=md5_gen(1060)faa6cb7d676e5b7c17fcbf966436aa0c$af32592775d27b1cd06356b3a0db9ddf$$Umoi$$F2myrealm$$F3GET$/$$F400000001$8e1d49754a25aea7$auth:kikou
+CONST1=:
+
+
+[List.Generic:md5_gen(1090)]
+Expression=md5(md5($p.$s).md5(md5($p).$s.md5($s.md5($s.$p))).md5(md5($s.$p.$p).$s.md5($p.md5($p.$s.$p))).$p.md5($s.$p.md5($s.$p.$s).$p.md5($s.$p.md5($p.$s.$s))))
+Flag=MGF_SALTED
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_salt2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1090)e49995dd9328ba663e8839734aaef068$zRwIEOWX:hallo
+
+
+[List.Generic:md5_gen(1061)]
+Expression=md5_gen(1061): md5($s.'-'.md5($p))
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1061)7fc1aa71056429e9f773b2cde1106aee$salt1:test1
+Test=md5_gen(1061)abdb2b7fbc78abaf475d3a5bb48b48bc$2tlas:testword2
+CONST1=-
+
+# md5(sha1($p))
+[List.Generic:md5_gen(1062)]
+Expression=md5_gen(1062): md5(sha1($p))
+Flag=MGF_StartInX86Mode
+Flag=MGF_KEYS_INPUT_BE_SAFE
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16
+Func=MD5GenBaseFunc__X86toSSE_switch_input2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1062)a7168f0f249e3add33da11a59e228a57:test1
+Test=md5_gen(1062)067dda3ad565339fffa61ba74fab0ba3:thatsworking
+Test=md5_gen(1062)71a1083be5c288da7e57b8c2bd7cbc96:test3
+
+# sha1(md5($p))
+[List.Generic:md5_gen(1063)]
+Expression=md5_gen(1063): sha1(md5($p))
+Flag=MGF_KEYS_INPUT
+Flag=MGF_SHA1_40_BYTE_FINISH
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL
+Test=md5_gen(1063)81d84525eb1499d518cf3cb3efcbe1d11c4ccf25:test1
+Test=md5_gen(1063)6cd62e1767b65eec58d687de6d9c08a828018254:thatsworking
+Test=md5_gen(1063)7d653cf00d747a9fbab213b6c2b335cfe8199ff3:test3
+
+
+# sha1($p)
+[List.Generic:md5_gen(1064)]
+Expression=md5_gen(1064): sha1($p)
+Flag=MGF_SHA1_40_BYTE_FINISH
+Flag=MGF_RAW_SHA1_INPUT
+Func=MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL
+Test=md5_gen(1064)b444ac06613fc8d63795be9ad0beaf55011936ac:test1
+Test=md5_gen(1064)1068db2941b46d12f790df99d72fe8c2eb6d3aaf:thatsworking
+Test=md5_gen(1064)3ebfa301dc59196f18593c45e519287a23297589:test3
+
+[List.Generic:md5_gen(1165)]
+Expression=md5_gen(1165): md5(sha1(md5(sha1($p))))
+Flag=MGF_StartInX86Mode
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16
+Func=MD5GenBaseFunc__X86toSSE_switch_input2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16
+Func=MD5GenBaseFunc__X86toSSE_switch_input2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1165)62f2dd3da9a39eea4314b846aaa02a3d:test1
+Test=md5_gen(1165)288f19a5a0967ef40d8e9ebfef79b0ea:thatsworking
+Test=md5_gen(1165)72a4064912ccaea4b982b3e9fc710cd7:test3
+
+[List.Generic:md5_gen(1066)]
+Expression=md5_gen(1066): sha1($p.$s)
+Flag=MGF_NOTSSE2Safe
+Flag=MGF_SALTED
+Flag=MGF_SHA1_40_BYTE_FINISH
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL
+Test=md5_gen(1066)5a12479f0a8286a832288e1dc2ea9b2eda4e382d$sG:test1
+Test=md5_gen(1066)c72b6f1caddb158831cab0b08d29243ea20fc869$xxRW:thatsworking
+Test=md5_gen(1066)b966eff1aac95e92818a7c59326cce297b935eff$s3xx:test3
+
+[List.Generic:md5_gen(1067)]
+Expression=md5_gen(1067): sha1($s.$p)
+Flag=MGF_NOTSSE2Safe
+Flag=MGF_SALTED
+Flag=MGF_SHA1_40_BYTE_FINISH
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL
+Test=md5_gen(1067)f5266f29ff7f1ea6fc30085c8347fcf6a6e36e9c$sG:test1
+Test=md5_gen(1067)a34af873d9047541b4d76ceae7b391f0664ca99e$xxRW:thatsworking
+Test=md5_gen(1067)f0058038be0e821caa3031b463aed00fbe7e3beb$s3xx:test3
+
+[List.Generic:md5_gen(1068)]
+Expression=md5_gen(1068): sha1(sha1($p))
+Flag=MGF_NOTSSE2Safe
+Flag=MGF_SHA1_40_BYTE_FINISH
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16
+Func=MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL
+Test=md5_gen(1068)2a367cbb171d78d293f40fd7d1defb31e3fb1728:test1
+Test=md5_gen(1068)d3e0a4d2f3ec196a79ab2890c65144c20ff24ed8:thatsworking
+Test=md5_gen(1068)b13773cfee62f832cacb618b257feec972f30b13:test3
+
+[List.Generic:md5_gen(1069)]
+Expression=md5_gen(1069): sha1(sha1($p))
+Flag=MGF_NOTSSE2Safe
+Flag=MGF_SHA1_40_BYTE_FINISH
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16
+Func=MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16
+Func=MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL
+Test=md5_gen(1069)00aeb6dc5e6269a6b2f39728cd8a6812a644dae6:test1
+Test=md5_gen(1069)d60112917380bb0641f5d1a4ce8fb77e958452f7:thatsworking
+Test=md5_gen(1069)54e45916fb79f7be1c695828fdba44915b50751e:test3
+
+[List.Generic:md5_gen(1065)]
+Expression=md5_gen(1065): md5(sha1(md5(sha1($p))))
+Flag=MGF_StartInX86Mode
+Flag=MGF_KEYS_INPUT_BE_SAFE
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16
+Func=MD5GenBaseFunc__X86toSSE_switch_input2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16
+Func=MD5GenBaseFunc__X86toSSE_switch_input2
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1065)62f2dd3da9a39eea4314b846aaa02a3d:test1
+Test=md5_gen(1065)288f19a5a0967ef40d8e9ebfef79b0ea:thatsworking
+Test=md5_gen(1065)72a4064912ccaea4b982b3e9fc710cd7:test3
+
+[List.Generic:md5_gen(1070)]
+Expression=md5_gen(1070): sha1(upr($u).':'.$p)
+Flag=MGF_NOTSSE2Safe
+Flag=MGF_SHA1_40_BYTE_FINISH
+Flag=MGF_USERNAME_UPCASE
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_userid
+Func=MD5GenBaseFunc__append_input1_from_CONST1
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL
+Test=md5_gen(1070)20fa5cf803e363ba9f13e12ca61586e2efabc737$$UROOT:test1
+Test=md5_gen(1070)2e839b0c32af0e2099584ea22f20d2f2c477d908$$UJAS0N:thatsworking
+Test=md5_gen(1070)55496ed9edcabdd2368e7cd22eaae633c6d6c40e$$UJOEBLOW:test3
+CONST1=:
+
+
+####################################################################
+####################################################################
+# END of GENERIC-MD5 examples
+####################################################################
+####################################################################
diff -rupN john-1.7.8/doc/MD5_GENERIC_SCRIPTING john-1.7.8-jumbo-2/doc/MD5_GENERIC_SCRIPTING
--- john-1.7.8/doc/MD5_GENERIC_SCRIPTING	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/MD5_GENERIC_SCRIPTING	2011-06-02 17:25:28.000000000 +0200
@@ -0,0 +1,480 @@
+For most hashes where MD5 is used, building a proper md5 format is likely
+not the best bet overall.  A format is not trivial.  It requires maintainance
+and will likely requires specific enhancements to get it to perform
+optimally on all hardware.  Likely there will need to be 'generic' C
+code done, then it will need code to tie it into CPU specific optimizations,
+such as SSE, MMX, intrisic SSE, GPU, ... ... ...    This will also mean that
+to stay up to date, the format will require ongoing work and mainainance.
+
+However, there is one format which may reduce a lot of this maintainance
+work to very little.  Now, that format itself will need to be kept up to
+date, but any formats that are built upon its internal workings.  That
+format is md5-gen.  In this 'format', there is a scripting language, where
+a format developer only need to describe the actual operations properly,
+and the format is 'done', and working.
+
+This document will go over how to 'build' a format that uses this md5-gen
+format, how to optimize it to work faster, and how to build a 'thin'
+quasi format which insulates the end user from the md5-gen format line
+building.
+
+**** Introduction ****
+
+To start off with, a little background on 'how' and 'where' to build the
+scripts that run md5-gen, what interanal data structures are available to
+be used.
+
+The 'where' which a format developer can easily build into john, is to add a
+new md5-gen format 'script', into john.ini file (john.conf).  This
+file usually is located in the current directory where john is run out
+of (but the --config=file can override the default behavior).  Within the
+john.conf, a new 'section' can be added for a md5 genercic format. The
+new 'section' will be set by using this section naming:
+
+[List.Generic:md5_gen(NUM)]
+
+You replace the NUM with the sub-format number (from 1001 to 9999).
+Pick a number that is not used.
+
+Within this 'section', there will be multiple lines added.  These lines
+are primarily of the form:    Type=Value
+
+The actual contents of these scripts will be addressed later.  That will
+be the 'How', and preforming this is actually outside of the intro section.
+
+The 'Data' and runtime information is this:
+
+Inside of the md5-gen format, there are 2 input buffers (actually ALL data
+is arrays of 128 of each buffer type).  There is input1 and input2 buffers.
+The main operations on these buffers is to clear them, and to append data,
+to build string which will later be md5 hashed.
+
+There are also 2 output buffers.  These buffers will receive the md5 hashing
+from the 2 input buffers.  NOTE, when the format processing is complete, the
+results MUST be placed into output1 buffer. This is where all of the comparison
+functions will check against.
+
+In the format, there is a salt (if the format is salted).   There may also be
+a second salt value.
+
+There are also 'keys' value(s).  These are the passwords being tested at this
+given time.
+
+There are also 8 'constant' strings which can be used within a format.  A
+format such as md5-po has a couple of constants within it.
+
+There are also numerous optimization 'flags' which do special things when
+loading keys or salts, and there are numourous special 'optimization' primative
+functions within the format, for speedup of certain operations.
+
+**** Simple format building ****
+
+We will start out with a few simple formats, and simply 'show' how to build
+a straight forward script. The scripts may or may not be optimal.  Later
+we will optimize these somewhat.  When building the formats here, there will
+be comments interspersed, listing just what is being done, and why.
+
+we will build these formats:
+md5_gen(1030) md5($p.$p)
+md5_gen(1031) md5($s.md5($p).$p)
+md5_gen(1032) md5(md5($s).md5($p).$p)
+
+[List.Generic:md5_gen(1030)]
+Expression=md5_gen(1030): md5($p.$p)
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1030)42b72f913c3201fc62660d512f5ac746:test1
+
+Here is the exact same format, with some comments added, describing the
+sub-sections, and exactly what is being done.
+
+#first line is the section name. It MUST be of the format shown.
+[List.Generic:md5_gen(1030)]
+#
+#the next line, is a required line.  It serves 2 purposes.  It is output
+#in john, when the format 'starts'.  Also, the md5_gen(#) part is used
+#to destinguish this exact format (so the command line of --sub=md5_gen(1030)
+#would specify this and only this format)
+#
+Expression=md5_gen(1030): md5($p.$p)
+#
+#This is the set of functions.  This is the ONLY section of the format
+#where order IS important.  The functions ARE handled one after the
+#other, from top to bottom, to perform the string operations, and md5
+#operations which are needed to perform the hash of this format
+#The functions ARE a required part of the format.
+#
+#first step, clean the input.  All work for this format is done using
+#only input 1 and output 1 buffers.
+Func=MD5GenBaseFunc__clean_input
+#
+#Step 2, append the keys. Note, the buffer is clean, so this is simply
+#the same as Input=keys (but required 2 steps, the clean and append keys).
+Func=MD5GenBaseFunc__append_keys
+#
+#Step 3, append keys again (the format is ($p.$p) or keys appended to keys.
+Func=MD5GenBaseFunc__append_keys
+#
+#Step 4, final step performs md5 of $p.$p  This will properly leave the
+#results in output1
+Func=MD5GenBaseFunc__crypt
+#
+#This is test string.  These ARE required. You can provide more than
+#one.  5 or 6 are best, to make sure the format is valid.
+#
+Test=md5_gen(1030)42b72f913c3201fc62660d512f5ac746:test1
+
+Ok, here is the second format.  The format being done is md5($s.md5($p).$p)
+Here are a few comments about this format:
+1.  There is a Flag= value.  This is because this is a Salted format. This
+    REQUIRES the MGF_SALTED flag.
+2.  We only use input 1 and output 1.
+3.  There are a couple of calls to crypt (md5).  The first simply gets
+    md5($p) and puts it into output1, which will later be appeneded in
+    base-16 format as we build our string.
+4.  After the first crypt (md5), we clear our input buffer, then put
+    the salt in, append the base-16 of md5($p), and then append $p
+5.  Finally, and call to crypt is done, which leaves the results in
+    output1, so the rest of the md5-gen format can properly compare it.
+
+[List.Generic:md5_gen(1031)]
+Expression=md5_gen(1031): md5($s.md5($p).$p)
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1031)a459f60614498dbdd9a79dcc9c538749$aabbccdd:test1
+
+
+Now, here is the final format:  md5(md5($s).md5($p).$p)
+
+[List.Generic:md5_gen(1032)]
+Expression=md5_gen(1032): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_keys2
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1032)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+Ok, now that these have been built, here are a few 'benchmarks' listing
+that they are WORKING, and what speed they are working:
+
+Here is MinGW build 'x86'
+
+john_x86 -test -for=md5-gen -sub=md5_gen(1030)
+Benchmarking: md5_gen(1030) md5_gen(1030): md5($p.$p) [128x1 (MD5_Go)]... DONE
+Raw:    3530K c/s
+
+john_x86 -test -for=md5-gen -sub=md5_gen(1031)
+Benchmarking: md5_gen(1031) md5_gen(1031): md5($s.md5($p).$p) [128x1 (MD5_Go)]... DONE
+Many salts:     1945K c/s
+Only one salt:  1890K c/s
+
+john_x86 -test -for=md5-gen -sub=md5_gen(1032)
+Benchmarking: md5_gen(1032) md5_gen(1032): md5(md5($s).md5($p).$p) [128x1 (MD5_Go)]... DONE
+Many salts:     1016K c/s
+Only one salt:  1031K c/s
+
+
+Here is MinGW build of SSE2
+
+john_sse2 -test -for=md5-gen -sub=md5_gen(1030)
+Benchmarking: md5_gen(1030) md5_gen(1030): md5($p.$p) SSE2 [SSE2 32x4 (.S)]... DONE
+Raw:    7250K c/s
+
+john_sse2 -test -for=md5-gen -sub=md5_gen(1031)
+Benchmarking: md5_gen(1031) md5_gen(1031): md5($s.md5($p).$p) SSE2 [SSE2 32x4 (.S)]... DONE
+Many salts:     5065K c/s
+Only one salt:  4436K c/s
+
+john_sse2 -test -for=md5-gen -sub=md5_gen(1032)
+Benchmarking: md5_gen(1032) md5_gen(1032): md5(md5($s).md5($p).$p) SSE2 [SSE2 32x4 (.S)]... FAILED (get_hash[0](0))
+
+
+Here is some timings to check against:
+
+john_x86 -test -for=md5-gen -sub=md5_gen(0)
+Benchmarking:  md5_gen(0): md5($p)  (raw-md5)  [128x1 (MD5_Go)]... DONE
+Raw:    4005K c/s
+
+john_sse2 -test -for=md5-gen -sub=md5_gen(0)
+Benchmarking:  md5_gen(0): md5($p)  (raw-md5)  SSE2 [SSE2 32x4 (.S)]... DONE
+Raw:    10740K c/s
+
+
+**** Optimizations of prior formats ****
+
+For format 1030, the speed should be very close to that of md5_gen(0).
+In both formats, there is only 1 call to md5().  However, we are seeing that the
+(1030) is slower than (0).  The explanation of this, is that the (0) format has
+an optimization used, which we can not use in the (1030).  The (1030) is likely
+about as optimal as it can be made in the current md5-gen format.   The optimization
+for format (0) is:   Flag=MGF_KEYS_INPUT  What that does, is to place the keys
+directly into the input field, and then later, when john gets the keys back (it
+does this if a hash is cracked), john gets them from the input.  In the (1030)
+format, we load the keys, into the 'keys' arrays.  We then have to call a function
+to clean input buffer 1, and to append the keys (twice).  Thus, what we have is
+additional memory movement, and that slows things down.  However, to use the
+MGF_KEYS_INPUT optimization, we would have had to keep the input1 buffer prestine
+and ONLY put in the keys (passwords).  Since we had to append the keys twice,
+we simply 'blew' that requirement, and thus, could NOT use it.    At a later
+time, we will show a format WHERE we can use this optimization.
+
+For format 1031, there also appears to be no optimizations available.
+
+For 1032, there are optimizations.  In this format, we notice that we have
+this sub expression:  md5($s).  Well, there is an optimization, which when it
+loads the input file, it converts all salts into md5($s) and uses that value
+instead.  So, at startup time, we perform md5 hashes of all salts, but at
+runtime, we simply place the salt into the building string, instead of performing
+a MD5 on the salt.  So, in the 1032, we had 3 calls to crypt.  By using this
+optimization, we can reduce that to 2 crypts. The starting format is:
+md5(md5($s).md5($p).$p)  This optimization makes the format 'behave' at
+runtime, like it is md5($s.md5($p).$p), which was format 1031.  Note, after
+we make this optimzation, the timings will be almost identical to the 1031
+timings.  Also note, the Test string for 1032 and 1042 are exactly the
+same.  These are the same formats. It is just that 1042 performs fewer
+crypt calls per test.  Also note, in the 'original' run of SSE2, the 1032
+format failed.  This failure, is due to the SSE2 / MMX code only working
+for strings up to 54 bytes (optimization reason).  The length of this string:
+md5($s).md5($p) is 64 bytes by itself, and we also append $p to that. Thus,
+our string is OVER 54 bytes in length, and thus, can not be used in SSE2
+mode. We do have a couple work arounds for this, to get it working properly
+on SSE2 builds.  We can use a flag which simply stops SSE2 dead in its tracks
+(and preforms all work using x86 code).  This is flag MGF_NOTSSE2Safe
+
+[List.Generic:md5_gen(1042)]
+Expression=md5_gen(1042): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Flag=MGF_SALT_AS_HEX
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1042)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+Once the above changes have been done, here are the speeds:
+
+john_x86 -test=5 -for=md5-gen -sub=md5_gen(1031)
+Benchmarking: md5_gen(1031) md5_gen(1031): md5($s.md5($p).$p) [128x1 (MD5_Go)]... DONE
+Many salts:     2007K c/s
+Only one salt:  1913K c/s
+
+john_x86 -test=5 -for=md5-gen -sub=md5_gen(1032)
+Benchmarking: md5_gen(1032) md5_gen(1032): md5(md5($s).md5($p).$p) [128x1 (MD5_Go)]... DONE
+Many salts:     1052K c/s
+Only one salt:  1030K c/s
+
+john_x86 -test=5 -for=md5-gen -sub=md5_gen(1042)
+Benchmarking: md5_gen(1042) md5_gen(1042): md5(md5($s).md5($p).$p) [128x1 (MD5_Go)]... DONE
+Many salts:     1420K c/s
+Only one salt:  1372K c/s
+
+john_sse2 -test=5 -for=md5-gen -sub=md5_gen(1042)
+Benchmarking: md5_gen(1042) md5_gen(1042): md5(md5($s).md5($p).$p) SSE2 [128x1 (MD5_Go)]... DONE
+Many salts:     1416K c/s
+Only one salt:  1372K c/s
+
+
+We can also perform even more optimizations in the format.  What we do in this format, is we
+md5 the salt (when we first load the file). Thus the salts which john works with, are really
+md5($s)  (same as we did in format 1042).  Then we use a different flag, which puts the
+md5($p) into offset 32 of input1 (where we want it). Then we simply overwrite the data in
+input 1 with the salt (which is md5($s) in base-16 format), then force set length to 64, then
+append the keys, then crypt.
+
+[List.Generic:md5_gen(1052)]
+Expression=md5_gen(1052): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Flag=MGF_SALT_AS_HEX
+Flag=MGF_KEYS_BASE16_IN1_Offset32
+Flag=MGF_NOTSSE2Safe
+Func=MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix
+Func=MD5GenBaseFunc__set_input_len_64
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1052)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+Here are the benchmarks for the above format:
+
+john_x86 -test=5 -for=md5-gen -sub=md5_gen(1052)
+Benchmarking: md5_gen(1052) md5_gen(1052): md5(md5($s).md5($p).$p) [128x1 (MD5_Go)]... DONE
+Many salts:     2251K c/s
+Only one salt:  1369K c/s
+
+john_sse2 -test=5 -for=md5-gen -sub=md5_gen(1052)
+Benchmarking: md5_gen(1052) md5_gen(1052): md5(md5($s).md5($p).$p) SSE2 [128x1 (MD5_Go)]... DONE
+Many salts:     2251K c/s
+Only one salt:  1369K c/s
+
+
+Now, note the speed for 'many salts'.  It is very close to the speed of (1031), actually faster.
+This speed is the speed john will have for a normal password cracking, where you have dozens (or
+hundreds, or 1000's) of password hashes to crack.
+
+To understand WHY this format is this much faster (the 'Many salts', is the normal way to
+benchmark the speed of a salted hash), is to understand what is happening under the hood within
+john's 'crypt all' loop.
+
+   while (!feof(password_file)) {
+      for (i = 0 to max_num_passwords)
+         SetKey(i, getnextpassword(password_file));
+      if (salted)
+      {
+         while (z<salt_count)
+         {
+            SetSalt(salt[z]);
+            crypt_all
+            for (all_binaries_for_salt[z])
+               CheckForMatched(binary)
+         }
+      }
+   }
+
+The above code is certainly not 'exact', but should show close enough, the algorithm used
+within john.  Now, the algorithm as used within md5-gen will be shown (specifically for the
+flag  MGF_KEYS_BASE16_IN1_Offset32).
+
+ - SetKey() is called numerous times.  This will set a 'dirty flag' for the keys inside of md5-gen.
+ - SetSalt() will be called.  The salt handed to us is actually md5($s), since MGF_SALT_AS_HEX is set
+   The SetSalt() calls are happening within the 'while(z<salt_count)' loop in john.
+ - crypt_all is called.
+   Within crypt_all, md5-gen knows that we want the base-16 md5($p) to be placed at offset 32
+   within input1.  So the first call to crypt_all (for the first salt), will cause the md5($p)
+   to be computed, and to be placed at offset 32.
+   Then the script will overwrite the starting bytes of input1 with the 32 bytes of the salt,
+   then the length is set to 64, then the key is appened, then a crypt, and then comparisons.
+ - NOW, we are at the next loop within the 'while(z<salt_count)'.
+ - Then john loads the next salt [ SetSalt() ].
+ - Then john calls crypt_all.
+   At this time, there have been NO additional SetKey() calls. Thus, md5-gen knows that the
+   base-16 text of md5($p) is STILL located at offset 32 of Input1. So, the format DOES NOT
+   perform this crypt again (until new SetKey() function calls happen).
+ - This SetSalt .. crypt_all .. compare continues until all salts are tested.  However, there
+   will be no crypt calls to md5($p) again, UNTIL the working code within john calls SetKey()
+   again (when starting with new passwords, after all salts have been checked).
+
+
+Now, in the final format, we start from 1042, and do NOT turn off the sse2 code. What we do, is
+to turn off SSE2 when it is not valid.  This will generate x86 code (generic) that runs exactly
+the same as in 1042 (the 2 function calls of MD5GenBaseFunc__SSEtoX86_switch_output1 and
+MD5GenBaseFunc__X86toSSE_switch_output1 are no-ops in x86 builds). However, in SSE mode,
+the first crypt will be done using SSE.  Thus, as we see, the speed went from 1420k, up
+to almost 1800k.  But note, this is NOT as fast as format 1052, for 'many' salts.
+
+[List.Generic:md5_gen(1062)]
+Expression=md5_gen(1062): md5(md5($s).md5($p).$p)
+Flag=MGF_SALTED
+Flag=MGF_SALT_AS_HEX
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__SSEtoX86_switch_output1
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__X86toSSE_switch_output1
+Test=md5_gen(1062)042d1f15ed57929a2ac8ee4f0a924679$aabbccdd:test1
+
+john_sse2 -test=5 -for=md5-gen -sub=md5_gen(1062)
+Benchmarking: md5_gen(1062) md5_gen(1062): md5(md5($s).md5($p).$p) SSE2 [SSE2 32x4 (.S)]... DONE
+Many salts:     1792K c/s
+Only one salt:  1715K c/s
+
+So all in all, 1032, 1042, 1052, 1062 were all equivalent (1032 was not, since it fails in
+SSE2 builds, but that was 'fixed' in 1042).  They all run using differing sets of flags, differing
+sets of Function primatives, and have different runtime speeds.  However, in the end, they all
+
+
+
+Now, the above format 1062 is slower than 1052. This is due to the final crypt still having to be
+done in x86 mode. However, in 1062, we crypt EVERY password for each salt.  Thus you can see there
+is no speed gain between many salts, and 1 salt.  Yes, the md5($p) IS done using SSE2 which is much
+faster, but in version 1052, when there are multiple salts, the slower md5($p) is done only 1 time
+per password.
+
+
+Now, the flag MGF_KEYS_BASE16_IN1_Offset32 (or other flags like it), CAN be used in SSE2 to
+get much faster behavior, however, it has to be in a format that IS SSE2 friendly.  Here
+is an example:
+
+md5(md5($p).$s)   In this format, we CAN build an SSE2 friendly format, that is VERY fast.
+For this test, we will set the salt length to a fixed size of 12.
+
+Here is a very easy to read, but also very far from optimal format for the above type:
+[List.Generic:md5_gen(1033)]
+Expression=md5_gen(1033): md5(md5($p).$s)
+Flag=MGF_SALTED
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_from_last_output_as_base16
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1033)e9fb44106edf60419d26a10b5439d0c7$aabbccddeeff:test1
+SaltLen=12
+
+john_x86 -test -format=md5-gen -subf=md5_gen(1033)
+Benchmarking: md5_gen(1033) md5_gen(1033): md5(md5($p).$s) [128x1 (MD5_Go)]... DONE
+Many salts:     1918K c/s
+Only one salt:  1889K c/s
+
+john_sse2 -test -format=md5-gen -subf=md5_gen(1033)
+Benchmarking: md5_gen(1033) md5_gen(1033): md5(md5($p).$s) SSE2 [SSE2 32x4 (.S)]... DONE
+Many salts:     5479K c/s
+Only one salt:  4922K c/s
+
+
+Here is a MUCH more optimal version (1043).  This version will use the flag
+MGF_KEYS_BASE16_IN1 to load the md5($p) into input 1, at the start of that string.  That
+will ONLY be done, if there is a SetKeys() change.  Then we simply set the input length
+to 32, append the salt, and call crypt.
+
+[List.Generic:md5_gen(1043)]
+Expression=md5_gen(1043): md5(md5($p).$s)
+Flag=MGF_SALTED
+Flag=MGF_KEYS_BASE16_IN1
+Func=MD5GenBaseFunc__set_input_len_32
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1033)e9fb44106edf60419d26a10b5439d0c7$aabbccddeeff:test1
+SaltLen=12
+
+john_x86 -test -format=md5-gen -subf=md5_gen(1043)
+Benchmarking: md5_gen(1043) md5_gen(1043): md5(md5($p).$s) [128x1 (MD5_Go)]... DONE
+Many salts:     4128K c/s
+Only one salt:  1890K c/s
+
+john_sse2 -test -format=md5-gen -subf=md5_gen(1043)
+Benchmarking: md5_gen(1043) md5_gen(1043): md5(md5($p).$s) SSE2 [SSE2 32x4 (.S)]... DONE
+Many salts:     13096K c/s
+Only one salt:  4834K c/s
+
+So in this case, we see that the 'only 1 salt' speed is pretty much a wash.  However, the
+'many salts' speed, has gone from 1900k to 4100k for non-sse, and from 5500k to 13100k.
+
+NOTE, the above format is actually md5_gen(6) (also md5_gen(7)) format.
+
diff -rupN john-1.7.8/doc/NETNTLM_README john-1.7.8-jumbo-2/doc/NETNTLM_README
--- john-1.7.8/doc/NETNTLM_README	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/NETNTLM_README	2011-06-02 17:25:28.000000000 +0200
@@ -0,0 +1,143 @@
+LM/NTLM Challenge / Response Authentication
+JoMo-Kun (jmk at foofus dot net) ~ 2010
+
+Microsoft Windows-based systems employ a challenge-response authentication
+protocol as one of the mechanisms used to validate requests for remote file
+access. The configured/negotiated authentication type, or level, determines how
+the system will perform authentication attempts on behalf of users for either
+incoming or outbound requests. These requests may be due to a user initiating a
+logon session with a remote host or, in some cases, transparently by an
+application they are running. In many cases, these exchanges can be replayed,
+manipulated or captured for offline password cracking. The following text
+discusses the available tools within the John the Ripper "Jumbo" patch for
+performing offline password auditing of these specific captured challenge-
+response pairs.
+
+Why might these exchanges be of interest? A primary point of most penetration
+tests is to find avenues through which the assessor can gain unauthorized access
+to some resource. This often relies on the compromise of a system's local
+accounts or the exploitation of some service-level vulnerability. The ability to
+capture on-the-wire authentication exchanges and to crack the associated
+password adds another option to the mix. The fact that these exchanges can be
+cracked aids in demonstrating to clients why one authentication algorithm may be
+preferred to another.
+
+A given server is likely to use one of the following protocols for
+authentication challenge-response: LMv1, NTLMv1, LMv2 or NTLMv2. It should be
+noted that these protocols may use the LM and NTLM password hashes stored on a
+system, but they are not the same thing. For an excellent in-depth discussion of
+the protocols see the Davenport paper entitled "The NTLM Authentication Protocol
+and Security Support Provider" [1]. For the purposes of this discussion, the key
+item of note is that the LMv1 and NTLMv1 protocols consist of a only a single
+server challenge. This allows an attacker to force a client into authenticating
+using a specific challenge and then attack that response using precomputed
+Rainbow Tables.
+
+There are a variety of methods for capturing challenge-response pairs, including
+the use of tools such as MetaSploit and Ettercap. The author's preferred method
+is to use a modified version of Samba[2]. The provided patch sets the server's
+challenge to a fixed value (i.e. 0x1122334455667788) and logs all authentication
+attempts in a format suitable for use with John. The patch also includes a
+modification to the nmbd application. Nmbd is used to respond to broadcast
+requests for NetBIOS name/IP information. The modified service simply responds
+to all requests with its own IP address, often resulting in hosts unknowingly
+authenticating to the wrong system. Another common method of forcing systems to
+authenticate to the Samba server is through the use of HTML image source tags.
+For example, simply inserting the tag "<img src=file://192.168.1.10/logo.gif>"
+into a HTML message will cause some email client applications to automatically
+perform an authentication attempt. Other examples include the use of specialized
+desktop.ini files and many other mischievous tricks.
+
+It is also worth noting that these challenge/response protocols are not limited
+to the Microsoft File and Print Services. For example, Cisco's LEAP wireless
+security mechanism, EAP-PEAP and PPTP all utilize a MS-CHAP handshake, or
+modified variant. The NTLMv1 challenge/response set can be extracted from this
+exchange and subjected to a brute-force guessing attack. Further discussion on
+this subject is outside of the scope of this write-up, but would certainly
+reveal numerous additional uses.
+
+The LMv1 challenge-response mechanism suffers a number of technical limitations.
+As previously noted, only a server challenge is used. This means that if the
+challenge is set to a constant value, a given password will always result in
+the same client authentication response. This allows for the precomputation of
+password / LMv1 responses and their subsequent retrieval using tools such as
+RainbowCrack.
+
+To further exacerbate the issue, the LM hash used during the generation of the
+LMv1 response converts a password into (at most) two 7 character upper-case
+passwords. The LM hash is then split into three pieces prior to calculating the
+LMv1 response. This process greatly reduces the size of the Rainbow Tables which
+need to be calculated in order to break a given password. For example, the
+so-called "halflmchall" tables widely available on the Internet utilize only the
+first third of the LMv1 response to break the first 7 characters of the
+respective password. The netnlm.pl script discussed in this document can be used
+to attempt to break the remaining characters of the password and its original
+case-sensitive version. The following is an example of cracking a captured
+LMv1/NTLMv1 challenge/response set.
+
+Example LMv1/NTLMv1 Challenge/Response (.lc Format):
+user::WORKGROUP:5237496CFCBD3C0CB0B1D6E0D579FE9977C173BC9AA997EF:A37C5C9316D9175589FDC21F260993DAF3644F1AAE2A3DFE:112233445566778
+
+LMv1 Response: 5237496CFCBD3C0CB0B1D6E0D579FE9977C173BC9AA997EF
+NTLMv1 Response: A37C5C9316D9175589FDC21F260993DAF3644F1AAE2A3DFE
+Server Challenge: 112233445566778
+
+RainbowCrack look-up of password's first 7 characters (upper-cased) using first
+third (8 bytes) of LMv1 response:
+% rcrack halflmchall/*.rt -f 5237496CFCBD3C0C
+Result: CRICKET
+
+First netntlm.pl Pass (Crack Remaining Characters):
+% netntlm.pl --file capture.lc --seed CRICKET
+Result: CRICKET88!
+
+Second netntlm.pl Pass (Determine Case Sensitive Password)[a]:
+% netntlm.pl --file capture.lc
+Result: Cricket88!
+
+[a] Note that the case-sensitive password will be shown about a third through
+the script's output following the text: "Performing NTLM case-sensitive crack
+for account".
+
+The following is an example of cracking a captured NTLMv1 challenge/response. If
+the LMv1 and NTLMv1 response hashes within a given client response are
+identical, it typically means one of two things: either the client machine is
+configured to send only a NTLMv1 response (e.g. LAN Manager Authentication Level
+Group Policy Object set to "Send NTLM response only"), or the user's password is
+greater than 14 characters. If the password is indeed over 14 characters in
+length, it is unlikely a suitable Rainbow Table set is available and brute-force
+guessing will be exhaustively time-consuming.
+
+Example NTLMv1 Challenge/Response (.lc Format):
+user::WORKGROUP:A37C5C9316D9175589FDC21F260993DAF3644F1AAE2A3DFE:A37C5C9316D9175589FDC21F260993DAF3644F1AAE2A3DFE:1122334455667788
+
+John Usage:
+% john -format:netntlm capture.lc
+
+The LMv2 and NTLMv2 challenge/response protocols both employ unique client
+challenges. This additional data effectively defeats the ability to precompute
+password/response pairs via Rainbow Tables. It should also be noted that
+despite its name, the LMv2 response is computed using a NTLM hash. This results
+in a much harder-to-crack response hash, as the password was not truncated to
+seven characters or upper-cased during the process.
+
+The use of NTLMv2 is now the default policy within Microsoft Windows Vista and
+Windows 7. Its use can be enforced for older versions via the LAN Manager
+Authentication Level Group Policy Object ("Send NTLMv2 response only" (level 3
+or higher)).
+
+Example LMv2 Challenge/Response (.lc Format):
+user::WORKGROUP:1122334455667788:6FAF764ECFDF1D1D9E7BA7B517190F3B:E15C1A679C7609CE
+
+John Usage:
+% john -format:netlmv2 capture.lc
+
+Example NTLMv2 Challenge/Response (.lc Format):
+user::ATS-W759420A:1122334455667788:02E12C3C2B2F5799D2C1A7661AE80491:0101000000000000B0736308F1C9CA01DABA9E3A11AFD91F0000000002001000310030002E0030002E0032002E0032000000000000000000
+
+John Usage:
+% john -format:netntlmv2 capture.lc
+
+
+[1] http://davenport.sourceforge.net/ntlm.html
+[2] http://www.foofus.net/jmk/smbchallenge.html
diff -rupN john-1.7.8/doc/OPTIONS john-1.7.8-jumbo-2/doc/OPTIONS
--- john-1.7.8/doc/OPTIONS	2011-04-27 20:02:49.000000000 +0200
+++ john-1.7.8-jumbo-2/doc/OPTIONS	2011-06-02 17:28:46.000000000 +0200
@@ -1,4 +1,5 @@
 	John the Ripper's command line syntax.
+	(Updated in/for the jumbo patch by Jim Fougeron)
 
 When invoked with no command line arguments, "john" prints its usage
 summary.
@@ -23,19 +24,29 @@ argument (if supported for a given optio
 The supported options are as follows, square brackets denote optional
 arguments:
 
---single			"single crack" mode
+--single[=SECTION]		"single crack" mode
 
 Enables the "single crack" mode, using rules from the configuration
-file section [List.Rules:Single].
+file section [List.Rules:Single].  If --single=Single_2 then the rules
+from [List.Rules:Single_2] section would be used.
 
 --wordlist=FILE			wordlist mode, read words from FILE,
 --stdin				or from stdin
 
 These are used to enable the wordlist mode.
 
---rules				enable word mangling rules for wordlist mode
+--utf8				enable UTF-8 conversion
+
+John defaults to assuming ISO-8859-1 when converting plaintexts or salts
+to UTF-16. Using this flag will enable UTF-8 conversion instead. This affects
+many Microsoft formats like NT, mscash and mssql. Formats not affected will
+silently ignore this option flag.
+
+--rules[=SECTION]		enable word mangling rules for wordlist mode
 
 Enables word mangling rules that are read from [List.Rules:Wordlist].
+If --rules=Wordlist_elite  was used, then [List.Rules:Wordlist_elite]
+would be the section used.
 
 --incremental[=MODE]		"incremental" mode [using section MODE]
 
@@ -69,6 +80,8 @@ its purpose is to give the new session a
 append the ".rec" suffix to form the session file name).  This is
 useful for running multiple instances of John in parallel or to be
 able to later recover a session other than the last one you interrupt.
+john.log file will also be named NAME.log (whatever 'NAME' is), so
+that any logging of the session work will end up in this file.
 
 --status[=NAME]			print status of a session [called NAME]
 
@@ -87,12 +100,14 @@ may restrict the set of passwords used b
 password files will be used), "--format", or/and "--external" (with an
 external mode that defines a filter() function).
 
---show				show cracked passwords
+--show[=left]			show cracked passwords
 
 Shows the cracked passwords for given password files (which you must
 specify).  You can use this option while another instance of John is
 cracking to see what John did so far; to get the most up to date
 information, first send a SIGHUP to the appropriate "john" process.
+if --show=left then all uncracked hashes are listed (in a john 'input'
+file format way).  =left is just that literal string "=left".
 
 --test[=TIME]			run tests and benchmarks for TIME seconds each
 
@@ -118,13 +133,21 @@ not load accounts with a bad shell.  You
 shell name, so "--shells=csh" will match both "/bin/csh" and
 "/usr/bin/csh", while "--shells=/bin/csh" will only match "/bin/csh".
 
---salts=[-]COUNT		load salts with[out] at least COUNT passwords
+--salts=[-]COUNT[:MAX]		load salts with[out] at least COUNT passwords
 
 This is a feature which allows to achieve better performance in some
 special cases.  For example, you can crack only some salts using
 "--salts=2" faster and then crack the rest using "--salts=-2".  Total
 cracking time will be about the same, but you will likely get some
-passwords cracked earlier.
+passwords cracked earlier.  If MAX is listed, then no hashes are
+loaded where there are more than MAX salts.  This is so that if you
+have run --salts=25 and then later can run --salts=10:24 and none of
+the hashes that were already done from the --salts=25 will be re-done.
+
+--pot=NAME			pot filename to use
+
+By default, john will use john.pot.  This override allows using a different
+john.pot-like file (to start from, and to store any found password into).
 
 --format=NAME			force hash type NAME
 
@@ -159,6 +182,8 @@ cracked) for hashes of the "faster" type
 ones loaded for cracking at the same time).  So you are advised to use
 separate invocations of John, one per hash type.
 
+--subformat=LIST displays all the built-in md5-gen formats, and exits
+
 --save-memory=LEVEL		enable memory saving, at LEVEL 1..3
 
 You might need this option if you don't have enough memory or don't
@@ -169,6 +194,51 @@ impact is that you won't see the login n
 memory saving levels have a performance impact; you should probably
 avoid using them unless John doesn't work or gets into swap otherwise.
 
+--mem-file-size=SIZE		max size of wordlist to preload into memory
+
+One of the significant performance improvements for some builds of
+john, is preloading the wordlist file into memory, instead of reading
+line by line. This is especially true when running with a large list
+of --rules.  The default max size file is 5 million bytes.  Using this
+option allows making this larger.   NOTE if --save-memory is used,
+then memory file processing is turned off.
+
+--field-separator-char=c	Use 'c' instead of the char ':'
+
+By design, john works with most files, as 'tokenized' files.  The field
+separator used by john is the colon ':' character.  However, there are
+hashes which use the colon in the salt field, and there are users which
+may have a colon for a user name (for a couple examples of problems
+with it).  However, an advanced john user can change the input files,
+by using a different character than the ':' (and different than any
+other 'used' character), and avoid problems of lines not being properly
+processed.  The side effects are that the pot file will get this
+'character' used in it also (and only lines in the pot file that HAVE
+that character will be loaded at startup), and there are other side
+effects.  Usually, this is ONLY used in very advanced situations, where
+the user 'knows what he is doing'.  If the character can not be easily
+represented by the keyboard, then the format of
+--field-separator-char=\xHH can be used. --field-separator-char=\x1F
+would represent the character right before the space (space is 0x20)
+
+--fix-state-delay=N		only determine the wordlist offset every N times
+
+This is an optimization which helps on some systems.  This just
+limits the number of times that the ftell() call is performed.
+The one side effect, is that if john is aborted, and restarted, it
+may redo more tests.  Thus, the use of this option is only acceptable
+and desirable for fast hash types (e.g., raw MD5).
+
+--nolog		            turns off john.log file
+
+This will turn off creation, or updating to the john.log file (which may
+have a different name if the --session=NAME flag was used.)  Often the
+logging is not wanted, and this log file can often become very large
+(such as working with many 'fast' rules on a fast format).  The log file
+is often used to check what work has been done, but if this will not be
+needed, and the log file is simply going to be deleted when done, then
+running in --nolog mode may be used.
+
 
 	Additional utilities.
 
@@ -199,10 +269,14 @@ the order of entries.  You might want to
 "--stdout" option if you've got a lot of disk space to trade for the
 reduced cracking time (on possibly trying some duplicates as they
 might be produced with word mangling rules).
+This program has been updated.  It is faster, it now can 'cut' the
+lines (in a couple of ways), and can unique the files data, AND also
+unique it against an existing file.
 
 	mailer PASSWORD-FILE
 
 A shell script to send mail to all the users who got weak passwords.
 You should edit the message inside the script before using it.
 
+Based on (and modified in the jumbo patch):
 $Owl: Owl/packages/john/john/doc/OPTIONS,v 1.9 2011/04/27 18:02:49 solar Exp $
diff -rupN john-1.7.8/doc/README.mpi john-1.7.8-jumbo-2/doc/README.mpi
--- john-1.7.8/doc/README.mpi	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/README.mpi	2011-05-22 01:23:25.000000000 +0200
@@ -0,0 +1,154 @@
+====================
+PRELUDE:
+====================
+    The original implementation was ca. 2004 by Ryan Lim as an academic
+    project.  It was later picked up and maintained at bindshell.net, adding
+    fixes for the JtR 1.7 releases and various cipher patches.
+
+    In 2008, it was picked up by AoZ and stripped back down to the original
+    MPI-only changes to improve its compatibility with the 'jumbo' patchsets,
+    which had better-maintained alternate cipher support. This is often
+    referred to as "the mpi10 patch"
+
+    In 2010, it was extended by magnum to support all cracking modes. This
+    should be referred to as "the fullmpi patch" to avoid confusion. With the
+    exception of Markov it is far from perfect but it works just fine and
+    should support correct resuming in all modes. It is well tested but you
+    have absolutely NO guarantees.
+
+====================
+COMPILING:
+====================
+    Unless using OMP, you should consider applying the nsk-3 patch, also known
+    as "Faster bitslice DES key setup".
+
+    To enable MPI in John, un-comment these two line in Makefile:
+
+----8<--------------8<--------------8<--------------8<--------------8<----------
+# Uncomment the TWO lines below for MPI (can be used together with OMP as well)
+CC = mpicc -DHAVE_MPI
+MPIOBJ = john-mpi.o
+----8<--------------8<--------------8<--------------8<--------------8<----------
+
+    You must have an operational MPI environment prior to both compiling and
+    using the MPI version; configuring one is outside the scope of this
+    document but for a single, multi-core, host you don't need much
+    configuration. MPICH2 or OpenMPI seems to do the job fine, for example.
+    Most testing of fullmpi is now done under latest stable OpenMPI.
+
+    Debian Linux example for installing OpenMPI:
+    sudo apt-get install libopenmpi-dev openmpi-bin
+
+    Note that this patch works just fine together with OMP enabled as well.
+    When MPI is in use (with more than one process), OMP is (by default)
+    automatically disabled. Advanced users may want to change this setting
+    (change MPIOMPmutex to N in john.conf) and start one MPI node per
+    multi-core host, letting OMP do the rest. Warnings are printed; these
+    can be muted in john.conf too.
+
+====================
+USAGE:
+====================
+    Typical invocation is as follows:
+
+    mpiexec -np 4 ./john --incremental passwd
+
+    The above will launch four parallel processes that will split the
+    Incremental keyspace in a more-or-less even fashion. If you run it to
+    completion, some nodes will however finish very early due to how this
+    mode is implemented, decreasing the overall performance. This problem
+    gets much worse with a lot of nodes.
+
+    In MARKOV mode, the range is automatically split evenly across the nodes,
+    just like you could do manually. This does not introduce any overhead,
+    assuming job runs to completion - and also assuming your MPI compiler
+    behaves.
+
+    The single and wordlist modes scale fairly well and cleartexts will not be
+    tried by more than one node (except when different word + rule combinations
+    result in the same candidate, but that problem is not MPI specific).
+
+    In SINGLE mode, and sometimes in Wordlist mode (see below), john will
+    distribute (actually leapfrog) the rules (after preprocessor expansion).
+    This works very well but will not likely result in a perfectly even
+    workload across nodes.
+
+    WORDLIST mode with rules will work the same way. Without rules, or when
+    rules can't be split across the nodes, john will distribute (again, it
+    really just leapfrogs) the words instead. This is practically the same as
+    using the External:Parallel example filter in john.conf, but much more user
+    friendly.
+
+    If the --mem-file-size parameter (default 5000000) will allow the file to
+    be loaded in memory, this will be preferred and each node will only load
+    its own share of words. In this case, there is no further leapfrogging and
+    no other overhead. Note that the limit is per node, so using the default
+    and four nodes, a 16 MB file WILL be loaded to memory, with 4 MB on each
+    node.
+
+    You can override the leapfrogging selection. This is debug code really and
+    should eventually be replace by proper options:
+
+       --mem-file-size=0   (force split loading, no leapfrog)
+       --mem-file-size=1   (force leapfrogging of words)
+       --mem-file-size=2   (force leapfrogging of rules)
+
+    In EXTERNAL mode, john will distribute candidates in the same way as in
+    Wordlist mode without rules. That is, all candidates will be produced on
+    all nodes, and then skipped by all nodes but one. This is the mode where
+    the fullmpi patch performs worst. When attacking very fast formats, this
+    scales VERY poorly.
+
+
+    You may send a USR1 signal to the parent MPI process (or HUP to all
+    individual processes) to cause the subprocesses to print out their status.
+    Be aware that they may not appear in order, because they blindly share the
+    same terminal.
+
+    skill -USR1 -c mpiexec
+
+    Another approach would be to do a normal status print. This must be done
+    with mpiexec and using the same -np as used for starting the job:
+
+    mpiexec -np 4 ./john --status
+
+    Which will dump the status of each process as recorded in the .rec files.
+    This way you also get a line with total statistics.
+
+====================
+CAVEATS:
+====================
+    - This implementation does not account for heterogeneous clusters or nodes
+      that come and go.
+    - In interest of cooperating with other patches, benchmarking is less
+      accurate.  Specifically, it assumes all participant cores are the same
+      as the fastest.
+    - Benchmark virtual c/s will appear inflated if launching more processes
+      than cores available. It will basically indicate what the speed would be
+      with that many real cores.
+    - There is no inter-process communication of cracked hashes yet. This means
+      that if one node cracks a hash, all other nodes will continue to waste
+      time on it. The current workaround is aborting and restarting the jobs
+      regularly. This also means that you may have to manually stop some or all
+      nodes after all hashes are cracked.
+    - Aborting a job using ctrl-c will often kill all nodes without updating
+      state files and logs. I have tried to mitigate this but it is still a
+      good idea to send a -USR1 to the parent before killing them. You should
+      lower the SAVE parameter in john.conf to 60 (seconds) if running MPI,
+      this will be the maximum time of repeated work after restarting.
+
+============================================================
+Following is the verbatim original content of this file:
+============================================================
+
+This distribution of John the Ripper (1.6.36) requires MPI to compile.
+
+If you don't have MPI, download and install it before proceeeding.
+
+Any bugs, patches, comments or love letters should be sent to
+jtr-mpi@hash.ryanlim.com. Hate mail, death threates should be sent to
+/dev/null.
+
+Enjoy.
+--
+Ryan Lim <jtr-mpi@hash.ryanlim.com>
diff -rupN john-1.7.8/doc/RULES john-1.7.8-jumbo-2/doc/RULES
--- john-1.7.8/doc/RULES	2010-02-26 02:13:37.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/RULES	2011-05-17 18:13:01.000000000 +0200
@@ -15,6 +15,8 @@ are compatible with those of Crack 5.0a)
 -8	reject this rule unless current hash type uses 8-bit characters
 -s	reject this rule unless some password hashes were split at loading
 -p	reject this rule unless word pair commands are currently allowed
+-u	reject this rule unless the --utf8 flag is used
+-U	reject this rule if the --utf8 flag is used
 
 
 	Numeric constants and variables.
@@ -57,6 +59,7 @@ than that of "l" (length).
 ?a	matches letters [a-zA-Z]
 ?x	matches letters and digits [a-zA-Z0-9]
 ?z	matches all characters
+?b	matches characters with 8th bit set (mnemonic "b for binary")
 
 The complement of a class can be specified by uppercasing its name.  For
 example, "?D" matches everything but digits.
diff -rupN john-1.7.8/doc/UTF8 john-1.7.8-jumbo-2/doc/UTF8
--- john-1.7.8/doc/UTF8	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/UTF8	2011-06-02 17:27:28.000000000 +0200
@@ -0,0 +1,58 @@
+This version of John is UTF-8 aware, using a new option flag. In short,
+this flag says "my wordlists and input files are encoded in UTF-8" and
+it can be used without knowing if the particular format is affected or
+not.
+
+Without this support, John will assume ISO-8859-1 when converting
+plaintexts or salts to UTF-16. This affects many Microsoft formats
+like NT, mscash and mssql. Other formats, like DES or MD5 are never
+doing such conversion, so you would just use wordlists encoded in the
+same format as the hashes once were generated in. The --utf8 flag is
+supported for such formats too, but will only affect the new reject
+rules, see below.
+
+To enable UTF-8 conversion, just add the --utf8 flag. This will affect
+not only wordlist files, but also salts, usernames (when used as salt)
+and any info used by --single. You can also test all the UTF-8 aware
+formats at once using "john --test --utf8"
+
+To convert a wordlist to UTF-8, use iconv(1):
+
+$ iconv -f koi8r -t utf-8 cslang >cslang.utf8
+
+You can convert from/to a large number of formats, see iconv's man page.
+
+
+Two new reject rules are implemented:
+
+ -u   reject rule unless the --utf8 flag is used
+
+ -U   reject rule if the --utf8 flag is used
+
+Note that this can be used to enable/disable certain rules even for
+formats that does not use UTF-16 internally (eg. raw md5 of utf-8
+plaintexts).
+
+
+A new character class is also implemented, ?b (b for binary). It matches
+8-bit characters. This can be used with or without the UTF-8 support.
+
+
+Caveats:
+- UTF-8 conversion is often slower than the default ISO-8859-1 one, so
+it's advisable to only use this when you have to. That is, when your
+wordlist contains characters not included in ISO-8859-1.
+- Some wordlist rules may cut UTF-8 multibyte sequences in the middle,
+resulting in garbage. You can reject such rules with -U to have them in
+use only when --utf8 is not used.
+- Beware of UTF-8 BOM's. Do not use them (they will cripple the first word
+in your wordlist, that's all).
+
+--
+
+These contributions to John are hereby placed in the public domain. In
+case that is not applicable, they are Copyright 2009, 2010, 2011 by me and
+hereby released to the general public. Redistribution and use in source
+and binary forms, with or without modification, is permitted.
+
+magnum
diff -rupN john-1.7.8/doc/UTF8-DEVEL.txt john-1.7.8-jumbo-2/doc/UTF8-DEVEL.txt
--- john-1.7.8/doc/UTF8-DEVEL.txt	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/UTF8-DEVEL.txt	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,71 @@
+These are "public" functions that can be used for supporting UTF-8 in your
+own formats for JtR. All are put in unicode.c.
+
+If you are not aware of UCS-2, just consider it a synonym to UTF-16. For our
+purposes, they are the same.
+
+
+Convert from ISO-8859-1 or UTF-8 to UTF-16LE:
+=============================================
+Source format depends on --utf8 flag given to john when running.
+If length is exceeded or malformed data is found, it will return a negative
+number telling you how much of the source that was read. That is, a return
+code of -32 means you have an UNKNOWN number of characters of UCS-2 [use
+strlen16()] in the destination buffer and you should truncate your
+"saved_plain" (if applicable) at 32.
+
+    #include "unicode.h"
+    int plaintowcs(UTF16 *dst, int maxdstlen, const UTF8 *src, int srclen);
+
+
+
+Convert UTF-8 to UTF-16LE:
+==========================
+Always from UTF-8. This is optimised for speed. If length is exceeded or
+malformed data is found, it will return a negative number telling you how much
+of the source that was read. That is, a return code of -32 means you have an
+UNKNOWN number of characters of UCS-2 [use strlen16()] in the destination
+buffer and you should truncate your "saved_plain" at 32.
+
+    #include "unicode.h"
+    int utf8towcs(UTF16 *target, int maxtargetlen,
+           const UTF8 *source, int sourcelen);
+
+
+
+Convert UTF-16LE to UTF-8:
+==========================
+Currently used in NT_fmt.c in order to avoid using a saved_plain buffer.
+
+    #include "unicode.h"
+    extern char * utf16toutf8 (const UTF16* source);
+
+
+
+Return length (in characters) of a UTF16 string:
+================================================
+Number of octets is the result * sizeof(UTF16)
+
+    #include "unicode.h"
+    int strlen16(const UTF16 *str);
+
+
+
+Create an NT hash:
+==================
+This will convert from ISO-8859 or UTF-8 depending on the --utf8 option. The
+function will use Alain's fast NT hashing if length is <= 27 characters,
+otherwise it will use Solar's MD4. Lengths up to MAX_PLAINTEXT_LENGTH is thus
+supported with no hassle for you. If length is exceeded or malformed data is
+found, it will return a negative number telling you how much of the source
+that was read. That is, a return code of -32 means you should truncate your
+"saved_plain" at 32.
+
+    #include "unicode.h"
+    int E_md4hash(const UTF8 *passwd, int len, unsigned char *p16);
+
+
+
+NOTE that there are more functions available in ConvertUTF.c.original
+(ConvertUTF.h.original) and if we need any of them, we should copy them to
+unicode.c/h and simplify/optimize them.
diff -rupN john-1.7.8/doc/pdfcrack_README john-1.7.8-jumbo-2/doc/pdfcrack_README
--- john-1.7.8/doc/pdfcrack_README	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/pdfcrack_README	2011-06-08 02:55:45.000000000 +0200
@@ -0,0 +1,48 @@
+Code and documentation are copyright 2006-2008 Henning Norn
+
+Parts of pdfcrack.c and md5.c is derived/copied/inspired from
+xpdf/poppler and are copyright 1995-2006 Glyph & Cog, LLC.
+
+The PDF data structures, operators, and specification are
+copyright 1985-2006 Adobe Systems Inc.
+
+
+Project page: http://sourceforge.net/projects/pdfcrack/
+
+
+pdfcrack is a simple tool for recovering passwords from pdf-documents.
+It should be able to handle all pdfs that uses the standard security handler
+but the pdf-parsing routines are a bit of a quick hack so you might stumble
+across some pdfs where the parser needs to be fixed to handle.
+
+Type 'make' (or 'gmake' if you have BSD-make as default) to build the program.
+You will need to have GNU Make and a recent version of GCC installed but there
+are no external dependencies on libraries.
+You will have to add the -march-switch in the CFLAGS-option in Makefile
+for best optimization on your platform. Look into the GCC-manual
+(http://gcc.gnu.org/onlinedocs/) if you are unsure.
+
+The program is distributed under GPL version 2 (or later).
+
+Features available in this release (check TODO for features that might come):
+* Both owner- and user-passwords with the Standard Security Handler, rev 2 & 3.
+* Search by wordlist
+* Search by bruteforcing with specific charset
+* Optimized search for owner-password when user-password is known (or empty)
+* Extremely simple permutations of passwords (makes first letter uppercase)
+
+- currently only useful for bruteforcing with charsets:
+* Auto-save when interrupted (Ctrl-C or send SIGINT to the process)
+* Loading saved state
+
+- currently only for bruteforcing with charsets:
+* Minimum length of password to start at
+* Maximum length of password to try
+
+
+Sort your wordlist by length for best performance and consider that almost
+all passwords in PDFs are in iso latin 1 so use the correct character encoding
+in your terminal and/or wordlist when using special characters.
+
+This tool can not decrypt a Password Protected PDF.
+Look up the pdftk toolkit which can do that, when you know the password.
diff -rupN john-1.7.8/doc/pdfcrack_TODO john-1.7.8-jumbo-2/doc/pdfcrack_TODO
--- john-1.7.8/doc/pdfcrack_TODO	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/doc/pdfcrack_TODO	2011-06-08 02:55:45.000000000 +0200
@@ -0,0 +1,26 @@
+Replace pdfparser with a more robust and complete parsing of a PDF
+
+Optimize the crack and crypto-routines for greater performance
+
+Add support for third-party security handlers
+
+Add real permutation-support. Maybe John the Ripper could be a
+source of inspiration?
+
+Add support for masked passwords, when we already knows parts of the password
+
+
+Furthermore:
+
+Replace pdfparser with a complete representation of the structure of a
+PDF-file that can be used to find information and more importantly, can be
+written out again to a file.
+For this we need to understand/represent objects (indirect and direct), the
+file structure (lineraized and standard) and xreftables with trailers.
+We need to be able to update/fix the xreftables when writing it.
+We also need support for LZM-compression that is used for many streams.
+
+When the above item is done there is nothing stopping us from adding complete
+RC4-keyspace search and decrypt without having to bother cracking the
+passwords. An example of this search can be viewed at:
+http://www.upl.cs.wisc.edu/~hamblin/files/rc4_single_brute.c
diff -rupN john-1.7.8/run/genincstats.rb john-1.7.8-jumbo-2/run/genincstats.rb
--- john-1.7.8/run/genincstats.rb	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/genincstats.rb	2011-06-02 17:30:56.000000000 +0200
@@ -0,0 +1,78 @@
+#!/usr/bin/ruby -w
+
+require 'getoptlong'
+
+def	help
+	puts "Usage: #{$0} [options]"
+	puts "\t-h --help\t\tthis help."
+	puts "\t-f --file\t\toutput file."
+	puts "\t-n --num\t\tcharset: 0123456789"
+	puts "\t-a --alpha\t\tcharset: abcdefghijklmnopqrstuvwxyz"
+	puts "\t-A --alphamaj\t\tcharset: ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+	puts "\t-l --alphanum\t\tcharset: alpha + num"
+	puts "\t-l --alphanummaj\tcharset: alpha + alphamaj + num"
+	puts "\t-s --all\t\tcharset: alpha + alphamaj + num + !@#$+=.*"
+	puts "\t-c --custom"
+	puts "\nExample:\n"
+	puts "#{$0} -f stats -s"
+	puts "#{$0} -f stats -c \"0123abc+=\""
+	exit
+end
+
+ch_alpha 	= 'abcdefghijklmnopqrstuvwxyz'
+ch_num 		= '0123456789'
+ch_sp		= '!@#$+=.*'
+
+opts = GetoptLong.new(
+	[ '--help', '-h', GetoptLong::NO_ARGUMENT ],
+	[ '--file', '-f', GetoptLong::OPTIONAL_ARGUMENT],
+	[ '--all', '-s', GetoptLong::NO_ARGUMENT],
+	[ '--num', '-n', GetoptLong::NO_ARGUMENT],
+	[ '--alpha', '-a', GetoptLong::NO_ARGUMENT ],
+	[ '--alphamaj', '-A', GetoptLong::NO_ARGUMENT ],
+	[ '--alphanum', '-l', GetoptLong::NO_ARGUMENT ],
+	[ '--alphanummaj', '-L', GetoptLong::NO_ARGUMENT ],
+	[ '--custom', '-c', GetoptLong::OPTIONAL_ARGUMENT ]
+)
+
+charset = nil
+filename = "stats_out"
+
+opts.each do |opt, arg|
+	case opt
+	when '--help'
+		help
+	when '--file'
+		filename = arg
+	when '--num'
+		charset = ch_num
+	when '--alpha'
+		charset = ch_alpha
+	when '--alphamaj'
+		charset = ch_alpha.capitalize
+	when '--alphanum'
+		charset = ch_alpha + ch_num
+	when '--alphanummaj'
+		charset = ch_alpha.capitalize + ch_num
+	when '--all'
+		charset = ch_alpha + ch_alpha.capitalize + ch_num + ch_sp
+	when '--custom'
+		charset = arg
+	end
+end
+
+
+if charset == nil
+	help
+end
+
+
+fstat = File.open(filename, "w")
+charset.each_byte do |c|
+	fstat.write("1=proba1[#{c.to_s}]\n")
+	charset.each_byte do |tmp|
+		fstat.write("1=proba2[#{c.to_s}*256+#{tmp.to_s}]\n")
+	end
+end
+fstat.close
+
diff -rupN john-1.7.8/run/john.conf john-1.7.8-jumbo-2/run/john.conf
--- john-1.7.8/run/john.conf	2011-05-23 03:19:14.000000000 +0200
+++ john-1.7.8-jumbo-2/run/john.conf	2011-07-02 20:42:27.000000000 +0200
@@ -2,10 +2,16 @@
 # This file is part of John the Ripper password cracker,
 # Copyright (c) 1996-2006,2008-2011 by Solar Designer
 #
+# ...with changes in the jumbo patch, by various authors
+#
 
 [Options]
 # Wordlist file name, to be used in batch mode
 Wordlist = $JOHN/password.lst
+# Default Markov mode settings
+Statsfile = $JOHN/stats
+MkvLvl = 200
+MkvMaxLen = 12
 # Use idle cycles only
 Idle = Y
 # Crash recovery file saving delay in seconds
@@ -13,6 +19,29 @@ Save = 600
 # Beep when a password is found (who needs this anyway?)
 Beep = N
 
+# Automagically disable OMP if MPI is used (set to N if
+# you want to run one MPI process per multi-core host)
+MPIOMPmutex = Y
+
+# Print a notice if disabling OMP (when MPIOMPmutex = Y)
+# or when running OMP and MPI at the same time
+MPIOMPverbose = Y
+
+# Time formatting string used in status ETA.
+# %c  means 'local' specific canonical form, such as:
+# 05/06/11 18:10:34
+#
+# Other examples
+# %d/%m/%y %H:%M   (day/mon/year hour:min)
+# %m/%d/%y %H:%M   (mon/day/year hour:min)
+# %Y-%m-%d %H:%M   (ISO 8601 style, 2011-05-06 18:10)
+TimeFormat = %c
+
+# Threshold for showing ETA, in percent. ETA will not be
+# shown if progress is less than this. If too low, early
+# reported figures will be less accurate (default 0.05%)
+ETAthreshold = 0.05%
+
 # "Single crack" mode rules
 [List.Rules:Single]
 # Simple rules come first...
@@ -342,6 +371,19 @@ void filter()
 	}
 }
 
+[List.External:Filter_No_Cap_or_Symbols]
+void filter()
+{
+	int i, c;
+
+	i = 0;
+	while (c = word[i++])
+	if ((c < 'a' || c > 'z') && (c < '0' || c > '9')) {
+		return;
+	}
+	word = 0; return;
+}
+
 [List.External:Filter_LanMan]
 void filter()
 {
@@ -1244,3 +1286,218 @@ void filter()
 	word[i--] = 0;
 	word[i] = map2[(o & 0xfff) + (e >> 12)];
 }
+
+# Here are some examples of GENERIC-MD5.
+# Please refer to doc/MD5_GENERIC for documentation on how to set these up.
+
+####################################################################
+# Simple GENERIC-MD5 type for md5($p)^^4  (i.e. 4 steps of md5 recursively)
+####################################################################
+[List.Generic:md5_gen(1001)]
+# expression shown will be the string:   md5_gen(1001) md5(md5(md5(md5($p))))
+Expression=md5(md5(md5(md5($p))))
+Flag=MGF_KEYS_INPUT
+# here is the optimized 'script' to perform the md5 4 times on itself.
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+Test=md5_gen(1001)57200e13b490d4ae47d5e19be026b057:test1
+Test=md5_gen(1001)c6cc44f9e7fb7efcde62ba2e627a49c6:thatsworking
+Test=md5_gen(1001)0ae9549604e539a249c1fa9f5e5fb73b:test3
+
+####################################################################
+# Simple GENERIC-MD5 type for md5($p)^^5  (i.e. 5 steps of md5 recursively)
+####################################################################
+[List.Generic:md5_gen(1002)]
+# expression shown will be the string:   md5_gen(1002) md5(md5(md5(md5(md5($p)))))
+Expression=md5(md5(md5(md5(md5($p)))))
+Flag=MGF_KEYS_INPUT
+# here is the optimized 'script' to perform the md5 5 times on itself.
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+# These are test strings for this format.
+Test=md5_gen(1002)25de8cd0b0cf69c5b5bc19c8ee64adab:test1
+Test=md5_gen(1002)a0b535420ea47849f7c2cc09a3ad0ac3:thatsworking
+Test=md5_gen(1002)4cb029bd5b4ef79f785ca685caf17bf8:test3
+
+####################################################################
+# Simple GENERIC-MD5 type for md5(md5($p).md5($p))
+####################################################################
+[List.Generic:md5_gen(1003)]
+# expression shown will be the string:   md5_gen(1003) md5(md5($p).md5($p))
+Expression=md5(md5($p).md5($p))
+# NOTE, this format does NOT work on SSE2.  It requires a md5() of a 64 byte string.
+# SSE (or MMX) is limtited to 54 byte max password, due to 'enhancements'
+# Thus, we need a non-sse2 safe flag.
+Flag=MGF_NOTSSE2Safe
+Flag=MGF_KEYS_INPUT
+# here is the optimized 'script' to perform hash 'like' IPB but salt replaced with password.
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+# These are test strings for this format.
+Test=md5_gen(1003)478b10974f15e7295883224fd286ccba:test1
+Test=md5_gen(1003)18a59101e6c6fb38260d542a394ecb22:thatsworking
+Test=md5_gen(1003)630b01b68b6db6fd43a751f8147d1faf:test3
+
+####################################################################
+# Simple GENERIC-MD5 type for md5($p)^^6  (i.e. 6 steps of md5 recursively)
+####################################################################
+[List.Generic:md5_gen(1004)]
+# expression shown will be the string:   md5_gen(1004) md5(md5(md5(md5(md5(md5($p))))))
+Expression=md5(md5(md5(md5(md5(md5($p))))))
+Flag=MGF_KEYS_INPUT
+# here is the optimized 'script' to perform the md5 6 times on itself.
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+# These are test strings for this format.
+Test=md5_gen(1004)de1b991dd27fb9813e88b957a455dccd:test1
+Test=md5_gen(1004)6a62cd3c4d81139f61fb2553cdef0dc7:thatsworking
+Test=md5_gen(1004)a977990e521c5d1d17c6d65fdf2681b4:test3
+
+
+####################################################################
+# Simple GENERIC-MD5 type for md5($p)^^7  (i.e. 7 steps of md5 recursively)
+####################################################################
+[List.Generic:md5_gen(1005)]
+# expression shown will be the string:   md5_gen(1005) md5(md5(md5(md5(md5(md5(md5($p)))))))
+Expression=md5(md5(md5(md5(md5(md5(md5($p)))))))
+Flag=MGF_KEYS_INPUT
+# here is the optimized 'script' to perform the md5 7 times on itself.
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+# These are test strings for this format.
+Test=md5_gen(1005)784c527d0d92873ff9c0773e1c35621d:test1
+Test=md5_gen(1005)efcbbe6331caecf0e7f40160e65aadcc:thatsworking
+Test=md5_gen(1005)abb8bdd2c6ac2dfea2b2af6f5aed5446:test3
+
+####################################################################
+# Simple GENERIC-MD5 type for md5($p)^^8  (i.e. 8 steps of md5 recursively)
+####################################################################
+[List.Generic:md5_gen(1006)]
+# expression shown will be the string:   md5_gen(1006) md5(md5(md5(md5(md5(md5(md5(md5($p))))))))
+Expression=md5(md5(md5(md5(md5(md5(md5(md5($p))))))))
+Flag=MGF_KEYS_INPUT
+# here is the optimized 'script' to perform the md5 8 times on itself.
+Func=MD5GenBaseFunc__crypt
+Func=MD5GenBaseFunc__clean_input2
+Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt2
+Func=MD5GenBaseFunc__clean_input2_kwik
+Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+Func=MD5GenBaseFunc__crypt_in2_to_out1
+# These are test strings for this format.
+Test=md5_gen(1006)1ec1f32398f64cab51183f63630eceea:test1
+Test=md5_gen(1006)f66b339ac21d6fd6af216f2b70aab2c9:thatsworking
+Test=md5_gen(1006)e9d38522b5eeec753332e576e2e0fe5d:test3
+
+####################################################################
+# Simple GENERIC-MD5 type for vBulletin md5(md5($p).$s)   Included here to 'exercise' the script parser
+####################################################################
+[List.Generic:md5_gen(1007)]
+# expression shown will be the string:   md5_gen(1007) md5(md5($p).$s) [vBulletin]
+Expression=md5(md5($p).$s) [vBulletin]
+# Flag needed here, is Salt.  There is no 'fixed' saltlen.
+Flag=MGF_SALTED
+Flag=MGF_ColonNOTValid
+Flag=MGF_KEYS_BASE16_IN1
+# vBulletin has a 'fixed' 3 byte salt, so list the fixed size
+SaltLen=3
+ColonChar=;
+# here is the optimized 'script' to perform vBulletin hash
+Func=MD5GenBaseFunc__set_input_len_32
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+# NOTE, vBulletin is setup to 'override' the ':'.  USUALLY, it is good to use something
+# outside of the ASCII values from 0x20 to 0x7F.  0x1F is a 'good' choice, but it will
+# cause john.conf to have a 'non-normal' ASCII char.  Thus for this 'simple' example, I
+# have used the ';' character.  NOTE this would have the same 'problems' as the ':' character
+# if used for real, since ; is also a valid character within the salt of vBulletin.
+# NOTE to run, you MUST use the command line switch:   -field-separator-char=;
+Test=md5_gen(1007)daa61d77e218e42060c2fa198ac1feaf$SXB;test1
+Test=md5_gen(1007)de56b00bb15d6db79204bd44383469bc$T &;thatsworking
+Test=md5_gen(1007)fb685c6f469f6e549c85e4c1fb5a65a6$\\H:;test3
+
+####################################################################
+# Simple GENERIC-MD5 type for joomla md5($p.$s)   Included here to 'exercise' the script parser
+####################################################################
+[List.Generic:md5_gen(1008)]
+# expression shown will be the string:   md5_gen(1008) md5($p.$s) [joomla]
+Expression=md5($p.$s) [joomla]
+# Flag needed here, is Salt.  There is no 'fixed' saltlen.
+Flag=MGF_SALTED
+# here is the optimized 'script' to perform the md5 8 times on itself.
+Func=MD5GenBaseFunc__clean_input
+Func=MD5GenBaseFunc__append_keys
+Func=MD5GenBaseFunc__append_salt
+Func=MD5GenBaseFunc__crypt
+Test=md5_gen(1008)ed52af63d8ecf0c682442dfef5f36391$1aDNNojYGSc7pSzcdxKxhbqvLtEe4deG:test1
+Test=md5_gen(1008)4fa1e9d54d89bfbe48b4c0f0ca0a3756$laxcaXPjgcdKdKEbkX1SIjHKm0gfYt1c:thatsworking
+Test=md5_gen(1008)82568eeaa1fcf299662ccd59d8a12f54$BdWwFsbGtXPGc0H1TBxCrn0GasyAlJBJ:test3
+
diff -rupN john-1.7.8/run/ldif2pw.pl john-1.7.8-jumbo-2/run/ldif2pw.pl
--- john-1.7.8/run/ldif2pw.pl	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/ldif2pw.pl	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,25 @@
+#!/usr/bin/perl
+
+$i=1;
+
+while(<>) {
+	chomp;
+	if(/^$/) {
+		if($object{"uid"} ne "") {
+			print $object{"uid"}.":";
+			print $object{"userPassword"} ne "" ? $object{"userPassword"} : "*";
+			print ":";
+			print $i.":";
+			print $i.":";
+			print $object{"cn"}.":";
+			print $object{"homeDirectory"} ne "" ? $object{"homeDirectory"} : "/";
+			print ":/bin/sh\n";
+		}
+		%object = ();
+		$i++;
+		next;
+	}
+
+	($lhs, $rhs) = split(/: /);
+	$object{$lhs} = $rhs;
+}
diff -rupN john-1.7.8/run/netntlm.pl john-1.7.8-jumbo-2/run/netntlm.pl
--- john-1.7.8/run/netntlm.pl	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/netntlm.pl	2011-06-02 17:30:21.000000000 +0200
@@ -0,0 +1,262 @@
+#!/usr/bin/perl
+#
+#####################################################################
+#
+#   Written by JoMo-Kun <jmk at foofus.net> in 2007
+#   and placed in the public domain.
+#
+#   The purpose of this script is to aid with cracking a LM/NTLM
+#   challenge/response set, when part of the password is known. It
+#   was written with John's NetLM/NetNTLM formats and "halflmchall"
+#   Rainbow Tables in mind.
+#
+#   Example Scenario:
+#   Let's assume you've captured LM/NTLM challenge/response set for
+#   the password Cricket88!. You may be able to crack the first part
+#   (i.e. CRICKET) using "Half LM" Rainbow Tables. This script will
+#   use that value as a seed and attempt to crack the second part
+#   (i.e. "88!") via an incremental brute. It'll then use the NetNTLM
+#   response hash to crack the case-sensitive version of the entire
+#   password.
+#
+#####################################################################
+
+use Getopt::Long;
+
+my $VERSION = "0.2";
+my %opt;
+my %data;
+
+my $JOHN = "john";
+
+GetOptions (
+  'seed=s'      => \$opt{'seed'},
+  'file=s'      => \$opt{'file'},
+  'help|h'      => sub { ShowUsage(); },
+);
+
+sub showUsage {
+  print "john-netntlm.pl v$VERSION\n\n";
+  print "JoMo-Kun <jmk\@foofus.net>\n\n";
+  print "Usage: $0 [OPTIONS]\n";
+  print " $0\n";
+  print "   --seed [RainbowCrack/HalfLM Response Password]\n";
+  print "   --file [File Containing LM/NTLM challenge/responses (.lc format)]\n";
+  print "          Ex: Domain\\User:::LM response:NTLM response:challenge";
+  print "\n";
+  print " Ex:\n";
+  print " $0 --file capture.lc\n";
+  print " $0 --seed \"GERGE!!\"--file capture.lc\n";
+  print "\n";
+  exit(1);
+}
+
+# Main
+{
+  if ( !defined($opt{'file'}) ) { &showUsage; }
+
+  # Parse accounts to audit
+  open(HAND, $opt{'file'}) || die("Failed to open response file: $opt{'file'} -- $!");
+  @{ $data{'pairs'} } = <HAND>;
+  close(HAND);
+
+  # Load information for any accounts previous cracked
+  print STDERR "\n\n";
+  print STDERR "###########################################################################################\n";
+
+  open (HAND, "$JOHN -format:netlm -show $opt{'file'} |") || die("Failed to execute john: $!");
+  print STDERR "The following LM responses have been previously cracked:\n";
+  while(<HAND>) {
+    next if ( /\d+ password hashes cracked, \d+ left/ );
+    last if /^$/;
+    print "\t$_";
+    push @{ $data{'cracked-lm'} }, $_;
+  }
+  close(HAND);
+
+  print STDERR "\nThe following NTLM responses have been previously cracked:\n";
+  open (HAND, "$JOHN -format:netntlm -show $opt{'file'} |") || die("Failed to execute john: $!");
+  while(<HAND>) {
+    next if ( /\d+ password hashes cracked, \d+ left/ );
+    last if /^$/;
+    print "\t$_";
+    push @{ $data{'cracked-ntlm'} }, $_;
+  }
+  close(HAND);
+
+  mkdir("/tmp/john.$$") || die;
+  my $tmpconf = &createConf();
+  my $tmpsession = "/tmp/john.$$/john.session";
+  my $tmpsessionlog = "/tmp/john.$$/john.session.log";
+  my $tmplog = "/tmp/john.$$/john.log";
+  #print STDERR "Created temporary configuration file: $tmpconf\n";
+
+  # Crack case-sensitive version of password
+  my $tmpdict = "/tmp/john.$$/john.dict";
+  #print STDERR "Created temporary dictionary file: $tmpdict\n";
+
+  foreach $credential_set ( @{ $data{'cracked-lm'} } ) {
+    my ($account,$lmpass,$bar,$netlm,$netntlm,$chall) = split(/:/, $credential_set);
+    next if ( grep(/^$account:/i, @{ $data{'cracked-ntlm'} }) );
+
+    print STDERR "\n\n";
+    print STDERR "###########################################################################################\n";
+    print STDERR "Performing NTLM case-sensitive crack for account: $account.\n";
+
+    open(HAND, ">$tmpdict") || die("Failed to option file: $tmpdict -- $!");
+    print HAND "$lmpass";
+    close(HAND);
+
+    open (HAND, "$JOHN -format:netntlm -config:$tmpconf -wordlist:$tmpdict -rules -user:\"$account\" -session:$tmpsession $opt{'file'} |") || die("Failed to execute john: $!");
+    while(<HAND>) { print; }
+    close(HAND);
+
+    unlink $tmpdict || warn("Failed to unlink $tmpdict -- $!");
+  }
+
+  print STDERR "\n\n";
+  print STDERR "###########################################################################################\n";
+  print STDERR "Isolating accounts which have only had their LM response cracked.\n";
+
+  foreach $credential_set ( @{ $data{'pairs'} } ) {
+    $credential_set =~ s/\\/\\\\/g;
+    my ($account,$foo,$bar,$netlm,$netntlm,$chall) = split(/:/, $credential_set);
+    if (lc($netlm) eq lc($netntlm)) {
+      print STDERR "LM response is not unique from NTLM response (skipping):\n\t$credential_set\n";
+      push  @{ $data{'pairs-ntlm'} }, $credential_set;
+    }
+    elsif ( @cracked = grep(/^$account:/i, @{ $data{'cracked-ntlm'} }) ) {
+      print STDERR "Account $account NTLM response previously cracked.\n";
+      #print "@cracked";
+    }
+    else {
+      print STDERR "Account $account LM response added to cracking list.\n";
+      push  @{ $data{'pairs-lm'} }, $credential_set;
+    }
+  }
+
+  if ( defined($opt{'seed'}) ) {
+    print STDERR "\n\n";
+    print STDERR "###########################################################################################\n";
+    print STDERR "Testing seed password to determine whether it is the actual password.\n";
+    open(HAND, ">$tmpdict") || die("Failed to option file: $tmpdict -- $!");
+    print HAND $opt{'seed'};
+    close(HAND);
+
+    open (HAND, "$JOHN -format:netntlm -config:$tmpconf -wordlist:$tmpdict -rules -session:$tmpsession $opt{'file'} |") || die("Failed to execute john: $!");
+    while(<HAND>) {
+      print;
+      next if (/^guesses: .*time: / || (/^Loaded .* password hash /) || (/^No password hashes loaded/));
+      my ($account) = $_ =~ / \((.*)\)$/;
+
+      # Remove accounts which just cracked from list
+      my $i = 0;
+      foreach $credential_set ( @{ $data{'pairs-lm'} } ) {
+        $account =~ s/\\/_/g;
+        $credential_set =~ s/\\\\/_/g;
+        if ( $credential_set =~  /^$account:/ ) {
+          splice(@{ $data{'pairs-lm'} }, $i, 1);
+        }
+        $i++;
+      }
+    }
+    close(HAND);
+    unlink $tmpdict || warn("Failed to unlink $tmpdict -- $!");
+
+    my $tmppasswd = "/tmp/john.$$/john.passwd";
+    open(HAND, ">$tmppasswd") || die("Failed to open $tmppasswd: $!");
+    print HAND  @{ $data{'pairs-lm'} };
+    close(HAND);
+
+    print STDERR "\n\n";
+    print STDERR "###########################################################################################\n";
+    print STDERR "The hashes contained within $tmppasswd have not been cracked.\n";
+    print STDERR "Executing the following (this could take a while...):\n\n";
+    print STDERR "john -format:netlm -config:$tmpconf -external:HalfLM -incremental:LM -session:$tmpsession $tmppasswd\n";
+    print STDERR "\n";
+    print STDERR " *If the passwords successfully crack, use this script again to crack the case-sensitive password\n";
+    print STDERR " without feeding a seed password\n";
+    print STDERR"\n\n";
+
+    system("$JOHN -format:netlm -config:$tmpconf -external:HalfLM -incremental:LM -session:$tmpsession $tmppasswd");
+    #exec("$JOHN -format:netlm -config:$tmpconf -external:HalfLM -incremental:LM -session:$tmpsession $tmppasswd");
+
+    unlink $tmppasswd || warn("Failed to unlink $tmppasswd -- $!");
+  }
+  else {
+    print STDERR "\nNo seed supplied for testing.\n";
+  }
+
+  #print STDERR "Removing temporary files and directory\n";
+  unlink $tmpconf, $tmplog, $tmpsession, $tmpsessionlog || warn("Failed to unlink temporary config files -- $!");
+  rmdir("/tmp/john.$$") || warn("Failed to delete temporary john directory -- $!");
+}
+
+exit(0);
+
+sub createConf {
+  my $tmpconf = "/tmp/john.$$/john.conf";
+  open(CONF, ">$tmpconf") || die("Failed to open $tmpconf: $!");
+
+  # Define character keyspace
+  print CONF "[Incremental:LM]\n";
+  print CONF "File = \$JOHN/lanman.chr\n";
+  print CONF "MinLen = 1\n";
+
+  # John compiled for MaxLen <= 8
+  if (14 - length($opt{'seed'}) > 8) {
+    print CONF "MaxLen = 8\n";
+  } else {
+    print CONF "MaxLen = ", 14 - length($opt{'seed'}), "\n";
+  }
+  print CONF "CharCount = 69\n\n";
+
+  # Add external filter to handle uncracked characters
+  if ($opt{'seed'} ne "") {
+    my $i; $j;
+    my @seed = split(//, $opt{'seed'});
+
+    print CONF "[List.External:HalfLM]\n";
+    print CONF "void init()\n";
+    print CONF "{\n";
+    print CONF "  word[14] = 0;\n";
+    print CONF "}\n\n";
+
+    print CONF "void filter()\n";
+    print CONF "{\n";
+
+    my $len = length($opt{'seed'});
+    for ($i = 13, $j = 13 - $len; $i>=0; $i--) {
+      if ($i >= $len) {
+        print CONF "  word[$i] = word[$j];\n";
+        $j--;
+      } else {
+        print CONF "  word[$i] = \'$seed[$i]\';\n";
+      }
+    }
+
+    print CONF "}\n\n";
+  }
+
+  # Add custom wordlist to utilize NTLM hash for character case cracking
+  print CONF "[List.Rules:Wordlist]\n";
+  print CONF ":\n";
+  print CONF "-c T0Q\n";
+  print CONF "-c T1QT[z0]\n";
+  print CONF "-c T2QT[z0]T[z1]\n";
+  print CONF "-c T3QT[z0]T[z1]T[z2]\n";
+  print CONF "-c T4QT[z0]T[z1]T[z2]T[z3]\n";
+  print CONF "-c T5QT[z0]T[z1]T[z2]T[z3]T[z4]\n";
+  print CONF "-c T6QT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]\n";
+  print CONF "-c T7QT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]T[z6]\n";
+  print CONF "-c T8QT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]T[z6]T[z7]\n";
+  print CONF "-c T9QT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]T[z6]T[z7]T[z8]\n";
+  print CONF "-c TAQT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]T[z6]T[z7]T[z8]T[z9]\n";
+  print CONF "-c TBQT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]T[z6]T[z7]T[z8]T[z9]T[zA]\n";
+  print CONF "-c TCQT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]T[z6]T[z7]T[z8]T[z9]T[zA]T[zB]\n";
+  print CONF "-c TDQT[z0]T[z1]T[z2]T[z3]T[z4]T[z5]T[z6]T[z7]T[z8]T[z9]T[zA]T[zB]T[zC]\n";
+
+  close(CONF);
+
+  return $tmpconf;
+}
diff -rupN john-1.7.8/run/netscreen.py john-1.7.8-jumbo-2/run/netscreen.py
--- john-1.7.8/run/netscreen.py	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/netscreen.py	2011-06-02 17:30:21.000000000 +0200
@@ -0,0 +1,132 @@
+##################################################################
+#  Filename: netscreen.py
+#
+#  Please note this script will now run in Python version 3.x
+#
+# This script will generate a netscreen formatted password
+#
+# This program requires two command line arguments, and works in two modes:
+#   Mode 1:
+#    The first argument is a username
+#    The second argument is a plaintext password
+#   Mode 2:
+#    The first argument is -f to indicate reading usernames and passwords from a file
+#    The second argument is the filename to read
+#
+#  The input file should have one of the following formats (a "," or ":" separator):
+#    <username>,<plain-text-password>
+#    or
+#    <username>:<plain-text-password>
+#
+#    (Don't put a "space" after the separator, unless it is part of the password)
+#
+#   Example input file:
+#     admin,netscreen
+#     cisco:cisco
+#     robert,harris
+#
+# Output will be the username and hashed password in John the Ripper format
+# If reading usernames and passwords from a file, the output file name will be: netscreen-JtR-output.txt
+#      If the file netscreen-JtR-output.txt exists, it will be overwritten.
+#
+#  Version 2.04
+#  Updated on September 13, 2010 by Robert B. Harris from VA and Brad Tilley
+#     Updated to now run in Python v3.x (still works in Python 2.x)
+#     Additional separator for the input file. It can now have the new separator ":" (or use the old one ",")
+#     Now correctly handles a separator ("," or ":") in the password field when reading from a file.
+#     Updated help text in script
+#
+#  Version 2.01
+#  Updated on August 30, 2010 by Robert B. Harris from VA
+#    Very minor changes, removed tab, noted it won't run in python 3.x
+#
+#  Version  2.0
+#  Updated on August 12, 2010 by Robert B. Harris from VA
+#    Updated to use the hashlib library
+#    Updated to print help text if both input arguments are missing
+#    Updated to optionally read from a file
+#
+##################################################################
+
+import sys
+
+def net(user, password):
+  b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
+  middle = "Administration Tools"
+  s = "%s:%s:%s" % (user, middle, password)
+
+   # For versions of Python 2.5 and older
+  if sys.version_info[0] == 2 and sys.version_info[1] < 6:
+    import md5
+    m = md5.new(s).digest()
+  else:
+    import hashlib
+    m = hashlib.md5(s.encode('latin_1')).digest()
+
+  narray = []
+  for i in range(8):
+     if sys.version_info[0] == 2:
+           n1 = ord(m[2*i])
+           n2 = ord(m[2*i+1])
+           narray.append( (n1<<8 & 0xff00) | (n2 & 0xff) )
+
+     if sys.version_info[0] == 3:
+           n1 = ord(chr(m[2*i]))
+           n2 = ord(chr(m[2*i+1]))
+           narray.append( (n1<<8 & 0xff00) | (n2 & 0xff) )
+  res = ""
+  for i in narray:
+    p1 = i >> 12 & 0xf
+    p2 = i >> 6  & 0x3f
+    p3 = i       & 0x3f
+    res = res + b64[p1] + b64[p2] + b64[p3]
+
+  for c, n in  zip("nrcstn", [0, 6, 12, 17, 23, 29]):
+        res = res[:n] + c + res[n:]
+  return res
+
+
+if __name__ == '__main__':
+  if len(sys.argv) == 3:
+    if  (sys.argv[1])== "-f":  # If true, reading from a file
+       in_file = (sys.argv[2])   # 2nd commandline arg is the filename to read from
+       input_file = open( in_file, 'r')
+       output_file = open ("netscreen-JtR-output.txt" , 'w')
+       import re
+       for line in input_file:
+          data=line.strip('\n')
+          if re.search(',',line):
+             data=data.split(',',1) # line contains ,
+          else:
+             if re.search(':',line):
+               data=data.split(':',1) # line contains :
+             else:
+                 print ("\n\n\n")
+                 print ("Error in input file.")
+                 print ("The input file must have either a \",\" or \":\" separator on each line.")
+                 print ("Also it should not contain any blank lines. Please correct the input file.")
+                 break
+          username = data[0]
+          password = data[1]
+          ciphertext = net(username,password)
+          output_file.write ("%s:%s$%s" % (username,username,ciphertext))
+          output_file.write ("\n")
+       input_file.close()
+       print("\nThe output file has been created.")
+       output_file.close()
+    else:   # We are not reading from a file
+      username = sys.argv[1]
+      password = sys.argv[2]
+      ciphertext = net(username,password)
+      print(("%s:%s$%s" % (username,username,ciphertext)))
+  else:   # User did not input the required two commandline arguments
+    print("\n\n")
+    print("This program requires two commandline arguments:")
+    print("The first argument is a username, or -f to indicate reading from a file.")
+    print("The second argument is a plaintext password, or the name of the file to read from.")
+    print("See the additional text at the beginning of this script for more details.\n")
+    print("Output will be the username and the (Netscreen algorithm based) hashed password, in John the Ripper format. \n\n")
+    print("Example")
+    print("Input: netscreen.py admin netscreen")
+    print("Output: admin:admin$nKv3LvrdAVtOcE5EcsGIpYBtniNbUn")
+    print("(Netscreen uses the username as the salt)")
diff -rupN john-1.7.8/run/sap_prepare.pl john-1.7.8-jumbo-2/run/sap_prepare.pl
--- john-1.7.8/run/sap_prepare.pl	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/sap_prepare.pl	2011-06-02 17:30:21.000000000 +0200
@@ -0,0 +1,89 @@
+#!/usr/bin/perl -w
+# Usage: sap_prepare.pl csv-input sap-codeB-output sap-codevnG-output
+#   csv-input: XLS-exported table USH02 or USR02
+#              tab-speparted e.g. column 4:username column 17:bcode column 24:codvn G
+#   sap-codeB-output:   username:username<spaces>$bcode
+#   sap-codevnG-output: username:Username<spaces>$codvnG
+#
+# (all other formats with the right column names should work)
+# sap uses the username as salt. those have different length, so we needed to come up w/ our
+# own format. that is: username<space-padding-to-40>$HASHCODE
+#
+# evil spaghetti code, but works. sorry for the eye cancer ;-)
+
+$SALT_LENGTH = 40;
+
+if ($#ARGV != 2) {
+  die ("usage = $0 csv-input sap-codeB-output sap-codevnG-output \n");
+}
+
+open INPUT_FILE,  "$ARGV[0]" or die ("Can't open input-file ($ARGV[0])\n");
+open CODEB_FILE,">>$ARGV[1]" or die ("Can't open codeb-file ($ARGV[1])\n");
+open CODEG_FILE,">>$ARGV[2]" or die ("Can't open codeg-file ($ARGV[2])\n");
+
+print "data from >>$ARGV[0]<<\nto sap-codeB-output: >>$ARGV[1]<<\n";
+print "and sap-codevnG-output: >>$ARGV[2]<<\n\n";
+
+$line = "";
+$pos_bname=-1;
+$pos_codeb=-1;
+$pos_codeg=-1;
+$count=0;
+
+until ($line =~ /BNAME/)  {
+	$line=<INPUT_FILE>;
+	$count++;
+}
+
+chomp($line);
+@tmp = split(/\t/, $line);
+
+for ($i=0;$i<=$#tmp;$i++) {
+	if    ($tmp[$i]=~ /BNAME/)    { $pos_bname=$i }
+	elsif ($tmp[$i]=~ /BCODE/)    { $pos_codeb=$i }
+	elsif ($tmp[$i]=~ /PASSCODE/) { $pos_codeg=$i }
+}
+print "Column: $#tmp BNAME: $pos_bname BCODE: $pos_codeb PASSCODE: $pos_codeg\n";
+
+if (-1==$pos_bname || (-1==$pos_codeg  && -1==$pos_codeb ) ) {
+	print "BNAME column not found OR both hash-columns are missing \n";
+	exit 0;
+}
+
+while ($line=<INPUT_FILE>) {
+	$count++;
+	chomp($line);
+	@tmp = split(/\t/, $line);
+	if ($#tmp<$pos_bname || ($#tmp<$pos_codeb && $#tmp<$pos_codeg)) {
+		print "******** line $count in csv file has the wrong format ********\n";
+		next;
+	}
+	if ($pos_codeg!=-1 && $tmp[$pos_codeg]=~/[a-zA-Z0-9]/) {  # both hashes
+ 		print "username: $tmp[$pos_bname] codeB: $tmp[$pos_codeb] codeG: $tmp[$pos_codeg] \n";
+		$strN = $tmp[$pos_bname];
+		$strSALT = "$strN"." "x($SALT_LENGTH-length($tmp[$pos_bname]));
+		$strB = "$tmp[$pos_codeb]";
+		$strG = "$tmp[$pos_codeg]";
+		print CODEB_FILE "$strN:$strSALT\$$strB\n";
+		print CODEG_FILE "$strN:$strSALT\$$strG\n";
+	}
+	elsif ($pos_codeb!=-1 &&  $tmp[$pos_codeb]=~/[a-zA-Z0-9]/ ) { # only bcode
+		print "username: $tmp[$pos_bname] codeB: $tmp[$pos_codeb] \n";
+		$strN = $tmp[$pos_bname];
+		$strSALT = "$strN"." "x($SALT_LENGTH-length($tmp[$pos_bname]));
+		$strB = "$tmp[$pos_codeb]";
+		print CODEB_FILE "$strN:$strSALT\$$strB\n";
+	}
+	else {
+		print "******** line $count in csv file has the wrong format ********\n";
+	}
+}
+
+close INPUT_FILE;
+close CODEB_FILE;
+close CODEG_FILE;
+
+print "\nDone!\n";
+exit 0;
+
+
diff -rupN john-1.7.8/run/sha-dump.pl john-1.7.8-jumbo-2/run/sha-dump.pl
--- john-1.7.8/run/sha-dump.pl	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/sha-dump.pl	2011-06-02 17:30:21.000000000 +0200
@@ -0,0 +1,23 @@
+#!/usr/bin/perl
+
+use Net::LDAP;
+
+$server = $ARGV[0];
+$password = $ARGV[1];
+
+$ldap = Net::LDAP->new($server) || die "$@";
+$ldap->bind("cn=Directory Manager", password => $password) || die "$@";
+$search = $ldap->search(base => "o=test",
+        scope => "subtree",
+        filter => "(uid=*)");
+
+$search->code && die $search->error;
+
+$i=0;
+foreach $user ($search->all_entries) {
+  @uid=$user->get("uid");
+  @pass=$user->get("userpassword");
+  print $uid[0].":".$pass[0].":".
+    $i.":".$i.":/".$uid[0].":\n";
+}
+$ldap->unbind();
diff -rupN john-1.7.8/run/sha-test.pl john-1.7.8-jumbo-2/run/sha-test.pl
--- john-1.7.8/run/sha-test.pl	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/sha-test.pl	2011-06-02 17:30:21.000000000 +0200
@@ -0,0 +1,19 @@
+#!/usr/bin/perl
+# http://www.perl.com/CPAN-local/modules/by-module/MIME/MIME-Base64-2.06.tar.gz
+# http://www.perl.com/CPAN-local/modules/by-module/SHA/SHA-1.2.tar.gz
+
+use MIME::Base64;
+use SHA;
+if ("SHA-1" ne &SHA::sha_version) { die "wrong SHA version\n"; }
+$sha = new SHA;
+
+$label = "{SHA}";
+$count = 1;
+while(<>) {
+  chomp;
+  $hash = $sha->hash ($_);
+  printf ("%s:%s%s:%d:%d:%s:/home/%s/:\n",
+    $_, $label, encode_base64 ($hash . $salt, ""), $count, $count,
+    $_, $_);
+  $count++;
+}
diff -rupN john-1.7.8/run/stats john-1.7.8-jumbo-2/run/stats
--- john-1.7.8/run/stats	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/run/stats	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,4986 @@
+97=proba1[32]
+51=proba2[32*256+35]
+44=proba2[32*256+38]
+51=proba2[32*256+39]
+40=proba2[32*256+48]
+35=proba2[32*256+49]
+37=proba2[32*256+50]
+51=proba2[32*256+51]
+44=proba2[32*256+52]
+44=proba2[32*256+53]
+33=proba2[32*256+54]
+44=proba2[32*256+55]
+44=proba2[32*256+56]
+44=proba2[32*256+57]
+44=proba2[32*256+66]
+44=proba2[32*256+67]
+51=proba2[32*256+68]
+44=proba2[32*256+69]
+40=proba2[32*256+71]
+51=proba2[32*256+73]
+44=proba2[32*256+77]
+44=proba2[32*256+78]
+40=proba2[32*256+80]
+51=proba2[32*256+82]
+44=proba2[32*256+84]
+51=proba2[32*256+86]
+51=proba2[32*256+87]
+33=proba2[32*256+97]
+33=proba2[32*256+98]
+25=proba2[32*256+99]
+32=proba2[32*256+100]
+37=proba2[32*256+101]
+44=proba2[32*256+102]
+37=proba2[32*256+103]
+37=proba2[32*256+104]
+40=proba2[32*256+105]
+40=proba2[32*256+106]
+51=proba2[32*256+107]
+32=proba2[32*256+108]
+24=proba2[32*256+109]
+37=proba2[32*256+110]
+37=proba2[32*256+111]
+27=proba2[32*256+112]
+51=proba2[32*256+113]
+35=proba2[32*256+114]
+32=proba2[32*256+115]
+33=proba2[32*256+116]
+40=proba2[32*256+117]
+51=proba2[32*256+118]
+44=proba2[32*256+121]
+51=proba2[32*256+122]
+80=proba1[33]
+15=proba2[33*256+33]
+51=proba2[33*256+34]
+51=proba2[33*256+35]
+51=proba2[33*256+40]
+51=proba2[33*256+41]
+51=proba2[33*256+42]
+51=proba2[33*256+43]
+51=proba2[33*256+48]
+31=proba2[33*256+49]
+37=proba2[33*256+50]
+37=proba2[33*256+51]
+51=proba2[33*256+52]
+51=proba2[33*256+54]
+35=proba2[33*256+55]
+51=proba2[33*256+56]
+44=proba2[33*256+57]
+51=proba2[33*256+59]
+51=proba2[33*256+61]
+37=proba2[33*256+63]
+51=proba2[33*256+64]
+40=proba2[33*256+70]
+51=proba2[33*256+71]
+51=proba2[33*256+76]
+37=proba2[33*256+78]
+51=proba2[33*256+80]
+51=proba2[33*256+83]
+51=proba2[33*256+84]
+51=proba2[33*256+87]
+51=proba2[33*256+95]
+40=proba2[33*256+97]
+37=proba2[33*256+98]
+37=proba2[33*256+99]
+44=proba2[33*256+100]
+37=proba2[33*256+101]
+40=proba2[33*256+102]
+40=proba2[33*256+103]
+44=proba2[33*256+105]
+44=proba2[33*256+106]
+51=proba2[33*256+107]
+33=proba2[33*256+108]
+37=proba2[33*256+109]
+35=proba2[33*256+110]
+35=proba2[33*256+111]
+37=proba2[33*256+112]
+51=proba2[33*256+113]
+31=proba2[33*256+114]
+31=proba2[33*256+115]
+31=proba2[33*256+116]
+51=proba2[33*256+119]
+51=proba2[33*256+120]
+51=proba2[33*256+121]
+44=proba2[33*256+122]
+118=proba1[34]
+17=proba2[34*256+38]
+23=proba2[34*256+39]
+23=proba2[34*256+40]
+23=proba2[34*256+48]
+23=proba2[34*256+54]
+23=proba2[34*256+97]
+23=proba2[34*256+99]
+23=proba2[34*256+100]
+23=proba2[34*256+101]
+23=proba2[34*256+119]
+86=proba1[35]
+42=proba2[35*256+33]
+26=proba2[35*256+35]
+42=proba2[35*256+36]
+35=proba2[35*256+38]
+42=proba2[35*256+48]
+24=proba2[35*256+49]
+35=proba2[35*256+50]
+26=proba2[35*256+51]
+42=proba2[35*256+52]
+42=proba2[35*256+53]
+35=proba2[35*256+54]
+35=proba2[35*256+55]
+24=proba2[35*256+57]
+42=proba2[35*256+63]
+35=proba2[35*256+65]
+42=proba2[35*256+83]
+42=proba2[35*256+87]
+28=proba2[35*256+97]
+35=proba2[35*256+98]
+42=proba2[35*256+99]
+42=proba2[35*256+100]
+42=proba2[35*256+102]
+35=proba2[35*256+105]
+35=proba2[35*256+106]
+31=proba2[35*256+109]
+31=proba2[35*256+110]
+42=proba2[35*256+111]
+42=proba2[35*256+112]
+31=proba2[35*256+114]
+42=proba2[35*256+115]
+42=proba2[35*256+116]
+42=proba2[35*256+118]
+42=proba2[35*256+119]
+42=proba2[35*256+121]
+42=proba2[35*256+123]
+82=proba1[36]
+45=proba2[36*256+33]
+45=proba2[36*256+35]
+26=proba2[36*256+36]
+45=proba2[36*256+37]
+45=proba2[36*256+41]
+34=proba2[36*256+42]
+45=proba2[36*256+43]
+39=proba2[36*256+48]
+39=proba2[36*256+49]
+34=proba2[36*256+50]
+39=proba2[36*256+54]
+45=proba2[36*256+55]
+34=proba2[36*256+56]
+34=proba2[36*256+57]
+45=proba2[36*256+61]
+45=proba2[36*256+65]
+45=proba2[36*256+66]
+45=proba2[36*256+67]
+45=proba2[36*256+69]
+45=proba2[36*256+84]
+45=proba2[36*256+90]
+45=proba2[36*256+94]
+34=proba2[36*256+97]
+39=proba2[36*256+98]
+45=proba2[36*256+99]
+32=proba2[36*256+100]
+34=proba2[36*256+101]
+32=proba2[36*256+102]
+39=proba2[36*256+103]
+39=proba2[36*256+104]
+39=proba2[36*256+106]
+39=proba2[36*256+107]
+32=proba2[36*256+108]
+29=proba2[36*256+109]
+39=proba2[36*256+110]
+45=proba2[36*256+111]
+29=proba2[36*256+112]
+45=proba2[36*256+114]
+32=proba2[36*256+115]
+29=proba2[36*256+116]
+45=proba2[36*256+117]
+39=proba2[36*256+118]
+45=proba2[36*256+119]
+45=proba2[36*256+120]
+45=proba2[36*256+121]
+39=proba2[36*256+122]
+97=proba1[37]
+32=proba2[37*256+35]
+25=proba2[37*256+36]
+32=proba2[37*256+38]
+32=proba2[37*256+42]
+32=proba2[37*256+43]
+32=proba2[37*256+44]
+32=proba2[37*256+49]
+32=proba2[37*256+52]
+32=proba2[37*256+71]
+32=proba2[37*256+78]
+18=proba2[37*256+97]
+32=proba2[37*256+98]
+32=proba2[37*256+99]
+32=proba2[37*256+100]
+32=proba2[37*256+109]
+32=proba2[37*256+112]
+18=proba2[37*256+115]
+32=proba2[37*256+117]
+86=proba1[38]
+47=proba2[38*256+32]
+47=proba2[38*256+34]
+33=proba2[38*256+38]
+40=proba2[38*256+39]
+47=proba2[38*256+40]
+40=proba2[38*256+43]
+47=proba2[38*256+44]
+40=proba2[38*256+45]
+36=proba2[38*256+49]
+47=proba2[38*256+50]
+47=proba2[38*256+51]
+47=proba2[38*256+52]
+47=proba2[38*256+54]
+40=proba2[38*256+55]
+40=proba2[38*256+57]
+47=proba2[38*256+66]
+47=proba2[38*256+67]
+47=proba2[38*256+69]
+40=proba2[38*256+70]
+47=proba2[38*256+71]
+36=proba2[38*256+74]
+47=proba2[38*256+77]
+40=proba2[38*256+83]
+40=proba2[38*256+87]
+47=proba2[38*256+89]
+29=proba2[38*256+97]
+36=proba2[38*256+98]
+22=proba2[38*256+99]
+36=proba2[38*256+100]
+31=proba2[38*256+101]
+40=proba2[38*256+102]
+36=proba2[38*256+103]
+47=proba2[38*256+105]
+40=proba2[38*256+106]
+40=proba2[38*256+107]
+29=proba2[38*256+108]
+29=proba2[38*256+109]
+36=proba2[38*256+110]
+33=proba2[38*256+111]
+36=proba2[38*256+112]
+31=proba2[38*256+114]
+36=proba2[38*256+115]
+47=proba2[38*256+116]
+47=proba2[38*256+117]
+40=proba2[38*256+118]
+40=proba2[38*256+119]
+47=proba2[38*256+121]
+47=proba2[38*256+122]
+47=proba2[38*256+123]
+118=proba1[39]
+30=proba2[39*256+38]
+30=proba2[39*256+39]
+37=proba2[39*256+40]
+37=proba2[39*256+44]
+37=proba2[39*256+51]
+37=proba2[39*256+52]
+37=proba2[39*256+57]
+30=proba2[39*256+83]
+37=proba2[39*256+95]
+18=proba2[39*256+97]
+30=proba2[39*256+98]
+26=proba2[39*256+99]
+23=proba2[39*256+101]
+37=proba2[39*256+103]
+30=proba2[39*256+111]
+26=proba2[39*256+114]
+17=proba2[39*256+115]
+37=proba2[39*256+119]
+37=proba2[39*256+122]
+91=proba1[40]
+36=proba2[40*256+36]
+36=proba2[40*256+37]
+36=proba2[40*256+40]
+25=proba2[40*256+41]
+29=proba2[40*256+42]
+22=proba2[40*256+45]
+36=proba2[40*256+49]
+36=proba2[40*256+54]
+36=proba2[40*256+69]
+36=proba2[40*256+94]
+29=proba2[40*256+95]
+29=proba2[40*256+97]
+36=proba2[40*256+99]
+36=proba2[40*256+100]
+29=proba2[40*256+103]
+29=proba2[40*256+105]
+29=proba2[40*256+110]
+36=proba2[40*256+112]
+36=proba2[40*256+114]
+29=proba2[40*256+115]
+29=proba2[40*256+116]
+36=proba2[40*256+118]
+36=proba2[40*256+121]
+36=proba2[40*256+124]
+118=proba1[41]
+13=proba2[41*256+40]
+27=proba2[41*256+41]
+27=proba2[41*256+54]
+27=proba2[41*256+61]
+27=proba2[41*256+103]
+27=proba2[41*256+107]
+27=proba2[41*256+108]
+20=proba2[41*256+111]
+20=proba2[41*256+112]
+27=proba2[41*256+114]
+78=proba1[42]
+44=proba2[42*256+36]
+44=proba2[42*256+38]
+51=proba2[42*256+40]
+51=proba2[42*256+41]
+15=proba2[42*256+42]
+51=proba2[42*256+44]
+44=proba2[42*256+45]
+44=proba2[42*256+46]
+44=proba2[42*256+48]
+33=proba2[42*256+49]
+40=proba2[42*256+50]
+34=proba2[42*256+51]
+40=proba2[42*256+52]
+37=proba2[42*256+54]
+37=proba2[42*256+55]
+51=proba2[42*256+56]
+34=proba2[42*256+57]
+51=proba2[42*256+59]
+51=proba2[42*256+61]
+51=proba2[42*256+63]
+51=proba2[42*256+64]
+51=proba2[42*256+65]
+44=proba2[42*256+66]
+51=proba2[42*256+67]
+44=proba2[42*256+68]
+51=proba2[42*256+69]
+51=proba2[42*256+73]
+51=proba2[42*256+77]
+51=proba2[42*256+78]
+51=proba2[42*256+80]
+51=proba2[42*256+82]
+51=proba2[42*256+95]
+28=proba2[42*256+97]
+40=proba2[42*256+98]
+31=proba2[42*256+99]
+40=proba2[42*256+100]
+51=proba2[42*256+101]
+51=proba2[42*256+102]
+37=proba2[42*256+103]
+37=proba2[42*256+105]
+44=proba2[42*256+106]
+37=proba2[42*256+108]
+33=proba2[42*256+109]
+44=proba2[42*256+110]
+51=proba2[42*256+111]
+37=proba2[42*256+112]
+44=proba2[42*256+113]
+51=proba2[42*256+114]
+33=proba2[42*256+115]
+51=proba2[42*256+116]
+51=proba2[42*256+117]
+37=proba2[42*256+118]
+51=proba2[42*256+119]
+51=proba2[42*256+120]
+51=proba2[42*256+122]
+96=proba1[43]
+38=proba2[43*256+38]
+19=proba2[43*256+43]
+31=proba2[43*256+45]
+29=proba2[43*256+49]
+38=proba2[43*256+50]
+45=proba2[43*256+51]
+45=proba2[43*256+52]
+31=proba2[43*256+53]
+29=proba2[43*256+54]
+34=proba2[43*256+55]
+38=proba2[43*256+61]
+45=proba2[43*256+66]
+38=proba2[43*256+67]
+45=proba2[43*256+72]
+38=proba2[43*256+74]
+38=proba2[43*256+75]
+45=proba2[43*256+76]
+45=proba2[43*256+80]
+45=proba2[43*256+85]
+45=proba2[43*256+89]
+38=proba2[43*256+97]
+29=proba2[43*256+98]
+38=proba2[43*256+99]
+45=proba2[43*256+101]
+38=proba2[43*256+102]
+45=proba2[43*256+103]
+45=proba2[43*256+104]
+45=proba2[43*256+105]
+45=proba2[43*256+106]
+45=proba2[43*256+107]
+29=proba2[43*256+108]
+38=proba2[43*256+109]
+45=proba2[43*256+110]
+38=proba2[43*256+111]
+45=proba2[43*256+112]
+38=proba2[43*256+113]
+45=proba2[43*256+115]
+31=proba2[43*256+116]
+38=proba2[43*256+119]
+38=proba2[43*256+120]
+96=proba1[44]
+24=proba2[44*256+44]
+28=proba2[44*256+46]
+44=proba2[44*256+48]
+28=proba2[44*256+49]
+33=proba2[44*256+50]
+37=proba2[44*256+51]
+33=proba2[44*256+55]
+33=proba2[44*256+56]
+37=proba2[44*256+57]
+28=proba2[44*256+59]
+37=proba2[44*256+65]
+44=proba2[44*256+66]
+44=proba2[44*256+73]
+44=proba2[44*256+83]
+44=proba2[44*256+84]
+44=proba2[44*256+86]
+37=proba2[44*256+97]
+44=proba2[44*256+98]
+37=proba2[44*256+99]
+33=proba2[44*256+100]
+37=proba2[44*256+102]
+44=proba2[44*256+103]
+44=proba2[44*256+105]
+37=proba2[44*256+106]
+44=proba2[44*256+107]
+23=proba2[44*256+109]
+37=proba2[44*256+110]
+30=proba2[44*256+112]
+37=proba2[44*256+115]
+26=proba2[44*256+116]
+37=proba2[44*256+118]
+44=proba2[44*256+121]
+44=proba2[44*256+122]
+91=proba1[45]
+57=proba2[45*256+34]
+57=proba2[45*256+36]
+43=proba2[45*256+38]
+57=proba2[45*256+39]
+57=proba2[45*256+40]
+43=proba2[45*256+43]
+27=proba2[45*256+45]
+33=proba2[45*256+48]
+23=proba2[45*256+49]
+32=proba2[45*256+50]
+43=proba2[45*256+51]
+43=proba2[45*256+52]
+46=proba2[45*256+53]
+33=proba2[45*256+54]
+36=proba2[45*256+55]
+36=proba2[45*256+56]
+30=proba2[45*256+57]
+57=proba2[45*256+63]
+57=proba2[45*256+65]
+50=proba2[45*256+66]
+50=proba2[45*256+67]
+50=proba2[45*256+68]
+57=proba2[45*256+69]
+50=proba2[45*256+70]
+50=proba2[45*256+71]
+57=proba2[45*256+73]
+57=proba2[45*256+74]
+57=proba2[45*256+75]
+50=proba2[45*256+76]
+57=proba2[45*256+77]
+57=proba2[45*256+78]
+57=proba2[45*256+80]
+50=proba2[45*256+84]
+57=proba2[45*256+87]
+46=proba2[45*256+88]
+57=proba2[45*256+97]
+39=proba2[45*256+98]
+33=proba2[45*256+99]
+41=proba2[45*256+100]
+50=proba2[45*256+101]
+35=proba2[45*256+102]
+36=proba2[45*256+103]
+41=proba2[45*256+104]
+39=proba2[45*256+105]
+36=proba2[45*256+106]
+50=proba2[45*256+107]
+30=proba2[45*256+108]
+35=proba2[45*256+109]
+37=proba2[45*256+110]
+43=proba2[45*256+111]
+39=proba2[45*256+112]
+35=proba2[45*256+114]
+36=proba2[45*256+115]
+32=proba2[45*256+116]
+57=proba2[45*256+117]
+46=proba2[45*256+118]
+41=proba2[45*256+119]
+50=proba2[45*256+120]
+57=proba2[45*256+121]
+57=proba2[45*256+122]
+93=proba1[46]
+54=proba2[46*256+32]
+54=proba2[46*256+35]
+54=proba2[46*256+43]
+41=proba2[46*256+44]
+23=proba2[46*256+46]
+24=proba2[46*256+48]
+27=proba2[46*256+49]
+32=proba2[46*256+50]
+34=proba2[46*256+51]
+41=proba2[46*256+52]
+35=proba2[46*256+53]
+41=proba2[46*256+54]
+36=proba2[46*256+55]
+29=proba2[46*256+56]
+38=proba2[46*256+57]
+43=proba2[46*256+65]
+47=proba2[46*256+70]
+54=proba2[46*256+71]
+47=proba2[46*256+73]
+54=proba2[46*256+74]
+47=proba2[46*256+78]
+54=proba2[46*256+79]
+54=proba2[46*256+83]
+41=proba2[46*256+84]
+54=proba2[46*256+85]
+54=proba2[46*256+87]
+38=proba2[46*256+97]
+35=proba2[46*256+98]
+36=proba2[46*256+99]
+35=proba2[46*256+100]
+41=proba2[46*256+101]
+38=proba2[46*256+102]
+43=proba2[46*256+103]
+41=proba2[46*256+104]
+54=proba2[46*256+105]
+38=proba2[46*256+106]
+54=proba2[46*256+107]
+34=proba2[46*256+108]
+38=proba2[46*256+109]
+34=proba2[46*256+110]
+47=proba2[46*256+111]
+47=proba2[46*256+112]
+54=proba2[46*256+113]
+54=proba2[46*256+114]
+30=proba2[46*256+115]
+38=proba2[46*256+117]
+47=proba2[46*256+118]
+43=proba2[46*256+119]
+47=proba2[46*256+120]
+54=proba2[46*256+121]
+47=proba2[46*256+122]
+46=proba1[48]
+94=proba2[48*256+32]
+83=proba2[48*256+33]
+94=proba2[48*256+35]
+78=proba2[48*256+36]
+87=proba2[48*256+37]
+87=proba2[48*256+41]
+94=proba2[48*256+42]
+83=proba2[48*256+43]
+76=proba2[48*256+45]
+73=proba2[48*256+46]
+14=proba2[48*256+48]
+20=proba2[48*256+49]
+26=proba2[48*256+50]
+27=proba2[48*256+51]
+27=proba2[48*256+52]
+27=proba2[48*256+53]
+27=proba2[48*256+54]
+22=proba2[48*256+55]
+27=proba2[48*256+56]
+29=proba2[48*256+57]
+87=proba2[48*256+59]
+94=proba2[48*256+60]
+94=proba2[48*256+64]
+75=proba2[48*256+65]
+78=proba2[48*256+66]
+87=proba2[48*256+67]
+94=proba2[48*256+69]
+83=proba2[48*256+70]
+87=proba2[48*256+71]
+87=proba2[48*256+72]
+87=proba2[48*256+73]
+94=proba2[48*256+74]
+80=proba2[48*256+75]
+80=proba2[48*256+76]
+72=proba2[48*256+77]
+83=proba2[48*256+78]
+94=proba2[48*256+79]
+94=proba2[48*256+80]
+83=proba2[48*256+82]
+76=proba2[48*256+83]
+87=proba2[48*256+84]
+83=proba2[48*256+86]
+94=proba2[48*256+88]
+80=proba2[48*256+90]
+94=proba2[48*256+95]
+53=proba2[48*256+97]
+56=proba2[48*256+98]
+52=proba2[48*256+99]
+56=proba2[48*256+100]
+60=proba2[48*256+101]
+59=proba2[48*256+102]
+63=proba2[48*256+103]
+67=proba2[48*256+104]
+69=proba2[48*256+105]
+63=proba2[48*256+106]
+63=proba2[48*256+107]
+54=proba2[48*256+108]
+51=proba2[48*256+109]
+55=proba2[48*256+110]
+62=proba2[48*256+111]
+58=proba2[48*256+112]
+78=proba2[48*256+113]
+56=proba2[48*256+114]
+54=proba2[48*256+115]
+56=proba2[48*256+116]
+60=proba2[48*256+117]
+64=proba2[48*256+118]
+65=proba2[48*256+119]
+65=proba2[48*256+120]
+72=proba2[48*256+121]
+66=proba2[48*256+122]
+38=proba1[49]
+75=proba2[49*256+33]
+95=proba2[49*256+35]
+88=proba2[49*256+36]
+84=proba2[49*256+38]
+95=proba2[49*256+41]
+75=proba2[49*256+42]
+82=proba2[49*256+43]
+79=proba2[49*256+44]
+73=proba2[49*256+45]
+69=proba2[49*256+46]
+21=proba2[49*256+48]
+21=proba2[49*256+49]
+17=proba2[49*256+50]
+26=proba2[49*256+51]
+28=proba2[49*256+52]
+28=proba2[49*256+53]
+30=proba2[49*256+54]
+27=proba2[49*256+55]
+29=proba2[49*256+56]
+20=proba2[49*256+57]
+88=proba2[49*256+59]
+84=proba2[49*256+61]
+84=proba2[49*256+64]
+67=proba2[49*256+65]
+76=proba2[49*256+66]
+76=proba2[49*256+67]
+76=proba2[49*256+68]
+82=proba2[49*256+69]
+84=proba2[49*256+70]
+79=proba2[49*256+71]
+88=proba2[49*256+72]
+84=proba2[49*256+73]
+88=proba2[49*256+74]
+82=proba2[49*256+75]
+75=proba2[49*256+76]
+72=proba2[49*256+77]
+76=proba2[49*256+78]
+79=proba2[49*256+79]
+82=proba2[49*256+80]
+82=proba2[49*256+82]
+79=proba2[49*256+83]
+75=proba2[49*256+84]
+95=proba2[49*256+85]
+88=proba2[49*256+86]
+88=proba2[49*256+87]
+95=proba2[49*256+88]
+95=proba2[49*256+89]
+84=proba2[49*256+90]
+46=proba2[49*256+97]
+50=proba2[49*256+98]
+52=proba2[49*256+99]
+54=proba2[49*256+100]
+54=proba2[49*256+101]
+58=proba2[49*256+102]
+56=proba2[49*256+103]
+64=proba2[49*256+104]
+59=proba2[49*256+105]
+56=proba2[49*256+106]
+63=proba2[49*256+107]
+55=proba2[49*256+108]
+51=proba2[49*256+109]
+53=proba2[49*256+110]
+59=proba2[49*256+111]
+56=proba2[49*256+112]
+63=proba2[49*256+113]
+56=proba2[49*256+114]
+51=proba2[49*256+115]
+54=proba2[49*256+116]
+67=proba2[49*256+117]
+60=proba2[49*256+118]
+63=proba2[49*256+119]
+65=proba2[49*256+120]
+70=proba2[49*256+121]
+69=proba2[49*256+122]
+42=proba1[50]
+82=proba2[50*256+32]
+69=proba2[50*256+33]
+82=proba2[50*256+35]
+86=proba2[50*256+36]
+86=proba2[50*256+37]
+86=proba2[50*256+39]
+71=proba2[50*256+42]
+82=proba2[50*256+43]
+93=proba2[50*256+44]
+71=proba2[50*256+45]
+65=proba2[50*256+46]
+20=proba2[50*256+48]
+22=proba2[50*256+49]
+23=proba2[50*256+50]
+18=proba2[50*256+51]
+26=proba2[50*256+52]
+25=proba2[50*256+53]
+28=proba2[50*256+54]
+26=proba2[50*256+55]
+28=proba2[50*256+56]
+30=proba2[50*256+57]
+86=proba2[50*256+59]
+86=proba2[50*256+61]
+86=proba2[50*256+63]
+82=proba2[50*256+64]
+69=proba2[50*256+65]
+69=proba2[50*256+66]
+65=proba2[50*256+67]
+77=proba2[50*256+68]
+86=proba2[50*256+69]
+79=proba2[50*256+70]
+73=proba2[50*256+71]
+75=proba2[50*256+72]
+86=proba2[50*256+73]
+82=proba2[50*256+74]
+79=proba2[50*256+75]
+82=proba2[50*256+76]
+72=proba2[50*256+77]
+71=proba2[50*256+78]
+93=proba2[50*256+79]
+75=proba2[50*256+80]
+86=proba2[50*256+81]
+75=proba2[50*256+82]
+79=proba2[50*256+83]
+71=proba2[50*256+84]
+86=proba2[50*256+85]
+79=proba2[50*256+86]
+93=proba2[50*256+87]
+86=proba2[50*256+88]
+75=proba2[50*256+89]
+73=proba2[50*256+90]
+93=proba2[50*256+91]
+93=proba2[50*256+95]
+46=proba2[50*256+97]
+45=proba2[50*256+98]
+46=proba2[50*256+99]
+49=proba2[50*256+100]
+53=proba2[50*256+101]
+50=proba2[50*256+102]
+56=proba2[50*256+103]
+57=proba2[50*256+104]
+56=proba2[50*256+105]
+56=proba2[50*256+106]
+59=proba2[50*256+107]
+51=proba2[50*256+108]
+46=proba2[50*256+109]
+56=proba2[50*256+110]
+59=proba2[50*256+111]
+50=proba2[50*256+112]
+61=proba2[50*256+113]
+48=proba2[50*256+114]
+49=proba2[50*256+115]
+53=proba2[50*256+116]
+60=proba2[50*256+117]
+57=proba2[50*256+118]
+55=proba2[50*256+119]
+63=proba2[50*256+120]
+59=proba2[50*256+121]
+58=proba2[50*256+122]
+52=proba1[51]
+69=proba2[51*256+33]
+88=proba2[51*256+34]
+77=proba2[51*256+35]
+88=proba2[51*256+36]
+88=proba2[51*256+37]
+82=proba2[51*256+38]
+71=proba2[51*256+42]
+82=proba2[51*256+43]
+88=proba2[51*256+44]
+68=proba2[51*256+45]
+60=proba2[51*256+46]
+21=proba2[51*256+48]
+22=proba2[51*256+49]
+24=proba2[51*256+50]
+23=proba2[51*256+51]
+20=proba2[51*256+52]
+26=proba2[51*256+53]
+28=proba2[51*256+54]
+28=proba2[51*256+55]
+29=proba2[51*256+56]
+32=proba2[51*256+57]
+88=proba2[51*256+59]
+88=proba2[51*256+61]
+88=proba2[51*256+62]
+77=proba2[51*256+63]
+82=proba2[51*256+64]
+61=proba2[51*256+65]
+64=proba2[51*256+66]
+68=proba2[51*256+67]
+68=proba2[51*256+68]
+72=proba2[51*256+69]
+71=proba2[51*256+70]
+64=proba2[51*256+71]
+88=proba2[51*256+72]
+82=proba2[51*256+73]
+77=proba2[51*256+74]
+69=proba2[51*256+75]
+71=proba2[51*256+76]
+68=proba2[51*256+77]
+77=proba2[51*256+78]
+88=proba2[51*256+79]
+72=proba2[51*256+80]
+88=proba2[51*256+81]
+66=proba2[51*256+82]
+77=proba2[51*256+83]
+71=proba2[51*256+84]
+88=proba2[51*256+85]
+75=proba2[51*256+86]
+88=proba2[51*256+87]
+77=proba2[51*256+88]
+69=proba2[51*256+90]
+77=proba2[51*256+95]
+43=proba2[51*256+97]
+48=proba2[51*256+98]
+45=proba2[51*256+99]
+42=proba2[51*256+100]
+48=proba2[51*256+101]
+52=proba2[51*256+102]
+50=proba2[51*256+103]
+54=proba2[51*256+104]
+55=proba2[51*256+105]
+51=proba2[51*256+106]
+57=proba2[51*256+107]
+51=proba2[51*256+108]
+44=proba2[51*256+109]
+53=proba2[51*256+110]
+54=proba2[51*256+111]
+48=proba2[51*256+112]
+61=proba2[51*256+113]
+47=proba2[51*256+114]
+49=proba2[51*256+115]
+52=proba2[51*256+116]
+60=proba2[51*256+117]
+53=proba2[51*256+118]
+58=proba2[51*256+119]
+61=proba2[51*256+120]
+61=proba2[51*256+121]
+54=proba2[51*256+122]
+56=proba1[52]
+80=proba2[52*256+32]
+87=proba2[52*256+33]
+87=proba2[52*256+35]
+80=proba2[52*256+36]
+73=proba2[52*256+37]
+87=proba2[52*256+39]
+87=proba2[52*256+40]
+87=proba2[52*256+42]
+68=proba2[52*256+43]
+87=proba2[52*256+44]
+76=proba2[52*256+45]
+69=proba2[52*256+46]
+22=proba2[52*256+48]
+23=proba2[52*256+49]
+25=proba2[52*256+50]
+29=proba2[52*256+51]
+24=proba2[52*256+52]
+19=proba2[52*256+53]
+27=proba2[52*256+54]
+25=proba2[52*256+55]
+28=proba2[52*256+56]
+30=proba2[52*256+57]
+80=proba2[52*256+59]
+87=proba2[52*256+61]
+87=proba2[52*256+64]
+69=proba2[52*256+65]
+80=proba2[52*256+66]
+69=proba2[52*256+67]
+80=proba2[52*256+68]
+80=proba2[52*256+69]
+73=proba2[52*256+70]
+71=proba2[52*256+71]
+80=proba2[52*256+72]
+87=proba2[52*256+73]
+73=proba2[52*256+74]
+80=proba2[52*256+75]
+76=proba2[52*256+76]
+73=proba2[52*256+77]
+76=proba2[52*256+78]
+87=proba2[52*256+79]
+66=proba2[52*256+80]
+87=proba2[52*256+81]
+68=proba2[52*256+82]
+87=proba2[52*256+83]
+73=proba2[52*256+84]
+76=proba2[52*256+85]
+80=proba2[52*256+86]
+76=proba2[52*256+87]
+87=proba2[52*256+88]
+76=proba2[52*256+89]
+76=proba2[52*256+90]
+80=proba2[52*256+95]
+42=proba2[52*256+97]
+47=proba2[52*256+98]
+50=proba2[52*256+99]
+48=proba2[52*256+100]
+46=proba2[52*256+101]
+48=proba2[52*256+102]
+50=proba2[52*256+103]
+53=proba2[52*256+104]
+54=proba2[52*256+105]
+52=proba2[52*256+106]
+57=proba2[52*256+107]
+49=proba2[52*256+108]
+43=proba2[52*256+109]
+52=proba2[52*256+110]
+62=proba2[52*256+111]
+49=proba2[52*256+112]
+60=proba2[52*256+113]
+51=proba2[52*256+114]
+47=proba2[52*256+115]
+48=proba2[52*256+116]
+51=proba2[52*256+117]
+57=proba2[52*256+118]
+57=proba2[52*256+119]
+58=proba2[52*256+120]
+54=proba2[52*256+121]
+57=proba2[52*256+122]
+57=proba1[53]
+80=proba2[53*256+32]
+80=proba2[53*256+33]
+76=proba2[53*256+35]
+76=proba2[53*256+36]
+80=proba2[53*256+37]
+87=proba2[53*256+38]
+87=proba2[53*256+39]
+69=proba2[53*256+43]
+87=proba2[53*256+44]
+71=proba2[53*256+45]
+71=proba2[53*256+46]
+21=proba2[53*256+48]
+23=proba2[53*256+49]
+26=proba2[53*256+50]
+28=proba2[53*256+51]
+26=proba2[53*256+52]
+24=proba2[53*256+53]
+19=proba2[53*256+54]
+24=proba2[53*256+55]
+27=proba2[53*256+56]
+26=proba2[53*256+57]
+87=proba2[53*256+59]
+87=proba2[53*256+61]
+80=proba2[53*256+63]
+68=proba2[53*256+65]
+68=proba2[53*256+66]
+64=proba2[53*256+67]
+87=proba2[53*256+68]
+87=proba2[53*256+69]
+67=proba2[53*256+70]
+68=proba2[53*256+71]
+80=proba2[53*256+72]
+80=proba2[53*256+73]
+73=proba2[53*256+74]
+87=proba2[53*256+75]
+73=proba2[53*256+76]
+73=proba2[53*256+77]
+80=proba2[53*256+78]
+80=proba2[53*256+79]
+68=proba2[53*256+80]
+87=proba2[53*256+81]
+73=proba2[53*256+82]
+71=proba2[53*256+83]
+71=proba2[53*256+84]
+76=proba2[53*256+85]
+87=proba2[53*256+86]
+76=proba2[53*256+87]
+87=proba2[53*256+88]
+80=proba2[53*256+89]
+87=proba2[53*256+90]
+45=proba2[53*256+97]
+48=proba2[53*256+98]
+49=proba2[53*256+99]
+52=proba2[53*256+100]
+50=proba2[53*256+101]
+50=proba2[53*256+102]
+50=proba2[53*256+103]
+58=proba2[53*256+104]
+56=proba2[53*256+105]
+56=proba2[53*256+106]
+55=proba2[53*256+107]
+52=proba2[53*256+108]
+46=proba2[53*256+109]
+54=proba2[53*256+110]
+58=proba2[53*256+111]
+49=proba2[53*256+112]
+57=proba2[53*256+113]
+51=proba2[53*256+114]
+49=proba2[53*256+115]
+51=proba2[53*256+116]
+62=proba2[53*256+117]
+58=proba2[53*256+118]
+60=proba2[53*256+119]
+62=proba2[53*256+120]
+54=proba2[53*256+121]
+57=proba2[53*256+122]
+56=proba1[54]
+75=proba2[54*256+32]
+70=proba2[54*256+33]
+81=proba2[54*256+36]
+81=proba2[54*256+42]
+81=proba2[54*256+43]
+68=proba2[54*256+45]
+70=proba2[54*256+46]
+23=proba2[54*256+48]
+26=proba2[54*256+49]
+30=proba2[54*256+50]
+29=proba2[54*256+51]
+26=proba2[54*256+52]
+27=proba2[54*256+53]
+15=proba2[54*256+54]
+24=proba2[54*256+55]
+26=proba2[54*256+56]
+22=proba2[54*256+57]
+88=proba2[54*256+59]
+81=proba2[54*256+61]
+88=proba2[54*256+63]
+88=proba2[54*256+64]
+68=proba2[54*256+65]
+61=proba2[54*256+66]
+81=proba2[54*256+67]
+77=proba2[54*256+68]
+77=proba2[54*256+69]
+75=proba2[54*256+70]
+77=proba2[54*256+71]
+77=proba2[54*256+72]
+66=proba2[54*256+73]
+88=proba2[54*256+74]
+68=proba2[54*256+75]
+88=proba2[54*256+76]
+77=proba2[54*256+77]
+88=proba2[54*256+78]
+88=proba2[54*256+79]
+75=proba2[54*256+80]
+81=proba2[54*256+81]
+75=proba2[54*256+82]
+77=proba2[54*256+83]
+88=proba2[54*256+84]
+88=proba2[54*256+85]
+77=proba2[54*256+86]
+75=proba2[54*256+87]
+88=proba2[54*256+88]
+88=proba2[54*256+89]
+88=proba2[54*256+90]
+88=proba2[54*256+93]
+88=proba2[54*256+94]
+47=proba2[54*256+97]
+49=proba2[54*256+98]
+52=proba2[54*256+99]
+51=proba2[54*256+100]
+53=proba2[54*256+101]
+53=proba2[54*256+102]
+55=proba2[54*256+103]
+58=proba2[54*256+104]
+55=proba2[54*256+105]
+54=proba2[54*256+106]
+54=proba2[54*256+107]
+53=proba2[54*256+108]
+48=proba2[54*256+109]
+53=proba2[54*256+110]
+59=proba2[54*256+111]
+50=proba2[54*256+112]
+64=proba2[54*256+113]
+53=proba2[54*256+114]
+47=proba2[54*256+115]
+54=proba2[54*256+116]
+64=proba2[54*256+117]
+57=proba2[54*256+118]
+65=proba2[54*256+119]
+61=proba2[54*256+120]
+58=proba2[54*256+121]
+61=proba2[54*256+122]
+55=proba1[55]
+82=proba2[55*256+32]
+71=proba2[55*256+33]
+78=proba2[55*256+35]
+78=proba2[55*256+36]
+82=proba2[55*256+38]
+71=proba2[55*256+42]
+82=proba2[55*256+43]
+82=proba2[55*256+44]
+67=proba2[55*256+45]
+67=proba2[55*256+46]
+23=proba2[55*256+48]
+24=proba2[55*256+49]
+26=proba2[55*256+50]
+26=proba2[55*256+51]
+24=proba2[55*256+52]
+23=proba2[55*256+53]
+25=proba2[55*256+54]
+20=proba2[55*256+55]
+23=proba2[55*256+56]
+26=proba2[55*256+57]
+78=proba2[55*256+59]
+82=proba2[55*256+64]
+71=proba2[55*256+65]
+71=proba2[55*256+66]
+73=proba2[55*256+67]
+71=proba2[55*256+68]
+75=proba2[55*256+69]
+75=proba2[55*256+70]
+89=proba2[55*256+71]
+78=proba2[55*256+72]
+75=proba2[55*256+73]
+78=proba2[55*256+74]
+78=proba2[55*256+75]
+71=proba2[55*256+76]
+71=proba2[55*256+77]
+75=proba2[55*256+78]
+82=proba2[55*256+79]
+78=proba2[55*256+80]
+89=proba2[55*256+81]
+78=proba2[55*256+82]
+78=proba2[55*256+83]
+78=proba2[55*256+84]
+89=proba2[55*256+85]
+75=proba2[55*256+86]
+75=proba2[55*256+87]
+78=proba2[55*256+88]
+82=proba2[55*256+89]
+82=proba2[55*256+90]
+48=proba2[55*256+97]
+50=proba2[55*256+98]
+51=proba2[55*256+99]
+53=proba2[55*256+100]
+54=proba2[55*256+101]
+56=proba2[55*256+102]
+52=proba2[55*256+103]
+60=proba2[55*256+104]
+55=proba2[55*256+105]
+53=proba2[55*256+106]
+56=proba2[55*256+107]
+50=proba2[55*256+108]
+49=proba2[55*256+109]
+55=proba2[55*256+110]
+61=proba2[55*256+111]
+53=proba2[55*256+112]
+67=proba2[55*256+113]
+58=proba2[55*256+114]
+52=proba2[55*256+115]
+53=proba2[55*256+116]
+56=proba2[55*256+117]
+54=proba2[55*256+118]
+63=proba2[55*256+119]
+62=proba2[55*256+120]
+61=proba2[55*256+121]
+58=proba2[55*256+122]
+89=proba2[55*256+124]
+60=proba1[56]
+86=proba2[56*256+32]
+75=proba2[56*256+33]
+75=proba2[56*256+36]
+86=proba2[56*256+38]
+86=proba2[56*256+41]
+66=proba2[56*256+42]
+86=proba2[56*256+44]
+68=proba2[56*256+45]
+66=proba2[56*256+46]
+19=proba2[56*256+48]
+21=proba2[56*256+49]
+24=proba2[56*256+50]
+25=proba2[56*256+51]
+27=proba2[56*256+52]
+27=proba2[56*256+53]
+27=proba2[56*256+54]
+25=proba2[56*256+55]
+25=proba2[56*256+56]
+27=proba2[56*256+57]
+86=proba2[56*256+59]
+86=proba2[56*256+61]
+72=proba2[56*256+63]
+79=proba2[56*256+65]
+68=proba2[56*256+66]
+75=proba2[56*256+67]
+79=proba2[56*256+68]
+79=proba2[56*256+69]
+68=proba2[56*256+70]
+75=proba2[56*256+71]
+79=proba2[56*256+72]
+70=proba2[56*256+74]
+75=proba2[56*256+75]
+70=proba2[56*256+76]
+66=proba2[56*256+77]
+79=proba2[56*256+78]
+75=proba2[56*256+79]
+72=proba2[56*256+80]
+79=proba2[56*256+81]
+79=proba2[56*256+82]
+68=proba2[56*256+83]
+72=proba2[56*256+84]
+86=proba2[56*256+85]
+86=proba2[56*256+86]
+86=proba2[56*256+87]
+79=proba2[56*256+88]
+79=proba2[56*256+89]
+72=proba2[56*256+90]
+79=proba2[56*256+94]
+46=proba2[56*256+97]
+46=proba2[56*256+98]
+47=proba2[56*256+99]
+52=proba2[56*256+100]
+49=proba2[56*256+101]
+54=proba2[56*256+102]
+49=proba2[56*256+103]
+50=proba2[56*256+104]
+55=proba2[56*256+105]
+49=proba2[56*256+106]
+51=proba2[56*256+107]
+53=proba2[56*256+108]
+46=proba2[56*256+109]
+56=proba2[56*256+110]
+60=proba2[56*256+111]
+50=proba2[56*256+112]
+60=proba2[56*256+113]
+53=proba2[56*256+114]
+45=proba2[56*256+115]
+50=proba2[56*256+116]
+58=proba2[56*256+117]
+58=proba2[56*256+118]
+59=proba2[56*256+119]
+64=proba2[56*256+120]
+57=proba2[56*256+121]
+55=proba2[56*256+122]
+59=proba1[57]
+82=proba2[57*256+32]
+73=proba2[57*256+33]
+89=proba2[57*256+36]
+89=proba2[57*256+38]
+78=proba2[57*256+42]
+78=proba2[57*256+43]
+71=proba2[57*256+45]
+68=proba2[57*256+46]
+26=proba2[57*256+48]
+27=proba2[57*256+49]
+30=proba2[57*256+50]
+30=proba2[57*256+51]
+29=proba2[57*256+52]
+27=proba2[57*256+53]
+24=proba2[57*256+54]
+20=proba2[57*256+55]
+15=proba2[57*256+56]
+21=proba2[57*256+57]
+89=proba2[57*256+61]
+89=proba2[57*256+62]
+67=proba2[57*256+65]
+78=proba2[57*256+66]
+75=proba2[57*256+68]
+75=proba2[57*256+69]
+82=proba2[57*256+71]
+82=proba2[57*256+72]
+78=proba2[57*256+73]
+78=proba2[57*256+74]
+71=proba2[57*256+75]
+75=proba2[57*256+76]
+71=proba2[57*256+77]
+78=proba2[57*256+78]
+82=proba2[57*256+79]
+75=proba2[57*256+80]
+70=proba2[57*256+82]
+71=proba2[57*256+83]
+75=proba2[57*256+84]
+89=proba2[57*256+85]
+82=proba2[57*256+86]
+89=proba2[57*256+87]
+75=proba2[57*256+89]
+78=proba2[57*256+90]
+49=proba2[57*256+97]
+54=proba2[57*256+98]
+49=proba2[57*256+99]
+57=proba2[57*256+100]
+58=proba2[57*256+101]
+55=proba2[57*256+102]
+55=proba2[57*256+103]
+57=proba2[57*256+104]
+57=proba2[57*256+105]
+57=proba2[57*256+106]
+61=proba2[57*256+107]
+53=proba2[57*256+108]
+51=proba2[57*256+109]
+57=proba2[57*256+110]
+63=proba2[57*256+111]
+55=proba2[57*256+112]
+66=proba2[57*256+113]
+55=proba2[57*256+114]
+51=proba2[57*256+115]
+55=proba2[57*256+116]
+63=proba2[57*256+117]
+59=proba2[57*256+118]
+61=proba2[57*256+119]
+60=proba2[57*256+120]
+64=proba2[57*256+121]
+65=proba2[57*256+122]
+97=proba1[59]
+40=proba2[59*256+39]
+40=proba2[59*256+42]
+33=proba2[59*256+48]
+40=proba2[59*256+50]
+40=proba2[59*256+51]
+33=proba2[59*256+52]
+40=proba2[59*256+55]
+33=proba2[59*256+57]
+18=proba2[59*256+59]
+40=proba2[59*256+61]
+40=proba2[59*256+76]
+33=proba2[59*256+77]
+40=proba2[59*256+78]
+40=proba2[59*256+80]
+40=proba2[59*256+84]
+40=proba2[59*256+97]
+33=proba2[59*256+98]
+33=proba2[59*256+100]
+29=proba2[59*256+101]
+33=proba2[59*256+102]
+33=proba2[59*256+103]
+40=proba2[59*256+104]
+40=proba2[59*256+105]
+33=proba2[59*256+108]
+33=proba2[59*256+109]
+26=proba2[59*256+110]
+40=proba2[59*256+111]
+40=proba2[59*256+112]
+40=proba2[59*256+113]
+33=proba2[59*256+114]
+29=proba2[59*256+115]
+111=proba1[60]
+19=proba2[60*256+35]
+19=proba2[60*256+49]
+12=proba2[60*256+50]
+19=proba2[60*256+51]
+12=proba2[60*256+62]
+95=proba1[61]
+43=proba2[61*256+37]
+43=proba2[61*256+40]
+43=proba2[61*256+41]
+32=proba2[61*256+42]
+43=proba2[61*256+44]
+43=proba2[61*256+45]
+37=proba2[61*256+49]
+24=proba2[61*256+50]
+32=proba2[61*256+51]
+37=proba2[61*256+53]
+37=proba2[61*256+55]
+43=proba2[61*256+56]
+43=proba2[61*256+57]
+43=proba2[61*256+59]
+15=proba2[61*256+61]
+43=proba2[61*256+63]
+43=proba2[61*256+71]
+43=proba2[61*256+83]
+43=proba2[61*256+90]
+43=proba2[61*256+94]
+37=proba2[61*256+97]
+37=proba2[61*256+98]
+43=proba2[61*256+100]
+43=proba2[61*256+102]
+37=proba2[61*256+103]
+43=proba2[61*256+107]
+37=proba2[61*256+108]
+20=proba2[61*256+109]
+43=proba2[61*256+110]
+43=proba2[61*256+111]
+43=proba2[61*256+112]
+43=proba2[61*256+113]
+43=proba2[61*256+115]
+32=proba2[61*256+116]
+43=proba2[61*256+117]
+43=proba2[61*256+119]
+13=proba2[62*256+65]
+13=proba2[62*256+98]
+13=proba2[62*256+108]
+13=proba2[62*256+115]
+97=proba1[63]
+25=proba2[63*256+33]
+36=proba2[63*256+43]
+29=proba2[63*256+46]
+36=proba2[63*256+50]
+36=proba2[63*256+54]
+22=proba2[63*256+63]
+36=proba2[63*256+65]
+36=proba2[63*256+69]
+36=proba2[63*256+73]
+36=proba2[63*256+78]
+36=proba2[63*256+89]
+36=proba2[63*256+91]
+36=proba2[63*256+98]
+29=proba2[63*256+99]
+36=proba2[63*256+101]
+36=proba2[63*256+109]
+29=proba2[63*256+110]
+36=proba2[63*256+111]
+36=proba2[63*256+113]
+29=proba2[63*256+114]
+29=proba2[63*256+115]
+36=proba2[63*256+116]
+36=proba2[63*256+119]
+22=proba2[63*256+122]
+82=proba1[64]
+48=proba2[64*256+33]
+37=proba2[64*256+35]
+48=proba2[64*256+36]
+48=proba2[64*256+46]
+37=proba2[64*256+48]
+32=proba2[64*256+49]
+41=proba2[64*256+50]
+37=proba2[64*256+51]
+37=proba2[64*256+52]
+48=proba2[64*256+53]
+41=proba2[64*256+54]
+41=proba2[64*256+55]
+41=proba2[64*256+57]
+48=proba2[64*256+63]
+23=proba2[64*256+64]
+48=proba2[64*256+66]
+48=proba2[64*256+82]
+41=proba2[64*256+91]
+48=proba2[64*256+98]
+34=proba2[64*256+99]
+32=proba2[64*256+100]
+48=proba2[64*256+101]
+37=proba2[64*256+102]
+34=proba2[64*256+103]
+48=proba2[64*256+104]
+41=proba2[64*256+106]
+48=proba2[64*256+107]
+25=proba2[64*256+108]
+18=proba2[64*256+109]
+34=proba2[64*256+110]
+27=proba2[64*256+114]
+32=proba2[64*256+115]
+27=proba2[64*256+116]
+37=proba2[64*256+118]
+41=proba2[64*256+119]
+48=proba2[64*256+120]
+48=proba2[64*256+122]
+59=proba1[65]
+72=proba2[65*256+33]
+65=proba2[65*256+43]
+65=proba2[65*256+44]
+65=proba2[65*256+45]
+72=proba2[65*256+46]
+54=proba2[65*256+48]
+36=proba2[65*256+49]
+39=proba2[65*256+50]
+48=proba2[65*256+51]
+51=proba2[65*256+52]
+45=proba2[65*256+53]
+47=proba2[65*256+54]
+54=proba2[65*256+55]
+51=proba2[65*256+56]
+45=proba2[65*256+57]
+72=proba2[65*256+59]
+40=proba2[65*256+65]
+35=proba2[65*256+66]
+33=proba2[65*256+67]
+35=proba2[65*256+68]
+47=proba2[65*256+69]
+43=proba2[65*256+70]
+42=proba2[65*256+71]
+49=proba2[65*256+72]
+33=proba2[65*256+73]
+56=proba2[65*256+74]
+43=proba2[65*256+75]
+25=proba2[65*256+76]
+29=proba2[65*256+77]
+22=proba2[65*256+78]
+50=proba2[65*256+79]
+40=proba2[65*256+80]
+56=proba2[65*256+81]
+25=proba2[65*256+82]
+28=proba2[65*256+83]
+30=proba2[65*256+84]
+35=proba2[65*256+85]
+43=proba2[65*256+86]
+50=proba2[65*256+87]
+49=proba2[65*256+88]
+44=proba2[65*256+89]
+35=proba2[65*256+90]
+58=proba2[65*256+97]
+49=proba2[65*256+98]
+53=proba2[65*256+99]
+44=proba2[65*256+100]
+65=proba2[65*256+101]
+72=proba2[65*256+102]
+56=proba2[65*256+103]
+65=proba2[65*256+104]
+58=proba2[65*256+105]
+58=proba2[65*256+107]
+37=proba2[65*256+108]
+56=proba2[65*256+109]
+37=proba2[65*256+110]
+54=proba2[65*256+112]
+65=proba2[65*256+113]
+43=proba2[65*256+114]
+46=proba2[65*256+115]
+51=proba2[65*256+116]
+51=proba2[65*256+117]
+61=proba2[65*256+118]
+61=proba2[65*256+119]
+65=proba2[65*256+120]
+56=proba2[65*256+121]
+72=proba2[65*256+122]
+63=proba1[66]
+63=proba2[66*256+35]
+49=proba2[66*256+45]
+43=proba2[66*256+48]
+34=proba2[66*256+49]
+40=proba2[66*256+50]
+43=proba2[66*256+51]
+41=proba2[66*256+52]
+47=proba2[66*256+53]
+39=proba2[66*256+54]
+49=proba2[66*256+55]
+41=proba2[66*256+56]
+41=proba2[66*256+57]
+63=proba2[66*256+64]
+25=proba2[66*256+65]
+38=proba2[66*256+66]
+36=proba2[66*256+67]
+33=proba2[66*256+68]
+25=proba2[66*256+69]
+49=proba2[66*256+70]
+39=proba2[66*256+71]
+63=proba2[66*256+72]
+30=proba2[66*256+73]
+47=proba2[66*256+74]
+52=proba2[66*256+75]
+35=proba2[66*256+76]
+41=proba2[66*256+77]
+43=proba2[66*256+78]
+25=proba2[66*256+79]
+63=proba2[66*256+80]
+63=proba2[66*256+81]
+34=proba2[66*256+82]
+45=proba2[66*256+83]
+52=proba2[66*256+84]
+39=proba2[66*256+85]
+47=proba2[66*256+86]
+56=proba2[66*256+87]
+56=proba2[66*256+88]
+49=proba2[66*256+89]
+43=proba2[66*256+90]
+29=proba2[66*256+97]
+63=proba2[66*256+98]
+63=proba2[66*256+99]
+35=proba2[66*256+101]
+63=proba2[66*256+104]
+35=proba2[66*256+105]
+49=proba2[66*256+108]
+63=proba2[66*256+110]
+29=proba2[66*256+111]
+52=proba2[66*256+112]
+63=proba2[66*256+113]
+35=proba2[66*256+114]
+56=proba2[66*256+115]
+56=proba2[66*256+116]
+39=proba2[66*256+117]
+56=proba2[66*256+118]
+56=proba2[66*256+119]
+56=proba2[66*256+120]
+56=proba2[66*256+122]
+61=proba1[67]
+65=proba2[67*256+32]
+65=proba2[67*256+39]
+65=proba2[67*256+41]
+59=proba2[67*256+46]
+48=proba2[67*256+48]
+37=proba2[67*256+49]
+36=proba2[67*256+50]
+39=proba2[67*256+51]
+43=proba2[67*256+52]
+42=proba2[67*256+53]
+42=proba2[67*256+54]
+65=proba2[67*256+55]
+54=proba2[67*256+56]
+48=proba2[67*256+57]
+24=proba2[67*256+65]
+42=proba2[67*256+66]
+41=proba2[67*256+67]
+43=proba2[67*256+68]
+28=proba2[67*256+69]
+49=proba2[67*256+70]
+49=proba2[67*256+71]
+23=proba2[67*256+72]
+32=proba2[67*256+73]
+65=proba2[67*256+74]
+33=proba2[67*256+75]
+38=proba2[67*256+76]
+43=proba2[67*256+77]
+49=proba2[67*256+78]
+22=proba2[67*256+79]
+42=proba2[67*256+80]
+59=proba2[67*256+81]
+31=proba2[67*256+82]
+40=proba2[67*256+83]
+41=proba2[67*256+84]
+42=proba2[67*256+85]
+54=proba2[67*256+86]
+54=proba2[67*256+88]
+54=proba2[67*256+89]
+59=proba2[67*256+90]
+65=proba2[67*256+94]
+33=proba2[67*256+97]
+65=proba2[67*256+98]
+52=proba2[67*256+99]
+41=proba2[67*256+101]
+65=proba2[67*256+102]
+54=proba2[67*256+103]
+33=proba2[67*256+104]
+45=proba2[67*256+105]
+65=proba2[67*256+106]
+65=proba2[67*256+107]
+38=proba2[67*256+108]
+48=proba2[67*256+109]
+31=proba2[67*256+111]
+65=proba2[67*256+112]
+65=proba2[67*256+113]
+43=proba2[67*256+114]
+54=proba2[67*256+115]
+65=proba2[67*256+116]
+54=proba2[67*256+117]
+41=proba2[67*256+121]
+65=proba1[68]
+56=proba2[68*256+38]
+63=proba2[68*256+43]
+40=proba2[68*256+48]
+36=proba2[68*256+49]
+41=proba2[68*256+50]
+42=proba2[68*256+51]
+49=proba2[68*256+52]
+52=proba2[68*256+53]
+49=proba2[68*256+54]
+45=proba2[68*256+55]
+43=proba2[68*256+56]
+40=proba2[68*256+57]
+63=proba2[68*256+59]
+63=proba2[68*256+64]
+24=proba2[68*256+65]
+45=proba2[68*256+66]
+45=proba2[68*256+67]
+41=proba2[68*256+68]
+23=proba2[68*256+69]
+47=proba2[68*256+70]
+52=proba2[68*256+71]
+49=proba2[68*256+72]
+25=proba2[68*256+73]
+36=proba2[68*256+74]
+47=proba2[68*256+75]
+42=proba2[68*256+76]
+40=proba2[68*256+77]
+56=proba2[68*256+78]
+27=proba2[68*256+79]
+47=proba2[68*256+80]
+30=proba2[68*256+82]
+39=proba2[68*256+83]
+47=proba2[68*256+84]
+38=proba2[68*256+85]
+49=proba2[68*256+86]
+52=proba2[68*256+87]
+49=proba2[68*256+89]
+47=proba2[68*256+90]
+63=proba2[68*256+95]
+32=proba2[68*256+97]
+49=proba2[68*256+100]
+31=proba2[68*256+101]
+63=proba2[68*256+102]
+63=proba2[68*256+103]
+63=proba2[68*256+104]
+33=proba2[68*256+105]
+49=proba2[68*256+106]
+56=proba2[68*256+107]
+63=proba2[68*256+108]
+52=proba2[68*256+109]
+56=proba2[68*256+110]
+33=proba2[68*256+111]
+49=proba2[68*256+112]
+36=proba2[68*256+114]
+47=proba2[68*256+115]
+63=proba2[68*256+116]
+38=proba2[68*256+117]
+56=proba2[68*256+118]
+63=proba2[68*256+119]
+45=proba2[68*256+120]
+56=proba2[68*256+121]
+69=proba1[69]
+68=proba2[69*256+42]
+68=proba2[69*256+45]
+68=proba2[69*256+46]
+46=proba2[69*256+48]
+35=proba2[69*256+49]
+41=proba2[69*256+50]
+52=proba2[69*256+51]
+50=proba2[69*256+52]
+43=proba2[69*256+53]
+47=proba2[69*256+54]
+57=proba2[69*256+55]
+52=proba2[69*256+56]
+39=proba2[69*256+57]
+35=proba2[69*256+65]
+39=proba2[69*256+66]
+35=proba2[69*256+67]
+35=proba2[69*256+68]
+44=proba2[69*256+69]
+49=proba2[69*256+70]
+41=proba2[69*256+71]
+52=proba2[69*256+72]
+47=proba2[69*256+73]
+52=proba2[69*256+74]
+46=proba2[69*256+75]
+22=proba2[69*256+76]
+32=proba2[69*256+77]
+26=proba2[69*256+78]
+46=proba2[69*256+79]
+38=proba2[69*256+80]
+18=proba2[69*256+82]
+27=proba2[69*256+83]
+27=proba2[69*256+84]
+39=proba2[69*256+85]
+44=proba2[69*256+86]
+50=proba2[69*256+87]
+40=proba2[69*256+88]
+45=proba2[69*256+89]
+52=proba2[69*256+90]
+54=proba2[69*256+97]
+54=proba2[69*256+98]
+50=proba2[69*256+99]
+54=proba2[69*256+100]
+57=proba2[69*256+101]
+61=proba2[69*256+102]
+61=proba2[69*256+103]
+57=proba2[69*256+104]
+57=proba2[69*256+105]
+61=proba2[69*256+106]
+61=proba2[69*256+107]
+38=proba2[69*256+108]
+49=proba2[69*256+109]
+43=proba2[69*256+110]
+61=proba2[69*256+111]
+68=proba2[69*256+112]
+57=proba2[69*256+114]
+54=proba2[69*256+115]
+50=proba2[69*256+116]
+50=proba2[69*256+117]
+57=proba2[69*256+118]
+68=proba2[69*256+119]
+54=proba2[69*256+120]
+68=proba2[69*256+121]
+68=proba2[69*256+122]
+66=proba1[70]
+59=proba2[70*256+35]
+59=proba2[70*256+38]
+59=proba2[70*256+44]
+59=proba2[70*256+45]
+59=proba2[70*256+46]
+43=proba2[70*256+48]
+35=proba2[70*256+49]
+37=proba2[70*256+50]
+40=proba2[70*256+51]
+48=proba2[70*256+52]
+45=proba2[70*256+53]
+40=proba2[70*256+54]
+48=proba2[70*256+55]
+48=proba2[70*256+56]
+40=proba2[70*256+57]
+23=proba2[70*256+65]
+41=proba2[70*256+66]
+41=proba2[70*256+67]
+37=proba2[70*256+68]
+33=proba2[70*256+69]
+35=proba2[70*256+70]
+43=proba2[70*256+71]
+59=proba2[70*256+72]
+27=proba2[70*256+73]
+41=proba2[70*256+74]
+48=proba2[70*256+75]
+32=proba2[70*256+76]
+41=proba2[70*256+77]
+59=proba2[70*256+78]
+31=proba2[70*256+79]
+48=proba2[70*256+80]
+59=proba2[70*256+81]
+29=proba2[70*256+82]
+37=proba2[70*256+83]
+41=proba2[70*256+84]
+36=proba2[70*256+85]
+43=proba2[70*256+86]
+48=proba2[70*256+87]
+48=proba2[70*256+88]
+59=proba2[70*256+89]
+59=proba2[70*256+90]
+59=proba2[70*256+93]
+59=proba2[70*256+95]
+30=proba2[70*256+97]
+48=proba2[70*256+99]
+59=proba2[70*256+100]
+36=proba2[70*256+101]
+45=proba2[70*256+102]
+52=proba2[70*256+103]
+41=proba2[70*256+105]
+59=proba2[70*256+107]
+33=proba2[70*256+108]
+52=proba2[70*256+109]
+52=proba2[70*256+110]
+38=proba2[70*256+111]
+30=proba2[70*256+114]
+52=proba2[70*256+116]
+41=proba2[70*256+117]
+59=proba2[70*256+121]
+59=proba2[70*256+122]
+66=proba1[71]
+54=proba2[71*256+32]
+54=proba2[71*256+33]
+54=proba2[71*256+42]
+61=proba2[71*256+45]
+43=proba2[71*256+48]
+37=proba2[71*256+49]
+39=proba2[71*256+50]
+41=proba2[71*256+51]
+47=proba2[71*256+52]
+47=proba2[71*256+53]
+54=proba2[71*256+54]
+37=proba2[71*256+55]
+54=proba2[71*256+56]
+37=proba2[71*256+57]
+23=proba2[71*256+65]
+38=proba2[71*256+66]
+43=proba2[71*256+67]
+45=proba2[71*256+68]
+27=proba2[71*256+69]
+47=proba2[71*256+70]
+38=proba2[71*256+71]
+39=proba2[71*256+72]
+31=proba2[71*256+73]
+50=proba2[71*256+74]
+54=proba2[71*256+75]
+41=proba2[71*256+76]
+45=proba2[71*256+77]
+41=proba2[71*256+78]
+27=proba2[71*256+79]
+40=proba2[71*256+80]
+54=proba2[71*256+81]
+35=proba2[71*256+82]
+47=proba2[71*256+83]
+43=proba2[71*256+84]
+35=proba2[71*256+85]
+50=proba2[71*256+86]
+50=proba2[71*256+87]
+45=proba2[71*256+88]
+50=proba2[71*256+89]
+61=proba2[71*256+90]
+30=proba2[71*256+97]
+54=proba2[71*256+98]
+50=proba2[71*256+100]
+47=proba2[71*256+101]
+61=proba2[71*256+102]
+47=proba2[71*256+103]
+43=proba2[71*256+104]
+35=proba2[71*256+105]
+54=proba2[71*256+106]
+50=proba2[71*256+107]
+40=proba2[71*256+108]
+54=proba2[71*256+109]
+54=proba2[71*256+110]
+30=proba2[71*256+111]
+50=proba2[71*256+112]
+41=proba2[71*256+114]
+61=proba2[71*256+116]
+31=proba2[71*256+117]
+54=proba2[71*256+119]
+54=proba2[71*256+120]
+50=proba2[71*256+121]
+72=proba1[72]
+58=proba2[72*256+32]
+58=proba2[72*256+33]
+58=proba2[72*256+44]
+58=proba2[72*256+45]
+58=proba2[72*256+48]
+37=proba2[72*256+49]
+37=proba2[72*256+50]
+40=proba2[72*256+51]
+51=proba2[72*256+52]
+58=proba2[72*256+53]
+51=proba2[72*256+54]
+44=proba2[72*256+55]
+47=proba2[72*256+56]
+42=proba2[72*256+57]
+20=proba2[72*256+65]
+42=proba2[72*256+66]
+44=proba2[72*256+67]
+42=proba2[72*256+68]
+21=proba2[72*256+69]
+42=proba2[72*256+70]
+58=proba2[72*256+71]
+42=proba2[72*256+72]
+26=proba2[72*256+73]
+51=proba2[72*256+74]
+39=proba2[72*256+75]
+47=proba2[72*256+76]
+36=proba2[72*256+77]
+47=proba2[72*256+78]
+26=proba2[72*256+79]
+51=proba2[72*256+80]
+47=proba2[72*256+81]
+35=proba2[72*256+82]
+47=proba2[72*256+83]
+47=proba2[72*256+84]
+37=proba2[72*256+85]
+58=proba2[72*256+86]
+51=proba2[72*256+87]
+44=proba2[72*256+88]
+39=proba2[72*256+89]
+42=proba2[72*256+90]
+51=proba2[72*256+95]
+32=proba2[72*256+97]
+51=proba2[72*256+98]
+58=proba2[72*256+99]
+47=proba2[72*256+100]
+32=proba2[72*256+101]
+58=proba2[72*256+102]
+37=proba2[72*256+105]
+51=proba2[72*256+106]
+58=proba2[72*256+107]
+58=proba2[72*256+108]
+58=proba2[72*256+110]
+36=proba2[72*256+111]
+51=proba2[72*256+114]
+58=proba2[72*256+115]
+58=proba2[72*256+116]
+42=proba2[72*256+117]
+51=proba2[72*256+121]
+51=proba2[72*256+122]
+58=proba2[72*256+125]
+75=proba1[73]
+67=proba2[73*256+36]
+67=proba2[73*256+38]
+67=proba2[73*256+46]
+49=proba2[73*256+48]
+41=proba2[73*256+49]
+44=proba2[73*256+50]
+51=proba2[73*256+51]
+49=proba2[73*256+52]
+60=proba2[73*256+53]
+46=proba2[73*256+54]
+46=proba2[73*256+55]
+56=proba2[73*256+56]
+53=proba2[73*256+57]
+29=proba2[73*256+65]
+45=proba2[73*256+66]
+26=proba2[73*256+67]
+35=proba2[73*256+68]
+21=proba2[73*256+69]
+44=proba2[73*256+70]
+36=proba2[73*256+71]
+67=proba2[73*256+72]
+42=proba2[73*256+73]
+60=proba2[73*256+74]
+37=proba2[73*256+75]
+28=proba2[73*256+76]
+30=proba2[73*256+77]
+21=proba2[73*256+78]
+33=proba2[73*256+79]
+43=proba2[73*256+80]
+44=proba2[73*256+81]
+31=proba2[73*256+82]
+25=proba2[73*256+83]
+27=proba2[73*256+84]
+56=proba2[73*256+85]
+39=proba2[73*256+86]
+53=proba2[73*256+87]
+42=proba2[73*256+88]
+67=proba2[73*256+89]
+45=proba2[73*256+90]
+53=proba2[73*256+97]
+56=proba2[73*256+99]
+53=proba2[73*256+100]
+60=proba2[73*256+102]
+60=proba2[73*256+103]
+67=proba2[73*256+104]
+67=proba2[73*256+105]
+67=proba2[73*256+107]
+56=proba2[73*256+108]
+53=proba2[73*256+109]
+45=proba2[73*256+110]
+60=proba2[73*256+112]
+60=proba2[73*256+113]
+53=proba2[73*256+114]
+49=proba2[73*256+115]
+67=proba2[73*256+116]
+60=proba2[73*256+118]
+67=proba2[73*256+119]
+67=proba2[73*256+120]
+60=proba2[73*256+122]
+67=proba1[74]
+57=proba2[74*256+42]
+57=proba2[74*256+46]
+37=proba2[74*256+48]
+46=proba2[74*256+49]
+37=proba2[74*256+50]
+46=proba2[74*256+51]
+57=proba2[74*256+52]
+50=proba2[74*256+53]
+57=proba2[74*256+54]
+43=proba2[74*256+55]
+57=proba2[74*256+56]
+50=proba2[74*256+57]
+50=proba2[74*256+64]
+28=proba2[74*256+65]
+39=proba2[74*256+66]
+39=proba2[74*256+67]
+46=proba2[74*256+68]
+26=proba2[74*256+69]
+36=proba2[74*256+70]
+46=proba2[74*256+71]
+43=proba2[74*256+72]
+32=proba2[74*256+73]
+36=proba2[74*256+74]
+46=proba2[74*256+75]
+39=proba2[74*256+76]
+39=proba2[74*256+77]
+57=proba2[74*256+78]
+21=proba2[74*256+79]
+30=proba2[74*256+80]
+50=proba2[74*256+81]
+39=proba2[74*256+82]
+43=proba2[74*256+83]
+46=proba2[74*256+84]
+27=proba2[74*256+85]
+57=proba2[74*256+87]
+57=proba2[74*256+89]
+50=proba2[74*256+90]
+57=proba2[74*256+95]
+31=proba2[74*256+97]
+50=proba2[74*256+98]
+43=proba2[74*256+99]
+57=proba2[74*256+100]
+34=proba2[74*256+101]
+50=proba2[74*256+102]
+46=proba2[74*256+104]
+50=proba2[74*256+105]
+50=proba2[74*256+106]
+57=proba2[74*256+107]
+50=proba2[74*256+109]
+57=proba2[74*256+110]
+32=proba2[74*256+111]
+57=proba2[74*256+112]
+57=proba2[74*256+114]
+57=proba2[74*256+116]
+30=proba2[74*256+117]
+50=proba2[74*256+118]
+50=proba2[74*256+119]
+57=proba2[74*256+121]
+70=proba1[75]
+56=proba2[75*256+39]
+56=proba2[75*256+46]
+56=proba2[75*256+48]
+35=proba2[75*256+49]
+34=proba2[75*256+50]
+49=proba2[75*256+51]
+40=proba2[75*256+52]
+45=proba2[75*256+53]
+38=proba2[75*256+54]
+49=proba2[75*256+55]
+40=proba2[75*256+56]
+45=proba2[75*256+57]
+56=proba2[75*256+63]
+56=proba2[75*256+64]
+22=proba2[75*256+65]
+42=proba2[75*256+66]
+56=proba2[75*256+67]
+49=proba2[75*256+68]
+30=proba2[75*256+69]
+45=proba2[75*256+70]
+56=proba2[75*256+71]
+45=proba2[75*256+72]
+23=proba2[75*256+73]
+45=proba2[75*256+74]
+45=proba2[75*256+75]
+35=proba2[75*256+76]
+40=proba2[75*256+77]
+49=proba2[75*256+78]
+30=proba2[75*256+79]
+56=proba2[75*256+80]
+56=proba2[75*256+81]
+37=proba2[75*256+82]
+45=proba2[75*256+83]
+45=proba2[75*256+84]
+49=proba2[75*256+85]
+56=proba2[75*256+86]
+49=proba2[75*256+87]
+56=proba2[75*256+88]
+42=proba2[75*256+89]
+56=proba2[75*256+90]
+56=proba2[75*256+95]
+26=proba2[75*256+97]
+49=proba2[75*256+98]
+45=proba2[75*256+100]
+31=proba2[75*256+101]
+49=proba2[75*256+102]
+49=proba2[75*256+103]
+40=proba2[75*256+104]
+34=proba2[75*256+105]
+49=proba2[75*256+107]
+56=proba2[75*256+108]
+56=proba2[75*256+110]
+33=proba2[75*256+111]
+49=proba2[75*256+112]
+49=proba2[75*256+113]
+42=proba2[75*256+114]
+56=proba2[75*256+115]
+56=proba2[75*256+116]
+45=proba2[75*256+117]
+56=proba2[75*256+118]
+56=proba2[75*256+119]
+49=proba2[75*256+120]
+56=proba2[75*256+121]
+49=proba2[75*256+122]
+56=proba2[75*256+124]
+65=proba1[76]
+66=proba2[76*256+32]
+66=proba2[76*256+41]
+66=proba2[76*256+45]
+55=proba2[76*256+46]
+44=proba2[76*256+48]
+41=proba2[76*256+49]
+45=proba2[76*256+50]
+52=proba2[76*256+51]
+46=proba2[76*256+52]
+46=proba2[76*256+53]
+50=proba2[76*256+54]
+55=proba2[76*256+55]
+59=proba2[76*256+56]
+48=proba2[76*256+57]
+66=proba2[76*256+64]
+21=proba2[76*256+65]
+45=proba2[76*256+66]
+44=proba2[76*256+67]
+36=proba2[76*256+68]
+21=proba2[76*256+69]
+44=proba2[76*256+70]
+45=proba2[76*256+71]
+46=proba2[76*256+72]
+20=proba2[76*256+73]
+66=proba2[76*256+74]
+52=proba2[76*256+75]
+28=proba2[76*256+76]
+36=proba2[76*256+77]
+24=proba2[76*256+79]
+39=proba2[76*256+80]
+52=proba2[76*256+82]
+43=proba2[76*256+83]
+40=proba2[76*256+84]
+36=proba2[76*256+85]
+44=proba2[76*256+86]
+59=proba2[76*256+87]
+41=proba2[76*256+89]
+66=proba2[76*256+90]
+66=proba2[76*256+93]
+32=proba2[76*256+97]
+66=proba2[76*256+98]
+55=proba2[76*256+99]
+55=proba2[76*256+100]
+36=proba2[76*256+101]
+50=proba2[76*256+102]
+66=proba2[76*256+103]
+59=proba2[76*256+104]
+38=proba2[76*256+105]
+59=proba2[76*256+106]
+55=proba2[76*256+109]
+66=proba2[76*256+110]
+35=proba2[76*256+111]
+66=proba2[76*256+112]
+66=proba2[76*256+113]
+66=proba2[76*256+114]
+66=proba2[76*256+115]
+55=proba2[76*256+116]
+41=proba2[76*256+117]
+66=proba2[76*256+118]
+66=proba2[76*256+119]
+55=proba2[76*256+121]
+50=proba2[76*256+122]
+58=proba1[77]
+60=proba2[77*256+32]
+67=proba2[77*256+33]
+60=proba2[77*256+42]
+60=proba2[77*256+43]
+60=proba2[77*256+44]
+51=proba2[77*256+45]
+46=proba2[77*256+48]
+39=proba2[77*256+49]
+44=proba2[77*256+50]
+46=proba2[77*256+51]
+60=proba2[77*256+52]
+51=proba2[77*256+53]
+49=proba2[77*256+54]
+46=proba2[77*256+55]
+47=proba2[77*256+56]
+46=proba2[77*256+57]
+60=proba2[77*256+63]
+18=proba2[77*256+65]
+39=proba2[77*256+66]
+42=proba2[77*256+67]
+45=proba2[77*256+68]
+25=proba2[77*256+69]
+49=proba2[77*256+70]
+44=proba2[77*256+71]
+60=proba2[77*256+72]
+26=proba2[77*256+73]
+53=proba2[77*256+74]
+51=proba2[77*256+75]
+46=proba2[77*256+76]
+34=proba2[77*256+77]
+45=proba2[77*256+78]
+27=proba2[77*256+79]
+38=proba2[77*256+80]
+56=proba2[77*256+81]
+46=proba2[77*256+82]
+51=proba2[77*256+83]
+47=proba2[77*256+84]
+44=proba2[77*256+85]
+51=proba2[77*256+86]
+49=proba2[77*256+87]
+67=proba2[77*256+88]
+36=proba2[77*256+89]
+53=proba2[77*256+90]
+67=proba2[77*256+95]
+22=proba2[77*256+97]
+51=proba2[77*256+98]
+51=proba2[77*256+99]
+32=proba2[77*256+101]
+60=proba2[77*256+102]
+56=proba2[77*256+103]
+67=proba2[77*256+104]
+32=proba2[77*256+105]
+56=proba2[77*256+106]
+56=proba2[77*256+107]
+60=proba2[77*256+108]
+60=proba2[77*256+109]
+56=proba2[77*256+110]
+35=proba2[77*256+111]
+67=proba2[77*256+112]
+56=proba2[77*256+114]
+67=proba2[77*256+115]
+56=proba2[77*256+116]
+46=proba2[77*256+117]
+67=proba2[77*256+119]
+67=proba2[77*256+120]
+39=proba2[77*256+121]
+67=proba2[77*256+122]
+69=proba1[78]
+64=proba2[78*256+33]
+64=proba2[78*256+43]
+53=proba2[78*256+45]
+57=proba2[78*256+46]
+57=proba2[78*256+48]
+39=proba2[78*256+49]
+40=proba2[78*256+50]
+46=proba2[78*256+51]
+45=proba2[78*256+52]
+45=proba2[78*256+53]
+48=proba2[78*256+54]
+46=proba2[78*256+55]
+50=proba2[78*256+56]
+50=proba2[78*256+57]
+64=proba2[78*256+61]
+64=proba2[78*256+64]
+26=proba2[78*256+65]
+50=proba2[78*256+66]
+33=proba2[78*256+67]
+26=proba2[78*256+68]
+19=proba2[78*256+69]
+39=proba2[78*256+70]
+34=proba2[78*256+71]
+50=proba2[78*256+72]
+25=proba2[78*256+73]
+48=proba2[78*256+74]
+57=proba2[78*256+75]
+48=proba2[78*256+76]
+50=proba2[78*256+77]
+30=proba2[78*256+78]
+28=proba2[78*256+79]
+53=proba2[78*256+80]
+64=proba2[78*256+81]
+44=proba2[78*256+83]
+26=proba2[78*256+84]
+40=proba2[78*256+85]
+64=proba2[78*256+87]
+46=proba2[78*256+88]
+41=proba2[78*256+89]
+48=proba2[78*256+90]
+33=proba2[78*256+97]
+53=proba2[78*256+98]
+57=proba2[78*256+99]
+64=proba2[78*256+100]
+39=proba2[78*256+101]
+64=proba2[78*256+102]
+48=proba2[78*256+103]
+64=proba2[78*256+104]
+34=proba2[78*256+105]
+64=proba2[78*256+107]
+64=proba2[78*256+109]
+64=proba2[78*256+110]
+37=proba2[78*256+111]
+46=proba2[78*256+112]
+57=proba2[78*256+115]
+53=proba2[78*256+116]
+48=proba2[78*256+117]
+64=proba2[78*256+119]
+64=proba2[78*256+121]
+57=proba2[78*256+122]
+64=proba2[78*256+125]
+77=proba1[79]
+66=proba2[79*256+32]
+66=proba2[79*256+46]
+45=proba2[79*256+48]
+43=proba2[79*256+49]
+44=proba2[79*256+50]
+48=proba2[79*256+51]
+66=proba2[79*256+52]
+50=proba2[79*256+53]
+50=proba2[79*256+54]
+59=proba2[79*256+55]
+55=proba2[79*256+56]
+44=proba2[79*256+57]
+55=proba2[79*256+61]
+48=proba2[79*256+65]
+38=proba2[79*256+66]
+31=proba2[79*256+67]
+44=proba2[79*256+68]
+50=proba2[79*256+69]
+50=proba2[79*256+70]
+40=proba2[79*256+71]
+50=proba2[79*256+72]
+36=proba2[79*256+73]
+44=proba2[79*256+74]
+52=proba2[79*256+75]
+26=proba2[79*256+76]
+27=proba2[79*256+77]
+20=proba2[79*256+78]
+34=proba2[79*256+79]
+35=proba2[79*256+80]
+24=proba2[79*256+82]
+30=proba2[79*256+83]
+30=proba2[79*256+84]
+18=proba2[79*256+85]
+47=proba2[79*256+86]
+55=proba2[79*256+87]
+50=proba2[79*256+88]
+42=proba2[79*256+89]
+52=proba2[79*256+90]
+66=proba2[79*256+93]
+59=proba2[79*256+98]
+59=proba2[79*256+99]
+66=proba2[79*256+103]
+66=proba2[79*256+104]
+59=proba2[79*256+105]
+66=proba2[79*256+106]
+66=proba2[79*256+107]
+52=proba2[79*256+108]
+59=proba2[79*256+109]
+50=proba2[79*256+110]
+66=proba2[79*256+112]
+59=proba2[79*256+114]
+66=proba2[79*256+115]
+55=proba2[79*256+116]
+66=proba2[79*256+117]
+66=proba2[79*256+120]
+66=proba2[79*256+121]
+55=proba2[79*256+122]
+63=proba1[80]
+56=proba2[80*256+45]
+41=proba2[80*256+48]
+36=proba2[80*256+49]
+36=proba2[80*256+50]
+43=proba2[80*256+51]
+41=proba2[80*256+52]
+52=proba2[80*256+53]
+46=proba2[80*256+54]
+52=proba2[80*256+55]
+63=proba2[80*256+56]
+46=proba2[80*256+57]
+63=proba2[80*256+61]
+63=proba2[80*256+63]
+23=proba2[80*256+65]
+49=proba2[80*256+66]
+45=proba2[80*256+67]
+42=proba2[80*256+68]
+27=proba2[80*256+69]
+49=proba2[80*256+70]
+39=proba2[80*256+71]
+29=proba2[80*256+72]
+30=proba2[80*256+73]
+45=proba2[80*256+74]
+49=proba2[80*256+75]
+36=proba2[80*256+76]
+42=proba2[80*256+77]
+46=proba2[80*256+78]
+27=proba2[80*256+79]
+38=proba2[80*256+80]
+56=proba2[80*256+81]
+32=proba2[80*256+82]
+39=proba2[80*256+83]
+39=proba2[80*256+84]
+37=proba2[80*256+85]
+42=proba2[80*256+86]
+56=proba2[80*256+87]
+63=proba2[80*256+88]
+41=proba2[80*256+89]
+63=proba2[80*256+90]
+28=proba2[80*256+97]
+63=proba2[80*256+98]
+34=proba2[80*256+101]
+63=proba2[80*256+103]
+36=proba2[80*256+104]
+36=proba2[80*256+105]
+56=proba2[80*256+108]
+56=proba2[80*256+109]
+52=proba2[80*256+110]
+29=proba2[80*256+111]
+63=proba2[80*256+113]
+42=proba2[80*256+114]
+63=proba2[80*256+115]
+63=proba2[80*256+116]
+46=proba2[80*256+117]
+63=proba2[80*256+118]
+63=proba2[80*256+119]
+56=proba2[80*256+120]
+63=proba2[80*256+121]
+84=proba1[81]
+47=proba2[81*256+48]
+47=proba2[81*256+49]
+40=proba2[81*256+50]
+47=proba2[81*256+51]
+36=proba2[81*256+52]
+33=proba2[81*256+53]
+47=proba2[81*256+54]
+33=proba2[81*256+55]
+47=proba2[81*256+56]
+33=proba2[81*256+57]
+33=proba2[81*256+65]
+47=proba2[81*256+67]
+40=proba2[81*256+68]
+40=proba2[81*256+69]
+40=proba2[81*256+70]
+33=proba2[81*256+71]
+40=proba2[81*256+73]
+40=proba2[81*256+74]
+40=proba2[81*256+76]
+40=proba2[81*256+77]
+47=proba2[81*256+79]
+40=proba2[81*256+80]
+47=proba2[81*256+81]
+40=proba2[81*256+82]
+40=proba2[81*256+83]
+40=proba2[81*256+84]
+20=proba2[81*256+85]
+33=proba2[81*256+87]
+33=proba2[81*256+89]
+47=proba2[81*256+90]
+47=proba2[81*256+97]
+40=proba2[81*256+98]
+47=proba2[81*256+99]
+40=proba2[81*256+102]
+47=proba2[81*256+103]
+40=proba2[81*256+104]
+47=proba2[81*256+107]
+47=proba2[81*256+109]
+47=proba2[81*256+110]
+47=proba2[81*256+112]
+40=proba2[81*256+113]
+47=proba2[81*256+114]
+40=proba2[81*256+116]
+26=proba2[81*256+117]
+29=proba2[81*256+119]
+47=proba2[81*256+122]
+69=proba1[82]
+55=proba2[82*256+32]
+66=proba2[82*256+35]
+66=proba2[82*256+42]
+66=proba2[82*256+43]
+55=proba2[82*256+48]
+36=proba2[82*256+49]
+38=proba2[82*256+50]
+48=proba2[82*256+51]
+45=proba2[82*256+52]
+48=proba2[82*256+53]
+59=proba2[82*256+54]
+45=proba2[82*256+55]
+52=proba2[82*256+56]
+48=proba2[82*256+57]
+21=proba2[82*256+65]
+44=proba2[82*256+66]
+38=proba2[82*256+67]
+34=proba2[82*256+68]
+22=proba2[82*256+69]
+47=proba2[82*256+70]
+38=proba2[82*256+71]
+66=proba2[82*256+72]
+20=proba2[82*256+73]
+52=proba2[82*256+74]
+52=proba2[82*256+75]
+39=proba2[82*256+76]
+39=proba2[82*256+77]
+44=proba2[82*256+78]
+24=proba2[82*256+79]
+45=proba2[82*256+80]
+52=proba2[82*256+81]
+36=proba2[82*256+82]
+33=proba2[82*256+83]
+32=proba2[82*256+84]
+36=proba2[82*256+85]
+47=proba2[82*256+86]
+59=proba2[82*256+87]
+59=proba2[82*256+88]
+41=proba2[82*256+89]
+66=proba2[82*256+90]
+66=proba2[82*256+93]
+66=proba2[82*256+96]
+40=proba2[82*256+97]
+55=proba2[82*256+100]
+37=proba2[82*256+101]
+59=proba2[82*256+102]
+66=proba2[82*256+103]
+66=proba2[82*256+104]
+41=proba2[82*256+105]
+66=proba2[82*256+106]
+66=proba2[82*256+107]
+66=proba2[82*256+108]
+36=proba2[82*256+111]
+55=proba2[82*256+113]
+55=proba2[82*256+114]
+59=proba2[82*256+115]
+59=proba2[82*256+116]
+43=proba2[82*256+117]
+66=proba2[82*256+118]
+59=proba2[82*256+119]
+66=proba2[82*256+121]
+66=proba2[82*256+122]
+61=proba1[83]
+59=proba2[83*256+32]
+66=proba2[83*256+35]
+66=proba2[83*256+38]
+66=proba2[83*256+41]
+66=proba2[83*256+42]
+66=proba2[83*256+45]
+44=proba2[83*256+48]
+33=proba2[83*256+49]
+43=proba2[83*256+50]
+48=proba2[83*256+51]
+48=proba2[83*256+52]
+50=proba2[83*256+53]
+50=proba2[83*256+54]
+46=proba2[83*256+55]
+50=proba2[83*256+56]
+42=proba2[83*256+57]
+66=proba2[83*256+64]
+25=proba2[83*256+65]
+46=proba2[83*256+66]
+33=proba2[83*256+67]
+50=proba2[83*256+68]
+25=proba2[83*256+69]
+55=proba2[83*256+70]
+66=proba2[83*256+71]
+40=proba2[83*256+72]
+32=proba2[83*256+73]
+55=proba2[83*256+74]
+50=proba2[83*256+75]
+40=proba2[83*256+76]
+45=proba2[83*256+77]
+42=proba2[83*256+78]
+35=proba2[83*256+79]
+35=proba2[83*256+80]
+46=proba2[83*256+81]
+43=proba2[83*256+82]
+27=proba2[83*256+83]
+25=proba2[83*256+84]
+38=proba2[83*256+85]
+50=proba2[83*256+86]
+42=proba2[83*256+87]
+50=proba2[83*256+88]
+39=proba2[83*256+89]
+55=proba2[83*256+90]
+31=proba2[83*256+97]
+66=proba2[83*256+98]
+44=proba2[83*256+99]
+59=proba2[83*256+100]
+36=proba2[83*256+101]
+59=proba2[83*256+102]
+66=proba2[83*256+103]
+42=proba2[83*256+104]
+40=proba2[83*256+105]
+66=proba2[83*256+106]
+50=proba2[83*256+107]
+59=proba2[83*256+108]
+48=proba2[83*256+109]
+52=proba2[83*256+110]
+33=proba2[83*256+111]
+48=proba2[83*256+112]
+55=proba2[83*256+113]
+66=proba2[83*256+114]
+66=proba2[83*256+115]
+38=proba2[83*256+116]
+41=proba2[83*256+117]
+59=proba2[83*256+119]
+66=proba2[83*256+120]
+48=proba2[83*256+121]
+64=proba1[84]
+66=proba2[84*256+33]
+66=proba2[84*256+39]
+66=proba2[84*256+43]
+66=proba2[84*256+44]
+59=proba2[84*256+45]
+52=proba2[84*256+48]
+42=proba2[84*256+49]
+39=proba2[84*256+50]
+50=proba2[84*256+51]
+46=proba2[84*256+52]
+48=proba2[84*256+53]
+44=proba2[84*256+54]
+48=proba2[84*256+55]
+48=proba2[84*256+56]
+44=proba2[84*256+57]
+24=proba2[84*256+65]
+48=proba2[84*256+66]
+37=proba2[84*256+67]
+48=proba2[84*256+68]
+22=proba2[84*256+69]
+50=proba2[84*256+70]
+48=proba2[84*256+71]
+33=proba2[84*256+72]
+24=proba2[84*256+73]
+50=proba2[84*256+74]
+66=proba2[84*256+75]
+44=proba2[84*256+76]
+43=proba2[84*256+77]
+45=proba2[84*256+78]
+23=proba2[84*256+79]
+52=proba2[84*256+80]
+31=proba2[84*256+82]
+42=proba2[84*256+83]
+31=proba2[84*256+84]
+39=proba2[84*256+85]
+55=proba2[84*256+86]
+50=proba2[84*256+87]
+59=proba2[84*256+88]
+39=proba2[84*256+89]
+52=proba2[84*256+90]
+37=proba2[84*256+97]
+50=proba2[84*256+98]
+55=proba2[84*256+99]
+66=proba2[84*256+100]
+39=proba2[84*256+101]
+52=proba2[84*256+102]
+66=proba2[84*256+103]
+33=proba2[84*256+104]
+37=proba2[84*256+105]
+66=proba2[84*256+106]
+66=proba2[84*256+108]
+59=proba2[84*256+110]
+34=proba2[84*256+111]
+48=proba2[84*256+112]
+55=proba2[84*256+113]
+41=proba2[84*256+114]
+66=proba2[84*256+115]
+55=proba2[84*256+116]
+42=proba2[84*256+117]
+66=proba2[84*256+118]
+59=proba2[84*256+119]
+59=proba2[84*256+120]
+46=proba2[84*256+121]
+81=proba1[85]
+61=proba2[85*256+42]
+61=proba2[85*256+45]
+61=proba2[85*256+48]
+37=proba2[85*256+49]
+43=proba2[85*256+50]
+50=proba2[85*256+51]
+44=proba2[85*256+52]
+54=proba2[85*256+53]
+50=proba2[85*256+54]
+40=proba2[85*256+55]
+43=proba2[85*256+57]
+61=proba2[85*256+64]
+40=proba2[85*256+65]
+32=proba2[85*256+66]
+28=proba2[85*256+67]
+28=proba2[85*256+68]
+30=proba2[85*256+69]
+44=proba2[85*256+70]
+43=proba2[85*256+71]
+54=proba2[85*256+72]
+31=proba2[85*256+73]
+54=proba2[85*256+74]
+47=proba2[85*256+75]
+25=proba2[85*256+76]
+34=proba2[85*256+77]
+28=proba2[85*256+78]
+54=proba2[85*256+79]
+39=proba2[85*256+80]
+24=proba2[85*256+82]
+24=proba2[85*256+83]
+33=proba2[85*256+84]
+50=proba2[85*256+85]
+41=proba2[85*256+86]
+54=proba2[85*256+87]
+44=proba2[85*256+88]
+39=proba2[85*256+90]
+50=proba2[85*256+97]
+61=proba2[85*256+98]
+54=proba2[85*256+101]
+61=proba2[85*256+102]
+54=proba2[85*256+103]
+61=proba2[85*256+104]
+54=proba2[85*256+105]
+61=proba2[85*256+106]
+61=proba2[85*256+107]
+47=proba2[85*256+108]
+61=proba2[85*256+109]
+36=proba2[85*256+110]
+61=proba2[85*256+112]
+50=proba2[85*256+114]
+43=proba2[85*256+115]
+61=proba2[85*256+116]
+61=proba2[85*256+118]
+50=proba2[85*256+120]
+47=proba2[85*256+121]
+50=proba2[85*256+122]
+73=proba1[86]
+55=proba2[86*256+33]
+55=proba2[86*256+43]
+55=proba2[86*256+46]
+55=proba2[86*256+48]
+31=proba2[86*256+49]
+31=proba2[86*256+50]
+37=proba2[86*256+51]
+55=proba2[86*256+52]
+48=proba2[86*256+53]
+44=proba2[86*256+54]
+48=proba2[86*256+55]
+48=proba2[86*256+56]
+48=proba2[86*256+57]
+20=proba2[86*256+65]
+44=proba2[86*256+66]
+55=proba2[86*256+67]
+35=proba2[86*256+68]
+22=proba2[86*256+69]
+48=proba2[86*256+70]
+48=proba2[86*256+71]
+48=proba2[86*256+72]
+25=proba2[86*256+73]
+44=proba2[86*256+74]
+55=proba2[86*256+75]
+44=proba2[86*256+76]
+34=proba2[86*256+79]
+44=proba2[86*256+80]
+55=proba2[86*256+81]
+41=proba2[86*256+82]
+41=proba2[86*256+83]
+38=proba2[86*256+84]
+55=proba2[86*256+85]
+44=proba2[86*256+86]
+55=proba2[86*256+87]
+55=proba2[86*256+89]
+55=proba2[86*256+90]
+26=proba2[86*256+97]
+29=proba2[86*256+101]
+44=proba2[86*256+102]
+55=proba2[86*256+103]
+55=proba2[86*256+104]
+27=proba2[86*256+105]
+48=proba2[86*256+107]
+55=proba2[86*256+108]
+48=proba2[86*256+109]
+41=proba2[86*256+111]
+48=proba2[86*256+112]
+44=proba2[86*256+114]
+55=proba2[86*256+117]
+48=proba2[86*256+118]
+55=proba2[86*256+122]
+79=proba1[87]
+51=proba2[87*256+33]
+51=proba2[87*256+42]
+40=proba2[87*256+46]
+51=proba2[87*256+48]
+35=proba2[87*256+49]
+44=proba2[87*256+50]
+35=proba2[87*256+51]
+44=proba2[87*256+52]
+51=proba2[87*256+53]
+44=proba2[87*256+54]
+37=proba2[87*256+55]
+51=proba2[87*256+63]
+22=proba2[87*256+65]
+44=proba2[87*256+66]
+40=proba2[87*256+67]
+51=proba2[87*256+68]
+33=proba2[87*256+69]
+51=proba2[87*256+70]
+51=proba2[87*256+71]
+30=proba2[87*256+72]
+31=proba2[87*256+73]
+44=proba2[87*256+74]
+40=proba2[87*256+75]
+40=proba2[87*256+76]
+37=proba2[87*256+77]
+44=proba2[87*256+78]
+33=proba2[87*256+79]
+40=proba2[87*256+80]
+35=proba2[87*256+81]
+40=proba2[87*256+82]
+40=proba2[87*256+83]
+40=proba2[87*256+84]
+51=proba2[87*256+85]
+51=proba2[87*256+86]
+44=proba2[87*256+87]
+51=proba2[87*256+88]
+44=proba2[87*256+90]
+28=proba2[87*256+97]
+51=proba2[87*256+100]
+27=proba2[87*256+101]
+40=proba2[87*256+104]
+33=proba2[87*256+105]
+51=proba2[87*256+106]
+37=proba2[87*256+107]
+51=proba2[87*256+110]
+40=proba2[87*256+111]
+37=proba2[87*256+113]
+44=proba2[87*256+114]
+51=proba2[87*256+115]
+51=proba2[87*256+120]
+80=proba1[88]
+50=proba2[88*256+45]
+50=proba2[88*256+46]
+39=proba2[88*256+48]
+30=proba2[88*256+49]
+27=proba2[88*256+50]
+43=proba2[88*256+51]
+34=proba2[88*256+52]
+50=proba2[88*256+53]
+39=proba2[88*256+54]
+34=proba2[88*256+55]
+50=proba2[88*256+56]
+50=proba2[88*256+57]
+28=proba2[88*256+65]
+50=proba2[88*256+66]
+30=proba2[88*256+67]
+32=proba2[88*256+68]
+32=proba2[88*256+69]
+36=proba2[88*256+70]
+39=proba2[88*256+71]
+34=proba2[88*256+73]
+50=proba2[88*256+74]
+50=proba2[88*256+75]
+50=proba2[88*256+77]
+43=proba2[88*256+78]
+39=proba2[88*256+79]
+34=proba2[88*256+80]
+39=proba2[88*256+82]
+39=proba2[88*256+83]
+43=proba2[88*256+84]
+50=proba2[88*256+85]
+50=proba2[88*256+86]
+39=proba2[88*256+87]
+25=proba2[88*256+88]
+39=proba2[88*256+89]
+36=proba2[88*256+97]
+50=proba2[88*256+99]
+43=proba2[88*256+100]
+43=proba2[88*256+101]
+39=proba2[88*256+103]
+50=proba2[88*256+104]
+50=proba2[88*256+105]
+50=proba2[88*256+106]
+50=proba2[88*256+109]
+50=proba2[88*256+111]
+50=proba2[88*256+112]
+50=proba2[88*256+113]
+39=proba2[88*256+114]
+50=proba2[88*256+116]
+50=proba2[88*256+118]
+39=proba2[88*256+119]
+50=proba2[88*256+120]
+50=proba2[88*256+121]
+39=proba2[88*256+122]
+78=proba1[89]
+47=proba2[89*256+32]
+54=proba2[89*256+38]
+54=proba2[89*256+45]
+43=proba2[89*256+48]
+30=proba2[89*256+49]
+43=proba2[89*256+50]
+47=proba2[89*256+51]
+47=proba2[89*256+52]
+40=proba2[89*256+53]
+36=proba2[89*256+54]
+33=proba2[89*256+55]
+54=proba2[89*256+56]
+43=proba2[89*256+57]
+28=proba2[89*256+65]
+43=proba2[89*256+66]
+35=proba2[89*256+67]
+33=proba2[89*256+68]
+38=proba2[89*256+69]
+54=proba2[89*256+70]
+28=proba2[89*256+71]
+54=proba2[89*256+72]
+43=proba2[89*256+73]
+54=proba2[89*256+74]
+47=proba2[89*256+75]
+31=proba2[89*256+76]
+31=proba2[89*256+77]
+38=proba2[89*256+78]
+28=proba2[89*256+79]
+36=proba2[89*256+80]
+40=proba2[89*256+81]
+47=proba2[89*256+82]
+31=proba2[89*256+83]
+43=proba2[89*256+84]
+47=proba2[89*256+85]
+54=proba2[89*256+86]
+54=proba2[89*256+87]
+54=proba2[89*256+88]
+54=proba2[89*256+89]
+38=proba2[89*256+90]
+36=proba2[89*256+97]
+54=proba2[89*256+99]
+47=proba2[89*256+100]
+54=proba2[89*256+101]
+38=proba2[89*256+103]
+54=proba2[89*256+104]
+47=proba2[89*256+105]
+47=proba2[89*256+106]
+43=proba2[89*256+107]
+47=proba2[89*256+108]
+54=proba2[89*256+110]
+33=proba2[89*256+111]
+47=proba2[89*256+112]
+54=proba2[89*256+114]
+47=proba2[89*256+115]
+43=proba2[89*256+116]
+54=proba2[89*256+117]
+47=proba2[89*256+118]
+35=proba2[89*256+119]
+54=proba2[89*256+120]
+47=proba2[89*256+122]
+76=proba1[90]
+54=proba2[90*256+32]
+54=proba2[90*256+38]
+54=proba2[90*256+42]
+33=proba2[90*256+48]
+34=proba2[90*256+49]
+34=proba2[90*256+50]
+47=proba2[90*256+51]
+32=proba2[90*256+52]
+40=proba2[90*256+53]
+38=proba2[90*256+54]
+40=proba2[90*256+55]
+54=proba2[90*256+56]
+54=proba2[90*256+57]
+25=proba2[90*256+65]
+38=proba2[90*256+66]
+47=proba2[90*256+67]
+47=proba2[90*256+68]
+24=proba2[90*256+69]
+38=proba2[90*256+70]
+31=proba2[90*256+73]
+43=proba2[90*256+74]
+43=proba2[90*256+75]
+47=proba2[90*256+76]
+54=proba2[90*256+77]
+25=proba2[90*256+79]
+54=proba2[90*256+80]
+47=proba2[90*256+81]
+47=proba2[90*256+82]
+43=proba2[90*256+83]
+43=proba2[90*256+84]
+43=proba2[90*256+85]
+47=proba2[90*256+86]
+47=proba2[90*256+87]
+47=proba2[90*256+88]
+47=proba2[90*256+89]
+34=proba2[90*256+90]
+36=proba2[90*256+97]
+54=proba2[90*256+98]
+54=proba2[90*256+99]
+54=proba2[90*256+100]
+34=proba2[90*256+101]
+38=proba2[90*256+105]
+54=proba2[90*256+106]
+40=proba2[90*256+107]
+47=proba2[90*256+109]
+47=proba2[90*256+110]
+32=proba2[90*256+111]
+47=proba2[90*256+112]
+47=proba2[90*256+115]
+54=proba2[90*256+116]
+33=proba2[90*256+117]
+43=proba2[90*256+120]
+54=proba2[90*256+121]
+97=proba1[91]
+23=proba2[91*256+48]
+23=proba2[91*256+57]
+17=proba2[91*256+77]
+23=proba2[91*256+83]
+23=proba2[91*256+93]
+23=proba2[91*256+97]
+17=proba2[91*256+98]
+23=proba2[91*256+110]
+23=proba2[91*256+117]
+118=proba1[93]
+12=proba2[93*256+48]
+19=proba2[93*256+54]
+19=proba2[93*256+59]
+12=proba2[93*256+64]
+19=proba2[93*256+125]
+23=proba2[94*256+40]
+23=proba2[94*256+41]
+23=proba2[94*256+42]
+23=proba2[94*256+49]
+23=proba2[94*256+95]
+23=proba2[94*256+98]
+16=proba2[94*256+99]
+23=proba2[94*256+109]
+23=proba2[94*256+110]
+98=proba1[95]
+35=proba2[95*256+33]
+49=proba2[95*256+41]
+49=proba2[95*256+42]
+49=proba2[95*256+43]
+42=proba2[95*256+45]
+33=proba2[95*256+48]
+29=proba2[95*256+49]
+31=proba2[95*256+50]
+42=proba2[95*256+51]
+42=proba2[95*256+52]
+42=proba2[95*256+53]
+35=proba2[95*256+54]
+49=proba2[95*256+55]
+49=proba2[95*256+56]
+29=proba2[95*256+57]
+49=proba2[95*256+64]
+49=proba2[95*256+65]
+49=proba2[95*256+68]
+49=proba2[95*256+72]
+49=proba2[95*256+77]
+49=proba2[95*256+80]
+49=proba2[95*256+85]
+27=proba2[95*256+95]
+35=proba2[95*256+97]
+49=proba2[95*256+98]
+33=proba2[95*256+99]
+27=proba2[95*256+100]
+38=proba2[95*256+101]
+29=proba2[95*256+102]
+49=proba2[95*256+103]
+49=proba2[95*256+104]
+49=proba2[95*256+105]
+42=proba2[95*256+106]
+42=proba2[95*256+107]
+33=proba2[95*256+108]
+49=proba2[95*256+109]
+35=proba2[95*256+111]
+42=proba2[95*256+112]
+35=proba2[95*256+114]
+38=proba2[95*256+115]
+31=proba2[95*256+116]
+49=proba2[95*256+117]
+38=proba2[95*256+118]
+42=proba2[95*256+119]
+42=proba2[95*256+120]
+42=proba2[95*256+121]
+42=proba2[95*256+122]
+49=proba2[95*256+126]
+118=proba1[96]
+10=proba2[96*256+49]
+10=proba2[96*256+51]
+10=proba2[96*256+100]
+27=proba1[97]
+85=proba2[97*256+32]
+83=proba2[97*256+33]
+112=proba2[97*256+34]
+98=proba2[97*256+35]
+98=proba2[97*256+36]
+105=proba2[97*256+37]
+86=proba2[97*256+38]
+112=proba2[97*256+39]
+105=proba2[97*256+40]
+105=proba2[97*256+41]
+98=proba2[97*256+42]
+98=proba2[97*256+43]
+98=proba2[97*256+44]
+83=proba2[97*256+45]
+84=proba2[97*256+46]
+57=proba2[97*256+48]
+46=proba2[97*256+49]
+51=proba2[97*256+50]
+59=proba2[97*256+51]
+61=proba2[97*256+52]
+62=proba2[97*256+53]
+60=proba2[97*256+54]
+58=proba2[97*256+55]
+64=proba2[97*256+56]
+55=proba2[97*256+57]
+98=proba2[97*256+59]
+112=proba2[97*256+60]
+98=proba2[97*256+61]
+101=proba2[97*256+62]
+105=proba2[97*256+63]
+105=proba2[97*256+64]
+112=proba2[97*256+65]
+98=proba2[97*256+66]
+92=proba2[97*256+67]
+105=proba2[97*256+68]
+98=proba2[97*256+70]
+98=proba2[97*256+71]
+105=proba2[97*256+72]
+112=proba2[97*256+73]
+105=proba2[97*256+74]
+92=proba2[97*256+75]
+101=proba2[97*256+76]
+88=proba2[97*256+77]
+98=proba2[97*256+78]
+105=proba2[97*256+79]
+85=proba2[97*256+80]
+105=proba2[97*256+81]
+91=proba2[97*256+82]
+94=proba2[97*256+83]
+98=proba2[97*256+84]
+101=proba2[97*256+86]
+112=proba2[97*256+87]
+112=proba2[97*256+88]
+112=proba2[97*256+90]
+112=proba2[97*256+93]
+83=proba2[97*256+95]
+44=proba2[97*256+97]
+32=proba2[97*256+98]
+31=proba2[97*256+99]
+32=proba2[97*256+100]
+45=proba2[97*256+101]
+42=proba2[97*256+102]
+34=proba2[97*256+103]
+45=proba2[97*256+104]
+32=proba2[97*256+105]
+52=proba2[97*256+106]
+41=proba2[97*256+107]
+23=proba2[97*256+108]
+28=proba2[97*256+109]
+18=proba2[97*256+110]
+49=proba2[97*256+111]
+37=proba2[97*256+112]
+57=proba2[97*256+113]
+20=proba2[97*256+114]
+28=proba2[97*256+115]
+27=proba2[97*256+116]
+30=proba2[97*256+117]
+38=proba2[97*256+118]
+52=proba2[97*256+119]
+46=proba2[97*256+120]
+41=proba2[97*256+121]
+40=proba2[97*256+122]
+28=proba1[98]
+86=proba2[98*256+32]
+89=proba2[98*256+33]
+99=proba2[98*256+36]
+93=proba2[98*256+38]
+99=proba2[98*256+40]
+99=proba2[98*256+41]
+99=proba2[98*256+42]
+93=proba2[98*256+43]
+99=proba2[98*256+44]
+89=proba2[98*256+45]
+80=proba2[98*256+46]
+52=proba2[98*256+48]
+46=proba2[98*256+49]
+48=proba2[98*256+50]
+54=proba2[98*256+51]
+59=proba2[98*256+52]
+59=proba2[98*256+53]
+56=proba2[98*256+54]
+55=proba2[98*256+55]
+59=proba2[98*256+56]
+55=proba2[98*256+57]
+99=proba2[98*256+59]
+93=proba2[98*256+61]
+99=proba2[98*256+63]
+93=proba2[98*256+64]
+83=proba2[98*256+65]
+93=proba2[98*256+66]
+99=proba2[98*256+67]
+89=proba2[98*256+68]
+99=proba2[98*256+69]
+93=proba2[98*256+70]
+83=proba2[98*256+71]
+86=proba2[98*256+73]
+93=proba2[98*256+74]
+99=proba2[98*256+75]
+93=proba2[98*256+78]
+86=proba2[98*256+82]
+93=proba2[98*256+83]
+93=proba2[98*256+84]
+99=proba2[98*256+90]
+86=proba2[98*256+95]
+18=proba2[98*256+97]
+37=proba2[98*256+98]
+40=proba2[98*256+99]
+41=proba2[98*256+100]
+16=proba2[98*256+101]
+49=proba2[98*256+102]
+49=proba2[98*256+103]
+53=proba2[98*256+104]
+22=proba2[98*256+105]
+51=proba2[98*256+106]
+56=proba2[98*256+107]
+28=proba2[98*256+108]
+45=proba2[98*256+109]
+50=proba2[98*256+110]
+18=proba2[98*256+111]
+50=proba2[98*256+112]
+63=proba2[98*256+113]
+25=proba2[98*256+114]
+40=proba2[98*256+115]
+49=proba2[98*256+116]
+31=proba2[98*256+117]
+54=proba2[98*256+118]
+56=proba2[98*256+119]
+60=proba2[98*256+120]
+40=proba2[98*256+121]
+53=proba2[98*256+122]
+25=proba1[99]
+87=proba2[99*256+32]
+81=proba2[99*256+33]
+103=proba2[99*256+34]
+92=proba2[99*256+36]
+103=proba2[99*256+37]
+85=proba2[99*256+38]
+96=proba2[99*256+39]
+89=proba2[99*256+42]
+89=proba2[99*256+43]
+92=proba2[99*256+44]
+85=proba2[99*256+45]
+89=proba2[99*256+46]
+55=proba2[99*256+48]
+45=proba2[99*256+49]
+49=proba2[99*256+50]
+56=proba2[99*256+51]
+60=proba2[99*256+52]
+62=proba2[99*256+53]
+57=proba2[99*256+54]
+60=proba2[99*256+55]
+65=proba2[99*256+56]
+56=proba2[99*256+57]
+96=proba2[99*256+59]
+85=proba2[99*256+61]
+89=proba2[99*256+64]
+89=proba2[99*256+65]
+103=proba2[99*256+66]
+96=proba2[99*256+67]
+103=proba2[99*256+68]
+92=proba2[99*256+69]
+87=proba2[99*256+70]
+87=proba2[99*256+72]
+103=proba2[99*256+74]
+103=proba2[99*256+75]
+103=proba2[99*256+76]
+103=proba2[99*256+80]
+92=proba2[99*256+81]
+103=proba2[99*256+82]
+92=proba2[99*256+83]
+96=proba2[99*256+84]
+92=proba2[99*256+85]
+103=proba2[99*256+86]
+103=proba2[99*256+88]
+87=proba2[99*256+89]
+92=proba2[99*256+95]
+19=proba2[99*256+97]
+44=proba2[99*256+98]
+39=proba2[99*256+99]
+43=proba2[99*256+100]
+24=proba2[99*256+101]
+49=proba2[99*256+102]
+48=proba2[99*256+103]
+16=proba2[99*256+104]
+31=proba2[99*256+105]
+53=proba2[99*256+106]
+28=proba2[99*256+107]
+30=proba2[99*256+108]
+43=proba2[99*256+109]
+50=proba2[99*256+110]
+18=proba2[99*256+111]
+45=proba2[99*256+112]
+50=proba2[99*256+113]
+31=proba2[99*256+114]
+43=proba2[99*256+115]
+37=proba2[99*256+116]
+39=proba2[99*256+117]
+48=proba2[99*256+118]
+58=proba2[99*256+119]
+62=proba2[99*256+120]
+38=proba2[99*256+121]
+62=proba2[99*256+122]
+103=proba2[99*256+124]
+30=proba1[100]
+100=proba2[100*256+32]
+76=proba2[100*256+33]
+86=proba2[100*256+35]
+100=proba2[100*256+37]
+86=proba2[100*256+38]
+84=proba2[100*256+39]
+86=proba2[100*256+42]
+100=proba2[100*256+43]
+79=proba2[100*256+45]
+84=proba2[100*256+46]
+49=proba2[100*256+48]
+43=proba2[100*256+49]
+47=proba2[100*256+50]
+53=proba2[100*256+51]
+55=proba2[100*256+52]
+57=proba2[100*256+53]
+54=proba2[100*256+54]
+54=proba2[100*256+55]
+61=proba2[100*256+56]
+53=proba2[100*256+57]
+89=proba2[100*256+59]
+100=proba2[100*256+61]
+100=proba2[100*256+64]
+93=proba2[100*256+65]
+93=proba2[100*256+66]
+100=proba2[100*256+68]
+84=proba2[100*256+69]
+100=proba2[100*256+70]
+93=proba2[100*256+71]
+93=proba2[100*256+72]
+100=proba2[100*256+73]
+100=proba2[100*256+76]
+84=proba2[100*256+77]
+93=proba2[100*256+78]
+100=proba2[100*256+79]
+89=proba2[100*256+80]
+100=proba2[100*256+81]
+100=proba2[100*256+82]
+93=proba2[100*256+83]
+100=proba2[100*256+84]
+93=proba2[100*256+85]
+100=proba2[100*256+86]
+93=proba2[100*256+87]
+100=proba2[100*256+89]
+89=proba2[100*256+90]
+86=proba2[100*256+95]
+20=proba2[100*256+97]
+41=proba2[100*256+98]
+41=proba2[100*256+99]
+38=proba2[100*256+100]
+15=proba2[100*256+101]
+43=proba2[100*256+102]
+43=proba2[100*256+103]
+46=proba2[100*256+104]
+21=proba2[100*256+105]
+36=proba2[100*256+106]
+52=proba2[100*256+107]
+41=proba2[100*256+108]
+40=proba2[100*256+109]
+48=proba2[100*256+110]
+21=proba2[100*256+111]
+45=proba2[100*256+112]
+64=proba2[100*256+113]
+26=proba2[100*256+114]
+38=proba2[100*256+115]
+47=proba2[100*256+116]
+29=proba2[100*256+117]
+49=proba2[100*256+118]
+50=proba2[100*256+119]
+57=proba2[100*256+120]
+37=proba2[100*256+121]
+53=proba2[100*256+122]
+36=proba1[101]
+75=proba2[101*256+32]
+82=proba2[101*256+33]
+91=proba2[101*256+35]
+91=proba2[101*256+36]
+110=proba2[101*256+37]
+89=proba2[101*256+38]
+103=proba2[101*256+39]
+103=proba2[101*256+40]
+103=proba2[101*256+41]
+84=proba2[101*256+42]
+92=proba2[101*256+43]
+96=proba2[101*256+44]
+78=proba2[101*256+45]
+87=proba2[101*256+46]
+54=proba2[101*256+48]
+42=proba2[101*256+49]
+47=proba2[101*256+50]
+54=proba2[101*256+51]
+58=proba2[101*256+52]
+58=proba2[101*256+53]
+56=proba2[101*256+54]
+54=proba2[101*256+55]
+61=proba2[101*256+56]
+52=proba2[101*256+57]
+103=proba2[101*256+59]
+92=proba2[101*256+61]
+103=proba2[101*256+63]
+91=proba2[101*256+64]
+103=proba2[101*256+65]
+92=proba2[101*256+66]
+92=proba2[101*256+67]
+89=proba2[101*256+68]
+110=proba2[101*256+69]
+99=proba2[101*256+70]
+99=proba2[101*256+71]
+99=proba2[101*256+72]
+110=proba2[101*256+73]
+103=proba2[101*256+74]
+92=proba2[101*256+75]
+91=proba2[101*256+76]
+92=proba2[101*256+77]
+96=proba2[101*256+78]
+110=proba2[101*256+79]
+110=proba2[101*256+80]
+103=proba2[101*256+81]
+87=proba2[101*256+82]
+87=proba2[101*256+83]
+94=proba2[101*256+84]
+92=proba2[101*256+85]
+103=proba2[101*256+86]
+99=proba2[101*256+87]
+96=proba2[101*256+88]
+110=proba2[101*256+89]
+94=proba2[101*256+90]
+110=proba2[101*256+93]
+103=proba2[101*256+94]
+83=proba2[101*256+95]
+32=proba2[101*256+97]
+33=proba2[101*256+98]
+33=proba2[101*256+99]
+32=proba2[101*256+100]
+38=proba2[101*256+101]
+41=proba2[101*256+102]
+38=proba2[101*256+103]
+51=proba2[101*256+104]
+40=proba2[101*256+105]
+53=proba2[101*256+106]
+47=proba2[101*256+107]
+22=proba2[101*256+108]
+33=proba2[101*256+109]
+23=proba2[101*256+110]
+44=proba2[101*256+111]
+38=proba2[101*256+112]
+62=proba2[101*256+113]
+16=proba2[101*256+114]
+25=proba2[101*256+115]
+26=proba2[101*256+116]
+35=proba2[101*256+117]
+39=proba2[101*256+118]
+49=proba2[101*256+119]
+41=proba2[101*256+120]
+43=proba2[101*256+121]
+45=proba2[101*256+122]
+110=proba2[101*256+126]
+31=proba1[102]
+84=proba2[102*256+32]
+74=proba2[102*256+33]
+88=proba2[102*256+38]
+88=proba2[102*256+41]
+95=proba2[102*256+42]
+84=proba2[102*256+44]
+84=proba2[102*256+45]
+81=proba2[102*256+46]
+52=proba2[102*256+48]
+41=proba2[102*256+49]
+46=proba2[102*256+50]
+54=proba2[102*256+51]
+53=proba2[102*256+52]
+52=proba2[102*256+53]
+53=proba2[102*256+54]
+53=proba2[102*256+55]
+57=proba2[102*256+56]
+52=proba2[102*256+57]
+88=proba2[102*256+64]
+84=proba2[102*256+65]
+84=proba2[102*256+66]
+88=proba2[102*256+67]
+88=proba2[102*256+68]
+95=proba2[102*256+69]
+95=proba2[102*256+70]
+88=proba2[102*256+72]
+95=proba2[102*256+73]
+95=proba2[102*256+74]
+95=proba2[102*256+75]
+95=proba2[102*256+76]
+81=proba2[102*256+78]
+95=proba2[102*256+80]
+95=proba2[102*256+84]
+95=proba2[102*256+85]
+88=proba2[102*256+86]
+95=proba2[102*256+87]
+88=proba2[102*256+90]
+81=proba2[102*256+95]
+20=proba2[102*256+97]
+41=proba2[102*256+98]
+40=proba2[102*256+99]
+42=proba2[102*256+100]
+25=proba2[102*256+101]
+28=proba2[102*256+102]
+40=proba2[102*256+103]
+52=proba2[102*256+104]
+24=proba2[102*256+105]
+50=proba2[102*256+106]
+51=proba2[102*256+107]
+26=proba2[102*256+108]
+40=proba2[102*256+109]
+50=proba2[102*256+110]
+22=proba2[102*256+111]
+43=proba2[102*256+112]
+64=proba2[102*256+113]
+17=proba2[102*256+114]
+40=proba2[102*256+115]
+35=proba2[102*256+116]
+31=proba2[102*256+117]
+51=proba2[102*256+118]
+54=proba2[102*256+119]
+48=proba2[102*256+120]
+48=proba2[102*256+121]
+59=proba2[102*256+122]
+32=proba1[103]
+86=proba2[103*256+32]
+81=proba2[103*256+33]
+97=proba2[103*256+35]
+90=proba2[103*256+36]
+97=proba2[103*256+38]
+83=proba2[103*256+39]
+97=proba2[103*256+42]
+90=proba2[103*256+43]
+83=proba2[103*256+45]
+90=proba2[103*256+46]
+55=proba2[103*256+48]
+46=proba2[103*256+49]
+49=proba2[103*256+50]
+56=proba2[103*256+51]
+59=proba2[103*256+52]
+57=proba2[103*256+53]
+56=proba2[103*256+54]
+56=proba2[103*256+55]
+61=proba2[103*256+56]
+56=proba2[103*256+57]
+97=proba2[103*256+59]
+97=proba2[103*256+60]
+86=proba2[103*256+64]
+81=proba2[103*256+65]
+83=proba2[103*256+66]
+97=proba2[103*256+67]
+97=proba2[103*256+68]
+86=proba2[103*256+69]
+97=proba2[103*256+70]
+97=proba2[103*256+71]
+90=proba2[103*256+72]
+97=proba2[103*256+74]
+97=proba2[103*256+75]
+97=proba2[103*256+76]
+90=proba2[103*256+78]
+90=proba2[103*256+79]
+83=proba2[103*256+80]
+97=proba2[103*256+84]
+97=proba2[103*256+86]
+83=proba2[103*256+87]
+90=proba2[103*256+90]
+97=proba2[103*256+94]
+86=proba2[103*256+95]
+18=proba2[103*256+97]
+41=proba2[103*256+98]
+46=proba2[103*256+99]
+43=proba2[103*256+100]
+18=proba2[103*256+101]
+48=proba2[103*256+102]
+38=proba2[103*256+103]
+35=proba2[103*256+104]
+24=proba2[103*256+105]
+55=proba2[103*256+106]
+54=proba2[103*256+107]
+32=proba2[103*256+108]
+42=proba2[103*256+109]
+32=proba2[103*256+110]
+21=proba2[103*256+111]
+45=proba2[103*256+112]
+67=proba2[103*256+113]
+25=proba2[103*256+114]
+41=proba2[103*256+115]
+45=proba2[103*256+116]
+23=proba2[103*256+117]
+55=proba2[103*256+118]
+47=proba2[103*256+119]
+61=proba2[103*256+120]
+43=proba2[103*256+121]
+57=proba2[103*256+122]
+38=proba1[104]
+79=proba2[104*256+32]
+90=proba2[104*256+33]
+97=proba2[104*256+39]
+97=proba2[104*256+42]
+90=proba2[104*256+45]
+84=proba2[104*256+46]
+53=proba2[104*256+48]
+47=proba2[104*256+49]
+49=proba2[104*256+50]
+56=proba2[104*256+51]
+58=proba2[104*256+52]
+59=proba2[104*256+53]
+56=proba2[104*256+54]
+55=proba2[104*256+55]
+60=proba2[104*256+56]
+55=proba2[104*256+57]
+97=proba2[104*256+59]
+97=proba2[104*256+60]
+97=proba2[104*256+61]
+86=proba2[104*256+64]
+86=proba2[104*256+65]
+86=proba2[104*256+66]
+90=proba2[104*256+67]
+97=proba2[104*256+68]
+81=proba2[104*256+71]
+97=proba2[104*256+74]
+97=proba2[104*256+75]
+97=proba2[104*256+79]
+97=proba2[104*256+80]
+97=proba2[104*256+81]
+97=proba2[104*256+82]
+86=proba2[104*256+83]
+81=proba2[104*256+84]
+97=proba2[104*256+87]
+86=proba2[104*256+88]
+84=proba2[104*256+89]
+90=proba2[104*256+95]
+14=proba2[104*256+97]
+45=proba2[104*256+98]
+47=proba2[104*256+99]
+47=proba2[104*256+100]
+16=proba2[104*256+101]
+54=proba2[104*256+102]
+53=proba2[104*256+103]
+54=proba2[104*256+104]
+19=proba2[104*256+105]
+56=proba2[104*256+106]
+54=proba2[104*256+107]
+41=proba2[104*256+108]
+42=proba2[104*256+109]
+41=proba2[104*256+110]
+20=proba2[104*256+111]
+47=proba2[104*256+112]
+59=proba2[104*256+113]
+32=proba2[104*256+114]
+48=proba2[104*256+115]
+39=proba2[104*256+116]
+31=proba2[104*256+117]
+58=proba2[104*256+118]
+56=proba2[104*256+119]
+57=proba2[104*256+120]
+39=proba2[104*256+121]
+59=proba2[104*256+122]
+42=proba1[105]
+95=proba2[105*256+32]
+90=proba2[105*256+33]
+108=proba2[105*256+36]
+97=proba2[105*256+38]
+108=proba2[105*256+39]
+108=proba2[105*256+41]
+95=proba2[105*256+42]
+92=proba2[105*256+43]
+108=proba2[105*256+44]
+81=proba2[105*256+45]
+88=proba2[105*256+46]
+59=proba2[105*256+48]
+50=proba2[105*256+49]
+54=proba2[105*256+50]
+61=proba2[105*256+51]
+65=proba2[105*256+52]
+64=proba2[105*256+53]
+62=proba2[105*256+54]
+60=proba2[105*256+55]
+66=proba2[105*256+56]
+58=proba2[105*256+57]
+101=proba2[105*256+59]
+101=proba2[105*256+61]
+101=proba2[105*256+63]
+97=proba2[105*256+64]
+95=proba2[105*256+65]
+101=proba2[105*256+66]
+97=proba2[105*256+67]
+97=proba2[105*256+68]
+97=proba2[105*256+69]
+108=proba2[105*256+70]
+90=proba2[105*256+71]
+101=proba2[105*256+75]
+92=proba2[105*256+76]
+95=proba2[105*256+77]
+90=proba2[105*256+78]
+108=proba2[105*256+79]
+95=proba2[105*256+80]
+95=proba2[105*256+82]
+108=proba2[105*256+83]
+92=proba2[105*256+84]
+108=proba2[105*256+86]
+108=proba2[105*256+89]
+108=proba2[105*256+90]
+90=proba2[105*256+95]
+30=proba2[105*256+97]
+38=proba2[105*256+98]
+24=proba2[105*256+99]
+33=proba2[105*256+100]
+22=proba2[105*256+101]
+43=proba2[105*256+102]
+35=proba2[105*256+103]
+57=proba2[105*256+104]
+54=proba2[105*256+105]
+56=proba2[105*256+106]
+38=proba2[105*256+107]
+24=proba2[105*256+108]
+32=proba2[105*256+109]
+18=proba2[105*256+110]
+32=proba2[105*256+111]
+39=proba2[105*256+112]
+50=proba2[105*256+113]
+30=proba2[105*256+114]
+24=proba2[105*256+115]
+28=proba2[105*256+116]
+50=proba2[105*256+117]
+39=proba2[105*256+118]
+59=proba2[105*256+119]
+45=proba2[105*256+120]
+65=proba2[105*256+121]
+44=proba2[105*256+122]
+108=proba2[105*256+123]
+108=proba2[105*256+124]
+32=proba1[106]
+91=proba2[106*256+33]
+91=proba2[106*256+36]
+84=proba2[106*256+38]
+84=proba2[106*256+39]
+91=proba2[106*256+43]
+80=proba2[106*256+44]
+80=proba2[106*256+45]
+80=proba2[106*256+46]
+62=proba2[106*256+48]
+48=proba2[106*256+49]
+50=proba2[106*256+50]
+57=proba2[106*256+51]
+56=proba2[106*256+52]
+58=proba2[106*256+53]
+57=proba2[106*256+54]
+56=proba2[106*256+55]
+62=proba2[106*256+56]
+57=proba2[106*256+57]
+84=proba2[106*256+63]
+84=proba2[106*256+64]
+84=proba2[106*256+65]
+91=proba2[106*256+68]
+91=proba2[106*256+69]
+91=proba2[106*256+70]
+84=proba2[106*256+75]
+91=proba2[106*256+77]
+91=proba2[106*256+80]
+80=proba2[106*256+81]
+84=proba2[106*256+85]
+84=proba2[106*256+87]
+91=proba2[106*256+89]
+84=proba2[106*256+95]
+19=proba2[106*256+97]
+35=proba2[106*256+98]
+31=proba2[106*256+99]
+38=proba2[106*256+100]
+19=proba2[106*256+101]
+36=proba2[106*256+102]
+43=proba2[106*256+103]
+48=proba2[106*256+104]
+30=proba2[106*256+105]
+39=proba2[106*256+106]
+44=proba2[106*256+107]
+35=proba2[106*256+108]
+32=proba2[106*256+109]
+46=proba2[106*256+110]
+18=proba2[106*256+111]
+30=proba2[106*256+112]
+64=proba2[106*256+113]
+41=proba2[106*256+114]
+40=proba2[106*256+115]
+44=proba2[106*256+116]
+22=proba2[106*256+117]
+48=proba2[106*256+118]
+56=proba2[106*256+119]
+61=proba2[106*256+120]
+47=proba2[106*256+121]
+59=proba2[106*256+122]
+91=proba2[106*256+123]
+37=proba1[107]
+78=proba2[107*256+32]
+78=proba2[107*256+33]
+92=proba2[107*256+34]
+92=proba2[107*256+36]
+76=proba2[107*256+38]
+92=proba2[107*256+39]
+92=proba2[107*256+41]
+92=proba2[107*256+42]
+92=proba2[107*256+44]
+76=proba2[107*256+45]
+76=proba2[107*256+46]
+50=proba2[107*256+48]
+41=proba2[107*256+49]
+45=proba2[107*256+50]
+52=proba2[107*256+51]
+55=proba2[107*256+52]
+57=proba2[107*256+53]
+51=proba2[107*256+54]
+50=proba2[107*256+55]
+50=proba2[107*256+56]
+49=proba2[107*256+57]
+92=proba2[107*256+59]
+92=proba2[107*256+63]
+81=proba2[107*256+64]
+85=proba2[107*256+65]
+92=proba2[107*256+68]
+92=proba2[107*256+69]
+92=proba2[107*256+70]
+78=proba2[107*256+71]
+92=proba2[107*256+72]
+92=proba2[107*256+77]
+92=proba2[107*256+78]
+74=proba2[107*256+80]
+85=proba2[107*256+81]
+92=proba2[107*256+82]
+81=proba2[107*256+84]
+85=proba2[107*256+85]
+92=proba2[107*256+87]
+92=proba2[107*256+88]
+92=proba2[107*256+95]
+16=proba2[107*256+97]
+45=proba2[107*256+98]
+44=proba2[107*256+99]
+46=proba2[107*256+100]
+19=proba2[107*256+101]
+47=proba2[107*256+102]
+50=proba2[107*256+103]
+35=proba2[107*256+104]
+18=proba2[107*256+105]
+50=proba2[107*256+106]
+39=proba2[107*256+107]
+36=proba2[107*256+108]
+41=proba2[107*256+109]
+43=proba2[107*256+110]
+23=proba2[107*256+111]
+46=proba2[107*256+112]
+66=proba2[107*256+113]
+32=proba2[107*256+114]
+36=proba2[107*256+115]
+44=proba2[107*256+116]
+34=proba2[107*256+117]
+58=proba2[107*256+118]
+46=proba2[107*256+119]
+63=proba2[107*256+120]
+30=proba2[107*256+121]
+50=proba2[107*256+122]
+30=proba1[108]
+92=proba2[108*256+32]
+85=proba2[108*256+33]
+106=proba2[108*256+35]
+95=proba2[108*256+36]
+83=proba2[108*256+38]
+106=proba2[108*256+39]
+106=proba2[108*256+40]
+106=proba2[108*256+41]
+95=proba2[108*256+42]
+106=proba2[108*256+43]
+86=proba2[108*256+44]
+83=proba2[108*256+45]
+83=proba2[108*256+46]
+53=proba2[108*256+48]
+47=proba2[108*256+49]
+52=proba2[108*256+50]
+57=proba2[108*256+51]
+63=proba2[108*256+52]
+62=proba2[108*256+53]
+59=proba2[108*256+54]
+60=proba2[108*256+55]
+63=proba2[108*256+56]
+55=proba2[108*256+57]
+95=proba2[108*256+59]
+106=proba2[108*256+61]
+86=proba2[108*256+64]
+86=proba2[108*256+65]
+90=proba2[108*256+66]
+95=proba2[108*256+67]
+99=proba2[108*256+68]
+88=proba2[108*256+69]
+106=proba2[108*256+70]
+99=proba2[108*256+71]
+99=proba2[108*256+75]
+106=proba2[108*256+76]
+95=proba2[108*256+77]
+106=proba2[108*256+78]
+99=proba2[108*256+79]
+92=proba2[108*256+80]
+99=proba2[108*256+82]
+90=proba2[108*256+84]
+92=proba2[108*256+85]
+106=proba2[108*256+86]
+106=proba2[108*256+87]
+106=proba2[108*256+88]
+99=proba2[108*256+89]
+106=proba2[108*256+90]
+86=proba2[108*256+95]
+18=proba2[108*256+97]
+42=proba2[108*256+98]
+43=proba2[108*256+99]
+36=proba2[108*256+100]
+16=proba2[108*256+101]
+43=proba2[108*256+102]
+47=proba2[108*256+103]
+50=proba2[108*256+104]
+19=proba2[108*256+105]
+56=proba2[108*256+106]
+49=proba2[108*256+107]
+22=proba2[108*256+108]
+41=proba2[108*256+109]
+53=proba2[108*256+110]
+20=proba2[108*256+111]
+41=proba2[108*256+112]
+74=proba2[108*256+113]
+50=proba2[108*256+114]
+41=proba2[108*256+115]
+39=proba2[108*256+116]
+31=proba2[108*256+117]
+44=proba2[108*256+118]
+59=proba2[108*256+119]
+63=proba2[108*256+120]
+37=proba2[108*256+121]
+60=proba2[108*256+122]
+25=proba1[109]
+83=proba2[109*256+32]
+84=proba2[109*256+33]
+102=proba2[109*256+34]
+102=proba2[109*256+35]
+91=proba2[109*256+36]
+102=proba2[109*256+37]
+88=proba2[109*256+38]
+88=proba2[109*256+39]
+95=proba2[109*256+41]
+86=proba2[109*256+42]
+88=proba2[109*256+43]
+88=proba2[109*256+44]
+83=proba2[109*256+45]
+79=proba2[109*256+46]
+54=proba2[109*256+48]
+45=proba2[109*256+49]
+49=proba2[109*256+50]
+57=proba2[109*256+51]
+60=proba2[109*256+52]
+59=proba2[109*256+53]
+60=proba2[109*256+54]
+58=proba2[109*256+55]
+61=proba2[109*256+56]
+54=proba2[109*256+57]
+91=proba2[109*256+59]
+102=proba2[109*256+60]
+91=proba2[109*256+61]
+95=proba2[109*256+63]
+81=proba2[109*256+64]
+88=proba2[109*256+65]
+102=proba2[109*256+66]
+102=proba2[109*256+67]
+95=proba2[109*256+68]
+102=proba2[109*256+70]
+95=proba2[109*256+71]
+91=proba2[109*256+72]
+102=proba2[109*256+74]
+102=proba2[109*256+76]
+91=proba2[109*256+77]
+102=proba2[109*256+78]
+102=proba2[109*256+80]
+102=proba2[109*256+81]
+95=proba2[109*256+84]
+95=proba2[109*256+85]
+95=proba2[109*256+86]
+102=proba2[109*256+88]
+102=proba2[109*256+89]
+91=proba2[109*256+95]
+12=proba2[109*256+97]
+34=proba2[109*256+98]
+41=proba2[109*256+99]
+45=proba2[109*256+100]
+20=proba2[109*256+101]
+50=proba2[109*256+102]
+49=proba2[109*256+103]
+53=proba2[109*256+104]
+20=proba2[109*256+105]
+51=proba2[109*256+106]
+55=proba2[109*256+107]
+44=proba2[109*256+108]
+35=proba2[109*256+109]
+50=proba2[109*256+110]
+20=proba2[109*256+111]
+33=proba2[109*256+112]
+67=proba2[109*256+113]
+46=proba2[109*256+114]
+39=proba2[109*256+115]
+47=proba2[109*256+116]
+34=proba2[109*256+117]
+57=proba2[109*256+118]
+60=proba2[109*256+119]
+60=proba2[109*256+120]
+35=proba2[109*256+121]
+59=proba2[109*256+122]
+102=proba2[109*256+125]
+35=proba1[110]
+86=proba2[110*256+32]
+84=proba2[110*256+33]
+94=proba2[110*256+35]
+94=proba2[110*256+36]
+105=proba2[110*256+37]
+84=proba2[110*256+38]
+91=proba2[110*256+39]
+105=proba2[110*256+40]
+105=proba2[110*256+41]
+79=proba2[110*256+42]
+87=proba2[110*256+43]
+87=proba2[110*256+44]
+77=proba2[110*256+45]
+87=proba2[110*256+46]
+51=proba2[110*256+48]
+42=proba2[110*256+49]
+47=proba2[110*256+50]
+56=proba2[110*256+51]
+61=proba2[110*256+52]
+60=proba2[110*256+53]
+54=proba2[110*256+54]
+56=proba2[110*256+55]
+62=proba2[110*256+56]
+55=proba2[110*256+57]
+91=proba2[110*256+59]
+105=proba2[110*256+61]
+98=proba2[110*256+63]
+86=proba2[110*256+64]
+86=proba2[110*256+65]
+98=proba2[110*256+66]
+105=proba2[110*256+67]
+91=proba2[110*256+68]
+98=proba2[110*256+69]
+105=proba2[110*256+70]
+89=proba2[110*256+71]
+105=proba2[110*256+72]
+84=proba2[110*256+73]
+98=proba2[110*256+74]
+105=proba2[110*256+75]
+98=proba2[110*256+76]
+98=proba2[110*256+77]
+91=proba2[110*256+79]
+98=proba2[110*256+80]
+98=proba2[110*256+82]
+83=proba2[110*256+83]
+105=proba2[110*256+84]
+105=proba2[110*256+85]
+105=proba2[110*256+87]
+89=proba2[110*256+89]
+94=proba2[110*256+90]
+105=proba2[110*256+94]
+84=proba2[110*256+95]
+22=proba2[110*256+97]
+45=proba2[110*256+98]
+30=proba2[110*256+99]
+26=proba2[110*256+100]
+17=proba2[110*256+101]
+43=proba2[110*256+102]
+29=proba2[110*256+103]
+50=proba2[110*256+104]
+22=proba2[110*256+105]
+45=proba2[110*256+106]
+41=proba2[110*256+107]
+48=proba2[110*256+108]
+48=proba2[110*256+109]
+30=proba2[110*256+110]
+24=proba2[110*256+111]
+48=proba2[110*256+112]
+64=proba2[110*256+113]
+48=proba2[110*256+114]
+33=proba2[110*256+115]
+25=proba2[110*256+116]
+39=proba2[110*256+117]
+54=proba2[110*256+118]
+58=proba2[110*256+119]
+60=proba2[110*256+120]
+40=proba2[110*256+121]
+47=proba2[110*256+122]
+105=proba2[110*256+125]
+41=proba1[111]
+90=proba2[111*256+32]
+85=proba2[111*256+33]
+108=proba2[111*256+35]
+97=proba2[111*256+36]
+108=proba2[111*256+37]
+101=proba2[111*256+38]
+101=proba2[111*256+39]
+108=proba2[111*256+40]
+89=proba2[111*256+42]
+90=proba2[111*256+43]
+94=proba2[111*256+44]
+89=proba2[111*256+45]
+83=proba2[111*256+46]
+55=proba2[111*256+48]
+45=proba2[111*256+49]
+50=proba2[111*256+50]
+57=proba2[111*256+51]
+61=proba2[111*256+52]
+62=proba2[111*256+53]
+59=proba2[111*256+54]
+56=proba2[111*256+55]
+64=proba2[111*256+56]
+55=proba2[111*256+57]
+94=proba2[111*256+59]
+97=proba2[111*256+61]
+108=proba2[111*256+62]
+108=proba2[111*256+63]
+97=proba2[111*256+64]
+92=proba2[111*256+66]
+94=proba2[111*256+67]
+108=proba2[111*256+68]
+108=proba2[111*256+69]
+94=proba2[111*256+70]
+94=proba2[111*256+71]
+108=proba2[111*256+72]
+101=proba2[111*256+73]
+97=proba2[111*256+74]
+101=proba2[111*256+76]
+97=proba2[111*256+77]
+101=proba2[111*256+78]
+94=proba2[111*256+80]
+101=proba2[111*256+81]
+92=proba2[111*256+82]
+89=proba2[111*256+83]
+89=proba2[111*256+84]
+92=proba2[111*256+85]
+101=proba2[111*256+88]
+108=proba2[111*256+90]
+92=proba2[111*256+95]
+46=proba2[111*256+97]
+36=proba2[111*256+98]
+34=proba2[111*256+99]
+36=proba2[111*256+100]
+44=proba2[111*256+101]
+41=proba2[111*256+102]
+39=proba2[111*256+103]
+47=proba2[111*256+104]
+33=proba2[111*256+105]
+53=proba2[111*256+106]
+42=proba2[111*256+107]
+25=proba2[111*256+108]
+29=proba2[111*256+109]
+19=proba2[111*256+110]
+33=proba2[111*256+111]
+34=proba2[111*256+112]
+60=proba2[111*256+113]
+23=proba2[111*256+114]
+31=proba2[111*256+115]
+30=proba2[111*256+116]
+17=proba2[111*256+117]
+42=proba2[111*256+118]
+43=proba2[111*256+119]
+48=proba2[111*256+120]
+42=proba2[111*256+121]
+48=proba2[111*256+122]
+28=proba1[112]
+92=proba2[112*256+32]
+76=proba2[112*256+33]
+85=proba2[112*256+36]
+88=proba2[112*256+38]
+85=proba2[112*256+43]
+88=proba2[112*256+44]
+85=proba2[112*256+45]
+78=proba2[112*256+46]
+55=proba2[112*256+48]
+47=proba2[112*256+49]
+49=proba2[112*256+50]
+51=proba2[112*256+51]
+58=proba2[112*256+52]
+58=proba2[112*256+53]
+58=proba2[112*256+54]
+56=proba2[112*256+55]
+65=proba2[112*256+56]
+55=proba2[112*256+57]
+92=proba2[112*256+59]
+99=proba2[112*256+61]
+99=proba2[112*256+63]
+92=proba2[112*256+64]
+85=proba2[112*256+67]
+99=proba2[112*256+68]
+99=proba2[112*256+69]
+99=proba2[112*256+71]
+92=proba2[112*256+72]
+92=proba2[112*256+73]
+99=proba2[112*256+75]
+99=proba2[112*256+76]
+88=proba2[112*256+77]
+85=proba2[112*256+78]
+92=proba2[112*256+79]
+88=proba2[112*256+80]
+88=proba2[112*256+82]
+92=proba2[112*256+83]
+83=proba2[112*256+84]
+99=proba2[112*256+86]
+99=proba2[112*256+87]
+85=proba2[112*256+89]
+99=proba2[112*256+90]
+83=proba2[112*256+95]
+17=proba2[112*256+97]
+45=proba2[112*256+98]
+40=proba2[112*256+99]
+48=proba2[112*256+100]
+20=proba2[112*256+101]
+47=proba2[112*256+102]
+48=proba2[112*256+103]
+23=proba2[112*256+104]
+21=proba2[112*256+105]
+51=proba2[112*256+106]
+53=proba2[112*256+107]
+31=proba2[112*256+108]
+42=proba2[112*256+109]
+52=proba2[112*256+110]
+21=proba2[112*256+111]
+34=proba2[112*256+112]
+60=proba2[112*256+113]
+28=proba2[112*256+114]
+33=proba2[112*256+115]
+38=proba2[112*256+116]
+36=proba2[112*256+117]
+52=proba2[112*256+118]
+54=proba2[112*256+119]
+63=proba2[112*256+120]
+39=proba2[112*256+121]
+58=proba2[112*256+122]
+54=proba1[113]
+77=proba2[113*256+32]
+77=proba2[113*256+44]
+70=proba2[113*256+45]
+70=proba2[113*256+46]
+61=proba2[113*256+48]
+39=proba2[113*256+49]
+42=proba2[113*256+50]
+50=proba2[113*256+51]
+52=proba2[113*256+52]
+45=proba2[113*256+53]
+50=proba2[113*256+54]
+46=proba2[113*256+55]
+54=proba2[113*256+56]
+44=proba2[113*256+57]
+77=proba2[113*256+66]
+77=proba2[113*256+68]
+66=proba2[113*256+69]
+77=proba2[113*256+70]
+77=proba2[113*256+72]
+77=proba2[113*256+74]
+77=proba2[113*256+75]
+77=proba2[113*256+79]
+70=proba2[113*256+80]
+77=proba2[113*256+81]
+77=proba2[113*256+82]
+66=proba2[113*256+83]
+77=proba2[113*256+84]
+77=proba2[113*256+85]
+70=proba2[113*256+87]
+70=proba2[113*256+88]
+63=proba2[113*256+90]
+35=proba2[113*256+97]
+41=proba2[113*256+98]
+37=proba2[113*256+99]
+43=proba2[113*256+100]
+44=proba2[113*256+101]
+42=proba2[113*256+102]
+50=proba2[113*256+103]
+50=proba2[113*256+104]
+43=proba2[113*256+105]
+46=proba2[113*256+106]
+52=proba2[113*256+107]
+48=proba2[113*256+108]
+41=proba2[113*256+109]
+48=proba2[113*256+110]
+53=proba2[113*256+111]
+41=proba2[113*256+112]
+40=proba2[113*256+113]
+43=proba2[113*256+114]
+35=proba2[113*256+115]
+41=proba2[113*256+116]
+6=proba2[113*256+117]
+45=proba2[113*256+118]
+30=proba2[113*256+119]
+49=proba2[113*256+120]
+53=proba2[113*256+121]
+46=proba2[113*256+122]
+34=proba1[114]
+88=proba2[114*256+32]
+82=proba2[114*256+33]
+100=proba2[114*256+35]
+89=proba2[114*256+36]
+107=proba2[114*256+37]
+88=proba2[114*256+38]
+107=proba2[114*256+39]
+100=proba2[114*256+41]
+89=proba2[114*256+42]
+89=proba2[114*256+43]
+107=proba2[114*256+44]
+84=proba2[114*256+45]
+84=proba2[114*256+46]
+56=proba2[114*256+48]
+45=proba2[114*256+49]
+50=proba2[114*256+50]
+58=proba2[114*256+51]
+60=proba2[114*256+52]
+60=proba2[114*256+53]
+59=proba2[114*256+54]
+57=proba2[114*256+55]
+62=proba2[114*256+56]
+56=proba2[114*256+57]
+107=proba2[114*256+59]
+107=proba2[114*256+61]
+107=proba2[114*256+63]
+83=proba2[114*256+64]
+107=proba2[114*256+65]
+100=proba2[114*256+66]
+107=proba2[114*256+67]
+107=proba2[114*256+68]
+100=proba2[114*256+69]
+100=proba2[114*256+70]
+100=proba2[114*256+71]
+100=proba2[114*256+72]
+100=proba2[114*256+73]
+107=proba2[114*256+74]
+96=proba2[114*256+75]
+96=proba2[114*256+76]
+93=proba2[114*256+77]
+107=proba2[114*256+78]
+100=proba2[114*256+79]
+100=proba2[114*256+80]
+96=proba2[114*256+81]
+107=proba2[114*256+82]
+89=proba2[114*256+83]
+96=proba2[114*256+84]
+96=proba2[114*256+85]
+100=proba2[114*256+86]
+107=proba2[114*256+87]
+107=proba2[114*256+91]
+96=proba2[114*256+95]
+20=proba2[114*256+97]
+41=proba2[114*256+98]
+35=proba2[114*256+99]
+30=proba2[114*256+100]
+18=proba2[114*256+101]
+45=proba2[114*256+102]
+37=proba2[114*256+103]
+54=proba2[114*256+104]
+19=proba2[114*256+105]
+56=proba2[114*256+106]
+44=proba2[114*256+107]
+38=proba2[114*256+108]
+39=proba2[114*256+109]
+36=proba2[114*256+110]
+21=proba2[114*256+111]
+44=proba2[114*256+112]
+62=proba2[114*256+113]
+35=proba2[114*256+114]
+35=proba2[114*256+115]
+28=proba2[114*256+116]
+35=proba2[114*256+117]
+46=proba2[114*256+118]
+54=proba2[114*256+119]
+66=proba2[114*256+120]
+39=proba2[114*256+121]
+57=proba2[114*256+122]
+96=proba2[114*256+125]
+26=proba1[115]
+84=proba2[115*256+32]
+84=proba2[115*256+33]
+93=proba2[115*256+35]
+93=proba2[115*256+36]
+90=proba2[115*256+37]
+86=proba2[115*256+38]
+104=proba2[115*256+39]
+104=proba2[115*256+41]
+86=proba2[115*256+42]
+84=proba2[115*256+43]
+90=proba2[115*256+44]
+83=proba2[115*256+45]
+79=proba2[115*256+46]
+50=proba2[115*256+48]
+41=proba2[115*256+49]
+45=proba2[115*256+50]
+54=proba2[115*256+51]
+56=proba2[115*256+52]
+55=proba2[115*256+53]
+55=proba2[115*256+54]
+53=proba2[115*256+55]
+59=proba2[115*256+56]
+51=proba2[115*256+57]
+104=proba2[115*256+59]
+104=proba2[115*256+60]
+104=proba2[115*256+61]
+97=proba2[115*256+63]
+88=proba2[115*256+64]
+97=proba2[115*256+65]
+104=proba2[115*256+66]
+104=proba2[115*256+67]
+83=proba2[115*256+68]
+104=proba2[115*256+69]
+93=proba2[115*256+70]
+104=proba2[115*256+71]
+97=proba2[115*256+72]
+97=proba2[115*256+73]
+104=proba2[115*256+75]
+104=proba2[115*256+76]
+86=proba2[115*256+77]
+97=proba2[115*256+81]
+97=proba2[115*256+82]
+104=proba2[115*256+83]
+97=proba2[115*256+84]
+104=proba2[115*256+86]
+104=proba2[115*256+87]
+104=proba2[115*256+89]
+81=proba2[115*256+95]
+104=proba2[115*256+96]
+22=proba2[115*256+97]
+43=proba2[115*256+98]
+30=proba2[115*256+99]
+43=proba2[115*256+100]
+21=proba2[115*256+101]
+48=proba2[115*256+102]
+47=proba2[115*256+103]
+33=proba2[115*256+104]
+25=proba2[115*256+105]
+54=proba2[115*256+106]
+38=proba2[115*256+107]
+40=proba2[115*256+108]
+37=proba2[115*256+109]
+41=proba2[115*256+110]
+26=proba2[115*256+111]
+33=proba2[115*256+112]
+53=proba2[115*256+113]
+48=proba2[115*256+114]
+23=proba2[115*256+115]
+19=proba2[115*256+116]
+34=proba2[115*256+117]
+53=proba2[115*256+118]
+46=proba2[115*256+119]
+56=proba2[115*256+120]
+37=proba2[115*256+121]
+60=proba2[115*256+122]
+31=proba1[116]
+87=proba2[116*256+32]
+77=proba2[116*256+33]
+92=proba2[116*256+36]
+83=proba2[116*256+38]
+92=proba2[116*256+39]
+90=proba2[116*256+42]
+97=proba2[116*256+43]
+103=proba2[116*256+44]
+79=proba2[116*256+45]
+90=proba2[116*256+46]
+54=proba2[116*256+48]
+44=proba2[116*256+49]
+48=proba2[116*256+50]
+56=proba2[116*256+51]
+57=proba2[116*256+52]
+60=proba2[116*256+53]
+57=proba2[116*256+54]
+57=proba2[116*256+55]
+61=proba2[116*256+56]
+54=proba2[116*256+57]
+103=proba2[116*256+59]
+97=proba2[116*256+61]
+86=proba2[116*256+64]
+87=proba2[116*256+65]
+92=proba2[116*256+66]
+97=proba2[116*256+68]
+92=proba2[116*256+69]
+103=proba2[116*256+71]
+103=proba2[116*256+72]
+97=proba2[116*256+73]
+97=proba2[116*256+74]
+103=proba2[116*256+76]
+90=proba2[116*256+77]
+92=proba2[116*256+78]
+97=proba2[116*256+79]
+103=proba2[116*256+80]
+103=proba2[116*256+81]
+87=proba2[116*256+82]
+92=proba2[116*256+84]
+103=proba2[116*256+85]
+103=proba2[116*256+86]
+97=proba2[116*256+88]
+92=proba2[116*256+89]
+81=proba2[116*256+95]
+21=proba2[116*256+97]
+46=proba2[116*256+98]
+38=proba2[116*256+99]
+48=proba2[116*256+100]
+17=proba2[116*256+101]
+50=proba2[116*256+102]
+51=proba2[116*256+103]
+24=proba2[116*256+104]
+21=proba2[116*256+105]
+55=proba2[116*256+106]
+58=proba2[116*256+107]
+43=proba2[116*256+108]
+42=proba2[116*256+109]
+47=proba2[116*256+110]
+20=proba2[116*256+111]
+47=proba2[116*256+112]
+67=proba2[116*256+113]
+25=proba2[116*256+114]
+37=proba2[116*256+115]
+29=proba2[116*256+116]
+34=proba2[116*256+117]
+54=proba2[116*256+118]
+49=proba2[116*256+119]
+60=proba2[116*256+120]
+37=proba2[116*256+121]
+48=proba2[116*256+122]
+103=proba2[116*256+124]
+51=proba1[117]
+102=proba2[117*256+32]
+81=proba2[117*256+33]
+95=proba2[117*256+35]
+91=proba2[117*256+36]
+102=proba2[117*256+37]
+88=proba2[117*256+38]
+102=proba2[117*256+40]
+86=proba2[117*256+42]
+102=proba2[117*256+43]
+95=proba2[117*256+44]
+81=proba2[117*256+45]
+84=proba2[117*256+46]
+58=proba2[117*256+48]
+47=proba2[117*256+49]
+50=proba2[117*256+50]
+58=proba2[117*256+51]
+61=proba2[117*256+52]
+60=proba2[117*256+53]
+57=proba2[117*256+54]
+58=proba2[117*256+55]
+63=proba2[117*256+56]
+57=proba2[117*256+57]
+102=proba2[117*256+59]
+102=proba2[117*256+61]
+102=proba2[117*256+63]
+102=proba2[117*256+64]
+102=proba2[117*256+65]
+91=proba2[117*256+66]
+91=proba2[117*256+68]
+88=proba2[117*256+70]
+95=proba2[117*256+71]
+102=proba2[117*256+72]
+102=proba2[117*256+73]
+86=proba2[117*256+75]
+88=proba2[117*256+76]
+102=proba2[117*256+77]
+102=proba2[117*256+78]
+91=proba2[117*256+79]
+91=proba2[117*256+80]
+86=proba2[117*256+82]
+88=proba2[117*256+83]
+88=proba2[117*256+84]
+102=proba2[117*256+85]
+102=proba2[117*256+87]
+91=proba2[117*256+88]
+102=proba2[117*256+90]
+102=proba2[117*256+91]
+102=proba2[117*256+93]
+84=proba2[117*256+95]
+35=proba2[117*256+97]
+32=proba2[117*256+98]
+29=proba2[117*256+99]
+28=proba2[117*256+100]
+27=proba2[117*256+101]
+40=proba2[117*256+102]
+36=proba2[117*256+103]
+51=proba2[117*256+104]
+27=proba2[117*256+105]
+49=proba2[117*256+106]
+42=proba2[117*256+107]
+23=proba2[117*256+108]
+32=proba2[117*256+109]
+26=proba2[117*256+110]
+51=proba2[117*256+111]
+33=proba2[117*256+112]
+60=proba2[117*256+113]
+20=proba2[117*256+114]
+23=proba2[117*256+115]
+29=proba2[117*256+116]
+59=proba2[117*256+117]
+43=proba2[117*256+118]
+61=proba2[117*256+119]
+37=proba2[117*256+120]
+45=proba2[117*256+121]
+43=proba2[117*256+122]
+38=proba1[118]
+72=proba2[118*256+33]
+85=proba2[118*256+35]
+85=proba2[118*256+36]
+85=proba2[118*256+38]
+85=proba2[118*256+42]
+85=proba2[118*256+43]
+92=proba2[118*256+44]
+92=proba2[118*256+45]
+74=proba2[118*256+46]
+57=proba2[118*256+48]
+47=proba2[118*256+49]
+50=proba2[118*256+50]
+57=proba2[118*256+51]
+56=proba2[118*256+52]
+54=proba2[118*256+53]
+57=proba2[118*256+54]
+56=proba2[118*256+55]
+55=proba2[118*256+56]
+55=proba2[118*256+57]
+85=proba2[118*256+61]
+81=proba2[118*256+64]
+81=proba2[118*256+65]
+85=proba2[118*256+66]
+92=proba2[118*256+67]
+92=proba2[118*256+68]
+85=proba2[118*256+69]
+92=proba2[118*256+71]
+78=proba2[118*256+72]
+85=proba2[118*256+75]
+92=proba2[118*256+76]
+92=proba2[118*256+77]
+92=proba2[118*256+79]
+92=proba2[118*256+80]
+85=proba2[118*256+81]
+92=proba2[118*256+84]
+81=proba2[118*256+85]
+85=proba2[118*256+95]
+16=proba2[118*256+97]
+42=proba2[118*256+98]
+44=proba2[118*256+99]
+42=proba2[118*256+100]
+14=proba2[118*256+101]
+50=proba2[118*256+102]
+50=proba2[118*256+103]
+51=proba2[118*256+104]
+13=proba2[118*256+105]
+55=proba2[118*256+106]
+56=proba2[118*256+107]
+42=proba2[118*256+108]
+45=proba2[118*256+109]
+49=proba2[118*256+110]
+27=proba2[118*256+111]
+47=proba2[118*256+112]
+59=proba2[118*256+113]
+34=proba2[118*256+114]
+45=proba2[118*256+115]
+46=proba2[118*256+116]
+46=proba2[118*256+117]
+48=proba2[118*256+118]
+58=proba2[118*256+119]
+57=proba2[118*256+120]
+44=proba2[118*256+121]
+61=proba2[118*256+122]
+43=proba1[119]
+86=proba2[119*256+32]
+86=proba2[119*256+33]
+86=proba2[119*256+34]
+72=proba2[119*256+37]
+86=proba2[119*256+38]
+79=proba2[119*256+42]
+86=proba2[119*256+44]
+79=proba2[119*256+45]
+79=proba2[119*256+46]
+56=proba2[119*256+48]
+47=proba2[119*256+49]
+45=proba2[119*256+50]
+50=proba2[119*256+51]
+52=proba2[119*256+52]
+57=proba2[119*256+53]
+55=proba2[119*256+54]
+52=proba2[119*256+55]
+55=proba2[119*256+56]
+53=proba2[119*256+57]
+79=proba2[119*256+65]
+86=proba2[119*256+68]
+86=proba2[119*256+69]
+79=proba2[119*256+70]
+86=proba2[119*256+71]
+86=proba2[119*256+72]
+86=proba2[119*256+73]
+79=proba2[119*256+74]
+86=proba2[119*256+77]
+79=proba2[119*256+81]
+79=proba2[119*256+83]
+86=proba2[119*256+84]
+75=proba2[119*256+86]
+86=proba2[119*256+89]
+86=proba2[119*256+90]
+79=proba2[119*256+95]
+16=proba2[119*256+97]
+42=proba2[119*256+98]
+46=proba2[119*256+99]
+43=proba2[119*256+100]
+14=proba2[119*256+101]
+46=proba2[119*256+102]
+47=proba2[119*256+103]
+38=proba2[119*256+104]
+20=proba2[119*256+105]
+53=proba2[119*256+106]
+46=proba2[119*256+107]
+44=proba2[119*256+108]
+47=proba2[119*256+109]
+39=proba2[119*256+110]
+22=proba2[119*256+111]
+49=proba2[119*256+112]
+55=proba2[119*256+113]
+42=proba2[119*256+114]
+34=proba2[119*256+115]
+46=proba2[119*256+116]
+45=proba2[119*256+117]
+59=proba2[119*256+118]
+36=proba2[119*256+119]
+43=proba2[119*256+120]
+40=proba2[119*256+121]
+49=proba2[119*256+122]
+51=proba1[120]
+82=proba2[120*256+37]
+76=proba2[120*256+38]
+82=proba2[120*256+39]
+82=proba2[120*256+42]
+82=proba2[120*256+43]
+76=proba2[120*256+44]
+61=proba2[120*256+45]
+66=proba2[120*256+46]
+40=proba2[120*256+48]
+31=proba2[120*256+49]
+35=proba2[120*256+50]
+39=proba2[120*256+51]
+44=proba2[120*256+52]
+47=proba2[120*256+53]
+42=proba2[120*256+54]
+42=proba2[120*256+55]
+45=proba2[120*256+56]
+41=proba2[120*256+57]
+82=proba2[120*256+59]
+82=proba2[120*256+63]
+82=proba2[120*256+64]
+82=proba2[120*256+65]
+82=proba2[120*256+68]
+82=proba2[120*256+70]
+76=proba2[120*256+71]
+76=proba2[120*256+72]
+82=proba2[120*256+76]
+76=proba2[120*256+77]
+76=proba2[120*256+80]
+76=proba2[120*256+81]
+82=proba2[120*256+82]
+82=proba2[120*256+83]
+82=proba2[120*256+84]
+76=proba2[120*256+85]
+82=proba2[120*256+86]
+82=proba2[120*256+87]
+82=proba2[120*256+88]
+82=proba2[120*256+90]
+82=proba2[120*256+93]
+82=proba2[120*256+95]
+24=proba2[120*256+97]
+38=proba2[120*256+98]
+32=proba2[120*256+99]
+40=proba2[120*256+100]
+25=proba2[120*256+101]
+37=proba2[120*256+102]
+44=proba2[120*256+103]
+48=proba2[120*256+104]
+24=proba2[120*256+105]
+48=proba2[120*256+106]
+49=proba2[120*256+107]
+38=proba2[120*256+108]
+34=proba2[120*256+109]
+45=proba2[120*256+110]
+31=proba2[120*256+111]
+32=proba2[120*256+112]
+51=proba2[120*256+113]
+41=proba2[120*256+114]
+36=proba2[120*256+115]
+31=proba2[120*256+116]
+40=proba2[120*256+117]
+45=proba2[120*256+118]
+42=proba2[120*256+119]
+24=proba2[120*256+120]
+33=proba2[120*256+121]
+45=proba2[120*256+122]
+45=proba1[121]
+75=proba2[121*256+32]
+72=proba2[121*256+33]
+91=proba2[121*256+34]
+80=proba2[121*256+36]
+78=proba2[121*256+38]
+91=proba2[121*256+39]
+91=proba2[121*256+41]
+69=proba2[121*256+42]
+78=proba2[121*256+44]
+69=proba2[121*256+45]
+84=proba2[121*256+46]
+43=proba2[121*256+48]
+34=proba2[121*256+49]
+38=proba2[121*256+50]
+48=proba2[121*256+51]
+46=proba2[121*256+52]
+51=proba2[121*256+53]
+47=proba2[121*256+54]
+44=proba2[121*256+55]
+49=proba2[121*256+56]
+43=proba2[121*256+57]
+91=proba2[121*256+59]
+78=proba2[121*256+63]
+91=proba2[121*256+64]
+84=proba2[121*256+65]
+84=proba2[121*256+66]
+80=proba2[121*256+67]
+73=proba2[121*256+68]
+91=proba2[121*256+69]
+91=proba2[121*256+72]
+84=proba2[121*256+74]
+84=proba2[121*256+76]
+78=proba2[121*256+77]
+91=proba2[121*256+78]
+84=proba2[121*256+80]
+91=proba2[121*256+82]
+80=proba2[121*256+83]
+66=proba2[121*256+84]
+78=proba2[121*256+85]
+80=proba2[121*256+88]
+91=proba2[121*256+89]
+91=proba2[121*256+93]
+78=proba2[121*256+95]
+22=proba2[121*256+97]
+28=proba2[121*256+98]
+33=proba2[121*256+99]
+35=proba2[121*256+100]
+27=proba2[121*256+101]
+44=proba2[121*256+102]
+32=proba2[121*256+103]
+49=proba2[121*256+104]
+48=proba2[121*256+105]
+47=proba2[121*256+106]
+44=proba2[121*256+107]
+27=proba2[121*256+108]
+32=proba2[121*256+109]
+31=proba2[121*256+110]
+24=proba2[121*256+111]
+35=proba2[121*256+112]
+63=proba2[121*256+113]
+30=proba2[121*256+114]
+25=proba2[121*256+115]
+37=proba2[121*256+116]
+39=proba2[121*256+117]
+37=proba2[121*256+118]
+48=proba2[121*256+119]
+48=proba2[121*256+120]
+47=proba2[121*256+121]
+45=proba2[121*256+122]
+44=proba1[122]
+80=proba2[122*256+33]
+87=proba2[122*256+34]
+87=proba2[122*256+35]
+87=proba2[122*256+36]
+87=proba2[122*256+37]
+80=proba2[122*256+38]
+76=proba2[122*256+40]
+87=proba2[122*256+42]
+76=proba2[122*256+44]
+73=proba2[122*256+45]
+53=proba2[122*256+48]
+46=proba2[122*256+49]
+46=proba2[122*256+50]
+46=proba2[122*256+51]
+49=proba2[122*256+52]
+53=proba2[122*256+53]
+49=proba2[122*256+54]
+52=proba2[122*256+55]
+49=proba2[122*256+56]
+52=proba2[122*256+57]
+87=proba2[122*256+59]
+80=proba2[122*256+64]
+80=proba2[122*256+65]
+87=proba2[122*256+66]
+87=proba2[122*256+67]
+87=proba2[122*256+68]
+87=proba2[122*256+70]
+80=proba2[122*256+71]
+80=proba2[122*256+73]
+80=proba2[122*256+75]
+87=proba2[122*256+76]
+73=proba2[122*256+77]
+87=proba2[122*256+78]
+87=proba2[122*256+81]
+87=proba2[122*256+83]
+87=proba2[122*256+85]
+87=proba2[122*256+87]
+80=proba2[122*256+88]
+73=proba2[122*256+89]
+80=proba2[122*256+95]
+18=proba2[122*256+97]
+44=proba2[122*256+98]
+48=proba2[122*256+99]
+46=proba2[122*256+100]
+17=proba2[122*256+101]
+51=proba2[122*256+102]
+47=proba2[122*256+103]
+41=proba2[122*256+104]
+21=proba2[122*256+105]
+60=proba2[122*256+106]
+50=proba2[122*256+107]
+44=proba2[122*256+108]
+38=proba2[122*256+109]
+48=proba2[122*256+110]
+18=proba2[122*256+111]
+50=proba2[122*256+112]
+53=proba2[122*256+113]
+46=proba2[122*256+114]
+49=proba2[122*256+115]
+45=proba2[122*256+116]
+34=proba2[122*256+117]
+54=proba2[122*256+118]
+47=proba2[122*256+119]
+45=proba2[122*256+120]
+35=proba2[122*256+121]
+24=proba2[122*256+122]
+87=proba2[122*256+126]
+104=proba1[123]
+19=proba2[123*256+75]
+19=proba2[123*256+91]
+19=proba2[123*256+97]
+19=proba2[123*256+102]
+19=proba2[123*256+114]
+19=proba2[123*256+122]
+19=proba2[123*256+124]
+111=proba1[124]
+20=proba2[124*256+38]
+20=proba2[124*256+41]
+20=proba2[124*256+45]
+20=proba2[124*256+53]
+20=proba2[124*256+82]
+20=proba2[124*256+106]
+20=proba2[124*256+108]
+20=proba2[124*256+109]
+118=proba1[125]
+13=proba2[125*256+54]
+13=proba2[125*256+66]
+13=proba2[125*256+101]
+13=proba2[125*256+115]
+111=proba1[126]
+13=proba2[126*256+86]
+13=proba2[126*256+98]
+13=proba2[126*256+115]
+13=proba2[126*256+122]
diff -rupN john-1.7.8/src/AFS_fmt.c john-1.7.8-jumbo-2/src/AFS_fmt.c
--- john-1.7.8/src/AFS_fmt.c	2010-01-16 18:22:50.000000000 +0100
+++ john-1.7.8-jumbo-2/src/AFS_fmt.c	2011-05-23 20:50:57.000000000 +0200
@@ -90,14 +90,14 @@ static union {
 } AFS_long_KS;
 static DES_binary AFS_long_IV_binary;
 
-static void init(void)
+static void init(struct fmt_main *pFmt)
 {
 	ARCH_WORD_32 block[2];
 #if !ARCH_LITTLE_ENDIAN
 	ARCH_WORD_32 tmp;
 #endif
 
-	DES_std_init();
+	DES_std_init(pFmt);
 
 	AFS_salt_binary = DES_std_get_salt(AFS_SALT);
 
@@ -113,7 +113,7 @@ static void init(void)
 	memcpy(AFS_long_IV_binary, DES_IV, sizeof(DES_binary));
 }
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	char *pos;
 	int index, count;
@@ -445,6 +445,7 @@ struct fmt_main fmt_AFS = {
 		tests
 	}, {
 		init,
+		fmt_default_prepare,
 		valid,
 		fmt_default_split,
 		get_binary,
diff -rupN john-1.7.8/src/BFEgg_fmt_plug.c john-1.7.8-jumbo-2/src/BFEgg_fmt_plug.c
--- john-1.7.8/src/BFEgg_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/BFEgg_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,127 @@
+/*
+ * This file is part of Eggdrop blowfish patch for John The Ripper.
+ * Copyright (c) 2002 by Sun-Zero <sun-zero at freemail.hu>
+ * This is a free software distributable under terms of the GNU GPL.
+ */
+
+#include <string.h>
+
+#include "misc.h"
+#include "formats.h"
+#include "common.h"
+#include "blowfish.c"
+
+#define FORMAT_LABEL			"bfegg"
+#define FORMAT_NAME			"Eggdrop"
+#define ALG_NAME			"blowfish"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		31
+#define CIPHERTEXT_LENGTH		33
+
+#define BINARY_SIZE			13
+#define SALT_SIZE			0
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests tests[] = {
+    {"+9F93o1OxwgK1", "123456"},
+    {"+C/.8o.Wuph9.", "qwerty"},
+    {"+EEHgy/MBLDd0", "walkman"},
+    {"+vPBrs07OTXE/", "tesztuser"},
+    {"+zIvO/1nDsd9.", "654321"},
+    {NULL}
+};
+
+int zerolengthkey = 0;
+
+static char crypt_key[BINARY_SIZE + 1];
+static char saved_key[PLAINTEXT_LENGTH + 1];
+
+static int valid(char *ciphertext, struct fmt_main *pFmt) {
+    if (strncmp(ciphertext, "+", 1) != 0) return 0;
+    if (strlen(ciphertext) != 13) return 0;
+
+    return 1;
+}
+
+void init(struct fmt_main *pFmt) {
+    blowfish_first_init();
+}
+
+
+static void set_key(char *key, int index) {
+    strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+}
+
+static char *get_key(int index) {
+  return saved_key;
+}
+
+static int cmp_all(void *binary, int index) {
+  if (zerolengthkey) return 0;
+  return !memcmp(binary, crypt_key, BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int index) {
+  return 1;
+}
+
+static void crypt_all(int count) {
+    if (saved_key[0] == '\0') {
+	zerolengthkey = 1;
+    } else {
+	zerolengthkey = 0;
+        blowfish_encrypt_pass(saved_key, crypt_key);
+    }
+}
+
+struct fmt_main fmt_BFEgg = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALG_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_CASE | FMT_8_BIT,
+    tests
+  }, {
+    init,
+	fmt_default_prepare,
+    valid,
+    fmt_default_split,
+    fmt_default_binary,
+    fmt_default_salt,
+    {
+	fmt_default_binary_hash,
+	fmt_default_binary_hash,
+	fmt_default_binary_hash,
+	fmt_default_binary_hash,
+	fmt_default_binary_hash
+    },
+	fmt_default_salt_hash,
+	fmt_default_set_salt,
+	set_key,
+	get_key,
+	fmt_default_clear_keys,
+	crypt_all,
+	{
+	    fmt_default_get_hash,
+	    fmt_default_get_hash,
+	    fmt_default_get_hash,
+	    fmt_default_get_hash,
+	    fmt_default_get_hash
+	},
+	    cmp_all,
+	    cmp_all,
+	    cmp_exact
+  }
+};
diff -rupN john-1.7.8/src/BF_fmt.c john-1.7.8-jumbo-2/src/BF_fmt.c
--- john-1.7.8/src/BF_fmt.c	2011-06-22 01:13:14.000000000 +0200
+++ john-1.7.8-jumbo-2/src/BF_fmt.c	2011-07-02 20:46:13.000000000 +0200
@@ -86,7 +86,7 @@ static BF_salt saved_salt;
 struct fmt_main fmt_BF;
 #endif
 
-static void init(void)
+static void init(struct fmt_main *pFmt)
 {
 #ifdef _OPENMP
 	int n = BF_Nmin * omp_get_max_threads();
@@ -105,7 +105,7 @@ static void init(void)
 	sign_extension_bug = 0;
 }
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	int rounds;
 	char *pos;
@@ -263,6 +263,7 @@ struct fmt_main fmt_BF = {
 		tests
 	}, {
 		init,
+		fmt_default_prepare,
 		valid,
 		fmt_default_split,
 		BF_std_get_binary,
diff -rupN john-1.7.8/src/BSDI_fmt.c john-1.7.8-jumbo-2/src/BSDI_fmt.c
--- john-1.7.8/src/BSDI_fmt.c	2010-01-16 18:13:35.000000000 +0100
+++ john-1.7.8-jumbo-2/src/BSDI_fmt.c	2011-05-23 20:50:57.000000000 +0200
@@ -77,9 +77,9 @@ static struct {
 	char key[PLAINTEXT_LENGTH];
 } buffer[MAX_KEYS_PER_CRYPT];
 
-static void init(void)
+static void init(struct fmt_main *pFmt)
 {
-	DES_std_init();
+	DES_std_init(pFmt);
 
 #if DES_BS
 	DES_bs_init(0);
@@ -91,7 +91,7 @@ static void init(void)
 #endif
 }
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	char *pos;
 
@@ -402,6 +402,7 @@ struct fmt_main fmt_BSDI = {
 		tests
 	}, {
 		init,
+		fmt_default_prepare,
 		valid,
 		fmt_default_split,
 		(void *(*)(char *))
diff -rupN john-1.7.8/src/DES_fmt.c john-1.7.8-jumbo-2/src/DES_fmt.c
--- john-1.7.8/src/DES_fmt.c	2010-01-16 18:05:46.000000000 +0100
+++ john-1.7.8-jumbo-2/src/DES_fmt.c	2011-05-23 20:50:57.000000000 +0200
@@ -70,14 +70,14 @@ static struct {
 
 #if DES_BS
 
-static void init(void)
+static void init(struct fmt_main *pFmt)
 {
 	DES_bs_init(0);
 }
 
 #endif
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	char *pos;
 
@@ -356,6 +356,7 @@ struct fmt_main fmt_DES = {
 #else
 		DES_std_init,
 #endif
+		fmt_default_prepare,
 		valid,
 		split,
 		(void *(*)(char *))
diff -rupN john-1.7.8/src/DES_std.c john-1.7.8-jumbo-2/src/DES_std.c
--- john-1.7.8/src/DES_std.c	2006-05-08 08:31:50.000000000 +0200
+++ john-1.7.8-jumbo-2/src/DES_std.c	2011-05-17 18:13:01.000000000 +0200
@@ -460,7 +460,7 @@ static void init_KS(void)
 	memcpy(DES_KS_current, DES_KS_table, sizeof(DES_KS));
 }
 
-void DES_std_init(void)
+void DES_std_init(struct fmt_main *pFmt)
 {
 	init_SPE();
 	init_IP_E();
diff -rupN john-1.7.8/src/DES_std.h john-1.7.8-jumbo-2/src/DES_std.h
--- john-1.7.8/src/DES_std.h	2002-04-10 16:13:25.000000000 +0200
+++ john-1.7.8-jumbo-2/src/DES_std.h	2011-05-17 18:13:01.000000000 +0200
@@ -124,7 +124,8 @@ extern ARCH_WORD DES_count;
 /*
  * Initializes the internal structures.
  */
-extern void DES_std_init(void);
+struct fmt_main;
+extern void DES_std_init(struct fmt_main *pFmt);
 
 /*
  * Sets a salt for DES_std_crypt().
diff -rupN john-1.7.8/src/DMD5_fmt_plug.c john-1.7.8-jumbo-2/src/DMD5_fmt_plug.c
--- john-1.7.8/src/DMD5_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/DMD5_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,275 @@
+/*
+ * DMD5_fmt.c (version 1)
+ *
+ * DIGEST-MD5 authentication module for Solar Designer's John the Ripper
+ * Uses Solar Designer's MD5 implementation.
+ * regenrecht@o2.pl, Jan 2006
+ *
+ * You need to sniff authentication data sent by client (all important values
+ * are sent in ASCII text) and fill up coresponding hard coded values below.
+ * Then simply run john against password file which contains single line:
+ * "username:$DIGEST-MD5$" (without quotes...)
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "md5.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL		"dmd5"
+#define FORMAT_NAME		"DIGEST-MD5"
+#define ALGORITHM_NAME		"DIGEST-MD5 authentication"
+#define DMD5_TEST		0
+
+#define BENCHMARK_COMMENT	""
+#define BENCHMARK_LENGTH	-1
+
+#define A1_x_MAX_LEN		1024
+#define A2_MAX_LEN		1024
+#define KD_MAX_LEN		1024
+
+#define MD5_BIN_SIZE		16
+#define MD5_HEX_SIZE		32
+
+#define BINARY_SIZE		16
+#define SALT_SIZE		0
+
+#define PLAINTEXT_LENGTH	32
+
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+/* ------------- so what's yer poison? 'test' ------------ */
+static char *username	= "s3443";
+static char *realm	= "pjwstk";
+static char *nonce	= "00";
+static char *digest_uri	= "ldap/10.253.34.43";
+static char *cnonce	= "0734d94ad9abd5bd7fc5e7e77bcf49a8";
+static char *nc		= "00000001";
+static char *qop	= "auth-int";
+static char *response	= "dd98347e6da3efd6c4ff2263a729ef77";
+static char *authzid	= 0;
+/* ------------------------------------------------------- */
+
+static char itoa16_shr_04[] =
+	"0000000000000000"
+	"1111111111111111"
+	"2222222222222222"
+	"3333333333333333"
+	"4444444444444444"
+	"5555555555555555"
+	"6666666666666666"
+	"7777777777777777"
+	"8888888888888888"
+	"9999999999999999"
+	"aaaaaaaaaaaaaaaa"
+	"bbbbbbbbbbbbbbbb"
+	"cccccccccccccccc"
+	"dddddddddddddddd"
+	"eeeeeeeeeeeeeeee"
+	"ffffffffffffffff";
+
+static char itoa16_and_0f[] =
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef";
+
+static unsigned char prehash_A1_0[A1_x_MAX_LEN+1];
+static unsigned char *prehash_A1_0_key;
+static unsigned int  prehash_A1_0_len;
+static unsigned char A1_0[MD5_BIN_SIZE];
+static unsigned char A1_1[A1_x_MAX_LEN+1];
+static unsigned int  A1_1_len;
+static unsigned char h_A1[MD5_BIN_SIZE];
+
+static unsigned char A2[A2_MAX_LEN+1];
+static unsigned char h_A2[MD5_BIN_SIZE];
+static unsigned char hex_h_A2[MD5_HEX_SIZE+1];
+
+static unsigned char binary_response[MD5_BIN_SIZE];
+
+static unsigned char prehash_KD_1[KD_MAX_LEN+1];
+static unsigned char prehash_KD[KD_MAX_LEN+1];
+static unsigned int  prehash_KD_len;
+static unsigned char KD[MD5_BIN_SIZE];
+
+static MD5_CTX ctx;
+
+#ifdef _MSC_VER
+#define snprintf sprintf_s
+#endif
+
+static void dmd5_init(struct fmt_main *pFmt)
+{
+	unsigned char *ptr_src, *ptr_dst, v, i;
+
+	if (!strcmp(qop, "auth"))
+		snprintf((char *)A2, A2_MAX_LEN, "AUTHENTICATE:%s", digest_uri);
+	else if (!strcmp(qop, "auth-int") || !strcmp(qop, "auth-conf"))
+		snprintf((char *)A2, A2_MAX_LEN,
+			"AUTHENTICATE:%s:00000000000000000000000000000000",
+			digest_uri);
+	else {
+		fprintf(stderr, "unknown 'qop' value\n");
+		exit(-1);
+	}
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, A2, strlen((char *)A2));
+	MD5_Final(h_A2, &ctx);
+
+	ptr_src = h_A2;
+	ptr_dst = hex_h_A2;
+	for (i = 0; i < MD5_BIN_SIZE; ++i) {
+		v = *ptr_src++;
+		*ptr_dst++ = itoa16_shr_04[ARCH_INDEX(v)];
+		*ptr_dst++ = itoa16_and_0f[ARCH_INDEX(v)];
+	}
+
+	snprintf((char *)prehash_KD_1, KD_MAX_LEN, ":%s:%s:%s:%s:%s", nonce, nc,
+		cnonce, qop, hex_h_A2);
+	prehash_KD_len = strlen((char *)prehash_KD_1) + MD5_HEX_SIZE;
+
+	snprintf((char *)prehash_KD + MD5_HEX_SIZE, KD_MAX_LEN - MD5_HEX_SIZE,
+		"%s", prehash_KD_1);
+
+	if (authzid != 0 && strlen(authzid))
+		snprintf((char *)A1_1, A1_x_MAX_LEN, ":%s:%s:%s", nonce, cnonce,
+			authzid);
+	else
+		snprintf((char *)A1_1, A1_x_MAX_LEN, ":%s:%s", nonce, cnonce);
+
+	A1_1_len = strlen((char *)A1_1);
+
+	snprintf((char *)prehash_A1_0, A1_x_MAX_LEN, "%s:%s:", username, realm);
+	prehash_A1_0_len = strlen((char *)prehash_A1_0);
+	prehash_A1_0_key = prehash_A1_0 + prehash_A1_0_len;
+
+	for (i = 0; i < MD5_HEX_SIZE; ++i)
+		binary_response[i] =
+			(atoi16[ARCH_INDEX(response[i*2])] << 4)
+			+ atoi16[ARCH_INDEX(response[i*2+1])];
+}
+
+static int dmd5_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	if (strncmp(ciphertext, "$DIGEST-MD5$", 12) != 0)
+		return 0;
+
+	return 1;
+}
+
+static void *dmd5_binary(char *ciphertext)
+{
+	return (void *)binary_response;
+}
+
+static void dmd5_set_key(char *key, int index)
+{
+	unsigned char *ptr_src, *ptr_dst, v;
+	int i, key_len;
+
+	ptr_dst = prehash_A1_0_key;
+	while ((*ptr_dst++ = *key++));
+	key_len = ptr_dst - prehash_A1_0_key - 1;
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, prehash_A1_0, prehash_A1_0_len + key_len);
+	MD5_Final(A1_0, &ctx);
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, A1_0, MD5_BIN_SIZE);
+	MD5_Update(&ctx, A1_1, A1_1_len);
+	MD5_Final(h_A1, &ctx);
+
+	ptr_src = h_A1;
+	ptr_dst = prehash_KD;
+
+	for (i = 0; i < MD5_BIN_SIZE; ++i) {
+		v = *ptr_src++;
+		*ptr_dst++ = itoa16_shr_04[ARCH_INDEX(v)];
+		*ptr_dst++ = itoa16_and_0f[ARCH_INDEX(v)];
+	}
+}
+
+static char *dmd5_get_key(int index)
+{
+	return (char *)(prehash_A1_0 + prehash_A1_0_len);
+}
+
+static void dmd5_crypt_all(int count)
+{
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, prehash_KD, prehash_KD_len);
+	MD5_Final(KD, &ctx);
+}
+
+static int dmd5_cmp_all(void *binary, int index)
+{
+	return !memcmp(binary, KD, MD5_BIN_SIZE);
+}
+
+static int dmd5_cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_DMD5 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		DMD5_TEST
+	},
+	{
+		dmd5_init,
+		fmt_default_prepare,
+		dmd5_valid,
+		fmt_default_split,
+		dmd5_binary,
+		fmt_default_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		dmd5_set_key,
+		dmd5_get_key,
+		fmt_default_clear_keys,
+		dmd5_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		dmd5_cmp_all,
+		dmd5_cmp_all,
+		dmd5_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/DOMINOSEC_fmt_plug.c john-1.7.8-jumbo-2/src/DOMINOSEC_fmt_plug.c
--- john-1.7.8/src/DOMINOSEC_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/DOMINOSEC_fmt_plug.c	2011-07-02 22:46:01.000000000 +0200
@@ -0,0 +1,461 @@
+/*
+ * DOMINOSEC_fmt.c (version 3)
+ *
+ * Notes/Domino More Secure Internet Password module for Solar Designer's JtR
+ * by regenrecht at o2.pl, Dec 2005.
+ * Algorithm discovery by regenrecht at o2.pl, bartavelle at bandecon.com.
+ *
+ * Short description.
+ * 1. Make 128bit digest of key. (128/8=16 bytes)
+ * 2. Do bin2hex() of key digest and put braces around it. (16*2+2=34 bytes)
+ * 3. Concat output of previous step to 5 bytes of salt. (5+34=39 bytes)
+ * 4. Make 128bit digest of first 34 bytes (out of 39 bytes). (128/8=16 bytes)
+ * 5. Compare first 10 bytes (out of 16) to check if the key was correct.
+ *
+ * Password file should have form of:
+ * TomaszJegerman:(GKjXibCW2Ml6juyQHUoP)
+ * RubasznyJan:(GrixoFHOckC/2CnHrHtM)
+ */
+
+#include <ctype.h>
+#include <string.h>
+
+#include "misc.h"
+#include "formats.h"
+#include "common.h"
+
+#define FORMAT_LABEL		"dominosec"
+#define FORMAT_NAME		"More Secure Internet Password"
+#define ALGORITHM_NAME		"RSA MD defined by BSAFE 1.x - Lotus v6"
+
+#define BENCHMARK_COMMENT	""
+#define BENCHMARK_LENGTH	0
+
+#define PLAINTEXT_LENGTH	64
+#define CIPHERTEXT_LENGTH	22
+#define BINARY_SIZE		9 /* oh, well :P */
+#define SALT_SIZE		5
+
+#define DIGEST_SIZE		16
+#define BINARY_BUFFER_SIZE	(DIGEST_SIZE-SALT_SIZE)
+#define ASCII_DIGEST_LENGTH	(DIGEST_SIZE*2)
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+static unsigned char key_digest[DIGEST_SIZE];
+static char saved_key[PLAINTEXT_LENGTH+1];
+static unsigned char crypted_key[DIGEST_SIZE];
+static unsigned char salt_and_digest[SALT_SIZE+1+ASCII_DIGEST_LENGTH+1+1] =
+	"saalt(................................)";
+static unsigned int saved_key_len;
+
+static const char *hex_table[] = {
+	"00", "01", "02", "03", "04", "05", "06", "07",
+	"08", "09", "0A", "0B",	"0C", "0D", "0E", "0F",
+	"10", "11", "12", "13", "14", "15", "16", "17",
+	"18", "19", "1A", "1B", "1C", "1D", "1E", "1F",
+	"20", "21", "22", "23",	"24", "25", "26", "27",
+	"28", "29", "2A", "2B", "2C", "2D", "2E", "2F",
+	"30", "31", "32", "33", "34", "35", "36", "37",
+	"38", "39", "3A", "3B",	"3C", "3D", "3E", "3F",
+	"40", "41", "42", "43", "44", "45", "46", "47",
+	"48", "49", "4A", "4B", "4C", "4D", "4E", "4F",
+	"50", "51", "52", "53",	"54", "55", "56", "57",
+	"58", "59", "5A", "5B", "5C", "5D", "5E", "5F",
+	"60", "61", "62", "63", "64", "65", "66", "67",
+	"68", "69", "6A", "6B",	"6C", "6D", "6E", "6F",
+	"70", "71", "72", "73", "74", "75", "76", "77",
+	"78", "79", "7A", "7B", "7C", "7D", "7E", "7F",
+	"80", "81", "82", "83",	"84", "85", "86", "87",
+	"88", "89", "8A", "8B", "8C", "8D", "8E", "8F",
+	"90", "91", "92", "93", "94", "95", "96", "97",
+	"98", "99", "9A", "9B",	"9C", "9D", "9E", "9F",
+	"A0", "A1", "A2", "A3", "A4", "A5", "A6", "A7",
+	"A8", "A9", "AA", "AB", "AC", "AD", "AE", "AF",
+	"B0", "B1", "B2", "B3",	"B4", "B5", "B6", "B7",
+	"B8", "B9", "BA", "BB", "BC", "BD", "BE", "BF",
+	"C0", "C1", "C2", "C3", "C4", "C5", "C6", "C7",
+	"C8", "C9", "CA", "CB",	"CC", "CD", "CE", "CF",
+	"D0", "D1", "D2", "D3", "D4", "D5", "D6", "D7",
+	"D8", "D9", "DA", "DB", "DC", "DD", "DE", "DF",
+	"E0", "E1", "E2", "E3",	"E4", "E5", "E6", "E7",
+	"E8", "E9", "EA", "EB", "EC", "ED", "EE", "EF",
+	"F0", "F1", "F2", "F3", "F4", "F5", "F6", "F7",
+	"F8", "F9", "FA", "FB",	"FC", "FD", "FE", "FF"
+};
+
+static const unsigned char lotus_magic_table[] = {
+	0xbd, 0x56, 0xea, 0xf2, 0xa2, 0xf1, 0xac, 0x2a,
+	0xb0, 0x93, 0xd1, 0x9c, 0x1b, 0x33, 0xfd, 0xd0,
+	0x30, 0x04, 0xb6, 0xdc, 0x7d, 0xdf, 0x32, 0x4b,
+	0xf7, 0xcb, 0x45, 0x9b, 0x31, 0xbb, 0x21, 0x5a,
+	0x41, 0x9f, 0xe1, 0xd9, 0x4a, 0x4d, 0x9e, 0xda,
+	0xa0, 0x68, 0x2c, 0xc3, 0x27, 0x5f, 0x80, 0x36,
+	0x3e, 0xee, 0xfb, 0x95, 0x1a, 0xfe, 0xce, 0xa8,
+	0x34, 0xa9, 0x13, 0xf0, 0xa6, 0x3f, 0xd8, 0x0c,
+	0x78, 0x24, 0xaf, 0x23, 0x52, 0xc1, 0x67, 0x17,
+	0xf5, 0x66, 0x90, 0xe7, 0xe8, 0x07, 0xb8, 0x60,
+	0x48, 0xe6, 0x1e, 0x53, 0xf3, 0x92, 0xa4, 0x72,
+	0x8c, 0x08, 0x15, 0x6e, 0x86, 0x00, 0x84, 0xfa,
+	0xf4, 0x7f, 0x8a, 0x42, 0x19, 0xf6, 0xdb, 0xcd,
+	0x14, 0x8d, 0x50, 0x12, 0xba, 0x3c, 0x06, 0x4e,
+	0xec, 0xb3, 0x35, 0x11, 0xa1, 0x88, 0x8e, 0x2b,
+	0x94, 0x99, 0xb7, 0x71, 0x74, 0xd3, 0xe4, 0xbf,
+	0x3a, 0xde, 0x96, 0x0e, 0xbc, 0x0a, 0xed, 0x77,
+	0xfc, 0x37, 0x6b, 0x03, 0x79, 0x89, 0x62, 0xc6,
+	0xd7, 0xc0, 0xd2, 0x7c, 0x6a, 0x8b, 0x22, 0xa3,
+	0x5b, 0x05, 0x5d, 0x02, 0x75, 0xd5, 0x61, 0xe3,
+	0x18, 0x8f, 0x55, 0x51, 0xad, 0x1f, 0x0b, 0x5e,
+	0x85, 0xe5, 0xc2, 0x57, 0x63, 0xca, 0x3d, 0x6c,
+	0xb4, 0xc5, 0xcc, 0x70, 0xb2, 0x91, 0x59, 0x0d,
+	0x47, 0x20, 0xc8, 0x4f, 0x58, 0xe0, 0x01, 0xe2,
+	0x16, 0x38, 0xc4, 0x6f, 0x3b, 0x0f, 0x65, 0x46,
+	0xbe, 0x7e, 0x2d, 0x7b, 0x82, 0xf9, 0x40, 0xb5,
+	0x1d, 0x73, 0xf8, 0xeb, 0x26, 0xc7, 0x87, 0x97,
+	0x25, 0x54, 0xb1, 0x28, 0xaa, 0x98, 0x9d, 0xa5,
+	0x64, 0x6d, 0x7a, 0xd4, 0x10, 0x81, 0x44, 0xef,
+	0x49, 0xd6, 0xae, 0x2e, 0xdd, 0x76, 0x5c, 0x2f,
+	0xa7, 0x1c, 0xc9, 0x09, 0x69, 0x9a, 0x83, 0xcf,
+	0x29, 0x39, 0xb9, 0xe9, 0x4c, 0xff, 0x43, 0xab,
+	/* double power! */
+	0xbd, 0x56, 0xea, 0xf2, 0xa2, 0xf1, 0xac, 0x2a,
+	0xb0, 0x93, 0xd1, 0x9c, 0x1b, 0x33, 0xfd, 0xd0,
+	0x30, 0x04, 0xb6, 0xdc, 0x7d, 0xdf, 0x32, 0x4b,
+	0xf7, 0xcb, 0x45, 0x9b, 0x31, 0xbb, 0x21, 0x5a,
+	0x41, 0x9f, 0xe1, 0xd9, 0x4a, 0x4d, 0x9e, 0xda,
+	0xa0, 0x68, 0x2c, 0xc3, 0x27, 0x5f, 0x80, 0x36,
+	0x3e, 0xee, 0xfb, 0x95, 0x1a, 0xfe, 0xce, 0xa8,
+	0x34, 0xa9, 0x13, 0xf0, 0xa6, 0x3f, 0xd8, 0x0c,
+	0x78, 0x24, 0xaf, 0x23, 0x52, 0xc1, 0x67, 0x17,
+	0xf5, 0x66, 0x90, 0xe7, 0xe8, 0x07, 0xb8, 0x60,
+	0x48, 0xe6, 0x1e, 0x53, 0xf3, 0x92, 0xa4, 0x72,
+	0x8c, 0x08, 0x15, 0x6e, 0x86, 0x00, 0x84, 0xfa,
+	0xf4, 0x7f, 0x8a, 0x42, 0x19, 0xf6, 0xdb, 0xcd,
+	0x14, 0x8d, 0x50, 0x12, 0xba, 0x3c, 0x06, 0x4e,
+	0xec, 0xb3, 0x35, 0x11, 0xa1, 0x88, 0x8e, 0x2b,
+	0x94, 0x99, 0xb7, 0x71, 0x74, 0xd3, 0xe4, 0xbf,
+	0x3a, 0xde, 0x96, 0x0e, 0xbc, 0x0a, 0xed, 0x77,
+	0xfc, 0x37, 0x6b, 0x03, 0x79, 0x89, 0x62, 0xc6,
+	0xd7, 0xc0, 0xd2, 0x7c, 0x6a, 0x8b, 0x22, 0xa3,
+	0x5b, 0x05, 0x5d, 0x02, 0x75, 0xd5, 0x61, 0xe3,
+	0x18, 0x8f, 0x55, 0x51, 0xad, 0x1f, 0x0b, 0x5e,
+	0x85, 0xe5, 0xc2, 0x57, 0x63, 0xca, 0x3d, 0x6c,
+	0xb4, 0xc5, 0xcc, 0x70, 0xb2, 0x91, 0x59, 0x0d,
+	0x47, 0x20, 0xc8, 0x4f, 0x58, 0xe0, 0x01, 0xe2,
+	0x16, 0x38, 0xc4, 0x6f, 0x3b, 0x0f, 0x65, 0x46,
+	0xbe, 0x7e, 0x2d, 0x7b, 0x82, 0xf9, 0x40, 0xb5,
+	0x1d, 0x73, 0xf8, 0xeb, 0x26, 0xc7, 0x87, 0x97,
+	0x25, 0x54, 0xb1, 0x28, 0xaa, 0x98, 0x9d, 0xa5,
+	0x64, 0x6d, 0x7a, 0xd4, 0x10, 0x81, 0x44, 0xef,
+	0x49, 0xd6, 0xae, 0x2e, 0xdd, 0x76, 0x5c, 0x2f,
+	0xa7, 0x1c, 0xc9, 0x09, 0x69, 0x9a, 0x83, 0xcf,
+	0x29, 0x39, 0xb9, 0xe9, 0x4c, 0xff, 0x43, 0xab,
+};
+
+static struct fmt_tests dominosec_tests[] = {
+	{"(GVMroLzc50YK/Yd+L8KH)", ""},
+	{"(GqnUDNNGNUz5HRoelmLU)", "x"},
+	{"(GNBpcGJRYpBe9orUOpmZ)", "dupaaa123"},
+	{"(G0xjUQzdKxvHpUYqo5hU)", "koziolekmatolek"},
+	{"(G+dfECo845XxUw+nFVYD)", "szesnascieznakow"},
+	{"(GowT5I2hVHZpRWpvGmux)", "terazjakiesdwadziesciacos"},
+	{"(Gq2bAtpguiTSSycy6dhu)", "trzydziescidwamozesieudaojnieuda"},
+	{"(G82TtgNcqcHGkpEo7wQp)", "looongrandominputdataforfunbutnotonlyoi!"},
+	{NULL}
+};
+
+struct cipher_binary_struct {
+	unsigned char salt[SALT_SIZE];
+	unsigned char hash[BINARY_BUFFER_SIZE];
+} cipher_binary;
+
+static void mdtransform(unsigned char state[16], unsigned char checksum[16], unsigned char block[16])
+{
+	unsigned char x[48];
+	unsigned int t = 0;
+	unsigned int i,j;
+	unsigned char * pt;
+	unsigned char c;
+
+	memcpy(x, state, 16);
+	memcpy(x+16, block, 16);
+
+	for(i=0;i<16;i++)
+		x[i+32] = state[i] ^ block[i];
+
+	for (i = 0; i < 18; ++i)
+	{
+		pt = (unsigned char*)&x;
+		for (j = 48; j > 0; j--)
+		{
+			*pt ^= lotus_magic_table[j+t];
+			t = *pt;
+			pt++;
+		}
+	}
+
+	memcpy(state, x, 16);
+
+	t = checksum[15];
+	for (i = 0; i < 16; i++)
+	{
+		c = lotus_magic_table[block[i]^t];
+		checksum[i] ^= c;
+		t = checksum[i];
+	}
+}
+
+static void mdtransform_norecalc(unsigned char state[16], unsigned char block[16])
+{
+	unsigned char x[48], *pt;
+	unsigned int t = 0;
+	unsigned int i,j;
+
+	memcpy(x, state, 16);
+	memcpy(x+16, block, 16);
+
+	for(i=0;i<16;i++)
+		x[i+32] = state[i] ^ block[i];
+
+	for(i = 0; i < 18; ++i)
+	{
+		pt = (unsigned char*)&x;
+		for (j = 48; j > 0; j--)
+		{
+			*pt ^= lotus_magic_table[j+t];
+			t = *pt;
+			pt++;
+		}
+  	}
+
+	memcpy(state, x, 16);
+}
+
+static void domino_big_md(unsigned char * saved_key, int size, unsigned char * crypt_key)
+{
+	unsigned char state[16] = {0};
+	unsigned char checksum[16] = {0};
+	unsigned char block[16];
+	unsigned int x;
+	unsigned int curpos = 0;
+
+	while(curpos + 15 < size)
+	{
+		memcpy(block, saved_key + curpos, 16);
+		mdtransform(state, checksum, block);
+		curpos += 16;
+	}
+
+	if(curpos != size)
+	{
+		x = size - curpos;
+		memcpy(block, saved_key + curpos, x);
+		memset(block + x, 16 - x, 16 - x);
+		mdtransform(state, checksum, block);
+	}
+	else
+	{
+		memset(block, 16, 16);
+		mdtransform(state, checksum, block);
+	}
+
+	mdtransform_norecalc(state, checksum);
+
+	memcpy(crypt_key, state, 16);
+}
+
+static int dominosec_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	unsigned int i;
+	unsigned char ch;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+
+	if (ciphertext[0] != '(' ||
+		ciphertext[1] != 'G' ||
+		ciphertext[CIPHERTEXT_LENGTH-1] != ')')
+		return 0;
+
+	for (i = 1; i < CIPHERTEXT_LENGTH-1; ++i) {
+		ch = ciphertext[i];
+		if (!isalnum(ch) && ch != '+' && ch != '/')
+			return 0;
+	}
+
+	return 1;
+}
+
+/*
+static unsigned int dominosec_proper_mul(int delta_apsik)
+{
+	__asm__("movl $0xAAAAAAAB, %eax	\n"
+		"movl 0x8(%ebp), %edx	\n"
+		"mul %edx		\n"
+		"shr $0x2,%edx		\n"
+		"movl %edx, %eax	\n");
+}
+*/
+
+static void dominosec_decode(unsigned char *ascii_cipher, unsigned char *binary)
+{
+	unsigned int out = 0, apsik = 0, loop;
+	unsigned int i;
+	unsigned char ch;
+
+	ascii_cipher += 2;
+	i = 0;
+	do {
+		if (apsik < 8) {
+			/* should be using proper_mul, but what the heck...
+			it's nearly the same :] */
+			loop = 2; /* ~ loop = proper_mul(13 - apsik); */
+			apsik += loop*6;
+
+			do {
+				out <<= 6;
+				ch = *ascii_cipher;
+
+				if (ch < '0' || ch > '9')
+					if (ch < 'A' || ch > 'Z')
+						if (ch < 'a' || ch > 'z')
+							if (ch != '+')
+								if (ch == '/')
+									out += '?';
+								else
+									; /* shit happens */
+							else
+								out += '>';
+						else
+							out += ch-'=';
+					else
+						out += ch-'7';
+				else
+					out += ch-'0';
+				++ascii_cipher;
+			} while (--loop);
+		}
+
+		loop = apsik-8;
+		ch = out >> loop;
+		*(binary+i) = ch;
+		ch <<= loop;
+		apsik = loop;
+		out -= ch;
+	} while (++i < 15);
+
+	binary[3] += -4;
+}
+
+static void *dominosec_binary(char *ciphertext)
+{
+	dominosec_decode((unsigned char*)ciphertext, (unsigned char*)&cipher_binary);
+	return (void*)cipher_binary.hash;
+}
+
+static void *dominosec_salt(char *ciphertext)
+{
+	return cipher_binary.salt;
+}
+
+static void dominosec_set_salt(void *salt)
+{
+	memcpy(salt_and_digest, salt, SALT_SIZE);
+}
+
+static void dominosec_set_key(char *key, int index)
+{
+	unsigned char *offset = salt_and_digest+6;
+	unsigned int i;
+
+	saved_key_len = strlen(key);
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH);
+
+	domino_big_md((unsigned char*)key, saved_key_len, key_digest);
+
+	i = 0;
+	do {
+		memcpy(offset, *(hex_table+*(key_digest+i)), 2);
+		offset += 2;
+	} while (++i < 14);
+
+	/*
+	 * Not (++i < 16) !
+	 * Domino will do hash of first 34 bytes ignoring The Fact that now
+	 * there is a salt at a beginning of buffer. This means that last 5
+	 * bytes "EEFF)" of password digest are meaningless.
+	 */
+}
+
+static char *dominosec_get_key(int index)
+{
+	return saved_key;
+}
+
+static void dominosec_crypt_all(int count)
+{
+	domino_big_md(salt_and_digest, 34, crypted_key);
+}
+
+static int dominosec_cmp_all(void *binary, int count)
+{
+	/*
+	 * Only 10 bytes of digest are to be checked.
+	 * 48 bits are left alone.
+	 * Funny that.
+	 */
+	return !memcmp(crypted_key, binary, BINARY_SIZE);
+}
+
+static int dominosec_cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_DOMINOSEC = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		dominosec_tests
+	},
+	{
+		fmt_default_init,
+		fmt_default_prepare,
+		dominosec_valid,
+		fmt_default_split,
+		dominosec_binary,
+		dominosec_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		dominosec_set_salt,
+		dominosec_set_key,
+		dominosec_get_key,
+		fmt_default_clear_keys,
+		dominosec_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		dominosec_cmp_all,
+		dominosec_cmp_all,
+		dominosec_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/EPI_fmt_plug.c john-1.7.8-jumbo-2/src/EPI_fmt_plug.c
--- john-1.7.8/src/EPI_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/EPI_fmt_plug.c	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,203 @@
+/*
+ * EPiServer module for john 1.7.2 (and possibly later)
+ * Uses hashes/salts found in the tblSID of an EPiServer database installation
+ *
+ * Created by Johannes Gumbel (johannes [at] iforge.cc)
+ *
+ * If you have any questions as to how a function incorporates with john, please refer to formats.h of john
+ *
+ * version 0.1 released on 10 jan 2007
+ *
+ * See doc/EPi.patch.README or http://iforge.cc/files/EPi.patch.README
+ * for information on the input file format.
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+
+#include "sha.h"
+
+#define PLAINTEXT_LENGTH   0x80-4
+#define BINARY_LENGTH      20
+#define SALT_LENGTH        30
+
+static ARCH_WORD global_crypt[BINARY_LENGTH / ARCH_SIZE + 1];
+static char global_key[PLAINTEXT_LENGTH]; // set by set_key and used by get_get
+static char global_salt[SALT_LENGTH + PLAINTEXT_LENGTH]; // set by set_salt and used by crypt_all
+                                                         // the extra plaintext_length is needed because the
+                                                         // current key is copied there before hashing
+
+int valid(char *ciphertext, struct fmt_main *pFmt);
+void* binary(char *ciphertext);
+void* salt(char *ciphertext);
+void set_salt(void *salt);
+void set_key(char *key, int index);
+char* get_key(int index);
+void crypt_all(int count);
+int cmp_all(void *binary, int count);
+int cmp_one(void *binary, int index);
+int cmp_exact(char *source, int index);
+
+struct fmt_tests global_tests[] =
+{
+  {"0x5F1D84A6DE97E2BEFB637A3CB5318AFEF0750B856CF1836BD1D4470175BE 0x4D5EFDFA143EDF74193076F174AC47CEBF2F417F", "Abc.!23"},
+  {NULL}
+};
+
+// Define john integration
+struct fmt_main fmt_EPI =
+{
+  { // fmt_params
+    "epi",
+    "EPiServer SID Hashes",
+    "SHA-1",
+    "", // benchmark comment
+    0, // benchmark length
+    PLAINTEXT_LENGTH,
+    BINARY_LENGTH,
+    SALT_LENGTH,
+    1,
+    1,
+    FMT_CASE | FMT_8_BIT, // flags XXX, these are just guesses
+    global_tests
+  },
+  { // fmt_methods
+    fmt_default_init,
+	fmt_default_prepare,
+    valid,
+    fmt_default_split,
+    binary,
+    salt,
+    { // binary_hash[3]
+      fmt_default_binary_hash,
+      fmt_default_binary_hash,
+      fmt_default_binary_hash,
+      fmt_default_binary_hash,
+      fmt_default_binary_hash
+    },
+    fmt_default_salt_hash,
+    set_salt,
+    set_key,
+    get_key,
+    fmt_default_clear_keys,
+    crypt_all,
+    { // get_hash[3]
+      fmt_default_get_hash,
+      fmt_default_get_hash,
+      fmt_default_get_hash,
+      fmt_default_get_hash,
+      fmt_default_get_hash
+    },
+    cmp_all,
+    cmp_one,
+    cmp_exact
+  }
+};
+
+/*
+ * Expects ciphertext of format: 0xHEX*60 0xHEX*40
+ */
+int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+  unsigned int len, n;
+
+  if(!ciphertext) return 0;
+  len = strlen(ciphertext);
+
+  if(len != 105)
+    return 0;
+
+  // check fixed positions
+  if(ciphertext[0]  != '0' || ciphertext[1]  != 'x' ||
+     ciphertext[62] != ' ' ||
+     ciphertext[63] != '0' || ciphertext[64] != 'x')
+    return 0;
+
+  for(n = 2; n < 62 && atoi16[ARCH_INDEX(ciphertext[n])] != 0x7F; ++n);
+  for(n = 65; n < 105 && atoi16[ARCH_INDEX(ciphertext[n])] != 0x7F; ++n);
+
+  return n == len;
+}
+
+void _tobin(char* dst, char *src, unsigned int len)
+{
+  unsigned int n;
+
+  if(src[0] == '0' && src[1] == 'x')
+    src += sizeof(char)*2;
+
+  for(n = 0; n < len; ++n)
+    dst[n] = atoi16[ARCH_INDEX(src[n*2])]<<4 |
+             atoi16[ARCH_INDEX(src[n*2+1])];
+}
+
+void* binary(char *ciphertext)
+{
+  static char bin[BINARY_LENGTH];
+
+  _tobin(bin, (char*)(ciphertext+65), sizeof(bin));
+
+  return bin;
+}
+
+void* salt(char *ciphertext)
+{
+  static char salt[SALT_LENGTH];
+
+  _tobin(salt, (char*)(ciphertext+2), sizeof(salt));
+
+  return salt;
+}
+
+void set_salt(void *salt)
+{
+  memcpy(global_salt, salt, SALT_LENGTH);
+}
+
+void set_key(char *key, int index)
+{
+  if(!key) return;
+  strnzcpy(global_key, key, PLAINTEXT_LENGTH);
+}
+
+char* get_key(int index)
+{
+  return global_key;
+}
+
+void crypt_all(int count)
+{
+  static SHA_CTX ctx;
+
+  // Yes, I'm overwriting the last byte of the salt, perhaps the coder at ElektoPost whom wrote the EPiServer password checking function used to be a C coder (their code is written in .NET)
+  strnzcpy(global_salt+SALT_LENGTH-1, global_key, PLAINTEXT_LENGTH);
+
+  SHA1_Init(&ctx);
+  SHA1_Update(&ctx, (unsigned char*)global_salt, SALT_LENGTH+strlen(global_key));
+  SHA1_Final((unsigned char*)global_crypt, &ctx);
+}
+
+int cmp_all(void *binary, int count)
+{
+  if (((ARCH_WORD *)binary)[0] != global_crypt[0])
+    return 0;
+
+  return !memcmp(&((ARCH_WORD *)binary)[1], &global_crypt[1],
+    BINARY_LENGTH - ARCH_SIZE);
+}
+
+int cmp_one(void *binary, int index)
+{
+  return cmp_all(binary, 0);
+}
+
+// This functions job is done in cmp_all instead
+int cmp_exact(char *source, int index)
+{
+  return 1;
+}
+
diff -rupN john-1.7.8/src/HDAA_fmt_plug.c john-1.7.8-jumbo-2/src/HDAA_fmt_plug.c
--- john-1.7.8/src/HDAA_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/HDAA_fmt_plug.c	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,398 @@
+/*  HTTP Digest access authentication patch for john
+ *
+ * Written by Romain Raboin - romain.raboin at gmail.com
+ *
+ */
+
+#include <string.h>
+
+#include "stdint.h"
+
+#ifdef _MSC_VER
+#define snprintf _snprintf
+#endif
+
+#ifdef	__MMX__
+#include <mmintrin.h>
+#endif
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5.h"
+
+#define FORMAT_LABEL			"hdaa"
+#define FORMAT_NAME			"HTTP Digest access authentication"
+#define ALGORITHM_NAME			"HDAA-MD5"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		32
+
+#define BINARY_SIZE			16
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+#define	SEPARATOR			'$'
+
+#define MAGIC				"$response$"
+#define SIZE_TAB			12
+
+#define HTMP				512
+
+typedef struct
+{
+	char 	**request;
+	char	h3tmp[HTMP + 1];
+	char	h1tmp[HTMP + 1];
+	size_t	h3tmplen;
+	size_t	h1tmplen;
+}      		reqinfo_t;
+
+#define SALT_SIZE			sizeof(reqinfo_t)
+
+
+/*
+  digest authentication scheme :
+  h1 = md5(user:realm:password)
+  h2 = md5(method:digestURI)
+  response = h3 = md5(h1:nonce:nonceCount:ClientNonce:qop:h2)
+*/
+
+/* request information */
+enum e_req {
+	R_RESPONSE,
+	R_USER,
+	R_REALM,
+	R_METHOD,
+	R_URI,
+	R_NONCE,
+	R_NONCECOUNT,
+	R_CLIENTNONCE,
+	R_QOP
+};
+
+/* response:user:realm:method:uri:nonce:nonceCount:ClientNonce:qop */
+static struct fmt_tests hdaa_tests[] = {
+	{"$response$679066476e67b5c7c4e88f04be567f8b$user$myrealm$GET$/$8c12bd8f728afe56d45a0ce846b70e5a$00000001$4b61913cec32e2c9$auth", "nocode"},
+	{"$response$faa6cb7d676e5b7c17fcbf966436aa0c$moi$myrealm$GET$/$af32592775d27b1cd06356b3a0db9ddf$00000001$8e1d49754a25aea7$auth", "kikou"},
+	{NULL}
+};
+
+
+static MD5_CTX ctx;
+
+/* used by set_key */
+static char saved_key[PLAINTEXT_LENGTH + 1];
+
+/* store the ciphertext for value currently being tested */
+static unsigned char crypt_key[BINARY_SIZE + 1];
+
+/* Store information about the request ()*/
+static reqinfo_t *rinfo = NULL;
+
+/* Store the hash convertion (binary to ascii)*/
+#ifdef __MMX__
+static __m64 conv[4 + 1];
+#else
+static uint32_t conv[(CIPHERTEXT_LENGTH / 4) + 1];
+#endif
+
+static int 	hdaa_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int	nb = 0;
+	int	i;
+
+	if (strncmp(ciphertext, MAGIC, strlen(MAGIC)) != 0)
+		return 0;
+	for (i = 0; ciphertext[i] != 0; i++) {
+		if (ciphertext[i] == SEPARATOR) {
+			nb++;
+		}
+	}
+	if (nb == 10)
+		return 1;
+	return 0;
+}
+
+static void	hdaa_set_salt(void *salt)
+{
+	rinfo = salt;
+}
+
+static void	hdaa_set_key(char *key, int index)
+{
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH + 1);
+}
+
+static char	*hdaa_get_key(int index)
+{
+	return saved_key;
+}
+
+static int	hdaa_cmp_all(void *binary, int index)
+{
+	return !(memcmp((char *)binary, (char *)crypt_key, BINARY_SIZE));
+}
+
+static int	hdaa_cmp_exact(char *source, int count)
+{
+	return 1;
+}
+
+
+/* convert hash from binary to ascii */
+
+#ifdef __MMX__
+
+static void	bin2ascii(__m64 src[2])
+{
+	unsigned int	i = 0;
+
+	while (i != 4) {
+		__m64	l;
+		__m64	r;
+		__m64	t;
+		__m64	u;
+		__m64	v;
+
+		/* 32 bits to 64 bits */
+		t = _mm_set1_pi32(0x0f0f0f0f);
+
+		/* Bit-wise AND the 64-bit values in M1 and M2.  */
+		u = _mm_and_si64(_mm_srli_si64(src[(i / 2)], 4), t);
+		v = _mm_and_si64(src[(i / 2)], t);
+
+		/* interleaving */
+		l = _mm_unpacklo_pi8(u, v);
+		r = _mm_unpackhi_pi8(u, v);
+
+		t = _mm_set1_pi32(0x06060606);
+		l = _mm_add_pi32(l, t);
+		r = _mm_add_pi32(r, t);
+
+		t = _mm_set1_pi32(0x01010101);
+		/* u = (l << 4) & t */
+		u = _mm_and_si64(_mm_srli_si64(l, 4), t);
+		/* v = (r << 4) & t */
+		v = _mm_and_si64(_mm_srli_si64(r, 4), t);
+
+		t = _mm_set1_pi32(0x00270027);
+		/* Multiply four 16-bit values in M1 by four 16-bit values in M2 and produce
+		   the low 16 bits of the results.  */
+		u = _mm_mullo_pi16(u, t);
+		v = _mm_mullo_pi16(v, t);
+
+		t = _mm_set1_pi32(0x2a2a2a2a);
+		u = _mm_add_pi32(u, t);
+		v = _mm_add_pi32(v, t);
+
+		conv[(i++)] = _mm_add_pi32(l, u);
+		conv[(i++)] = _mm_add_pi32(r, v);
+	}
+}
+
+#else
+
+static void		bin2ascii(unsigned char *src)
+{
+	unsigned int	i;
+	unsigned int	j = 0;
+	uint32_t	t = 0;
+
+	for (i = 0; i < BINARY_SIZE; i += 2) {
+#if (ARCH_LITTLE_ENDIAN == 0)
+		t = (src[i] & 0xf0);
+		t *= 0x10;
+		t += (src[i] & 0x0f);
+		t *= 0x1000;
+		t += (src[(i + 1)] & 0xf0);
+		t *= 0x10;
+		t += (src[(i + 1)] & 0x0f);
+#else
+		t = (src[(i + 1)] & 0x0f);
+		t *= 0x1000;
+		t += (src[(i + 1)] & 0xf0);
+		t *= 0x10;
+		t += (src[i] & 0x0f);
+		t *= 0x100;
+		t += ((src[i] & 0xf0) >> 4);
+#endif
+		t += 0x06060606;
+		t += ((((t >> 4) & 0x01010101) * 0x27) + 0x2a2a2a2a);
+		conv[(j++)] = t;
+	}
+}
+
+#endif /* MMX */
+
+static void		hdaa_crypt_all(int count)
+{
+	int		len;
+	char	*h1tmp, *h3tmp;
+	size_t	tmp;
+#ifdef __MMX__
+	__m64		h1[2];
+#else
+	static unsigned char *h1;
+	if (!h1) h1 = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+#endif
+
+	h3tmp = rinfo->h3tmp;
+	h1tmp = rinfo->h1tmp;
+	tmp = rinfo->h1tmplen;
+	len = strlen(saved_key);
+	memcpy(&h1tmp[tmp], saved_key, len + 1);
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, h1tmp, len + tmp);
+	MD5_Final((unsigned char*)h1, &ctx);
+	bin2ascii(h1);
+
+	memcpy(h3tmp, conv, CIPHERTEXT_LENGTH);
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, h3tmp, rinfo->h3tmplen);
+	MD5_Final(crypt_key, &ctx);
+}
+
+static char		*mystrndup(const char *s, size_t n)
+{
+	size_t	tmp;
+	size_t	size;
+	char	*ret;
+
+	for (tmp = 0; s[tmp] != 0 && tmp <= n; tmp++);
+	size = n;
+	if (tmp < size)
+		size = tmp;
+	if ((ret = mem_alloc_tiny(sizeof(char) * size + 1, MEM_ALIGN_WORD)) == NULL)
+		return NULL;
+	memmove(ret, s, size);
+	ret[size] = 0;
+	return ret;
+}
+
+static size_t		reqlen(char *str)
+{
+	size_t	len;
+
+	for (len = 0; str[len] != 0 && str[len] != SEPARATOR; len++);
+	return len;
+}
+
+static void			*hdaa_salt(char *ciphertext)
+{
+
+	int		nb;
+	int		i;
+	char		**request;
+	char		*str;
+	reqinfo_t	*r;
+#ifdef __MMX__
+	__m64		h2[2];
+#else
+	static unsigned char	*h2;
+	if (!h2) h2 = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+#endif
+	/* parse the password string */
+	request = mem_alloc_tiny(sizeof(char *) * SIZE_TAB,MEM_ALIGN_WORD);
+	r = mem_alloc_tiny(sizeof(*r),MEM_ALIGN_WORD);
+	memset(r, 0, sizeof(*r));
+	for (nb = 0, i = 1; ciphertext[i] != 0; i++) {
+		if (ciphertext[i] == SEPARATOR) {
+			i++;
+			request[nb] = mystrndup(&ciphertext[i], reqlen(&ciphertext[i]));
+			nb++;
+		}
+	}
+
+	/* calculate h2 (h2 = md5(method:digestURI))*/
+	str = mem_alloc(strlen(request[R_METHOD]) + strlen(request[R_URI]) + 2);
+	sprintf(str, "%s:%s", request[R_METHOD], request[R_URI]);
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, str, strlen(str));
+	MD5_Final((unsigned char *)h2, &ctx);
+
+	memset(conv, 0, sizeof(conv));
+	bin2ascii(h2);
+	MEM_FREE(str);
+
+	/* create a part of h1 (h1tmp = request:realm:)*/
+	snprintf(r->h1tmp, HTMP - PLAINTEXT_LENGTH, "%s:%s:", request[R_USER], request[R_REALM]);
+
+	/* create a part of h3 (h3tmp = nonce:noncecount:clientnonce:qop:h2)*/
+	snprintf(&r->h3tmp[CIPHERTEXT_LENGTH], HTMP - CIPHERTEXT_LENGTH, ":%s:%s:%s:%s:%s",
+		request[R_NONCE], request[R_NONCECOUNT], request[R_CLIENTNONCE],
+		request[R_QOP], (char*)conv);
+	r->request = request;
+	r->h1tmplen = strlen(r->h1tmp);
+	r->h3tmplen = strlen(&r->h3tmp[CIPHERTEXT_LENGTH]) + CIPHERTEXT_LENGTH;
+	return r;
+}
+
+/* convert response in binary form */
+static void		*hdaa_binary(char *ciphertext)
+{
+	static char	*realcipher;
+	int		i;
+
+	if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	ciphertext += 10;
+	for (i = 0; i < BINARY_SIZE; i++) {
+		realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16 +
+			atoi16[ARCH_INDEX(ciphertext[i * 2 + 1])];
+	}
+	return (void *) realcipher;
+}
+
+struct fmt_main fmt_HDAA = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		hdaa_tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		hdaa_valid,
+		fmt_default_split,
+		hdaa_binary,
+		hdaa_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		hdaa_set_salt,
+		hdaa_set_key,
+		hdaa_get_key,
+		fmt_default_clear_keys,
+		hdaa_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		hdaa_cmp_all,
+		hdaa_cmp_all,
+		hdaa_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/IPB2_fmt_plug.c john-1.7.8-jumbo-2/src/IPB2_fmt_plug.c
--- john-1.7.8/src/IPB2_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/IPB2_fmt_plug.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,257 @@
+/*
+ * IPB2_fmt.c (version 4)
+ *
+ * Invision Power Board 2.x salted MD5 module for Solar Designer's JtR
+ * Uses Solar Designer's MD5 implementation.
+ * regenrecht at o2.pl, Jan 2006
+ *
+ * Hashes list should have form of username:$IPB2$salt$hash
+ * Values to be taken from IPB database, where:
+ * salt = bin2hex(ibf_members_converge.converge_pass_salt)
+ * hash = ibf_members_converge.converge_pass_hash
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "md5.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL		"ipb2"
+#define FORMAT_NAME		"IPB2 MD5"
+#define ALGORITHM_NAME		"Invision Power Board 2.x salted MD5"
+
+#define BENCHMARK_COMMENT	""
+#define BENCHMARK_LENGTH	0
+
+#define MD5_BINARY_SIZE		16
+#define MD5_HEX_SIZE		(MD5_BINARY_SIZE * 2)
+
+#define BINARY_SIZE		MD5_BINARY_SIZE
+
+#define SALT_SIZE		5
+#define PROCESSED_SALT_SIZE	MD5_HEX_SIZE
+
+#define PLAINTEXT_LENGTH	32
+#define CIPHERTEXT_LENGTH	(1 + 4 + 1 + SALT_SIZE * 2 + 1 + MD5_HEX_SIZE)
+
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+static struct fmt_tests ipb2_tests[] = {
+	{"$IPB2$2e75504633$d891f03a7327639bc632d62a7f302604", "welcome"},
+	{"$IPB2$735a213a4e$4f23de7bb115139660db5e953153f28a", "enter"},
+	{"$IPB2$5d75343455$de98ba8ca7bb16f43af05e9e4fb8afee", "matrix"},
+	{"$IPB2$556c576c39$16d4f29c71b05bd75e61d0254800bfa3", "123456"},
+	{NULL}
+};
+
+static char itoa16_shr_04[] =
+	"0000000000000000"
+	"1111111111111111"
+	"2222222222222222"
+	"3333333333333333"
+	"4444444444444444"
+	"5555555555555555"
+	"6666666666666666"
+	"7777777777777777"
+	"8888888888888888"
+	"9999999999999999"
+	"aaaaaaaaaaaaaaaa"
+	"bbbbbbbbbbbbbbbb"
+	"cccccccccccccccc"
+	"dddddddddddddddd"
+	"eeeeeeeeeeeeeeee"
+	"ffffffffffffffff";
+
+static char itoa16_and_0f[] =
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef";
+
+static MD5_CTX ctx;
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static int saved_key_len;
+static char workspace[MD5_HEX_SIZE * 2];
+static char output[MD5_BINARY_SIZE];
+
+static int ipb2_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+
+	if (strncmp(ciphertext, "$IPB2$", 6) != 0)
+		return 0;
+
+	if (ciphertext[16] != '$')
+		return 0;
+
+	if (strspn(ciphertext+6, itoa16) != SALT_SIZE*2)
+		return 0;
+
+	if (strspn(ciphertext+17, itoa16) != MD5_HEX_SIZE)
+		return 0;
+
+	return 1;
+}
+
+static void *ipb2_binary(char *ciphertext)
+{
+	static unsigned char binary_cipher[BINARY_SIZE];
+	int i;
+
+	ciphertext += 17;
+	for (i = 0; i < MD5_HEX_SIZE; ++i)
+		binary_cipher[i] =
+			(atoi16[ARCH_INDEX(ciphertext[i*2])] << 4)
+			+ atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+	return (void *)binary_cipher;
+}
+
+static void *ipb2_salt(char *ciphertext)
+{
+	static unsigned char binary_salt[SALT_SIZE];
+	static unsigned char salt_hash[MD5_BINARY_SIZE];
+	static unsigned char hex_salt[MD5_HEX_SIZE];
+	int i;
+
+	ciphertext += 6;
+	for (i = 0; i < SALT_SIZE; ++i)
+		binary_salt[i] =
+			(atoi16[ARCH_INDEX(ciphertext[i*2])] << 4)
+			+ atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, binary_salt, SALT_SIZE);
+	MD5_Final(salt_hash, &ctx);
+
+	for (i = 0; i < MD5_BINARY_SIZE; ++i) {
+		hex_salt[i*2] = itoa16[ARCH_INDEX(salt_hash[i] >> 4)];
+		hex_salt[i*2+1] = itoa16[ARCH_INDEX(salt_hash[i] & 0x0f)];
+	}
+
+	return (void*)hex_salt;
+}
+
+static void ipb2_set_salt(void *salt)
+{
+	memcpy((char*)workspace, (char*)salt, PROCESSED_SALT_SIZE);
+}
+
+static int strnfcpy_count(char *dst, char *src, int size)
+{
+	char *dptr = dst, *sptr = src;
+	int count = size;
+
+	while (count--)
+		if (!(*dptr++ = *sptr++)) break;
+
+	return size-count-1;
+}
+
+static void ipb2_set_key(char *key, int index)
+{
+	static unsigned char key_hash[MD5_BINARY_SIZE];
+	unsigned char *kh = key_hash;
+	unsigned char *workspace_ptr = (unsigned char *) (workspace + PROCESSED_SALT_SIZE);
+	unsigned char v;
+	int i;
+
+	saved_key_len = strnfcpy_count(saved_key, key, PLAINTEXT_LENGTH);
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, saved_key, saved_key_len);
+	MD5_Final(key_hash, &ctx);
+
+	for (i = 0; i < MD5_BINARY_SIZE; ++i) {
+		v = *kh++;
+		*workspace_ptr++ = itoa16_shr_04[ARCH_INDEX(v)];
+		*workspace_ptr++ = itoa16_and_0f[ARCH_INDEX(v)];
+	}
+}
+
+static char *ipb2_get_key(int index)
+{
+	return saved_key;
+}
+
+static void ipb2_crypt_all(int count)
+{
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, workspace, MD5_HEX_SIZE * 2);
+	MD5_Final((unsigned char *) output, &ctx);
+}
+
+static int ipb2_cmp_all(void *binary, int index)
+{
+	return !memcmp(binary, output, MD5_BINARY_SIZE);
+}
+
+static int ipb2_cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_IPB2 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		PROCESSED_SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		ipb2_tests
+	},
+	{
+		fmt_default_init,
+		fmt_default_prepare,
+		ipb2_valid,
+		fmt_default_split,
+		ipb2_binary,
+		ipb2_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		ipb2_set_salt,
+		ipb2_set_key,
+		ipb2_get_key,
+		fmt_default_clear_keys,
+		ipb2_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		ipb2_cmp_all,
+		ipb2_cmp_all,
+		ipb2_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/KRB4_fmt_plug.c john-1.7.8-jumbo-2/src/KRB4_fmt_plug.c
--- john-1.7.8/src/KRB4_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/KRB4_fmt_plug.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,291 @@
+/*
+  KRB4_fmt.c
+
+  AFS/krb4 TGT dictionary attack module for Solar Designer's John the Ripper.
+
+  tgtsnarf files should only contain entries for one cell/realm.
+
+  Copyright (c) 1999 Dug Song <dugsong@monkey.org>
+  All rights reserved, all wrongs reversed.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+  3. The name of author may not be used to endorse or promote products
+     derived from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <string.h>
+#include <ctype.h>
+#include <openssl/des.h>
+
+#include "arch.h"
+#include "DES_std.h"
+#include "KRB4_std.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+
+#define TGT_LENGTH		16	/* 2 des_cblock's */
+
+#define FORMAT_LABEL		"krb4"
+#define FORMAT_NAME		"Kerberos v4 TGT"
+#define ALGORITHM_NAME		"krb4 DES"
+#define BENCHMARK_COMMENT	""
+#define BENCHMARK_LENGTH	-1
+#define PLAINTEXT_LENGTH	32
+#define BINARY_SIZE		0
+#define SALT_SIZE		TGT_LENGTH + REALM_SZ
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+static struct fmt_tests krb4_tests[] = {
+	{"$af$UMICH.EDU$bb46613c503ad92e649d99d038efddb2", "w00w00"},
+	{"$af$UMICH.EDU$95cd4367d4828d117b745ed63b9229be", "asdfjkl;"},
+	{"$af$UMICH.EDU$000084efbde96969fd54d1a2ec8c287d", "hello!"},
+	{"$af$UMICH.EDU$e9660a21b280875a7ecfc68aa771e34a", "a12345"},
+	{"$af$UMICH.EDU$566f2b8629b9be36680866b0e613f239", "a1b2c3"},
+	{"$af$UMICH.EDU$bebcedf43f7f2aa78cf9c0639e494c92", "abcdefg12345678"},
+	{"$af$ENGIN.UMICH.EDU$9ef1034301e1f1fcf1516cb65aa1cc79", "asdfjkl;"},
+	{"$af$ENGIN.UMICH.EDU$02ad23a6364df67a4db473de053cacbb", "a1b2c3"},
+	{"$af$ENGIN.UMICH.EDU$14d0a59a2f9e746f1a3bf02ec4fb447e", "abc123!"},
+	{"$af$ENGIN.UMICH.EDU$44feffd06e68e30bc8890e253760858d", "12345"},
+	{NULL}
+};
+
+static const unsigned char odd_parity[256]={
+	1,  1,  2,  2,  4,  4,  7,  7,  8,  8, 11, 11, 13, 13, 14, 14,
+       16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
+       32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
+       49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
+       64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
+       81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
+       97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
+      112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
+      128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
+      145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
+      161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
+      176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
+      193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
+      208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
+      224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
+      241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254
+};
+
+static struct salt_st {
+	unsigned char		tgt[TGT_LENGTH];
+	char			realm[REALM_SZ];
+} *saved_salt;
+
+static struct key_st {
+	DES_cblock		key;
+	DES_key_schedule	sched;
+	char			string[PLAINTEXT_LENGTH];
+} saved_key;
+
+
+static int
+krb4_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *p, *tgt;
+
+	if (strncmp(ciphertext, "$k4$", 4) != 0 &&
+	    strncmp(ciphertext, "$af$", 4) != 0)
+		return 0;
+
+	tgt = strchr(ciphertext + 4, '$') + 1;
+
+	for (p = tgt; p && *p != '\0'; p++)
+		if (!isxdigit((int)*p)) return 0;
+
+	if (p - tgt != TGT_LENGTH * 2)
+		return 0;
+
+	return 1;
+}
+
+static int
+hex_decode(char *src, unsigned char *dst, int outsize)
+{
+	char *p, *pe;
+	unsigned char *q, *qe, ch, cl;
+
+	pe = src + strlen(src);
+	qe = dst + outsize;
+
+	for (p = src, q = dst; p < pe && q < qe && isxdigit((int)*p); p += 2) {
+		ch = tolower(p[0]);
+		cl = tolower(p[1]);
+
+		if ((ch >= '0') && (ch <= '9')) ch -= '0';
+		else if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;
+		else return (-1);
+
+		if ((cl >= '0') && (cl <= '9')) cl -= '0';
+		else if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;
+		else return (-1);
+
+		*q++ = (ch << 4) | cl;
+	}
+	return (q - dst);
+}
+
+static void *
+krb4_salt(char *ciphertext)
+{
+	static struct salt_st salt;
+	char *p;
+
+	if (strncmp(ciphertext, "$af$", 4) == 0) {
+		ciphertext += 4;
+		p = strchr(ciphertext, '$');
+		strnzcpy(salt.realm, ciphertext, (p - ciphertext) + 1);
+		ciphertext = p + 1;
+	}
+	else {
+		salt.realm[0] = '\0';
+		ciphertext += 4;
+	}
+	if (hex_decode(ciphertext, salt.tgt, sizeof(salt.tgt)) !=
+	    sizeof(salt.tgt))
+		return (NULL);
+
+	return (&salt);
+}
+
+static void
+krb4_set_salt(void *salt)
+{
+	saved_salt = (struct salt_st *)salt;
+}
+
+static void
+krb4_set_key(char *key, int index)
+{
+	if (saved_salt->realm[0] != '\0')
+		afs_string_to_key(key, saved_salt->realm, &saved_key.key);
+	else
+		des_string_to_key(key, &saved_key.key);
+
+	strnzcpy(saved_key.string, key, sizeof(saved_key.string));
+}
+
+static char *
+krb4_get_key(int index)
+{
+	return (saved_key.string);
+}
+
+static void
+krb4_crypt_all(int count)
+{
+	/* XXX - NOOP */
+}
+
+static int
+krb4_check_parity(DES_cblock *key)
+{
+	int i;
+
+	for (i = 0; i < DES_KEY_SZ; i++) {
+		if ((*key)[i] != odd_parity[(*key)[i]])
+			return (0);
+	}
+	return (1);
+}
+
+static int
+krb4_cmp_all(void *binary, int count)
+{
+	DES_cblock tmp;
+
+	DES_set_key(&saved_key.key, &saved_key.sched);
+
+	DES_pcbc_encrypt(saved_salt->tgt, (unsigned char *)&tmp,
+	                 sizeof(tmp), &saved_key.sched,
+	                 &saved_key.key, DES_DECRYPT);
+
+	return (krb4_check_parity(&tmp));
+}
+
+static int
+krb4_cmp_one(void *binary, int count)
+{
+	unsigned char text[TGT_LENGTH];
+
+	DES_pcbc_encrypt(saved_salt->tgt, text,
+	                 sizeof(text), &saved_key.sched, &saved_key.key,
+	                 DES_DECRYPT);
+
+	return (memcmp(text + 8, "krbtgt", 6) == 0);
+}
+
+static int
+krb4_cmp_exact(char *source, int index)
+{
+	return (1);	/* XXX - fallthrough from krb4_cmp_one() */
+}
+
+struct fmt_main fmt_KRB4 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		krb4_tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		krb4_valid,
+		fmt_default_split,
+		fmt_default_binary,
+		krb4_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		krb4_set_salt,
+		krb4_set_key,
+		krb4_get_key,
+		fmt_default_clear_keys,
+		krb4_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		krb4_cmp_all,
+		krb4_cmp_one,
+		krb4_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/KRB4_std.h john-1.7.8-jumbo-2/src/KRB4_std.h
--- john-1.7.8/src/KRB4_std.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/KRB4_std.h	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,16 @@
+/*
+ * KRB4_std.h
+ *
+ * Kerberos v4 jonks, from KTH krb4.
+ *
+ * Dug Song <dugsong@monkey.org>
+ */
+
+#ifndef KRB4_STD_H
+#define KRB4_STD_H
+
+#define REALM_SZ	40
+
+void afs_string_to_key(char *str, char *cell, DES_cblock *key);
+
+#endif /* KRB4_STD_H */
diff -rupN john-1.7.8/src/KRB4_std_plug.c john-1.7.8-jumbo-2/src/KRB4_std_plug.c
--- john-1.7.8/src/KRB4_std_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/KRB4_std_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,134 @@
+/*
+  KRB4_std.c
+
+  Kerberos v4 jonks, from KTH krb4.
+
+  $OpenBSD: str2key.c,v 1.6 1998/06/22 15:22:27 beck Exp $
+  $KTH: str2key.c,v 1.10 1997/03/23 03:53:19 joda Exp $
+*/
+
+/* This defines the Andrew string_to_key function.  It accepts a password
+ * string as input and converts its via a one-way encryption algorithm to a DES
+ * encryption key.  It is compatible with the original Andrew authentication
+ * service password database.
+ */
+
+#ifdef KRB4_USE_SYSTEM_CRYPT
+#define _XOPEN_SOURCE 4 /* for crypt(3) */
+#define _XOPEN_SOURCE_EXTENDED
+#define _XOPEN_VERSION 4
+#define _XPG4_2
+#include <unistd.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <openssl/des.h>
+
+#include "KRB4_std.h"
+
+#ifndef des_fixup_key_parity
+#define des_fixup_key_parity	des_set_odd_parity
+#endif
+
+static void
+mklower(char *s)
+{
+    for (; s[0] != '\0'; s++)
+        if ('A' <= *s && *s <= 'Z')
+            *s = *s - 'A' + 'a';
+}
+
+/*
+ * Short passwords, i.e 8 characters or less.
+ */
+static void
+afs_cmu_StringToKey (char *str, char *cell, DES_cblock *key)
+{
+    char  password[8+1];	/* crypt is limited to 8 chars anyway */
+    int   i;
+    int   passlen;
+
+    memset(key, 0, sizeof(key));
+    memset(password, 0, sizeof(password));
+
+    strncpy (password, cell, 8);
+    password[8] = '\0';
+    passlen = strlen (str);
+    if (passlen > 8) passlen = 8;
+
+    for (i=0; i<passlen; i++)
+        password[i] = str[i] ^ cell[i];	/* make sure cell is zero padded */
+
+    for (i=0; i<8; i++)
+        if (password[i] == '\0') password[i] = 'X';
+
+    /* crypt only considers the first 8 characters of password but for some
+       reason returns eleven characters of result (plus the two salt chars). */
+#ifdef KRB4_USE_SYSTEM_CRYPT
+    strncpy((char *)key, crypt(password, "p1") + 2, sizeof(DES_cblock));
+#else
+/* Use OpenSSL's DES_crypt() */
+    strncpy((char *)key, DES_crypt(password, "p1") + 2, sizeof(DES_cblock));
+#endif
+
+    /* parity is inserted into the LSB so leftshift each byte up one bit.  This
+       allows ascii characters with a zero MSB to retain as much significance
+       as possible. */
+    {   char *keybytes = (char *)key;
+        unsigned int temp;
+
+        for (i = 0; i < 8; i++) {
+            temp = (unsigned int) keybytes[i];
+            keybytes[i] = (unsigned char) (temp << 1);
+        }
+    }
+    des_fixup_key_parity (key);
+}
+
+/*
+ * Long passwords, i.e 9 characters or more.
+ */
+static void
+afs_transarc_StringToKey (char *str, char *cell, DES_cblock *key)
+{
+    DES_key_schedule schedule;
+    DES_cblock temp_key;
+    DES_cblock ivec;
+    char password[512];
+    int  passlen;
+
+    strncpy (password, str, sizeof(password));
+    password[sizeof(password)-1] = '\0';
+    if ((passlen = strlen (password)) < sizeof(password)-1)
+        strncat (password, cell, sizeof(password)-passlen);
+    if ((passlen = strlen(password)) > sizeof(password)) passlen = sizeof(password);
+
+    memcpy(&ivec, "kerberos", 8);
+    memcpy(&temp_key, "kerberos", 8);
+    des_fixup_key_parity (&temp_key);
+    DES_key_sched (&temp_key, &schedule);
+    DES_cbc_cksum ((unsigned char *)password, &ivec, passlen, &schedule, &ivec);
+
+    memcpy(&temp_key, &ivec, 8);
+    des_fixup_key_parity (&temp_key);
+    DES_key_sched (&temp_key, &schedule);
+    DES_cbc_cksum ((unsigned char *)password, key, passlen, &schedule, &ivec);
+
+    des_fixup_key_parity (key);
+}
+
+void
+afs_string_to_key(char *str, char *cell, DES_cblock *key)
+{
+    char realm[REALM_SZ+1];
+    strncpy(realm, cell, REALM_SZ);
+    realm[REALM_SZ] = 0;
+    mklower(realm);
+
+    if (strlen(str) > 8)
+        afs_transarc_StringToKey (str, realm, key);
+    else
+        afs_cmu_StringToKey (str, realm, key);
+}
diff -rupN john-1.7.8/src/KRB5_fmt_plug.c john-1.7.8-jumbo-2/src/KRB5_fmt_plug.c
--- john-1.7.8/src/KRB5_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/KRB5_fmt_plug.c	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,361 @@
+/*
+ * KRB5_fmt.c
+ *
+ *  Kerberos 5 module for John the Ripper, based on the
+ *  KRB4 module by Dug Song.
+ *
+ * Author: Nasko Oskov <nasko at netsekure.org>
+ *
+ * Licensing:
+ *
+ *  The module contains code derived or copied from the Heimdal project.
+ *
+ *  Copyright (c) 1997-2000 Kungliga Tekniska Hgskolan
+ *  (Royal Institute of Technology, Stockholm, Sweden).
+ *  All rights reserved.
+ *
+ *  Which is distribution of Kerberos based on M.I.T. implementation.
+ *
+ *  Copyright (C) 1990 by the Massachusetts Institute of Technology
+ *
+ */
+
+#include <stdlib.h>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+
+#include <string.h>
+#include <openssl/des.h>
+
+#include <ctype.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "formats.h"    // needed for format structs
+#include "memory.h"
+#include "KRB5_std.h"
+
+
+// defines                                                  // {{{
+#define MAGIC_PREFIX        "$krb5$"
+#define MAX_REALM_LEN       64
+#define TGT_SIZE            228
+#define MAX_USER_LEN        64
+#define MAX_PASS_LEN        64
+
+#define FORMAT_LABEL        "krb5"
+#define FORMAT_NAME         "Kerberos v5 TGT"
+#define ALGORITHM_NAME      "krb5 3DES (des3-cbc-sha1)"
+#define BENCHMARK_COMMENT   ""
+#define BENCHMARK_LENGTH    -1
+#define PLAINTEXT_LENGTH    32
+#define BINARY_SIZE         0
+#define MIN_KEYS_PER_CRYPT  1
+#define MAX_KEYS_PER_CRYPT  1
+
+/* This string is a bit too short - might give false positives */
+#define KRBTGT              "krbtgt"
+// }}}
+
+
+/**
+ * structure to hold the self tests                             // {{{
+ */
+static struct fmt_tests    KRB5_fmt_tests[] = {
+    {"$krb5$oskov$ACM.UIUC.EDU$4730d7249765615d6f3652321c4fb76d09fb9cd06faeb0c31b8737f9fdfcde4bd4259c31cb1dff25df39173b09abdff08373302d99ac09802a290915243d9f0ea0313fdedc7f8d1fae0d9df8f0ee6233818d317f03a72c2e77b480b2bc50d1ca14fba85133ea00e472c50dbc825291e2853bd60a969ddb69dae35b604b34ea2c2265a4ffc72e9fb811da17c7f2887ccb17e2f87cd1f6c28a9afc0c083a9356a9ee2a28d2e4a01fc7ea90cc8836b8e25650c3a1409b811d0bad42a59aa418143291d42d7b1e6cb5b1876a4cc758d721323a762e943f774630385c9faa68df6f3a94422f97", "p4ssW0rd"},
+    {"$krb5$oskov$ACM.UIUC.EDU$6cba0316d38e31ba028f87394792baade516afdfd8c5a964b6a7677adbad7815d778b297beb238394aa97a4d495adb7c9b7298ba7c2a2062fb6c9a4297f12f83755060f4f58a1ea4c7026df585cdfa02372ad619ab1a4ec617ad23e76d6e37e36268d9aa0abcf83f11fa8092b4328c5e6c577f7ec6f1c1684d9c99a309eee1f5bd764c4158a2cf311cded8794b2de83131c3dc51303d5300e563a2b7a230eac67e85b4593e561bf6b88c77b82c729e7ba7f3d2f99b8dc85b07873e40335aff4647833a87681ee557fbd1ffa1a458a5673d1bd3c1587eceeabaebf4e44c24d9a8ac8c1d89", "Nask0Oskov"},
+    {NULL}
+};
+// }}}
+
+/**
+ * struct to save the salt into
+ */
+struct salt {                                                       // {{{
+    char    realm[MAX_REALM_LEN];
+    char    user[MAX_USER_LEN];
+    char    tgt_ebin[TGT_SIZE];
+    char    passwd[MAX_PASS_LEN];
+};
+#define SALT_SIZE           sizeof(struct salt)
+// }}}
+
+struct key {                                                        // {{{
+    char    passwd[MAX_PASS_LEN];
+    char    key[MAX_PASS_LEN];
+    DES_key_schedule sched[3];
+};
+// }}}
+
+static struct salt *psalt = NULL;
+static struct key skey;
+
+static char username[MAX_USER_LEN];
+static char realm[MAX_REALM_LEN];
+static char password[MAX_PASS_LEN];
+
+// initialization vector for des
+static DES_cblock ivec;
+
+krb5_key _krb5key;
+krb5_key *krb5key = &_krb5key;
+
+/**
+ * hex2bin           // {{{
+ */
+static char *hex2bin(char *src, unsigned char *dst, int outsize) {
+    char *p, *pe;
+    unsigned char *q, *qe, ch, cl;
+
+    pe = src + strlen(src);
+    qe = dst + outsize;
+
+    for (p = src, q = dst; p < pe && q < qe && isxdigit((int)(unsigned char)*p); p += 2) {
+        ch = tolower((int)(unsigned char)p[0]);
+        cl = tolower((int)(unsigned char)p[1]);
+
+        if ((ch >= '0') && (ch <= '9')) ch -= '0';
+        else if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;
+        else return p;
+
+        if ((cl >= '0') && (cl <= '9')) cl -= '0';
+        else if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;
+        else return p+1;
+
+        *q++ = (ch << 4) | cl;
+    }
+    return p;
+}
+// }}}
+
+/**
+ * krb5_decrypt_compare                                             // {{{
+ *
+ */
+int krb5_decrypt_compare() {
+/* TGT_SIZE is not a multiple of DES block size; add space for one extra
+ * DES block to make sure the OpenSSL routines will not overwrite stack
+ * space beyond the end of plain[] when they operate on whole DES blocks. */
+    char plain[TGT_SIZE + 8];
+    int i;
+
+    memset(krb5key->key, 0x00, DES3_KEY_SIZE);
+    memset(krb5key->schedule, 0x00, DES3_KEY_SCHED_SIZE);
+
+/* NUL padding is intentional */
+    strncpy(username, psalt->user, MAX_USER_LEN);
+    strncpy(realm, psalt->realm, MAX_REALM_LEN);
+    strncpy(password, skey.passwd, MAX_PASS_LEN);
+
+    // do str2key
+    str2key(username, realm, password, krb5key);
+
+/* Possible optimization: we might not have to decrypt the entire thing */
+    des3_decrypt(krb5key, psalt->tgt_ebin, plain, TGT_SIZE);
+
+    for(i=0;i<TGT_SIZE;++i)
+        if (plain[i] == 'k')
+            if (strncmp(plain + i, KRBTGT, strlen(KRBTGT)) == 0) {
+/* NUL padding is intentional */
+                strncpy(psalt->passwd, skey.passwd, MAX_PASS_LEN);
+                return 1;
+            }
+    return 0;
+}
+// }}}
+
+/**
+ * void * krb5_salt                                                 // {{{
+ *
+ */
+static void * krb5_salt(char *ciphertext) {
+    static struct salt salt;
+    char *data = ciphertext, *p;
+    int n;
+
+    // advance past the $krb5$ string - it was checked for in valid()
+    data += strlen(MAGIC_PREFIX);
+
+    // find and copy the user field
+    p = strchr(data, '$');
+    if (!p)
+	return NULL;
+    n = (p - data) + 1;
+    if (n >= sizeof(salt.user))
+	return NULL;
+    strnzcpy(salt.user, data, n);
+    data = p + 1;
+
+    // find and copy the realm field
+    p = strchr(data, '$');
+    if (!p)
+	return NULL;
+    n = (p - data) + 1;
+    if (n >= sizeof(salt.realm))
+	return NULL;
+    strnzcpy(salt.realm, data, n);
+    data = p + 1;
+
+    // copy over the TGT in a binary form to the salt struct
+    p = hex2bin(data, (unsigned char *) salt.tgt_ebin, TGT_SIZE);
+    if (*p || p - data != TGT_SIZE * 2)
+	return NULL;
+
+    return &salt;
+}
+// }}}
+
+/**
+ * int krb5_valid                                                   // {{{
+ *
+ */
+static int krb5_valid(char *ciphertext, struct fmt_main *pFmt) {
+
+    if (strncmp(ciphertext, MAGIC_PREFIX, strlen(MAGIC_PREFIX)) != 0)
+        return 0;
+
+    return krb5_salt(ciphertext) ? 1 : 0;
+}
+// }}}
+
+/**
+ * void krb5_set_salt                                               // {{{
+ *
+ */
+static void krb5_set_salt(void *salt) {
+    psalt = (struct salt *) salt;
+}
+// }}}
+
+/**
+ * void krb5_set_key                                                // {{{
+ *
+ */
+static void krb5_set_key(char *key, int index) {
+
+    // copy the string key to the saved key
+    memset(skey.passwd, 0x00, MAX_PASS_LEN);
+    strnzcpy(skey.passwd, key, sizeof(skey.passwd));
+
+}
+// }}}
+
+/**
+ * char * krb5_get_key                                              // {{{
+ *
+ */
+static char * krb5_get_key(int index) {
+    return skey.passwd;
+}
+// }}}
+
+/**
+ * void krb5_crypt_all                                              // {{{
+ *
+ */
+static void krb5_crypt_all(int count) {
+    // do nothing
+}
+// }}}
+
+/**
+ * int krb5_cmp_all                                                 // {{{
+ *
+ */
+static int krb5_cmp_all(void *binary, int count) {
+    return krb5_decrypt_compare();
+}
+// }}}
+
+/**
+ * int krb5_cmp_one                                                 // {{{
+ *
+ */
+static int krb5_cmp_one(void *binary, int count) {
+
+    return krb5_decrypt_compare();
+
+}
+// }}}
+
+/**
+ * int krb5_cmp_exact                                               // {{{
+ *
+ */
+static int krb5_cmp_exact(char *source, int index) {
+    return 1;
+}
+// }}}
+
+/**
+ * void krb5_init                                                   // {{{
+ *
+ */
+static void krb5_init(struct fmt_main *pFmt) {
+
+    memset(&ivec, 0x00, sizeof(ivec));
+    memset(&skey, 0x00, sizeof(skey));
+    memset(krb5key, 0x00, sizeof(krb5_key));
+
+    krb5key->key = (char *) mem_alloc_tiny(DES3_KEY_SIZE, MEM_ALIGN_NONE);
+    krb5key->schedule = (char *) mem_alloc_tiny(DES3_KEY_SCHED_SIZE, MEM_ALIGN_WORD);
+    memset(krb5key->key, 0x00, DES3_KEY_SIZE);
+    memset(krb5key->schedule, 0x00, DES3_KEY_SCHED_SIZE);
+
+}
+// }}}
+
+/**
+ * fmt_main struct with KRB5 values                                     // {{{
+ */
+struct fmt_main fmt_KRB5 = {
+    {
+        FORMAT_LABEL,
+        FORMAT_NAME,
+        ALGORITHM_NAME,
+        BENCHMARK_COMMENT,
+        BENCHMARK_LENGTH,
+        PLAINTEXT_LENGTH,
+        BINARY_SIZE,
+        SALT_SIZE,
+        MIN_KEYS_PER_CRYPT,
+        MAX_KEYS_PER_CRYPT,
+        FMT_CASE | FMT_8_BIT,
+        KRB5_fmt_tests
+    }, {
+        krb5_init,
+		fmt_default_prepare,
+        krb5_valid,
+        fmt_default_split,
+        fmt_default_binary,
+        krb5_salt,
+        {
+            fmt_default_binary_hash,
+            fmt_default_binary_hash,
+            fmt_default_binary_hash,
+            fmt_default_binary_hash,
+            fmt_default_binary_hash
+        },
+        fmt_default_salt_hash,
+        krb5_set_salt,
+        krb5_set_key,
+        krb5_get_key,
+	    fmt_default_clear_keys,
+        krb5_crypt_all,
+        {
+            fmt_default_get_hash,
+            fmt_default_get_hash,
+            fmt_default_get_hash,
+            fmt_default_get_hash,
+            fmt_default_get_hash
+        },
+        krb5_cmp_all,
+        krb5_cmp_one,
+        krb5_cmp_exact
+    }
+};
+// }}}
+
diff -rupN john-1.7.8/src/KRB5_std.h john-1.7.8-jumbo-2/src/KRB5_std.h
--- john-1.7.8/src/KRB5_std.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/KRB5_std.h	2011-06-08 03:10:15.000000000 +0200
@@ -0,0 +1,56 @@
+/*
+ * KRB5_std.h
+ *
+ *  Kerberos 5 module for John the Ripper, based on the
+ *  KRB4 module by Dug Song.
+ *
+ * Author: Nasko Oskov <nasko at netsekure.org>
+ *
+ * Licensing:
+ *
+ *  The module contains code derived or copied from the Heimdal project.
+ *
+ *  Copyright (c) 1997-2000 Kungliga Tekniska Hgskolan
+ *  (Royal Institute of Technology, Stockholm, Sweden).
+ *  All rights reserved.
+ *
+ *  Which is distribution of Kerberos based on M.I.T. implementation.
+ *
+ *  Copyright (C) 1990 by the Massachusetts Institute of Technology
+ *
+ */
+
+#ifndef _KRB5_STD_H_
+#define _KRB5_STD_H_
+
+#include <openssl/des.h>
+
+#define DES3_BLOCK_SIZE         8
+#define DES3_KEY_SIZE           24
+#define DES3_KEY_BITS           168
+#define DES3_KEY_BITS_BYTES     DES3_KEY_BITS/8
+#define DES3_KEY_SCHED_SIZE     (sizeof(DES_key_schedule) * 3)
+
+#ifndef sfree
+#define sfree(x, len) if (x) { /* memset(x, 0x00, len); */ free(x); }
+#endif
+
+#ifndef min
+#define min(A, B) ((A) < (B) ? (A): (B))
+#endif
+
+#ifndef max
+#define max(A, B) ((A) > (B) ? (A): (B))
+#endif
+
+typedef struct _krb5_key {
+    char *key;
+    char *schedule;
+} krb5_key;
+
+void des3_decrypt(krb5_key *key, char *cipher, char *plain, int len);
+
+void str2key(char *user, char *realm, char *passwd, krb5_key *krb5key);
+
+#endif // _KRB5_STD_H_
+
diff -rupN john-1.7.8/src/KRB5_std_plug.c john-1.7.8-jumbo-2/src/KRB5_std_plug.c
--- john-1.7.8/src/KRB5_std_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/KRB5_std_plug.c	2011-06-08 03:09:38.000000000 +0200
@@ -0,0 +1,287 @@
+/*
+ * KRB5_std.c
+ *
+ *  Kerberos 5 module for John the Ripper, based on the
+ *  KRB4 module by Dug Song.
+ *
+ * Author: Nasko Oskov <nasko at netsekure.org>
+ *
+ * Licensing:
+ *
+ *  The module contains code derived or copied from the Heimdal project.
+ *
+ *  Copyright (c) 1997-2000 Kungliga Tekniska Hgskolan
+ *  (Royal Institute of Technology, Stockholm, Sweden).
+ *  All rights reserved.
+ *
+ *  Which is distribution of Kerberos based on M.I.T. implementation.
+ *
+ *  Copyright (C) 1990 by the Massachusetts Institute of Technology
+ *
+ */
+
+
+#include <stdlib.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "KRB5_std.h"
+
+#ifdef _MSC_VER
+#define inline _inline
+#endif
+
+
+static DES_cblock ivec;
+static const char derive_const[5] = "\x00\x00\x00\x03\xaa";
+
+/**
+ * Heimdal rr13 function                // {{{
+ */
+static inline void rr13(unsigned char *buf, int len) {
+
+    unsigned char *tmp;
+    int bytes = (len + 7) / 8;
+    int i;
+
+    int bb;
+    int b1, s1, b2, s2;
+
+    const int bits = 13 % len;
+    const int lbit = len % 8;
+
+    if(len == 0)
+        return;
+
+    tmp = (unsigned char *) malloc(bytes);
+    memcpy(tmp, buf, bytes);
+    if(lbit) {
+        // pad final byte with inital bits
+        tmp[bytes - 1] &= 0xff << (8 - lbit);
+        for(i = lbit; i < 8; i += len)
+            tmp[bytes - 1] |= buf[0] >> i;
+    }
+    for(i = 0; i < bytes; i++) {
+        // calculate first bit position of this byte
+        bb = 8 * i - bits;
+        while(bb < 0)
+            bb += len;
+        // byte offset and shift count
+        b1 = bb / 8;
+        s1 = bb % 8;
+
+        if(bb + 8 > bytes * 8)
+            // watch for wraparound
+            s2 = (len + 8 - s1) % 8;
+        else
+            s2 = 8 - s1;
+        b2 = (b1 + 1) % bytes;
+        buf[i] = (tmp[b1] << s1) | (tmp[b2] >> s2);
+    }
+    free(tmp);
+}
+// }}}
+
+/**
+ * Heimdal add1 function                            // {{{
+ */
+static inline void add1(unsigned char *a, unsigned char *b, size_t len) {
+    int i, x;
+    int carry = 0;
+    for(i = len - 1; i >= 0; i--){
+        x = a[i] + b[i] + carry;
+        carry = x > 0xff;
+        a[i] = x & 0xff;
+    }
+    for(i = len - 1; carry && i >= 0; i--){
+        x = a[i] + carry;
+        carry = x > 0xff;
+        a[i] = x & 0xff;
+    }
+}
+// }}}
+
+/**
+ * Heimdal _krb5_n_fold function        // {{{
+ */
+static inline void _krb5_n_fold(const void *str, int len, void *key, int size) {
+
+    int maxlen = 2 * max(size, len), l = 0;
+    unsigned char *tmp = (unsigned char *) malloc(maxlen);
+    unsigned char *buf = (unsigned char *) malloc(len);
+
+    memcpy(buf, str, len);
+    memset(key, 0, size);
+    do {
+        memcpy(tmp + l, buf, len);
+        l += len;
+        rr13(buf, len * 8);
+        while(l >= size) {
+            add1(key, tmp, size);
+            l -= size;
+            if(l == 0)
+                break;
+            memmove(tmp, tmp + size, l);
+        }
+    } while(l != 0);
+    sfree(buf, len);
+    sfree(tmp, maxlen);
+}
+// }}}
+
+/**
+ * Heimdal DES3_postproc function               // {{{
+ */
+static inline void DES3_postproc(unsigned char *k, int len, krb5_key *krb5key) {
+    unsigned char x[24];
+    int i, j;
+    unsigned char foo;
+    unsigned char b;
+
+    memset(x, 0, sizeof(x));
+    for (i = 0; i < 3; ++i) {
+        for (j = 0; j < 7; ++j) {
+            b = k[7 * i + j];
+            x[8 * i + j] = b;
+        }
+        foo = 0;
+        for (j = 6; j >= 0; --j) {
+            foo |= k[7 * i + j] & 1;
+            foo <<= 1;
+        }
+        x[8 * i + 7] = foo;
+    }
+    k = (unsigned char *) krb5key->key;
+    memcpy(k, x, 24);
+    DES_set_odd_parity((DES_cblock*)k);
+    DES_set_odd_parity((DES_cblock*)(k + 8));
+    DES_set_odd_parity((DES_cblock*)(k + 16));
+
+#if 0
+    memset(x, 0, sizeof(x));
+#endif
+}
+// }}}
+
+/**
+ * Heimdal based derive_key function                      // {{{
+ */
+static inline void derive_key(const void *constant, int len, krb5_key *krb5key) {
+
+    unsigned char *k;
+    unsigned int nblocks = 0, i;
+    DES_cblock *bk;
+    DES_key_schedule *s;
+
+    // set the des schedule
+    bk = (DES_cblock*) krb5key->key;
+    s = (DES_key_schedule *) krb5key->schedule;
+    DES_set_key(&bk[0], &s[0]);
+    DES_set_key(&bk[1], &s[1]);
+    DES_set_key(&bk[2], &s[2]);
+
+    if(DES3_BLOCK_SIZE * 8 < DES3_KEY_BITS || len != DES3_BLOCK_SIZE) {
+        nblocks = (DES3_KEY_BITS + DES3_BLOCK_SIZE * 8 - 1) / (DES3_BLOCK_SIZE * 8);
+        k = (unsigned char *) malloc(nblocks * DES3_BLOCK_SIZE);
+        if(k == NULL) {
+            printf("malloc: out of memory\n");
+            exit(1);
+        }
+        _krb5_n_fold(constant, len, k, DES3_BLOCK_SIZE);
+        for(i = 0; i < nblocks; i++) {
+            if(i > 0)
+                memcpy(k + i * DES3_BLOCK_SIZE, k + (i - 1) * DES3_BLOCK_SIZE, DES3_BLOCK_SIZE);
+
+            memset(ivec, 0x00, sizeof(ivec));
+            DES_ede3_cbc_encrypt((void *) &k[i * DES3_BLOCK_SIZE], (void *) &k[i * DES3_BLOCK_SIZE],
+                    DES3_BLOCK_SIZE, &s[0], &s[1], &s[2], (DES_cblock *) ivec, 1);
+        }
+    } else {
+        printf("Error, should never get here\n");
+        exit(1);
+    }
+
+    // keytype dependent post-processing
+    DES3_postproc(k, nblocks * DES3_BLOCK_SIZE, krb5key);
+
+    sfree(k, nblocks * DES3_BLOCK_SIZE);
+}
+// }}}
+
+/**
+ * Heimdal based string_to_key_derived function          // {{{
+ */
+static inline void string_to_key_derived(const void *passwd, int len, krb5_key *krb5key) {
+
+    unsigned char *tmp;
+
+    tmp = (unsigned char *) malloc(DES3_KEY_BITS_BYTES);
+    if(tmp == NULL) {
+        printf("malloc: out of memory\n");
+        // FIXME make it real return value if sometime this is needed
+        exit(1);
+    }
+    _krb5_n_fold(passwd, len, tmp, DES3_KEY_BITS_BYTES);
+
+    DES3_postproc(tmp, DES3_KEY_BITS_BYTES, krb5key);
+    derive_key("kerberos", strlen("kerberos"), krb5key);
+
+    sfree(tmp, DES3_KEY_BITS_BYTES);
+}
+// }}}
+
+/**
+ * des3_decrypt                                                 // {{{
+ */
+void des3_decrypt(krb5_key *key, char *cipher, char *plain, int len) {
+
+    DES_cblock *k;
+    DES_key_schedule *s;
+
+    memset(&ivec, 0x00, sizeof(ivec));
+
+    k = (DES_cblock *) key->key;
+    s = (DES_key_schedule *) key->schedule;
+
+    DES_set_key(&k[0], &s[0]);
+    DES_set_key(&k[1], &s[1]);
+    DES_set_key(&k[2], &s[2]);
+
+    DES_ede3_cbc_encrypt((const unsigned char*) cipher, (unsigned char*) plain, len, &s[0], &s[1], &s[2], &ivec, 0);
+
+}
+// }}}
+
+/**
+ * str2key                                                  // {{{
+ */
+void str2key(char *user, char *realm, char *passwd, krb5_key *krb5key) {
+    int offset = 0;
+    char *text;
+
+    text = (char*) malloc(strlen(user) + strlen(realm) + strlen(passwd));
+    if (text == NULL) {
+        return;
+    }
+
+    memset(krb5key->key, 0x00, DES3_KEY_SIZE);
+    memset(krb5key->schedule, 0x00, DES3_KEY_SCHED_SIZE);
+
+    // make the string from the passwd, realm, username
+    offset = 0;
+    memcpy(text + offset, passwd, strlen(passwd));
+    offset += strlen(passwd);
+    memcpy(text + offset, realm, strlen(realm));
+    offset += strlen(realm);
+    memcpy(text + offset, user, strlen(user));
+    offset += strlen(user);
+
+    string_to_key_derived(text, offset, krb5key);
+
+    // derive key from key
+    derive_key(derive_const, sizeof(derive_const), krb5key);
+
+    free(text);
+}
+// }}}
+
diff -rupN john-1.7.8/src/LM_fmt.c john-1.7.8-jumbo-2/src/LM_fmt.c
--- john-1.7.8/src/LM_fmt.c	2011-02-27 14:01:53.000000000 +0100
+++ john-1.7.8-jumbo-2/src/LM_fmt.c	2011-05-23 20:50:58.000000000 +0200
@@ -44,12 +44,12 @@ static struct fmt_tests tests[] = {
 #define MIN_KEYS_PER_CRYPT		DES_BS_DEPTH
 #define MAX_KEYS_PER_CRYPT		DES_BS_DEPTH
 
-static void init(void)
+static void init(struct fmt_main *pFmt)
 {
 	DES_bs_init(1);
 }
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	char *pos;
 	char lower[CIPHERTEXT_LENGTH - 16 + 1];
@@ -72,6 +72,15 @@ static int valid(char *ciphertext)
 	return 1;
 }
 
+// here to 'handle' the pwdump files:  user:gid:lmhash:ntlmhash:::
+// Note, we do NOT address the group id issues in the lm stuff, inside loader.
+static char *prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	if (!valid(split_fields[1], pFmt) && valid(split_fields[2], pFmt))
+		return split_fields[2];
+	return split_fields[1];
+}
+
 static char *split(char *ciphertext, int index)
 {
 	static char out[21];
@@ -193,6 +202,7 @@ struct fmt_main fmt_LM = {
 		tests
 	}, {
 		init,
+		prepare,
 		valid,
 		split,
 		get_binary,
diff -rupN john-1.7.8/src/MD5_fmt.c john-1.7.8-jumbo-2/src/MD5_fmt.c
--- john-1.7.8/src/MD5_fmt.c	2011-02-27 12:18:06.000000000 +0100
+++ john-1.7.8-jumbo-2/src/MD5_fmt.c	2011-06-08 04:09:31.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2008,2010,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by bartavelle
  */
 
 #include <string.h>
@@ -11,6 +13,10 @@
 #include "common.h"
 #include "formats.h"
 
+#ifdef MD5_SSE_PARA
+#include "sse-intrinsics.h"
+#endif
+
 #define FORMAT_LABEL			"md5"
 #define FORMAT_NAME			"FreeBSD MD5"
 
@@ -20,7 +26,11 @@
 #define PLAINTEXT_LENGTH		15
 #define CIPHERTEXT_LENGTH		22
 
+#ifdef MD5_SSE_PARA
+#define BINARY_SIZE			16
+#else
 #define BINARY_SIZE			4
+#endif
 #define SALT_SIZE			9
 
 #define MIN_KEYS_PER_CRYPT		MD5_N
@@ -39,12 +49,25 @@ static struct fmt_tests tests[] = {
 	{"$apr1$rBXqc...$NlXxN9myBOk95T0AyLAsJ0", "john"},
 	{"$apr1$Grpld/..$qp5GyjwM2dnA5Cdej9b411", "the"},
 	{"$apr1$GBx.D/..$yfVeeYFCIiEXInfRhBRpy/", "ripper"},
+	{"$1$bb$19smCEBG0Q1pVil0/HqK./", "aaaaa"},
+	{"$1$coin$rebm0t9KJ56mgGWJF5o5M0", "lapin"},
+	{"$1$pouet$/Ecz/vyk.zCYvrr6wB78h0", "canard"},
+	{"$1$test2$02MCIATVoxq3IhgK6XRkb1", "test1"},
+	{"$1$aussi$X67z3kXsWo92F15uChx1H1", "felicie"},
+	{"$1$boire$gf.YM2y3InYEu9.NbVr.v0", "manger"},
+	{"$1$bas$qvkmmWnVHRCSv/6LQ1doH/", "haut"},
+	{"$1$gauche$EPvd6LZlrgb0MMFPxUrJN1", "droite"},
 	{NULL}
 };
 
 static char saved_key[MD5_N][PLAINTEXT_LENGTH + 1];
+#ifdef MD5_SSE_PARA
+static unsigned char cursalt[SALT_SIZE];
+static int CryptType;
+static MD5_word sout[MD5_N*BINARY_SIZE/sizeof(MD5_word)];
+#endif
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	char *pos, *start;
 
@@ -93,29 +116,65 @@ static int binary_hash_4(void *binary)
 
 static int get_hash_0(int index)
 {
+#ifdef MD5_SSE_PARA
+	unsigned int x,y;
+	x = index&3;
+	y = index/4;
+	return ((MD5_word *)sout)[x+y*MMX_COEF*4] & 0xF;
+#else
 	return MD5_out[index][0] & 0xF;
+#endif
 }
 
 static int get_hash_1(int index)
 {
+#ifdef MD5_SSE_PARA
+	unsigned int x,y;
+	x = index&3;
+	y = index/4;
+	return ((MD5_word *)sout)[x+y*MMX_COEF*4] & 0xFF;
+#else
 	return MD5_out[index][0] & 0xFF;
+#endif
 }
 
 static int get_hash_2(int index)
 {
+#ifdef MD5_SSE_PARA
+	unsigned int x,y;
+	x = index&3;
+	y = index/4;
+	return ((MD5_word *)sout)[x+y*MMX_COEF*4] & 0xFFF;
+#else
 	return MD5_out[index][0] & 0xFFF;
+#endif
 }
 
 static int get_hash_3(int index)
 {
+#ifdef MD5_SSE_PARA
+	unsigned int x,y;
+	x = index&3;
+	y = index/4;
+	return ((MD5_word *)sout)[x+y*MMX_COEF*4] & 0xFFFF;
+#else
 	return MD5_out[index][0] & 0xFFFF;
+#endif
 }
 
 static int get_hash_4(int index)
 {
+#ifdef MD5_SSE_PARA
+	unsigned int x,y;
+	x = index&3;
+	y = index/4;
+	return ((MD5_word *)sout)[x+y*MMX_COEF*4] & 0xFFFFF;
+#else
 	return MD5_out[index][0] & 0xFFFFF;
+#endif
 }
 
+
 static int salt_hash(void *salt)
 {
 	unsigned int i, h, retval;
@@ -138,7 +197,9 @@ static int salt_hash(void *salt)
 
 static void set_key(char *key, int index)
 {
+#ifndef MD5_SSE_PARA
 	MD5_std_set_key(key, index);
+#endif
 
 	strnfcpy(saved_key[index], key, PLAINTEXT_LENGTH);
 }
@@ -152,23 +213,84 @@ static char *get_key(int index)
 
 static int cmp_all(void *binary, int count)
 {
-#if MD5_X2
+#ifdef MD5_SSE_PARA
+	unsigned int x,y;
+
+	for(y=0;y<MD5_SSE_PARA;y++) for(x=0;x<MMX_COEF;x++)
+	{
+		if( ((MD5_word *)binary)[0] == ((MD5_word *)sout)[x+y*MMX_COEF*4] )
+			return 1;
+	}
+	return 0;
+#else
+# if MD5_X2
 	return *(MD5_word *)binary == MD5_out[0][0] ||
 		*(MD5_word *)binary == MD5_out[1][0];
-#else
+# else
 	return *(MD5_word *)binary == MD5_out[0][0];
+# endif
 #endif
 }
 
 static int cmp_one(void *binary, int index)
 {
+#ifdef MD5_SSE_PARA
+	unsigned int x,y;
+	x = index&3;
+	y = index/4;
+
+	if( ((unsigned int *)binary)[0] != ((unsigned int *)sout)[x+y*MMX_COEF*4] )
+		return 0;
+	if( ((unsigned int *)binary)[1] != ((unsigned int *)sout)[x+y*MMX_COEF*4+4] )
+		return 0;
+	if( ((unsigned int *)binary)[2] != ((unsigned int *)sout)[x+y*MMX_COEF*4+8] )
+		return 0;
+	if( ((unsigned int *)binary)[3] != ((unsigned int *)sout)[x+y*MMX_COEF*4+12] )
+		return 0;
+	return 1;
+#else
 	return *(MD5_word *)binary == MD5_out[index][0];
+#endif
 }
 
 static int cmp_exact(char *source, int index)
 {
+#ifdef MD5_SSE_PARA
+	return 1;
+#else
 	return !memcmp(MD5_std_get_binary(source), MD5_out[index],
 	    sizeof(MD5_binary));
+#endif
+}
+
+static void crypt_all(int count) {
+#ifdef MD5_SSE_PARA
+	md5cryptsse((unsigned char *)saved_key, cursalt, (char *)sout, CryptType);
+#else
+	MD5_std_crypt();
+#endif
+}
+
+void myMD5_std_set_salt(char *salt)
+{
+#ifdef MD5_SSE_PARA
+	memcpy(cursalt, salt, SALT_SIZE);
+	if (cursalt[8]) {
+		CryptType = MD5_TYPE_APACHE;
+		cursalt[8] = 0;
+	}
+	else
+		CryptType = MD5_TYPE_STD;
+#endif
+	MD5_std_set_salt(salt);
+}
+
+static void *get_salt(char *ciphertext) {
+	return MD5_std_get_salt(ciphertext);
+}
+
+static void *get_binary(char *ciphertext) {
+	return MD5_std_get_binary(ciphertext);
 }
 
 struct fmt_main fmt_MD5 = {
@@ -187,10 +309,11 @@ struct fmt_main fmt_MD5 = {
 		tests
 	}, {
 		MD5_std_init,
+		fmt_default_prepare,
 		valid,
 		fmt_default_split,
-		(void *(*)(char *))MD5_std_get_binary,
-		(void *(*)(char *))MD5_std_get_salt,
+		get_binary,		//(void *(*)(char *))MD5_std_get_binary,
+		get_salt,		//(void *(*)(char *))MD5_std_get_salt,
 		{
 			binary_hash_0,
 			binary_hash_1,
@@ -199,11 +322,11 @@ struct fmt_main fmt_MD5 = {
 			binary_hash_4
 		},
 		salt_hash,
-		(void (*)(void *))MD5_std_set_salt,
+		(void (*)(void *))myMD5_std_set_salt,
 		set_key,
 		get_key,
 		fmt_default_clear_keys,
-		(void (*)(int))MD5_std_crypt,
+		crypt_all,		// (void (*)(int))MD5_std_crypt,
 		{
 			get_hash_0,
 			get_hash_1,
diff -rupN john-1.7.8/src/MD5_std.c john-1.7.8-jumbo-2/src/MD5_std.c
--- john-1.7.8/src/MD5_std.c	2011-02-27 11:49:03.000000000 +0100
+++ john-1.7.8-jumbo-2/src/MD5_std.c	2011-06-02 17:19:48.000000000 +0200
@@ -266,10 +266,10 @@ static MD5_data MD5_data_init = {
 	(a) += (b);
 
 #if MD5_X2
-static void MD5_body(MD5_word x0[15], MD5_word x1[15],
+extern void MD5_body(MD5_word x0[15], MD5_word x1[15],
 	MD5_word out0[4], MD5_word out1[4]);
 #else
-static void MD5_body(MD5_word x[15], MD5_word out[4]);
+extern void MD5_body(MD5_word x[15], MD5_word out[4]);
 #endif
 
 #else
@@ -316,11 +316,20 @@ static void init_line(int line, int inde
 	order[line][index].odd = odd;
 }
 
-void MD5_std_init(void)
+void MD5_std_init(struct fmt_main *pFmt)
 {
 	int index;
 	MD5_pool *current;
 
+	// Note, md5_gen will call here for setup.  If set are !MD5_IMM,
+	// md5_gen will NOT be able to use the MD5 functions.
+	// but since I do not know if this function can be called multiple
+	// times, I simply added a static, so the init WILL get run, but
+	// only 1 time.
+	static int bFirst = 1;
+	if (!bFirst) return;
+	bFirst = 0;
+
 #if !MD5_IMM
 	MD5_std_all.data = MD5_data_init;
 #endif
@@ -595,7 +604,7 @@ void MD5_std_crypt(void)
 
 #if !MD5_X2
 
-static void MD5_body(MD5_word x[15], MD5_word out[4])
+void MD5_body(MD5_word x[15], MD5_word out[4])
 {
 	MD5_word a, b = Cb, c = Cc, d;
 
@@ -687,7 +696,7 @@ static void MD5_body(MD5_word x[15], MD5
 
 #else
 
-static void MD5_body(MD5_word x0[15], MD5_word x1[15],
+void MD5_body(MD5_word x0[15], MD5_word x1[15],
 	MD5_word out0[4], MD5_word out1[4])
 {
 	MD5_word a0, b0 = Cb, c0 = Cc, d0;
diff -rupN john-1.7.8/src/MD5_std.h john-1.7.8-jumbo-2/src/MD5_std.h
--- john-1.7.8/src/MD5_std.h	2011-02-27 11:42:17.000000000 +0100
+++ john-1.7.8-jumbo-2/src/MD5_std.h	2011-06-08 04:17:11.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2000,2003,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by bartavelle
  */
 
 /*
@@ -56,10 +58,24 @@ typedef struct {
 } MD5_data;
 #endif
 
-#if MD5_X2
-#define MD5_N				2
+#if !defined(MD5_in_sse_intrinsics) && defined(__GNUC__) && __GNUC__ < 4
+#undef MD5_SSE_PARA
+#endif
+
+#ifdef MD5_SSE_PARA
+# ifndef MMX_COEF
+#  define MMX_COEF			4
+# endif
+# define MD5_N				(MD5_SSE_PARA*MMX_COEF)
+# define MD5_ALGORITHM_NAME		MD5_N_STR
 #else
-#define MD5_N				1
+# if MD5_X2
+#  define MD5_N				2
+#  define MD5_ALGORITHM_NAME		"32/" ARCH_BITS_STR " X2"
+# else
+#  define MD5_N				1
+#  define MD5_ALGORITHM_NAME		"32/" ARCH_BITS_STR
+# endif
 #endif
 
 typedef struct {
@@ -84,16 +100,15 @@ extern MD5_std_combined MD5_std_all;
  */
 #define MD5_out				MD5_std_all.out
 
-#if MD5_X2
-#define MD5_ALGORITHM_NAME		"32/" ARCH_BITS_STR " X2"
-#else
-#define MD5_ALGORITHM_NAME		"32/" ARCH_BITS_STR
-#endif
+// these 2 are still used by the 'para' function
+#define MD5_TYPE_APACHE 1
+#define MD5_TYPE_STD	2
 
 /*
  * Initializes the internal structures.
  */
-extern void MD5_std_init(void);
+struct fmt_main;
+extern void MD5_std_init(struct fmt_main *pFmt);
 
 /*
  * Sets a salt for MD5_std_crypt().
diff -rupN john-1.7.8/src/MSCHAPv2_fmt_plug.c john-1.7.8-jumbo-2/src/MSCHAPv2_fmt_plug.c
--- john-1.7.8/src/MSCHAPv2_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/MSCHAPv2_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,483 @@
+/*
+ * MSCHAPv2_fmt.c -- Microsoft PPP CHAP Extensions, Version 2
+ *
+ * Written by JoMo-Kun <jmk at foofus.net> in 2010
+ * and placed in the public domain.
+ *
+ * Modified for performance, OMP and utf-8 support
+ * by magnum 2010-2011, no rights reserved
+ *
+ * This algorithm is designed for performing brute-force cracking of the
+ * MSCHAPv2 challenge/response sets exchanged during network-based
+ * authentication attempts. The captured challenge/response set from these
+ * attempts should be stored using the following format:
+ *
+ * USERNAME:::AUTHENTICATOR CHALLENGE:MSCHAPv2 RESPONSE:PEER CHALLENGE
+ * USERNAME::DOMAIN:AUTHENTICATOR CHALLENGE:MSCHAPv2 RESPONSE:PEER CHALLENGE
+ * DOMAIN\USERNAME:::AUTHENTICATOR CHALLENGE:MSCHAPv2 RESPONSE:PEER CHALLENGE
+ *
+ * For example:
+ * User:::5B5D7C7D7B3F2F3E3C2C602132262628:82309ECD8D708B5EA08FAA3981CD83544233114A3D85D6DF:21402324255E262A28295F2B3A337C7E
+ * domain\fred:::56d64cbe7bad61349a0b752335100eaf:d7d829d9545cef1d631b4e568ffb7586050fa3a4d02dbc0b:7f8a466cff2a6bf0c80218bbf56d76bc
+ *
+ * http://freeradius.org/rfc/rfc2759.txt
+ *
+ */
+
+#include <string.h>
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+#include "memory.h"
+
+#include "sha.h"
+#include <openssl/des.h>
+
+#ifndef uchar
+#define uchar unsigned char
+#endif
+
+#define FORMAT_LABEL         "mschapv2"
+#define FORMAT_NAME          "MSCHAPv2 C/R MD4 DES"
+#define ALGORITHM_NAME       "mschapv2"
+#define BENCHMARK_COMMENT    ""
+#define BENCHMARK_LENGTH     0
+#define PLAINTEXT_LENGTH     54 /* lmcons.h - PWLEN (256) ? 127 ? */
+#define UTF8_PLAINTEXT_LEN   125
+#define USERNAME_LENGTH      256 /* lmcons.h - UNLEN (256) / LM20_UNLEN (20) */
+#define DOMAIN_LENGTH        15  /* lmcons.h - CNLEN / DNLEN */
+#define PARTIAL_BINARY_SIZE  8
+#define BINARY_SIZE          24
+#define CHALLENGE_LENGTH     64
+#define SALT_SIZE            8
+#define CIPHERTEXT_LENGTH    48
+#define TOTAL_LENGTH         13 + USERNAME_LENGTH + CHALLENGE_LENGTH + CIPHERTEXT_LENGTH
+
+// these may be altered in init() if running OMP
+// and that formula is subject to change
+#define MIN_KEYS_PER_CRYPT	    1
+#define THREAD_RATIO            256
+#ifdef _OPENMP
+#define MAX_KEYS_PER_CRYPT	    0x10000
+#else
+#define MAX_KEYS_PER_CRYPT	    THREAD_RATIO
+#endif
+
+static struct fmt_tests tests[] = {
+  {"$MSCHAPv2$5B5D7C7D7B3F2F3E3C2C602132262628$82309ECD8D708B5EA08FAA3981CD83544233114A3D85D6DF$21402324255E262A28295F2B3A337C7E$User", "clientPass"},
+  {"$MSCHAPv2$d07054459a1fdbc266a006f0220e6fac$33c8331a9b03b7e003f09dd253d740a2bead544143cc8bde$3545cb1d89b507a5de104435e81b14a4$testuser1", "Cricket8"},
+  {"$MSCHAPv2$56d64cbe7bad61349a0b752335100eaf$d7d829d9545cef1d631b4e568ffb7586050fa3a4d02dbc0b$7f8a466cff2a6bf0c80218bbf56d76bc$fred", "OMG!BBQ!11!one"}, /* domain\fred */
+  {"$MSCHAPv2$b3c42db475b881d3c52ff3923d7b3bf8$f07c7a4eb391f5debe32d814679a5a69661b86b33227c4f8$6321f8649b971bd11ce8d5cb22a4a738$bOb", "asdblahblahblahblahblahblahblahblah"}, /* WorkGroup\bOb */
+  {"$MSCHAPv2$d94e7c7972b2376b28c268583e162de7$eba25a3b04d2c7085d01f842e2befc91745c40db0f792356$0677ca7318fd7f65ae1b4f58c9f4f400$lameuser", ""}, /* no password */
+
+  {"", "clientPass",     {"User",        "", "",    "5B5D7C7D7B3F2F3E3C2C602132262628", "82309ECD8D708B5EA08FAA3981CD83544233114A3D85D6DF", "21402324255E262A28295F2B3A337C7E"} },
+  {"", "Cricket8",       {"testuser1",   "", "",    "d07054459a1fdbc266a006f0220e6fac", "33c8331a9b03b7e003f09dd253d740a2bead544143cc8bde", "3545cb1d89b507a5de104435e81b14a4"} },
+  {"", "OMG!BBQ!11!one", {"domain\\fred", "", "",   "56d64cbe7bad61349a0b752335100eaf", "d7d829d9545cef1d631b4e568ffb7586050fa3a4d02dbc0b", "7f8a466cff2a6bf0c80218bbf56d76bc"} }, /* domain\fred */
+  {"", "",               {"lameuser", "", "domain", "d94e7c7972b2376b28c268583e162de7", "eba25a3b04d2c7085d01f842e2befc91745c40db0f792356", "0677ca7318fd7f65ae1b4f58c9f4f400"} }, /* no password */
+  {"", "asdblahblahblahblahblahblahblahblah", {"WorkGroup\\bOb", "", "", "b3c42db475b881d3c52ff3923d7b3bf8", "f07c7a4eb391f5debe32d814679a5a69661b86b33227c4f8", "6321f8649b971bd11ce8d5cb22a4a738"} }, /* WorkGroup\bOb */
+
+  {NULL}
+};
+
+static uchar saved_plain[MAX_KEYS_PER_CRYPT][UTF8_PLAINTEXT_LEN + 1];
+static uchar saved_key[MAX_KEYS_PER_CRYPT][21];
+static uchar *challenge;
+static ARCH_WORD_32 output[MAX_KEYS_PER_CRYPT][PARTIAL_BINARY_SIZE/sizeof(ARCH_WORD_32)];
+
+#include "unicode.h"
+
+extern struct fmt_main fmt_MSCHAPv2;
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = MIN_KEYS_PER_CRYPT * omp_get_max_threads();
+	if (n < MIN_KEYS_PER_CRYPT)
+		n = MIN_KEYS_PER_CRYPT;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_MSCHAPv2.params.min_keys_per_crypt = n;
+	n = n * n * ((n >> 1) + 1) * THREAD_RATIO;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_MSCHAPv2.params.max_keys_per_crypt = n;
+#endif
+	if (options.flags & FLG_UTF8) {
+		// in utf-8, up to four bytes can compose one character
+		fmt_MSCHAPv2.params.plaintext_length = UTF8_PLAINTEXT_LEN;
+	}
+}
+
+static int mschapv2_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+  char *pos, *pos2;
+
+  if (ciphertext == NULL) return 0;
+  else if (strncmp(ciphertext, "$MSCHAPv2$", 10)!=0) return 0;
+
+  /* Validate Authenticator/Server Challenge Length */
+  pos = &ciphertext[10];
+  for (pos2 = pos; strncmp(pos2, "$", 1) != 0; pos2++)
+    if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos == CHALLENGE_LENGTH / 2)) )
+    return 0;
+
+  /* Validate MSCHAPv2 Response Length */
+  pos2++; pos = pos2;
+  for (; strncmp(pos2, "$", 1) != 0; pos2++)
+    if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos == CIPHERTEXT_LENGTH)) )
+    return 0;
+
+  /* Validate Peer/Client Challenge Length */
+  pos2++; pos = pos2;
+  for (; strncmp(pos2, "$", 1) != 0; pos2++)
+    if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos == CHALLENGE_LENGTH / 2)) )
+    return 0;
+
+  /* Validate Username Length */
+  pos2++; pos = pos2;
+  for (; atoi16[ARCH_INDEX(*pos2)] != 0x7F; pos2++);
+  if ( !(*pos2 && (pos2 - pos <= USERNAME_LENGTH)) )
+    return 0;
+
+  return 1;
+}
+
+static char *mschapv2_prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+//	else if (options.format && (strncmp(options.format, "mschapv2", 8)==0)) {
+//		char *srv_challenge = ldr_get_field(&line, db_options->field_sep_char);
+//		char *mschapv2 = ldr_get_field(&line, db_options->field_sep_char);
+//		char *cli_challenge = ldr_get_field(&line, db_options->field_sep_char);
+//		char *username = NULL;
+//
+//	/* DOMAIN\USERNAME -or - USERNAME -- ignore DOMAIN */
+//	if ((tmp = strstr(*login, "\\")) == NULL)
+//		tmp = *login;
+//	else
+//		tmp++;
+//
+//		username = (char *) mem_alloc(strlen(tmp) + 1);
+//		strcpy(username, tmp);
+//
+//		tmp = (char *) mem_alloc_tiny(8 + strlen(srv_challenge) + 1 + strlen(mschapv2) + 1 + strlen(cli_challenge) + 1 + strlen(username) + 1, MEM_ALIGN_NONE);
+//		sprintf(tmp, "$MSCHAPv2$%s$%s$%s$%s", srv_challenge, mschapv2, cli_challenge, username);
+//		*ciphertext = tmp;
+//	}
+	char *username, *cp;
+
+	if (!strncmp(split_fields[1], "$MSCHAPv2$", 10))
+		return split_fields[1];
+	if (strlen(split_fields[3]) != CHALLENGE_LENGTH/2)
+		return split_fields[1];
+	if (strlen(split_fields[4]) != CIPHERTEXT_LENGTH)
+		return split_fields[1];
+	if (strlen(split_fields[5]) != CHALLENGE_LENGTH/2)
+		return split_fields[1];
+
+    /* DOMAIN\USERNAME -or - USERNAME -- ignore DOMAIN */
+    if ((username = strstr(split_fields[0], "\\")) == NULL)
+      username = split_fields[0];
+    else
+      username++;
+	cp = mem_alloc(1+8+1+strlen(split_fields[3])+1+strlen(split_fields[4])+1+strlen(split_fields[5])+1+strlen(username)+1);
+	sprintf(cp, "$MSCHAPv2$%s$%s$%s$%s", split_fields[3], split_fields[4], split_fields[5], username);
+	if (mschapv2_valid(cp,pFmt)) {
+		char *cp2 = str_alloc_copy(cp);
+		MEM_FREE(cp);
+		return cp2;
+	}
+	MEM_FREE(cp);
+	return split_fields[1];
+}
+
+static char *mschapv2_split(char *ciphertext, int index)
+{
+  static char *out;
+  int i;
+
+  if (!out) out = mem_alloc_tiny(TOTAL_LENGTH + 1, MEM_ALIGN_WORD);
+
+  memset(out, 0, TOTAL_LENGTH + 1);
+  memcpy(out, ciphertext, strlen(ciphertext));
+
+  /* convert hashes to lower-case - exclude $MSCHAPv2 and USERNAME */
+  for (i = 10; i < 10 + 16*2 + 1 + 24*2 + 1 + 16*2; i++)
+    if (out[i] >= 'A' && out[i] <= 'Z')
+      out[i] |= 0x20;
+
+  return out;
+}
+
+static void *mschapv2_get_binary(char *ciphertext)
+{
+  static uchar *binary;
+  int i;
+
+  if (!binary) binary = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+  ciphertext += 10 + 16*2 + 1; /* Skip - $MSCHAPv2$, Authenticator Challenge */
+
+  for (i=0; i<BINARY_SIZE; i++)
+  {
+    binary[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])])<<4;
+    binary[i] |= (atoi16[ARCH_INDEX(ciphertext[i*2+1])]);
+  }
+  return binary;
+}
+
+static inline void setup_des_key(unsigned char key_56[], DES_key_schedule *ks)
+{
+  DES_cblock key;
+
+  key[0] = key_56[0];
+  key[1] = (key_56[0] << 7) | (key_56[1] >> 1);
+  key[2] = (key_56[1] << 6) | (key_56[2] >> 2);
+  key[3] = (key_56[2] << 5) | (key_56[3] >> 3);
+  key[4] = (key_56[3] << 4) | (key_56[4] >> 4);
+  key[5] = (key_56[4] << 3) | (key_56[5] >> 5);
+  key[6] = (key_56[5] << 2) | (key_56[6] >> 6);
+  key[7] = (key_56[6] << 1);
+
+  DES_set_key(&key, ks);
+}
+
+/* Calculate the MSCHAPv2 response for the given challenge, using the
+   specified authentication identity (username), password and client
+   nonce.
+*/
+static void mschapv2_crypt_all(int count)
+{
+	DES_key_schedule ks;
+	int i;
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)
+#endif
+	for(i=0; i<count; i++) {
+
+		/* Just do first DES for a partial binary */
+		setup_des_key(saved_key[i], &ks);
+		DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)output[i], &ks, DES_ENCRYPT);
+	}
+}
+
+static int mschapv2_cmp_all(void *binary, int count)
+{
+	int index = 0;
+	for(; index<count; index++)
+		if (!memcmp(output[index], binary, PARTIAL_BINARY_SIZE))
+			return 1;
+	return 0;
+}
+
+static int mschapv2_cmp_one(void *binary, int index)
+{
+	return (!memcmp(output[index], binary, PARTIAL_BINARY_SIZE));
+}
+
+static int mschapv2_cmp_exact(char *source, int index)
+{
+	DES_key_schedule ks;
+	uchar binary[24];
+
+	/* NULL-pad 16-byte NTLM hash to 21-bytes (postponed until now) */
+	memset(&saved_key[index][16], 0, 5);
+
+	/* Split resultant value into three 7-byte thirds
+	   DES-encrypt challenge using each third as a key
+	   Concatenate three 8-byte resulting values to form 24-byte LM response
+	*/
+	setup_des_key(saved_key[index], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)binary, &ks, DES_ENCRYPT);
+	setup_des_key(&saved_key[index][7], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)&binary[8], &ks, DES_ENCRYPT);
+	setup_des_key(&saved_key[index][14], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)&binary[16], &ks, DES_ENCRYPT);
+
+	return !memcmp(binary, mschapv2_get_binary(source), BINARY_SIZE);
+}
+
+/* We're essentially using three salts, but we're going to generate a single value here for later use.
+   |Peer/Client Challenge (8 Bytes)|Authenticator/Server Challenge (8 Bytes)|Username (<=256)|
+*/
+static void *mschapv2_get_salt(char *ciphertext)
+{
+  static unsigned char binary_salt[SALT_SIZE];
+  static SHA_CTX ctx;
+  unsigned char tmp[16];
+  int i;
+  char *pos = NULL;
+  unsigned char digest[20];
+
+  memset(binary_salt, 0, SALT_SIZE);
+  memset(digest, 0, 20);
+  SHA1_Init(&ctx);
+
+  /* Peer Challenge */
+  pos = ciphertext + 10 + 16*2 + 1 + 24*2 + 1; /* Skip $MSCHAPv2$, Authenticator Challenge and Response Hash */
+
+  memset(tmp, 0, 16);
+  for (i = 0; i < 16; i++)
+    tmp[i] = (atoi16[ARCH_INDEX(pos[i*2])] << 4) + atoi16[ARCH_INDEX(pos[i*2+1])];
+
+  SHA1_Update(&ctx, tmp, 16);
+
+  /* Authenticator Challenge */
+  pos = ciphertext + 10; /* Skip $MSCHAPv2$ */
+
+  memset(tmp, 0, 16);
+  for (i = 0; i < 16; i++)
+    tmp[i] = (atoi16[ARCH_INDEX(pos[i*2])] << 4) + atoi16[ARCH_INDEX(pos[i*2+1])];
+
+  SHA1_Update(&ctx, tmp, 16);
+
+  /* Username - Only the user name (as presented by the peer and
+     excluding any prepended domain name) is used as input to SHAUpdate()
+  */
+  pos = ciphertext + 10 + 16*2 + 1 + 24*2 + 1 + 16*2 + 1; /* Skip $MSCHAPv2$, Authenticator, Response and Peer */
+  SHA1_Update(&ctx, pos, strlen(pos));
+
+  SHA1_Final(digest, &ctx);
+  memcpy(binary_salt, digest, SALT_SIZE);
+
+  return (void*)binary_salt;
+}
+
+static void mschapv2_set_salt(void *salt)
+{
+	challenge = salt;
+}
+
+static void mschapv2_set_key(char *key, int index)
+{
+	int len = strlen(key);
+	memcpy(saved_plain[index], key, len + 1);
+
+	/* Generate 16-byte NTLM hash */
+	len = E_md4hash((uchar *) saved_plain[index], len, saved_key[index]);
+
+	if (len <= 0)
+		saved_plain[index][-len] = 0; // match if it was truncated
+
+	/* NULL-padding the 16-byte hash to 21-bytes is made in cmp_exact if needed */
+}
+
+static char *mschapv2_get_key(int index)
+{
+	return (char *)saved_plain[index];
+}
+
+static int salt_hash(void *salt)
+{
+	return *(ARCH_WORD_32 *)salt & (SALT_HASH_SIZE - 1);
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFFF;
+}
+
+struct fmt_main fmt_MSCHAPv2 = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALGORITHM_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP | FMT_UNICODE | FMT_UTF8,
+    tests
+  }, {
+    init,
+	mschapv2_prepare,
+    mschapv2_valid,
+    mschapv2_split,
+    mschapv2_get_binary,
+    mschapv2_get_salt,
+    {
+	    binary_hash_0,
+	    binary_hash_1,
+	    binary_hash_2,
+	    binary_hash_3,
+	    binary_hash_4
+    },
+    salt_hash,
+    mschapv2_set_salt,
+    mschapv2_set_key,
+    mschapv2_get_key,
+    fmt_default_clear_keys,
+    mschapv2_crypt_all,
+    {
+	    get_hash_0,
+	    get_hash_1,
+	    get_hash_2,
+	    get_hash_3,
+	    get_hash_4
+    },
+    mschapv2_cmp_all,
+    mschapv2_cmp_one,
+    mschapv2_cmp_exact
+  }
+};
diff -rupN john-1.7.8/src/MYSQL_fast_fmt_plug.c john-1.7.8-jumbo-2/src/MYSQL_fast_fmt_plug.c
--- john-1.7.8/src/MYSQL_fast_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/MYSQL_fast_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,268 @@
+/* MYSQL_half_fmt.c
+ *
+ * Copyright (c) 2008 by <earthquake at rycon.hu>
+ *
+ * John the ripper MYSQL-fast module
+ *
+ *
+ * Note: The mysql hash's first 8byte is relevant,
+ * the another ones depends on the first 8. Maybe
+ * the passwords after 9-10character have collision
+ * in the first 8byte, so we have to check the full
+ * hash.
+ *
+ * Unbelievable good optimization by Pter Kasza
+ *
+ * http://rycon.hu/
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL			"mysql-fast"
+#define FORMAT_NAME			"MYSQL_fast"
+#define ALGORITHM_NAME			"mysql-fast"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		16
+
+#define BINARY_SIZE			8
+#define SALT_SIZE			0
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		64
+
+static struct fmt_tests mysql_tests[] = {
+	// ciphertext, plaintext
+	{"445ff82636a7ba59", "probe"},
+	{"60671c896665c3fa", "a"},
+	{"1acbed4a27b20da3", "hash"},
+	{"77ff75006118bab8", "hacker"},
+	{"1b38cd9c2f809809", "hacktivity2008"},
+	{"1b38cd9c2f809809", "hacktivity 2008"},
+	{"6fc81597422015a8", "johnmodule"},
+	{NULL}
+};
+
+static ARCH_WORD_32 crypt_key[MAX_KEYS_PER_CRYPT][BINARY_SIZE / 4];
+static char saved_key[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1];
+
+static int mysql_valid(char* ciphertext, struct fmt_main *pFmt)
+{
+	unsigned int i;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+
+	for (i = 0; i < CIPHERTEXT_LENGTH; i++)
+	{
+		if (!(((ciphertext[i] >= '0') && (ciphertext[i] <= '9')) ||
+			((ciphertext[i] >= 'a') && (ciphertext[i] <= 'f')) ||
+			((ciphertext[i] >= 'A') && (ciphertext[i] <= 'F')))
+				)
+			return 0;
+	}
+
+	return 1;
+}
+
+static void* mysql_get_binary(char* ciphertext)
+{
+	static unsigned char buff[BINARY_SIZE / 2];
+	unsigned int i;
+
+	for (i = 0; i < BINARY_SIZE / 2; i++)
+	{
+#if ARCH_LITTLE_ENDIAN == 1
+		buff[((BINARY_SIZE / 2) - 1) - i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16 + atoi16[ARCH_INDEX(ciphertext[i * 2 + 1])];
+#else
+		buff[i] = atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16 + atoi16[ARCH_INDEX(ciphertext[i * 2 + 1])];
+#endif
+	}
+
+	return buff;
+}
+
+static void mysql_set_key(char* key, int index)
+{
+	strnzcpy(saved_key[index], key, PLAINTEXT_LENGTH + 1);
+}
+
+static char* mysql_get_key(int index)
+{
+	return saved_key[index];
+}
+
+static int mysql_cmp_one(void* binary, int index)
+{
+	return *(ARCH_WORD_32 *)binary == crypt_key[index][0];
+}
+
+static int mysql_cmp_all(void* binary, int count)
+{
+	unsigned int i;
+
+	for (i = 0; i < count; i++) {
+		if (*(ARCH_WORD_32 *)binary == crypt_key[i][0])
+			return 1;
+	}
+
+	return 0;
+}
+
+static int mysql_cmp_exact(char* source, int index)
+{
+	register unsigned long nr = 1345345333L, add = 7, nr2 = 0x12345671L;
+	register unsigned long tmp;
+	char* password;
+	char ctmp[CIPHERTEXT_LENGTH+1];
+
+	password = saved_key[index];
+	for (; *password; password++)
+	{
+		if (*password == ' ' || *password == '\t')
+			continue;
+
+		tmp = (unsigned long) (unsigned char) *password;
+		nr ^= (((nr & 63) + add) * tmp) + (nr << 8);
+		nr2 += (nr2 << 8) ^ nr;
+		add += tmp;
+	}
+
+	sprintf(ctmp, "%08lx%08lx", (nr & (((unsigned long) 1L << 31) -1L)), (nr2 & (((unsigned long) 1L << 31) -1L)));
+	return !memcmp(source, ctmp, CIPHERTEXT_LENGTH);
+}
+
+static void mysql_crypt_all(int count)
+{
+	unsigned long nr, add;
+	unsigned long tmp;
+	unsigned int i;
+	char* password;
+
+	for (i = 0; i < count; i++)
+	{
+		nr=1345345333L;
+		add=7;
+
+		password = saved_key[i];
+		for (; *password; password++)
+		{
+			if (*password == ' ' || *password == '\t')
+				continue;
+
+			tmp = (unsigned long) (unsigned char) *password;
+			nr ^= (((nr & 63) + add) * tmp) + (nr << 8);
+			add += tmp;
+		}
+
+		crypt_key[i][0] = (nr & (((ARCH_WORD_32)1 << 31) - 1));
+	}
+}
+
+int mysql_binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+int mysql_binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+int mysql_binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+int mysql_binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+int mysql_binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+int mysql_get_hash_0(int index)
+{
+	return crypt_key[index][0] & 0xF;
+}
+
+int mysql_get_hash_1(int index)
+{
+	return crypt_key[index][0] & 0xFF;
+}
+
+int mysql_get_hash_2(int index)
+{
+	return crypt_key[index][0] & 0xFFF;
+}
+
+int mysql_get_hash_3(int index)
+{
+	return crypt_key[index][0] & 0xFFFF;
+}
+
+int mysql_get_hash_4(int index)
+{
+	return crypt_key[index][0] & 0xFFFFF;
+}
+
+struct fmt_main fmt_MYSQL_fast =
+{
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		mysql_tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		mysql_valid,
+		fmt_default_split,
+		mysql_get_binary,
+		fmt_default_salt,
+		{
+			mysql_binary_hash_0,
+			mysql_binary_hash_1,
+			mysql_binary_hash_2,
+			mysql_binary_hash_3,
+			mysql_binary_hash_4
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		mysql_set_key,
+		mysql_get_key,
+		fmt_default_clear_keys,
+		mysql_crypt_all,
+		{
+			mysql_get_hash_0,
+			mysql_get_hash_1,
+			mysql_get_hash_2,
+			mysql_get_hash_3,
+			mysql_get_hash_4
+		},
+		mysql_cmp_all,
+		mysql_cmp_one,
+		mysql_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/MYSQL_fmt_plug.c john-1.7.8-jumbo-2/src/MYSQL_fmt_plug.c
--- john-1.7.8/src/MYSQL_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/MYSQL_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,244 @@
+////////////////////////////////////////////////////////////////
+// MySQL password cracker - v1.0 - 16.1.2003
+//
+//    by Andrew Hintz <http://guh.nu> drew at overt.org
+//
+//    This production has been brought to you by
+//    4tphi <http://4tphi.net> and violating <http://violating.us>
+//
+// This file is an add-on to John the Ripper <http://www.openwall.com/john/>
+//
+// Part of this code is based on the MySQL brute password cracker
+//   mysqlpassword.c by Chris Given
+// This program executes about 75% faster than mysqlpassword.c
+// John the ripper also performs sophisticated password guessing.
+//
+// John the Ripper will expect the MySQL password file to be
+// in the following format (without the leading // ):
+// dumb_user:5d2e19393cc5ef67
+// another_luser:28ff8d49159ffbaf
+
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+
+// johntr includes
+#include "arch.h"
+#include "misc.h"
+#include "formats.h"
+#include "common.h"
+
+//johntr defines
+#define FORMAT_LABEL "mysql"
+#define FORMAT_NAME "MYSQL"
+#define ALGORITHM_NAME "mysql"
+
+#define BENCHMARK_COMMENT ""
+#define BENCHMARK_LENGTH -1
+
+// Increase the PLAINTEXT_LENGTH value for longer passwords.
+// You can also set it to 8 when using MySQL systems that truncate
+//  the password to only 8 characters.
+#define PLAINTEXT_LENGTH 32
+
+#define CIPHERTEXT_LENGTH 16
+
+#define BINARY_SIZE 16
+#define SALT_SIZE 0
+
+#define MIN_KEYS_PER_CRYPT 1
+#define MAX_KEYS_PER_CRYPT 1
+
+
+//used for mysql scramble function
+struct rand_struct {
+  unsigned long seed1,seed2,max_value;
+  double max_value_dbl;
+};
+
+
+void make_scrambled_password(char *,const char *);
+char *scramble(char *,const char *,const char *, int);
+
+//test cases
+static struct fmt_tests mysql_tests[] = {
+  {"30f098972cc8924d", "http://guh.nu"},
+  {"3fc56f6037218993", "Andrew Hintz"},
+  {"697a7de87c5390b2", "drew"},
+  {"1eb71cf460712b3e", "http://4tphi.net"},
+  {"28ff8d49159ffbaf", "http://violating.us"},
+  {"5d2e19393cc5ef67", "password"},
+  {NULL}
+};
+
+
+//stores the ciphertext for value currently being tested
+static char crypt_key[BINARY_SIZE+1];
+
+//used by set_key
+static char saved_key[PLAINTEXT_LENGTH + 1];
+
+static int mysql_valid(char *ciphertext, struct fmt_main *pFmt) { //returns 0 for invalid ciphertexts
+
+  int i; //used as counter in loop
+
+  //ciphertext is 16 characters
+  if (strlen(ciphertext) != 16) return 0;
+
+  //ciphertext is ASCII representation of hex digits
+  for (i = 0; i < 16; i++){
+    if (!(  ((48 <= ciphertext[i])&&(ciphertext[i] <= 57)) ||
+	    ((97 <= ciphertext[i])&&(ciphertext[i] <= 102))  ))
+      return 0;
+  }
+
+  return 1;
+}
+
+static void mysql_set_key(char *key, int index) {
+  strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+}
+
+static char *mysql_get_key(int index) {
+    return saved_key;
+}
+
+static int mysql_cmp_all(void *binary, int index) { //also is mysql_cmp_one
+  return !memcmp(binary, crypt_key, BINARY_SIZE);
+}
+
+static int mysql_cmp_exact(char *source, int count){
+  return (1); //  mysql_cmp_all fallthrough?
+}
+
+static void mysql_crypt_all(int count) {
+  // get plaintext input in saved_key put it into ciphertext crypt_key
+  make_scrambled_password(crypt_key,saved_key);
+}
+
+////////////////////////////////////////////////////////////////
+//begin mysql code
+// This code was copied from mysqlpassword.c by Chris Given
+// He probably copied it from password.c in the MySQL source
+// The code is GPLed
+
+void randominit(struct rand_struct *rand_st,unsigned long seed1, unsigned long seed2) {
+  rand_st->max_value= 0x3FFFFFFFL;
+  rand_st->max_value_dbl=(double) rand_st->max_value;
+  rand_st->seed1=seed1%rand_st->max_value ;
+  rand_st->seed2=seed2%rand_st->max_value;
+}
+static void old_randominit(struct rand_struct *rand_st,unsigned long seed1) {
+  rand_st->max_value= 0x01FFFFFFL;
+  rand_st->max_value_dbl=(double) rand_st->max_value;
+  seed1%=rand_st->max_value;
+  rand_st->seed1=seed1 ; rand_st->seed2=seed1/2;
+}
+double rnd(struct rand_struct *rand_st) {
+  rand_st->seed1=(rand_st->seed1*3+rand_st->seed2) %
+    rand_st->max_value;
+  rand_st->seed2=(rand_st->seed1+rand_st->seed2+33) %
+    rand_st->max_value;
+  return(((double) rand_st->seed1)/rand_st->max_value_dbl);
+}
+void hash_password(unsigned long *result, const char *password) {
+  register unsigned long nr=1345345333L, add=7, nr2=0x12345671L;
+  unsigned long tmp;
+  for (; *password ; password++) {
+    if (*password == ' ' || *password == '\t')
+      continue;
+    tmp= (unsigned long) (unsigned char) *password;
+    nr^= (((nr & 63)+add)*tmp)+ (nr << 8);
+    nr2+=(nr2 << 8) ^ nr;
+    add+=tmp;
+  }
+  result[0]=nr & (((unsigned long) 1L << 31) -1L); /* Don't use sign bit
+					      (str2int) */;
+  result[1]=nr2 & (((unsigned long) 1L << 31) -1L);
+  return;
+}
+void make_scrambled_password(char *to,const char *password) {
+  unsigned long hash_res[2];
+  hash_password(hash_res,password);
+  sprintf(to,"%08lx%08lx",hash_res[0],hash_res[1]);
+}
+static inline unsigned int char_val(char X) {
+  return (unsigned int) (X >= '0' && X <= '9' ? X-'0' : X >= 'A' && X <= 'Z' ?
+		 X-'A'+10 : X-'a'+10);
+}
+char *scramble(char *to,const char *message,const char *password, int
+	       old_ver) {
+  struct rand_struct rand_st;
+  unsigned long hash_pass[2],hash_message[2];
+  if(password && password[0]) {
+    char *to_start=to;
+    hash_password(hash_pass,password);
+    hash_password(hash_message,message);
+    if (old_ver)
+      old_randominit(&rand_st,hash_pass[0] ^
+		     hash_message[0]);
+    else
+      randominit(&rand_st,hash_pass[0] ^ hash_message[0],
+		 hash_pass[1] ^ hash_message[1]);
+    while (*message++)
+      *to++= (char) (floor(rnd(&rand_st)*31)+64);
+    if (!old_ver) {
+      char extra=(char) (floor(rnd(&rand_st)*31));
+      while(to_start != to)
+        *(to_start++)^=extra;
+    }
+  }
+  *to=0;
+  return to;
+}
+
+//end mysql code
+////////////////////////////////////////////////////////////////
+
+struct fmt_main fmt_MYSQL = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALGORITHM_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_CASE | FMT_8_BIT,
+    mysql_tests
+    }, {
+      fmt_default_init,
+	  fmt_default_prepare,
+      mysql_valid,
+      fmt_default_split,
+      fmt_default_binary,
+      fmt_default_salt,
+      {
+	fmt_default_binary_hash,
+	fmt_default_binary_hash,
+	fmt_default_binary_hash,
+	fmt_default_binary_hash,
+	fmt_default_binary_hash
+      },
+      fmt_default_salt_hash,
+      fmt_default_set_salt,
+      mysql_set_key,
+      mysql_get_key,
+      fmt_default_clear_keys,
+      mysql_crypt_all,
+      {
+	fmt_default_get_hash,
+	fmt_default_get_hash,
+	fmt_default_get_hash,
+	fmt_default_get_hash,
+	fmt_default_get_hash
+      },
+      mysql_cmp_all,
+      mysql_cmp_all, //should it be the same as cmp_all or same as cmp_exact?
+      mysql_cmp_exact //fallthrough
+    }
+};
diff -rupN john-1.7.8/src/Makefile john-1.7.8-jumbo-2/src/Makefile
--- john-1.7.8/src/Makefile	2011-05-04 20:52:31.000000000 +0200
+++ john-1.7.8-jumbo-2/src/Makefile	2011-07-03 16:03:58.000000000 +0200
@@ -2,43 +2,85 @@
 # This file is part of John the Ripper password cracker,
 # Copyright (c) 1996-2011 by Solar Designer
 #
+# ...with changes in the jumbo patch, by various authors
+#
 
 CC = gcc
 AS = $(CC)
 LD = $(CC)
 CPP = $(CC)
 CP = cp
-LN = ln -sf
+LN = ln -f -s
 RM = rm -f
 TR = tr
 SED = sed
 NULL = /dev/null
 CPPFLAGS = -E
+
+## Uncomment the TWO lines below for MPI (can be used together with OMP as well)
+## If you experience problems with MPI_Barrier, remove -DJOHN_MPI_BARRIER
+## If you experience problems with MPI_Abort, remove -DJOHN_MPI_ABORT
+#CC = mpicc -DHAVE_MPI -DJOHN_MPI_BARRIER -DJOHN_MPI_ABORT
+#MPIOBJ = john-mpi.o
+
+
 OMPFLAGS =
 # gcc with OpenMP
 #OMPFLAGS = -fopenmp
 # Sun Studio with OpenMP (set the OMP_NUM_THREADS env var at runtime)
 #OMPFLAGS = -xopenmp
-CFLAGS = -c -Wall -O2 -fomit-frame-pointer $(OMPFLAGS)
+# icc with OpenMP (for make target linux-x86-64-icc)
+#OMPFLAGS = -openmp
+
+CFLAGS = -c -Wall -O2 -fomit-frame-pointer -I/usr/local/include $(OMPFLAGS)
+# -DHAVE_SKEY
 ASFLAGS = -c $(OMPFLAGS)
-LDFLAGS = -s $(OMPFLAGS)
+LDFLAGS = -s -L/usr/local/lib -L/usr/local/ssl/lib -lcrypto -lssl -lm $(OMPFLAGS)
+# -lskey
+LDFLAGS_SOLARIS = -lrt -lnsl -lsocket
+LDFLAGS_MKV = -s -lm
 OPT_NORMAL = -funroll-loops
 OPT_INLINE = -finline-functions
 
+# Should work on Solaris and gmake
+PLUGFORMATS_SRCS: sh =if [ -f *_plug.c ]; then ls *_plug.c; fi
+PLUGFORMATS_SRCS += $(shell ls *_plug.c)
+PLUGFORMATS_OBJS = $(PLUGFORMATS_SRCS:.c=.o)
+
 JOHN_OBJS = \
+	$(MPIOBJ) \
 	DES_fmt.o DES_std.o DES_bs.o DES_bs_b.o \
 	BSDI_fmt.o \
 	MD5_fmt.o MD5_std.o \
 	BF_fmt.o BF_std.o \
 	AFS_fmt.o \
 	LM_fmt.o \
+	timer.o \
+	md5_go.o \
+	md5_eq.o \
+	md5.o \
+	hmacmd5.o \
+	base64.o \
+	md4.o \
+	md5_gen_fmt.o md5_gen_parser.o md5_gen_preloads.o md5_gen_utils.o \
+	hmailserver_fmt.o \
+	SybaseASE_fmt.o \
+	SKEY_fmt.o \
+	ssh_fmt.o ssh2john.o \
+	pdf_fmt.o pdf2john.o pdfcrack_common.o pdfcrack_md5.o pdfparser.o pdfcrack.o pdfcrack_rc4.o \
+	rar_fmt.o rar2john.o \
+	zip_fmt.o zip2john.o gladman_hmac.o gladman_pwd2key.o \
+	$(PLUGFORMATS_OBJS) \
 	dummy.o \
 	batch.o bench.o charset.o common.o compiler.o config.o cracker.o \
 	crc32.o external.o formats.o getopt.o idle.o inc.o john.o list.o \
 	loader.o logger.o math.o memory.o misc.o options.o params.o path.o \
 	recovery.o rpp.o rules.o signals.o single.o status.o tty.o wordlist.o \
+	mkv.o mkvlib.o \
+	unicode.o \
 	unshadow.o \
 	unafs.o \
+	undrop.o \
 	unique.o
 
 BENCH_DES_OBJS_ORIG = \
@@ -57,18 +99,35 @@ BENCH_BF_OBJS_DEPEND = \
 	BF_fmt.o BF_std.o
 
 BENCH_OBJS = \
+    $(MPIOBJ) \
 	$(BENCH_DES_OBJS_DEPEND) \
 	DES_bs.o $(BENCH_DES_BS_OBJS_DEPEND) \
 	$(BENCH_MD5_OBJS_DEPEND) \
 	$(BENCH_BF_OBJS_DEPEND) \
-	bench.o best.o common.o config.o formats.o math.o memory.o miscnl.o \
+	bench-t.o best.o common.o config.o formats.o math.o memory.o miscnl.o \
 	params.o path.o signals.o tty.o
 
-PROJ = ../run/john ../run/unshadow ../run/unafs ../run/unique
+GENMKVPWD_OBJS = \
+	genmkvpwd.o mkvlib.o memory.o miscnl.o
+
+PROJ = ../run/john ../run/unshadow ../run/unafs ../run/unique ../run/undrop \
+	../run/ssh2john ../run/pdf2john ../run/rar2john ../run/zip2john \
+	../run/genmkvpwd ../run/mkvcalcproba ../run/calc_stat \
+	../run/tgtsnarf
 PROJ_DOS = ../run/john.bin ../run/john.com \
-	../run/unshadow.com ../run/unafs.com ../run/unique.com
+	../run/unshadow.com ../run/unafs.com ../run/unique.com \
+	../run/undrop.com \
+	../run/ssh2john.com ../run/pdf2john.com ../run/rar2john.com ../run/zip2john
 PROJ_WIN32 = ../run/john.exe \
-	../run/unshadow.exe ../run/unafs.exe ../run/unique.exe
+	../run/unshadow.exe ../run/unafs.exe ../run/unique.exe \
+	../run/undrop.exe \
+	../run/ssh2john.exe ../run/pdf2john.exe ../run/rar2john.exe ../run/zip2john.exe \
+	../run/genmkvpwd.exe ../run/mkvcalcproba.exe ../run/calc_stat.exe
+PROJ_WIN32_MINGW = ../run/john-mingw.exe \
+	../run/unshadow.exe ../run/unafs.exe ../run/unique.exe \
+	../run/undrop.exe \
+	../run/ssh2john.exe ../run/pdf2john.exe ../run/rar2john.exe ../run/zip2john.exe \
+	../run/genmkvpwd.exe ../run/mkvcalcproba.exe ../run/calc_stat.exe
 
 default:
 	@echo "To build John the Ripper, type:"
@@ -77,9 +136,14 @@ default:
 	@echo "linux-x86-64             Linux, x86-64 with SSE2 (best tested)"
 	@echo "linux-x86-64-avx         Linux, x86-64 with AVX (experimental)"
 	@echo "linux-x86-64-xop         Linux, x86-64 with AVX and XOP (experimental)"
-#	@echo "linux-x86-64-32-sse2     Linux, x86-64, 32-bit with SSE2"
-#	@echo "linux-x86-64-32-mmx      Linux, x86-64, 32-bit with MMX"
+	@echo "linux-x86-64-icc         Linux, x86-64 compiled with icc (best)"
+	@echo "linux-x86-64-clang       Linux, x86-64 compiled with clang (good)"
+#	@echo "linux-x86-64-32-sse2     Linux, x86-64, 32-bit with SSE2 (for regression tests)"
+#	@echo "linux-x86-64-32-mmx      Linux, x86-64, 32-bit with MMX (for regression tests)"
+#	@echo "linux-x86-64-32-any      Linux, x86-64, 32-bit (for regression tests)"
+#	@echo "linux-x86-64-32-clang    Linux, x86-64, 32-bit compiled with clang (for regression tests)"
 	@echo "linux-x86-sse2           Linux, x86 32-bit with SSE2 (best tested if 32-bit)"
+	@echo "linux-x86-sse2i          Linux, x86 32-bit with SSE2 (32-bit, intrinsic)"
 	@echo "linux-x86-mmx            Linux, x86 32-bit with MMX (for old computers)"
 	@echo "linux-x86-any            Linux, x86 32-bit (for truly ancient computers)"
 	@echo "linux-x86-avx            Linux, x86 32-bit with AVX (experimental)"
@@ -143,6 +207,10 @@ default:
 	@echo "win32-cygwin-x86-sse2    Win32, Cygwin, x86 with SSE2 (best)"
 	@echo "win32-cygwin-x86-mmx     Win32, Cygwin, x86 with MMX"
 	@echo "win32-cygwin-x86-any     Win32, Cygwin, x86"
+	@echo "win32-mingw-x86-sse2     Win32, MinGW, x86 with SSE2 (best)"
+	@echo "win32-mingw-x86-sse2i    Win32, MinGW, x86 with SSE2 (intrinsic)"
+	@echo "win32-mingw-x86-mmx      Win32, MinGW, x86 with MMX"
+	@echo "win32-mingw-x86-any      Win32, MinGW, x86"
 	@echo "beos-x86-sse2            BeOS, x86 with SSE2 (best)"
 	@echo "beos-x86-mmx             BeOS, x86 with MMX"
 	@echo "beos-x86-any             BeOS, x86"
@@ -151,28 +219,44 @@ default:
 linux-x86-64:
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o sse-intrinsics.o" \
 		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
 		LDFLAGS="$(LDFLAGS) -lcrypt"
 
 linux-x86-64-avx:
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o sse-intrinsics.o" \
 		CFLAGS="$(CFLAGS) -mavx -DHAVE_CRYPT" \
 		LDFLAGS="$(LDFLAGS) -lcrypt"
 
 linux-x86-64-xop:
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o sse-intrinsics.o" \
 		CFLAGS="$(CFLAGS) -mxop -DHAVE_CRYPT" \
 		LDFLAGS="$(LDFLAGS) -lcrypt"
 
+linux-x86-64-clang:
+	$(LN) x86-64.h arch.h
+	$(MAKE) $(PROJ) \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o sse-intrinsics.o" \
+		CFLAGS="-c -O2 -I/usr/include -msse2 -DHAVE_CRYPT" \
+		LDFLAGS="-lm -lssl -lcrypto -lcrypt " \
+		CPP="clang" CC="clang" AS="clang" LD="clang"
+
+linux-x86-64-icc:
+	$(LN) x86-64.h arch.h
+	$(MAKE) $(PROJ) \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o sse-intrinsics.o" \
+		CFLAGS="-c -fast -I/usr/include -static-intel -DHAVE_CRYPT $(OMPFLAGS)" \
+		LDFLAGS="-lm -lssl -lcrypto -ipo -no-prec-div -xSSE3 -static-intel -lcrypt $(OMPFLAGS) -s " \
+		CPP="icc" CC="icc" AS="icc" LD="icc"
+
 linux-x86-64-32-sse2:
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		CFLAGS="$(CFLAGS) -m32 -DHAVE_CRYPT" \
 		ASFLAGS="$(ASFLAGS) -m32" \
 		LDFLAGS="$(LDFLAGS) -m32 -lcrypt"
@@ -180,22 +264,46 @@ linux-x86-64-32-sse2:
 linux-x86-64-32-mmx:
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
+		CFLAGS="$(CFLAGS) -m32 -DHAVE_CRYPT" \
+		ASFLAGS="$(ASFLAGS) -m32" \
+		LDFLAGS="$(LDFLAGS) -m32 -lcrypt"
+
+linux-x86-64-32-any:
+	$(LN) x86-any.h arch.h
+	$(MAKE) $(PROJ) \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o" \
 		CFLAGS="$(CFLAGS) -m32 -DHAVE_CRYPT" \
 		ASFLAGS="$(ASFLAGS) -m32" \
 		LDFLAGS="$(LDFLAGS) -m32 -lcrypt"
 
+linux-x86-64-32-clang:
+	$(LN) x86-any.h arch.h
+	$(MAKE) $(PROJ) \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o" \
+		CFLAGS="-c -O2 -I/usr/include -m32 -DHAVE_CRYPT" \
+		ASFLAGS="$(ASFLAGS) -m32" \
+		LDFLAGS="-lm -lssl -lcrypto -lcrypt -m32" \
+		CPP="clang" CC="clang" AS="clang" LD="clang"
+
 linux-x86-sse2:
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
+		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
+		LDFLAGS="$(LDFLAGS) -lcrypt"
+
+linux-x86-sse2i:
+	$(LN) x86-ssei.h arch.h
+	$(MAKE) $(PROJ) \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-sse.o sha1-mmx.o md5-mmx.o sse-intrinsics.o" \
 		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
 		LDFLAGS="$(LDFLAGS) -lcrypt"
 
 linux-x86-mmx:
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
 		LDFLAGS="$(LDFLAGS) -lcrypt"
 
@@ -290,18 +398,18 @@ linux-ia64:
 freebsd-x86-64:
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86-64.o"
+		JOHN_OBJS="$(JOHN_OBJS) x86-64.o sse-intrinsics.o"
 
 freebsd-x86-sse2:
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		ASFLAGS="$(ASFLAGS) -DBSD"
 
 freebsd-x86-mmx:
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		ASFLAGS="$(ASFLAGS) -DBSD"
 
 freebsd-x86-any:
@@ -324,18 +432,18 @@ freebsd-alpha:
 openbsd-x86-64:
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86-64.o"
+		JOHN_OBJS="$(JOHN_OBJS) x86-64.o sse-intrinsics.o"
 
 openbsd-x86-sse2:
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		ASFLAGS="$(ASFLAGS) -DBSD"
 
 openbsd-x86-mmx:
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		ASFLAGS="$(ASFLAGS) -DBSD"
 
 openbsd-x86-any:
@@ -396,103 +504,114 @@ netbsd-vax:
 	$(MAKE) $(PROJ)
 
 solaris-sparc64-cc:
+	$(RM) arch.h
 	$(LN) sparc64.h arch.h
 	$(MAKE) $(PROJ) \
 		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o" \
 		CC=cc \
 		CFLAGS="-c -fast -xarch=native64 -DHAVE_CRYPT $(OMPFLAGS)" \
-		LDFLAGS="-s -xarch=native64 $(OMPFLAGS) -lc -lrt" \
+		LDFLAGS="-s -xarch=native64 $(OMPFLAGS) -lc $(LDFLAGS_SOLARIS)" \
 		OPT_NORMAL="" \
 		OPT_INLINE="-xinline=s1,s2,s3,s4,s5,s6,s7,s8"
 
 solaris-sparc64-gcc:
+	$(RM) arch.h
 	$(LN) sparc64.h arch.h
 	$(MAKE) $(PROJ) \
 		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o" \
 		CFLAGS="$(CFLAGS) -m64 -mcpu=ultrasparc -DHAVE_CRYPT" \
-		LDFLAGS="$(LDFLAGS) -m64 -lrt"
+		LDFLAGS="$(LDFLAGS) -m64 $(LDFLAGS_SOLARIS)"
 
 solaris-sparcv9-cc:
+	$(RM) arch.h
 	$(LN) sparc32.h arch.h
 	$(MAKE) $(PROJ) \
 		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o" \
 		CC=cc \
 		CFLAGS="-c -xO4 -xarch=v8plusa -xchip=ultra -DHAVE_CRYPT $(OMPFLAGS)" \
-		LDFLAGS="-s $(OMPFLAGS) -lc -lrt" \
+		LDFLAGS="-s $(OMPFLAGS) -lc $(LDFLAGS_SOLARIS)" \
 		OPT_NORMAL="" \
 		OPT_INLINE="-xinline=s1,s2,s3,s4,s5,s6,s7,s8"
 
 solaris-sparcv8-cc:
+	$(RM) arch.h
 	$(LN) sparc32.h arch.h
 	$(MAKE) $(PROJ) \
 		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o" \
 		CC=cc \
 		CFLAGS="-c -xO4 -xarch=v8 -DHAVE_CRYPT $(OMPFLAGS)" \
-		LDFLAGS="-s $(OMPFLAGS) -lc -lrt" \
+		LDFLAGS="-s $(OMPFLAGS) -lc $(LDFLAGS_SOLARIS)" \
 		OPT_NORMAL="" \
 		OPT_INLINE="-xinline=s1,s2,s3,s4,s5,s6,s7,s8"
 
 solaris-sparc-gcc:
+	$(RM) arch.h
 	$(LN) sparc32.h arch.h
 	$(MAKE) $(PROJ) \
 		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o" \
 		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
-		LDFLAGS="$(LDFLAGS) -lrt"
+		LDFLAGS="$(LDFLAGS) $(LDFLAGS_SOLARIS)"
 
 solaris-x86-64-cc:
+	$(RM) arch.h
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o sse-intrinsics.o" \
 		CC=cc \
 		CFLAGS="-c -fast -xarch=native64 -DHAVE_CRYPT $(OMPFLAGS)" \
 		ASFLAGS="-c -xarch=native64 $(OMPFLAGS)" \
-		LDFLAGS="-s -xarch=native64 $(OMPFLAGS) -lrt" \
+		LDFLAGS="-s -xarch=native64 $(OMPFLAGS) $(LDFLAGS_SOLARIS)" \
 		OPT_NORMAL="" \
 		OPT_INLINE="-xinline=s1,s2,s3,s4,s5,s6,s7,s8"
 
 solaris-x86-64-gcc:
+	$(RM) arch.h
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o x86-64.o sse-intrinsics.o" \
 		CFLAGS="$(CFLAGS) -m64 -DHAVE_CRYPT" \
 		ASFLAGS="$(CFLAGS) -m64" \
-		LDFLAGS="$(LDFLAGS) -m64 -lrt"
+		LDFLAGS="$(LDFLAGS) -m64 $(LDFLAGS_SOLARIS)"
 
 solaris-x86-sse2-cc:
+	$(RM) arch.h
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		CC=cc \
 		CFLAGS="-c -fast -xarch=native -DHAVE_CRYPT $(OMPFLAGS)" \
 		ASFLAGS="-c -xarch=native $(OMPFLAGS)" \
-		LDFLAGS="-s -xarch=native $(OMPFLAGS) -lrt" \
+		LDFLAGS="-s -xarch=native $(OMPFLAGS) $(LDFLAGS_SOLARIS)" \
 		OPT_NORMAL="" \
 		OPT_INLINE="-xinline=s1,s2,s3,s4,s5,s6,s7,s8"
 
 solaris-x86-sse2-gcc:
+	$(RM) arch.h
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
-		LDFLAGS="$(LDFLAGS) -lrt"
+		LDFLAGS="$(LDFLAGS) $(LDFLAGS_SOLARIS)"
 
 solaris-x86-mmx-cc:
+	$(RM) arch.h
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		CC=cc \
 		CFLAGS="-c -fast -xarch=native -DHAVE_CRYPT $(OMPFLAGS)" \
 		ASFLAGS="-c -xarch=native $(OMPFLAGS)" \
-		LDFLAGS="-s -xarch=native $(OMPFLAGS) -lrt" \
+		LDFLAGS="-s -xarch=native $(OMPFLAGS) $(LDFLAGS_SOLARIS)" \
 		OPT_NORMAL="" \
 		OPT_INLINE="-xinline=s1,s2,s3,s4,s5,s6,s7,s8"
 
 solaris-x86-mmx-gcc:
+	$(RM) arch.h
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
-		LDFLAGS="$(LDFLAGS) -lrt"
+		LDFLAGS="$(LDFLAGS) $(LDFLAGS_SOLARIS)"
 
 solaris-x86-any-cc:
 	$(RM) arch.h
@@ -503,7 +622,7 @@ solaris-x86-any-cc:
 		CC=cc \
 		CFLAGS="-c -xO4 -DHAVE_CRYPT $(OMPFLAGS)" \
 		ASFLAGS="-c $(OMPFLAGS)" \
-		LDFLAGS="-s $(OMPFLAGS) -lc -lrt" \
+		LDFLAGS="-s $(OMPFLAGS) -lc $(LDFLAGS_SOLARIS)" \
 		OPT_NORMAL="" \
 		OPT_INLINE="-xinline=s1,s2,s3,s4,s5,s6,s7,s8"
 
@@ -514,7 +633,7 @@ solaris-x86-any-gcc:
 		SHELL=/bin/sh \
 		JOHN_OBJS="$(JOHN_OBJS) c3_fmt.o solaris-x86.o" \
 		CFLAGS="$(CFLAGS) -DHAVE_CRYPT" \
-		LDFLAGS="$(LDFLAGS) -lc -lrt"
+		LDFLAGS="$(LDFLAGS) -lc $(LDFLAGS_SOLARIS)"
 
 # Older versions of Sun's assembler had a line length restriction (and some
 # other problems, which affect newer versions as well and which are worked
@@ -577,7 +696,7 @@ aix-ppc32:
 macosx-x86-64:
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86-64.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86-64.o sse-intrinsics.o" \
 		ASFLAGS="$(ASFLAGS) -m64 -DUNDERSCORES -DBSD -DALIGN_LOG" \
 		CFLAGS="$(CFLAGS) -m64" \
 		LDFLAGS="$(LDFLAGS) -m64"
@@ -585,7 +704,7 @@ macosx-x86-64:
 macosx-x86-sse2:
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		ASFLAGS="$(ASFLAGS) -m32 -DUNDERSCORES -DBSD -DALIGN_LOG" \
 		CFLAGS="$(CFLAGS) -m32" \
 		LDFLAGS="$(LDFLAGS) -m32"
@@ -593,7 +712,7 @@ macosx-x86-sse2:
 macosx-x86-mmx:
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		ASFLAGS="$(ASFLAGS) -m32 -DUNDERSCORES -DBSD -DALIGN_LOG" \
 		CFLAGS="$(CFLAGS) -m32" \
 		LDFLAGS="$(LDFLAGS) -m32"
@@ -674,7 +793,7 @@ john-macosx-x86-64:
 	$(RM) *.o
 	$(LN) x86-64.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86-64.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86-64.o sse-intrinsics.o" \
 		ASFLAGS="$(ASFLAGS) -arch x86_64 -m64 -DUNDERSCORES -DBSD -DALIGN_LOG" \
 		CFLAGS="$(CFLAGS) -arch x86_64 -m64" \
 		LDFLAGS="$(LDFLAGS) -arch x86_64 -m64"
@@ -684,7 +803,7 @@ john-macosx-x86:
 	$(RM) *.o
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		ASFLAGS="$(ASFLAGS) -arch i386 -m32 -DUNDERSCORES -DBSD -DALIGN_LOG" \
 		CFLAGS="$(CFLAGS) -arch i386 -m32" \
 		LDFLAGS="$(LDFLAGS) -arch i386 -m32"
@@ -749,7 +868,7 @@ irix-mips32:
 dos-djgpp-x86-mmx:
 	copy x86-mmx.h arch.h
 	$(MAKE) $(PROJ_DOS) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		CFLAGS="$(CFLAGS) -mpreferred-stack-boundary=2" \
 		ASFLAGS="$(ASFLAGS) -DUNDERSCORES -DALIGN_LOG"
 
@@ -763,14 +882,14 @@ dos-djgpp-x86-any:
 win32-cygwin-x86-sse2:
 	$(CP) x86-sse.h arch.h
 	$(MAKE) $(PROJ_WIN32) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
 		CFLAGS="$(CFLAGS) -mpreferred-stack-boundary=2" \
 		ASFLAGS="$(ASFLAGS) -DUNDERSCORES"
 
 win32-cygwin-x86-mmx:
 	$(CP) x86-mmx.h arch.h
 	$(MAKE) $(PROJ_WIN32) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o" \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
 		CFLAGS="$(CFLAGS) -mpreferred-stack-boundary=2" \
 		ASFLAGS="$(ASFLAGS) -DUNDERSCORES"
 
@@ -781,15 +900,43 @@ win32-cygwin-x86-any:
 		CFLAGS="$(CFLAGS) -mpreferred-stack-boundary=2" \
 		ASFLAGS="$(ASFLAGS) -DUNDERSCORES"
 
+win32-mingw-x86-sse2i:
+	$(CP) x86-ssei.h arch.h
+	$(MAKE) $(PROJ_WIN32_MINGW) \
+		JOHN_OBJS="sse-intrinsics.o $(JOHN_OBJS) x86.o x86-sse.o " \
+		CFLAGS="$(CFLAGS) -Wall -mpreferred-stack-boundary=4 -msse2 -m32" \
+		ASFLAGS="$(ASFLAGS) -DUNDERSCORES"
+
+win32-mingw-x86-sse2:
+	$(CP) x86-sse.h arch.h
+	$(MAKE) $(PROJ_WIN32_MINGW) \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o sha1-mmx.o md5-mmx.o" \
+		CFLAGS="$(CFLAGS) -Wall -mpreferred-stack-boundary=4 -msse2 -m32" \
+		ASFLAGS="$(ASFLAGS) -DUNDERSCORES"
+
+win32-mingw-x86-mmx:
+	$(CP) x86-mmx.h arch.h
+	$(MAKE) $(PROJ_WIN32_MINGW) \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o sha1-mmx.o md5-mmx.o" \
+		CFLAGS="$(CFLAGS) -mpreferred-stack-boundary=3 -mmmx -m32" \
+		ASFLAGS="$(ASFLAGS) -DUNDERSCORES"
+
+win32-mingw-x86-any:
+	$(CP) x86-any.h arch.h
+	$(MAKE) $(PROJ_WIN32_MINGW) \
+		JOHN_OBJS="$(JOHN_OBJS) x86.o" \
+		CFLAGS="$(CFLAGS) -Wall -mpreferred-stack-boundary=2 -m32" \
+		ASFLAGS="$(ASFLAGS) -DUNDERSCORES"
+
 beos-x86-sse2:
 	$(LN) x86-sse.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o"
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-sse.o sha1-mmx.o md5-mmx.o"
 
 beos-x86-mmx:
 	$(LN) x86-mmx.h arch.h
 	$(MAKE) $(PROJ) \
-		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o"
+		JOHN_OBJS="$(JOHN_OBJS) x86.o x86-mmx.o sha1-mmx.o md5-mmx.o"
 
 beos-x86-any:
 	$(LN) x86-any.h arch.h
@@ -825,6 +972,26 @@ bench: $(BENCH_OBJS)
 	$(RM) ../run/unafs
 	ln -s john ../run/unafs
 
+../run/undrop: ../run/john
+	$(RM) ../run/undrop
+	ln -s john ../run/undrop
+
+../run/ssh2john: ../run/john
+	$(RM) ../run/ssh2john
+	ln -s john ../run/ssh2john
+
+../run/zip2john: ../run/john
+	$(RM) ../run/zip2john
+	ln -s john ../run/zip2john
+
+../run/pdf2john: ../run/john
+	$(RM) ../run/pdf2john
+	ln -s john ../run/pdf2john
+
+../run/rar2john: ../run/john
+	$(RM) ../run/rar2john
+	ln -s john ../run/rar2john
+
 ../run/unique: ../run/john
 	$(RM) ../run/unique
 	ln -s john ../run/unique
@@ -843,16 +1010,47 @@ bench: $(BENCH_OBJS)
 ../run/unafs.com: john.com
 	copy john.com ..\run\unafs.com
 
+../run/undrop.com: john.com
+	copy john.com ..\run\undrop.com
+
+../run/ssh2john.com: john.com
+	copy john.com ..\run\ssh2john.com
+
+../run/pdf2john.com: john.com
+	copy john.com ..\run\pdf2john.com
+
+../run/rar2john.com: john.com
+	copy john.com ..\run\rar2john.com
+
+../run/zip2john.com: john.com
+	copy john.com ..\run\zip2john.com
+
 ../run/unique.com: john.com
 	copy john.com ..\run\unique.com
 
 john.com: john.asm
 	@echo Use Borland TASM/TLINK to make JOHN.COM
 
+# this LD line removed from the ../run/john.exe rule (Cygwin builds)
+# this change needed for full openssl linking, in 1.7.7-jumbo-6
+# this comment should stay for a jumbo or 2, to make sure this does not break
+# other peoples cygwin builds.
+#	$(LD) $(JOHN_OBJS) -lkernel32 -lcrypto -o ../run/john.exe
+
 ../run/john.exe: $(JOHN_OBJS)
-	$(LD) $(JOHN_OBJS) -lkernel32 -o ../run/john.exe
+	$(LD) $(JOHN_OBJS) $(LDFLAGS) -lkernel32 -o ../run/john.exe
 	strip ../run/john.exe
 
+# this LD line removed from the ../run/john-mingw.exe rule (MinGW32 builds)
+# this change needed for full openssl linking, in 1.7.7-jumbo-6
+#	$(LD) $(JOHN_OBJS) -lkernel32 -leay32 -o ../run/john-mingw.exe
+#	$(LD) $(JOHN_OBJS) $(LDFLAGS) -lkernel32 -o ../run/john-mingw.exe
+
+../run/john-mingw.exe: $(JOHN_OBJS)
+	$(LD) $(JOHN_OBJS) $(LDFLAGS) -lkernel32 -o ../run/john-mingw.exe
+	strip ../run/john-mingw.exe
+	cp ../run/john-mingw.exe ../run/john.exe
+
 ../run/unshadow.exe: symlink.c
 	$(CC) symlink.c -o ../run/unshadow.exe
 	strip ../run/unshadow.exe
@@ -861,10 +1059,51 @@ john.com: john.asm
 	$(CC) symlink.c -o ../run/unafs.exe
 	strip ../run/unafs.exe
 
+../run/undrop.exe: symlink.c
+	$(CC) symlink.c -o ../run/undrop.exe
+	strip ../run/undrop.exe
+
+../run/ssh2john.exe: symlink.c
+	$(CC) symlink.c -o ../run/ssh2john.exe
+	strip ../run/ssh2john.exe
+
+../run/pdf2john.exe: symlink.c
+	$(CC) symlink.c -o ../run/pdf2john.exe
+	strip ../run/pdf2john.exe
+
+../run/rar2john.exe: symlink.c
+	$(CC) symlink.c -o ../run/rar2john.exe
+	strip ../run/rar2john.exe
+
+../run/zip2john.exe: symlink.c
+	$(CC) symlink.c -o ../run/zip2john.exe
+	strip ../run/zip2john.exe
+
 ../run/unique.exe: symlink.c
 	$(CC) symlink.c -o ../run/unique.exe
 	strip ../run/unique.exe
 
+../run/genmkvpwd: $(GENMKVPWD_OBJS)
+	$(LD) $(GENMKVPWD_OBJS) $(LDFLAGS) -o ../run/genmkvpwd
+
+../run/genmkvpwd.exe: $(GENMKVPWD_OBJS)
+	$(LD) $(GENMKVPWD_OBJS) $(LDFLAGS_MKV) -o ../run/genmkvpwd.exe
+
+../run/mkvcalcproba: mkvcalcproba.o
+	$(LD) mkvcalcproba.o $(LDFLAGS) -o ../run/mkvcalcproba
+
+../run/mkvcalcproba.exe: mkvcalcproba.o
+	$(LD) mkvcalcproba.o $(LDFLAGS_MKV) -o ../run/mkvcalcproba.exe
+
+../run/calc_stat: calc_stat.o
+	$(LD) calc_stat.o $(LDFLAGS) -o ../run/calc_stat
+
+../run/calc_stat.exe: calc_stat.o
+	$(LD) calc_stat.o $(LDFLAGS_MKV) -o ../run/calc_stat.exe
+
+../run/tgtsnarf: tgtsnarf.o
+	$(LD) tgtsnarf.o $(LDFLAGS) -o ../run/tgtsnarf
+
 # Inlining the S-boxes produces faster code as long as they fit in the cache.
 DES_bs_b.o: DES_bs_b.c sboxes.c nonstd.c sboxes-s.c
 	$(CC) $(CFLAGS) $(OPT_INLINE) DES_bs_b.c
@@ -872,9 +1111,17 @@ DES_bs_b.o: DES_bs_b.c sboxes.c nonstd.c
 miscnl.o: misc.c
 	$(CC) $(CFLAGS) $(OPT_NORMAL) -D_JOHN_MISC_NO_LOG misc.c -o miscnl.o
 
+bench-t.o: bench.c
+	$(CC) $(CFLAGS) $(OPT_NORMAL) -D_JOHN_BENCH_TMP bench.c -o bench-t.o
+
 .c.o:
 	$(CC) $(CFLAGS) $(OPT_NORMAL) $*.c
 
+john.o: john.c $(PLUGFORMATS_SRCS)
+	grep "struct fmt_main [^\*]" *_fmt_plug.c | grep -v extern | grep " =" | sed 's/.c:struct/.c/' | awk '{printf("/* %-22s */ extern struct %s %s;\n",$$1,$$2,$$3);}' > fmt_externs.h
+	grep "struct fmt_main [^\*]" *_fmt_plug.c | grep -v extern | grep " =" | sed 's/.c:struct/.c/' | awk '{printf("/* %-22s */ john_register_one(&%s);\n",$$1,$$3);}' > fmt_registers.h
+	$(CC) -c $(CFLAGS) $(OPT_NORMAL) john.c
+
 .S.o:
 	$(AS) $(ASFLAGS) $*.S
 
@@ -889,9 +1136,10 @@ depend:
 	makedepend -fMakefile.dep -Y *.c 2>> /dev/null
 
 clean:
-	$(RM) $(PROJ) $(PROJ_DOS) $(PROJ_WIN32)
+	$(RM) $(PROJ) $(PROJ_DOS) $(PROJ_WIN32) $(PROJ_WIN32_MINGW)
 	$(RM) ../run/john.exe john-macosx-* *.o *.bak core
 	$(RM) detect bench generic.h arch.h tmp.s
+	$(RM) fmt_registers.h fmt_externs.h
 	$(CP) $(NULL) Makefile.dep
 
 include Makefile.dep
diff -rupN john-1.7.8/src/NETLM_fmt_plug.c john-1.7.8-jumbo-2/src/NETLM_fmt_plug.c
--- john-1.7.8/src/NETLM_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NETLM_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,392 @@
+/*
+ * NETLM_fmt.c -- LM Challenge/Response
+ *
+ * Written by JoMo-Kun <jmk at foofus.net> in 2007
+ * and placed in the public domain.
+ *
+ * Performance and OMP fixes by magnum 2011, no rights reserved
+ *
+ * This algorithm is designed for performing brute-force cracking of the LM
+ * challenge/response pairs exchanged during network-based authentication
+ * attempts [1]. The captured challenge/response pairs from these attempts
+ * should be stored using the L0phtCrack 2.0 LC format, specifically:
+ * username:unused:unused:lm response:ntlm response:challenge. For example:
+ *
+ * CORP\Administrator:::25B2B477CE101D83648BB087CE7A1C217F51C7FC64C0EBB1::
+ * C8BD0C1630A9ECF7A95F494A8F0B2CB4A3F25B1225514304:1122334455667788
+ *
+ * It should be noted that a LM authentication response is not same as a LM
+ * password hash, which can be extracted using tools such as FgDump [2]. LM
+ * responses can be gathered via normal network capture or via tools which
+ * perform layer 2 attacks, such as Ettercap [3] and Cain [4]. The responses can
+ * also be harvested using a modified Samba service [5] in conjunction with
+ * some trickery to convince the user to connect to it. I leave what that
+ * trickery may actually be as an exercise for the reader (HINT: Karma, NMB
+ * broadcasts, IE, Outlook, social engineering, ...).
+ *
+ * [1] http://davenport.sourceforge.net/ntlm.html#theLmResponse
+ * [2] http://www.foofus.net/fizzgig/fgdump/
+ * [3] http://ettercap.sourceforge.net/
+ * [4] http://www.oxid.it/cain.html
+ * [5] http://www.foofus.net/jmk/smbchallenge.html
+ *
+ */
+
+#include <string.h>
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "memory.h"
+
+#include <openssl/des.h>
+
+#ifndef uchar
+#define uchar unsigned char
+#endif
+
+#define FORMAT_LABEL         "netlm"
+#define FORMAT_NAME          "LM C/R DES"
+#define ALGORITHM_NAME       "netlm"
+#define BENCHMARK_COMMENT    ""
+#define BENCHMARK_LENGTH     0
+#define PLAINTEXT_LENGTH     14
+#define PARTIAL_BINARY_SIZE  8
+#define BINARY_SIZE          24
+#define SALT_SIZE            8
+#define CIPHERTEXT_LENGTH    48
+#define TOTAL_LENGTH         8 + 2 * SALT_SIZE + CIPHERTEXT_LENGTH
+
+// these may be altered in init() if running OMP
+// and that formula is subject to change
+#define MIN_KEYS_PER_CRYPT	    1
+#define THREAD_RATIO            256
+#ifdef _OPENMP
+#define MAX_KEYS_PER_CRYPT	    0x10000
+#else
+#define MAX_KEYS_PER_CRYPT	    THREAD_RATIO
+#endif
+
+static struct fmt_tests tests[] = {
+  {"$NETLM$1122334455667788$6E1EC36D3417CE9E09A4424309F116C4C991948DAEB4ADAD", "G3RG3P00!"},
+  {"$NETLM$1122334455667788$16A7FDFE0CA109B937BFFB041F0E5B2D8B94A97D3FCA1A18", "HIYAGERGE"},
+  {"$NETLM$1122334455667788$B3A1B87DBBD4DF3CFA296198DD390C2F4E2E93C5C07B1D8B", "MEDUSAFGDUMP12"},
+  {"$NETLM$1122334455667788$0836F085B124F33895875FB1951905DD2F85252CC731BB25", "CORY21"},
+
+  {"", "G3RG3P00!",      {"User", "", "", "6E1EC36D3417CE9E09A4424309F116C4C991948DAEB4ADAD", "ntlm-hash", "1122334455667788"} },
+  {"", "HIYAGERGE",      {"User", "", "", "16A7FDFE0CA109B937BFFB041F0E5B2D8B94A97D3FCA1A18", "ntlm-hash", "1122334455667788"} },
+  {"", "MEDUSAFGDUMP12", {"User", "", "", "B3A1B87DBBD4DF3CFA296198DD390C2F4E2E93C5C07B1D8B", "ntlm-hash", "1122334455667788"} },
+  {"", "CORY21",         {"User", "", "", "0836F085B124F33895875FB1951905DD2F85252CC731BB25", "ntlm-hash", "1122334455667788"} },
+  {NULL}
+};
+
+static uchar saved_key[MAX_KEYS_PER_CRYPT][21];
+static uchar saved_plain[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1];
+static uchar *challenge;
+static ARCH_WORD_32 output[MAX_KEYS_PER_CRYPT][PARTIAL_BINARY_SIZE/sizeof(ARCH_WORD_32)];
+
+extern struct fmt_main fmt_NETLM;
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = MIN_KEYS_PER_CRYPT * omp_get_max_threads();
+	if (n < MIN_KEYS_PER_CRYPT)
+		n = MIN_KEYS_PER_CRYPT;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETLM.params.min_keys_per_crypt = n;
+	n = n * n * ((n >> 1) + 1) * THREAD_RATIO;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETLM.params.max_keys_per_crypt = n;
+#endif
+}
+
+static int netlm_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+  char *pos;
+
+  if (strncmp(ciphertext, "$NETLM$", 5)!=0) return 0;
+  if (ciphertext[23] != '$') return 0;
+
+  if (strncmp(&ciphertext[24 + 2 * SALT_SIZE],
+              "00000000000000000000000000000000", 32) == 0)
+	  return 0; // This is NTLM ESS C/R
+
+  for (pos = &ciphertext[24]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++);
+    if (!*pos && pos - ciphertext - 24 == CIPHERTEXT_LENGTH)
+      return 1;
+    else
+      return 0;
+}
+
+static char *netlm_prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	char *cp;
+	if (!strncmp(split_fields[1], "$NETLM$", 7))
+		return split_fields[1];
+	if (strlen(split_fields[3]) != CIPHERTEXT_LENGTH)
+		return split_fields[1];
+
+	// if LMresp == NTresp then it's NTLM-only, not LM
+	if (!strncmp(split_fields[3], split_fields[4], 48))
+		return split_fields[1];
+
+	cp = mem_alloc(7+strlen(split_fields[3])+1+strlen(split_fields[5])+1);
+	sprintf(cp, "$NETLM$%s$%s", split_fields[5], split_fields[3]);
+
+	if (netlm_valid(cp,pFmt)) {
+		char *cp2 = str_alloc_copy(cp);
+		free(cp);
+		return cp2;
+	}
+	free(cp);
+	return split_fields[1];
+}
+
+
+static char *netlm_split(char *ciphertext, int index)
+{
+  static char out[TOTAL_LENGTH + 1];
+
+  memset(out, 0, TOTAL_LENGTH + 1);
+  memcpy(&out, ciphertext, TOTAL_LENGTH);
+  strlwr(&out[6]); /* Exclude: $NETLM$ */
+
+  return out;
+}
+
+static void *netlm_get_binary(char *ciphertext)
+{
+  static uchar *binary;
+  int i;
+
+  if (!binary) binary = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+  ciphertext+=24;
+  for (i=0; i<BINARY_SIZE; i++)
+  {
+    binary[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])])<<4;
+    binary[i] |= (atoi16[ARCH_INDEX(ciphertext[i*2+1])]);
+  }
+
+  return binary;
+}
+
+static inline void setup_des_key(unsigned char key_56[], DES_key_schedule *ks)
+{
+  DES_cblock key;
+
+  key[0] = key_56[0];
+  key[1] = (key_56[0] << 7) | (key_56[1] >> 1);
+  key[2] = (key_56[1] << 6) | (key_56[2] >> 2);
+  key[3] = (key_56[2] << 5) | (key_56[3] >> 3);
+  key[4] = (key_56[3] << 4) | (key_56[4] >> 4);
+  key[5] = (key_56[4] << 3) | (key_56[5] >> 5);
+  key[6] = (key_56[5] << 2) | (key_56[6] >> 6);
+  key[7] = (key_56[6] << 1);
+
+  DES_set_key(&key, ks);
+}
+
+static void netlm_crypt_all(int count)
+{
+	DES_key_schedule ks;
+	int i;
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_key)
+#endif
+	for(i=0; i<count; i++) {
+
+		/* Just do a partial binary, the first DES operation */
+		setup_des_key(saved_key[i], &ks);
+		DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)output[i], &ks, DES_ENCRYPT);
+	}
+}
+
+static int netlm_cmp_all(void *binary, int count)
+{
+	int index;
+	for(index=0; index<count; index++)
+		if (!memcmp(output[index], binary, PARTIAL_BINARY_SIZE))
+			return 1;
+	return 0;
+}
+
+static int netlm_cmp_one(void *binary, int index)
+{
+	return !memcmp(output[index], binary, PARTIAL_BINARY_SIZE);
+}
+
+static int netlm_cmp_exact(char *source, int index)
+{
+	DES_key_schedule ks;
+	uchar binary[BINARY_SIZE];
+
+	/* NULL-pad 16-byte LM hash to 21-bytes (we postponed it until now) */
+	memset(&saved_key[index][16], 0, 5);
+
+	/* Split padded LM hash into three 7-byte thirds
+	   DES-encrypt challenge using each third as a key
+	   Concatenate three 8-byte resulting values to form 24-byte LM response */
+	setup_des_key(saved_key[index], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)binary, &ks, DES_ENCRYPT);
+	setup_des_key(&saved_key[index][7], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)&binary[8], &ks, DES_ENCRYPT);
+	setup_des_key(&saved_key[index][14], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)&binary[16], &ks, DES_ENCRYPT);
+
+	return (!memcmp(binary, netlm_get_binary(source), BINARY_SIZE));
+}
+
+static void *netlm_get_salt(char *ciphertext)
+{
+  static unsigned char *binary_salt;
+  int i;
+
+  if (!binary_salt) binary_salt = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);
+
+  ciphertext += 7;
+  for (i = 0; i < SALT_SIZE; ++i)
+    binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+  return (void*)binary_salt;
+}
+
+static void netlm_set_salt(void *salt)
+{
+	challenge = salt;
+}
+
+static void netlm_set_key(char *key, int index)
+{
+	const unsigned char magic[] = {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25};
+	DES_key_schedule ks;
+	int i = 0;
+
+	strncpy((char *)saved_plain[index], key, sizeof(saved_plain[index]));
+	saved_plain[index][sizeof(saved_plain[index])-1] = 0;
+
+	/* Upper-case password */
+	for(; i<PLAINTEXT_LENGTH && saved_plain[index][i] != 0; i++)
+		if ((saved_plain[index][i] >= 'a') && (saved_plain[index][i] <= 'z')) saved_plain[index][i] ^= 0x20;
+
+	/* Generate 16-byte LM hash */
+	setup_des_key(saved_plain[index], &ks);
+	DES_ecb_encrypt((DES_cblock*)magic, (DES_cblock*)saved_key[index], &ks, DES_ENCRYPT);
+	setup_des_key(&saved_plain[index][7], &ks);
+	DES_ecb_encrypt((DES_cblock*)magic, (DES_cblock*)&saved_key[index][8], &ks, DES_ENCRYPT);
+
+	/* NULL-padding the 16-byte LM hash to 21-bytes is done in cmp_exact */
+}
+
+static char *netlm_get_key(int index)
+{
+	return (char*)saved_plain[index];
+}
+
+static int salt_hash(void *salt)
+{
+	return *(ARCH_WORD_32 *)salt & (SALT_HASH_SIZE - 1);
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFFF;
+}
+
+struct fmt_main fmt_NETLM = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALGORITHM_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_8_BIT | FMT_BS | FMT_SPLIT_UNIFIES_CASE | FMT_OMP,
+    tests
+  }, {
+    init,
+	netlm_prepare,
+    netlm_valid,
+    netlm_split,
+    netlm_get_binary,
+    netlm_get_salt,
+    {
+	    binary_hash_0,
+	    binary_hash_1,
+	    binary_hash_2,
+	    binary_hash_3,
+	    binary_hash_4
+    },
+    salt_hash,
+    netlm_set_salt,
+    netlm_set_key,
+    netlm_get_key,
+    fmt_default_clear_keys,
+    netlm_crypt_all,
+    {
+	    get_hash_0,
+	    get_hash_1,
+	    get_hash_2,
+	    get_hash_3,
+	    get_hash_4
+    },
+    netlm_cmp_all,
+    netlm_cmp_one,
+    netlm_cmp_exact
+  }
+};
diff -rupN john-1.7.8/src/NETLMv2_fmt_plug.c john-1.7.8-jumbo-2/src/NETLMv2_fmt_plug.c
--- john-1.7.8/src/NETLMv2_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NETLMv2_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,562 @@
+/*
+ * NETLMv2_fmt.c -- LMv2 Challenge/Response
+ *
+ * Written by JoMo-Kun <jmk at foofus.net> in 2008
+ * and placed in the public domain.
+ *
+ * Performance fixes, OMP and utf-8 support by magnum 2010-2011
+ * no rights reserved.
+ *
+ * This algorithm is designed for performing brute-force cracking of the LMv2
+ * challenge/response sets exchanged during network-based authentication
+ * attempts [1]. The captured challenge/response set from these attempts
+ * should be stored using the following format:
+ *
+ * USERNAME::DOMAIN:SERVER CHALLENGE:LMv2 RESPONSE:CLIENT CHALLENGE
+ *
+ * For example:
+ * Administrator::WORKGROUP:1122334455667788:6759A5A7EFB25452911DE7DE8296A0D8:F503236B200A5B3A
+ *
+ * It should be noted that a LMv2 authentication response is not same as a LM
+ * password hash, which can be extracted using tools such as FgDump [2]. In
+ * fact, a NTLM hash and not a LM hash is used within the LMv2 algorithm. LMv2
+ * challenge/response authentication typically takes place when the GPO
+ * "Network Security: LAN Manager authentication level" is configured to a setting
+ * that enforces the use of NTLMv2, such as "Send NTLMv2 response only\refuse
+ * LM & NTLM."
+ *
+ * LMv2 responses can be gathered via normal network capture or via tools which
+ * perform layer 2 attacks, such as Ettercap [3] and Cain [4]. The responses can
+ * also be harvested using a modified Samba service [5] in conjunction with
+ * some trickery to convince the user to connect to it. I leave what that
+ * trickery may actually be as an exercise for the reader (HINT: Karma, NMB
+ * broadcasts, IE, Outlook, social engineering, ...).
+ *
+ * [1] http://davenport.sourceforge.net/ntlm.html#theLmv2Response
+ * [2] http://www.foofus.net/fizzgig/fgdump/
+ * [3] http://ettercap.sourceforge.net/
+ * [4] http://www.oxid.it/cain.html
+ * [5] http://www.foofus.net/jmk/smbchallenge.html
+ *
+ */
+
+#include <string.h>
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+#include "unicode.h"
+
+#if 0
+#warning INFO: We are using OpenSSL HMAC_MD5
+#include <openssl/hmac.h>
+static void hmac_md5(const unsigned char *key, const unsigned char *data, int datalen, unsigned char *digest)
+{
+	HMAC(EVP_md5(), key, 16, data, datalen, digest, NULL);
+}
+#else
+#include "md5.h"
+#include "hmacmd5.h"
+// Move a hmac_md5_init() from crypt_all to set_key(),
+// and store &ctx in saved_key.
+//
+// Pro: saves another key setup using same key
+// Con: larger saved_key (288 bytes vs 16)
+//
+// This boosted performance with about 8%
+#define SPLIT_HMACMD5
+#endif
+
+#ifndef uchar
+#define uchar unsigned char
+#endif
+
+#define FORMAT_LABEL         "netlmv2"
+#define FORMAT_NAME          "LMv2 C/R MD4 HMAC-MD5"
+#define ALGORITHM_NAME       "netlmv2"
+#define BENCHMARK_COMMENT    ""
+#define BENCHMARK_LENGTH     0
+#define PLAINTEXT_LENGTH     54 /* lmcons.h - PWLEN (256) ? 127 ? */
+#define UTF8_PLAINTEXT_LEN   125
+#define USERNAME_LENGTH      20 /* lmcons.h - UNLEN (256) / LM20_UNLEN (20) */
+#define DOMAIN_LENGTH        15 /* lmcons.h - CNLEN / DNLEN */
+#define BINARY_SIZE          16
+#define CHALLENGE_LENGTH     32
+#define SALT_SIZE            16 + 1 + 2 * (USERNAME_LENGTH + DOMAIN_LENGTH) + 1
+#define CIPHERTEXT_LENGTH    32
+#define TOTAL_LENGTH         12 + USERNAME_LENGTH + DOMAIN_LENGTH + CHALLENGE_LENGTH + CIPHERTEXT_LENGTH
+
+// these may be altered in init() if running OMP
+// and that formula is subject to change
+#define MIN_KEYS_PER_CRYPT	    1
+#define THREAD_RATIO            64
+#ifdef _OPENMP
+#define MAX_KEYS_PER_CRYPT	    0x10000
+#else
+#define MAX_KEYS_PER_CRYPT	    THREAD_RATIO
+#endif
+
+static struct fmt_tests tests[] = {
+  {"$NETLMv2$ADMINISTRATORFOODOM$1122334455667788$6F64C5C1E35F68DD80388C0F00F34406$F0F3FF27037AA69F", "1337adminPASS"},
+  {"$NETLMv2$USER1$1122334455667788$B1D163EA5881504F3963DC50FCDC26C1$EB4D9E8138149E20", "foobar"},
+  {"$NETLMv2$ATEST$1122334455667788$83B59F1536D3321DBF1FAEC14ADB1675$A1E7281FE8C10E53", "SomeFancyP4$$w0rdHere"},
+  {"", "1337adminPASS",         {"FOODOM\\Administrator", "", "",       "1122334455667788", "6F64C5C1E35F68DD80388C0F00F34406", "F0F3FF27037AA69F"} },
+  {"", "1337adminPASS",         {"administrator",         "", "FOODOM", "1122334455667788", "6F64C5C1E35F68DD80388C0F00F34406", "F0F3FF27037AA69F"} },
+  {"", "foobar",                {"user1",                 "", "",       "1122334455667788", "B1D163EA5881504F3963DC50FCDC26C1", "EB4D9E8138149E20"} },
+  {"", "SomeFancyP4$$w0rdHere", {"aTest",                 "", "",       "1122334455667788", "83B59F1536D3321DBF1FAEC14ADB1675", "A1E7281FE8C10E53"} },
+  {NULL}
+};
+
+static unsigned char saved_plain[MAX_KEYS_PER_CRYPT][UTF8_PLAINTEXT_LEN+1];
+static unsigned char *challenge;
+static ARCH_WORD_32 output[MAX_KEYS_PER_CRYPT][BINARY_SIZE/sizeof(ARCH_WORD_32)];
+
+#ifdef SPLIT_HMACMD5
+static HMACMD5Context saved_key[MAX_KEYS_PER_CRYPT];
+#else
+static unsigned char saved_key[MAX_KEYS_PER_CRYPT][16];
+#endif
+
+#if !defined(uint16) && !defined(HAVE_UINT16_FROM_RPC_RPC_H)
+#if (SIZEOF_SHORT == 4)
+#define uint16 __ERROR___CANNOT_DETERMINE_TYPE_FOR_INT16;
+#else /* SIZEOF_SHORT != 4 */
+#define uint16 unsigned short
+#endif /* SIZEOF_SHORT != 4 */
+#endif
+
+#if !defined(int16) && !defined(HAVE_INT16_FROM_RPC_RPC_H)
+#if (SIZEOF_SHORT == 4)
+#define int16 __ERROR___CANNOT_DETERMINE_TYPE_FOR_INT16;
+#else /* SIZEOF_SHORT != 4 */
+#define int16 short
+#endif /* SIZEOF_SHORT != 4 */
+#endif
+
+#include "byteorder.h"
+
+extern struct fmt_main fmt_NETLMv2;
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = MIN_KEYS_PER_CRYPT * omp_get_max_threads();
+	if (n < MIN_KEYS_PER_CRYPT)
+		n = MIN_KEYS_PER_CRYPT;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETLMv2.params.min_keys_per_crypt = n;
+	n = n * n * ((n >> 1) + 1) * THREAD_RATIO;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETLMv2.params.max_keys_per_crypt = n;
+#endif
+	if (options.flags & FLG_UTF8) {
+		// in utf-8, up to four bytes can compose one character
+		fmt_NETLMv2.params.plaintext_length = UTF8_PLAINTEXT_LEN;
+	}
+}
+
+static int netlmv2_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+  char *pos, *pos2;
+
+  if (ciphertext == NULL) return 0;
+  else if (strncmp(ciphertext, "$NETLMv2$", 9)!=0) return 0;
+
+  pos = &ciphertext[9];
+
+  /* Validate Username and Domain Length */
+  for (pos2 = pos; strncmp(pos2, "$", 1) != 0; pos2++)
+    if ( (*pos2 < 0x20) || (*pos2 > 0x7E) )
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos <= USERNAME_LENGTH + DOMAIN_LENGTH)) )
+    return 0;
+
+  /* Validate Server Challenge Length */
+  pos2++; pos = pos2;
+  for (; strncmp(pos2, "$", 1) != 0; pos2++)
+    if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos == CHALLENGE_LENGTH / 2)) )
+    return 0;
+
+  /* Validate LMv2 Response Length */
+  pos2++; pos = pos2;
+  for (; strncmp(pos2, "$", 1) != 0; pos2++)
+    if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos == CIPHERTEXT_LENGTH)) )
+    return 0;
+
+  /* Validate Client Challenge Length */
+  pos2++; pos = pos2;
+  for (; atoi16[ARCH_INDEX(*pos2)] != 0x7F; pos2++);
+  if (pos2 - pos != CHALLENGE_LENGTH / 2)
+    return 0;
+
+  return 1;
+}
+
+static char *netlmv2_prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+//	else if (options.format && ((strncmp(options.format, "netlmv2", 7)==0) ||
+//			(strncmp(options.format, "netntlmv2", 9)==0))) {
+//		char *srv_challenge = ldr_get_field(&line, db_options->field_sep_char);
+//		char *nethashv2 = ldr_get_field(&line, db_options->field_sep_char);
+//		char *cli_challenge = ldr_get_field(&line, db_options->field_sep_char);
+//		char *identity = NULL;
+//		int i;
+//
+//	/* DOMAIN\USER: -or- USER::DOMAIN: */
+//	if ((tmp = strstr(*login, "\\")) != NULL) {
+//		identity = (char *) mem_alloc(strlen(*login));
+//	  	strcpy(identity, tmp + 1);
+//
+//		/* Upper-Case Username - Not Domain */
+//		for(i=0; i<strlen(identity); i++)
+//		 if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+//
+//		  strncat(identity, *login, tmp - *login);
+//	}
+//	else {
+//		identity = (char *) mem_alloc(strlen(*login) + strlen(uid) + 1);
+//		strcpy(identity, *login);
+//
+//			for(i=0; i<strlen(identity); i++)
+//		if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+//
+//		strcat(identity, uid);
+//	}
+//	if (strncmp(options.format, "netlmv2", 7)==0) {
+//		  tmp = (char *) mem_alloc_tiny(9 + strlen(identity) + 1 + strlen(srv_challenge) + 1 + strlen(nethashv2) + 1 + strlen(cli_challenge) + 1, MEM_ALIGN_NONE);
+//		  sprintf(tmp, "$NETLMv2$%s$%s$%s$%s", identity, srv_challenge, nethashv2, cli_challenge);
+//		*ciphertext = tmp;
+//	}
+//	else {
+//		  tmp = (char *) mem_alloc_tiny(9 + strlen(identity) + 1 + strlen(srv_challenge) + 1 + strlen(nethashv2) + 1 + strlen(cli_challenge) + 1, MEM_ALIGN_NONE);
+//		  sprintf(tmp, "$NETNTLMv2$%s$%s$%s$%s", identity, srv_challenge, nethashv2, cli_challenge);
+//		  *ciphertext = tmp;
+//	}
+//
+//		MEM_FREE(identity);
+//	}
+
+	char *srv_challenge = split_fields[3];
+	char *nethashv2     = split_fields[4];
+	char *cli_challenge = split_fields[5];
+	char *login = split_fields[0];
+	char *uid = split_fields[2];
+	char *identity = NULL, *tmp;
+	int i;
+
+	if (!strncmp(split_fields[1], "$NETLMv2$", 9))
+		return split_fields[1];
+	/* DOMAIN\USER: -or- USER::DOMAIN: */
+	if ((tmp = strstr(login, "\\")) != NULL) {
+		identity = (char *) mem_alloc(strlen(login));
+	  	strcpy(identity, tmp + 1);
+
+		/* Upper-Case Username - Not Domain */
+		for(i=0; i<strlen(identity); i++)
+		 if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+
+		  strncat(identity, login, tmp - login);
+	}
+	else {
+		identity = (char *) mem_alloc(strlen(login) + strlen(uid) + 1);
+		strcpy(identity, login);
+
+			for(i=0; i<strlen(identity); i++)
+		if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+		strcat(identity, uid);
+	}
+	tmp = (char *) mem_alloc(9 + strlen(identity) + 1 + strlen(srv_challenge) + 1 + strlen(nethashv2) + 1 + strlen(cli_challenge) + 1);
+	sprintf(tmp, "$NETLMv2$%s$%s$%s$%s", identity, srv_challenge, nethashv2, cli_challenge);
+	MEM_FREE(identity);
+
+	if (netlmv2_valid(tmp, pFmt)) {
+		char *cp = str_alloc_copy(tmp);
+		MEM_FREE(tmp);
+		return cp;
+	}
+	MEM_FREE(tmp);
+	return split_fields[1];
+}
+
+
+static char *netlmv2_split(char *ciphertext, int index)
+{
+  static char out[TOTAL_LENGTH + 1];
+  char *pos = NULL;
+  int identity_length = 0;
+
+  /* Calculate identity length */
+  for (pos = ciphertext + 9; strncmp(pos, "$", 1) != 0; pos++);
+  identity_length = pos - (ciphertext + 9);
+
+  memset(out, 0, TOTAL_LENGTH + 1);
+  memcpy(&out, ciphertext, strlen(ciphertext));
+  strlwr(&out[10 + identity_length]); /* Exclude: $NETLMv2$USERDOMAIN$ */
+
+  return out;
+}
+
+static void *netlmv2_get_binary(char *ciphertext)
+{
+  static uchar *binary;
+  char *pos = NULL;
+  int i, identity_length;
+
+  if (!binary) binary = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+  for (pos = ciphertext + 9; strncmp(pos, "$", 1) != 0; pos++);
+  identity_length = pos - (ciphertext + 9);
+
+  ciphertext += 9 + identity_length + 1 + CHALLENGE_LENGTH / 2 + 1;
+  for (i=0; i<BINARY_SIZE; i++)
+  {
+    binary[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])])<<4;
+    binary[i] |= (atoi16[ARCH_INDEX(ciphertext[i*2+1])]);
+  }
+
+  return binary;
+}
+
+/* Calculate the LMv2 response for the given challenge, using the
+   specified authentication identity (username and domain), password
+   and client nonce.
+*/
+static void netlmv2_crypt_all(int count)
+{
+	unsigned char ntlm_v2_hash[16];
+	int i;
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i, ntlm_v2_hash) shared(count, saved_key, challenge, output)
+#endif
+	for(i=0; i<count; i++) {
+		/* Generate 16-byte NTLMv2 Hash */
+		/* HMAC-MD5(Username + Domain, NTLM Hash) */
+#ifdef SPLIT_HMACMD5
+		HMACMD5Context ctx; // can't be moved above the OMP pragma
+		memcpy(&ctx, &saved_key[i], sizeof(ctx));
+		hmac_md5_update(&challenge[17], (int)challenge[16], &ctx);
+		hmac_md5_final(ntlm_v2_hash, &ctx);
+#else
+		hmac_md5(saved_key[i], &challenge[17], (int)challenge[16], ntlm_v2_hash);
+#endif
+
+		/* Generate 16-byte non-client nonce portion of LMv2 Response */
+		/* HMAC-MD5(Challenge + Nonce, NTLMv2 Hash) + Nonce */
+		hmac_md5(ntlm_v2_hash, challenge, 16, (unsigned char*)output[i]);
+	}
+}
+
+static int netlmv2_cmp_all(void *binary, int count)
+{
+	int index;
+	for(index=0; index<count; index++)
+		if (!memcmp(output[index], binary, BINARY_SIZE))
+			return 1;
+	return 0;
+}
+
+static int netlmv2_cmp_one(void *binary, int index)
+{
+	return !memcmp(output[index], binary, BINARY_SIZE);
+}
+
+static int netlmv2_cmp_exact(char *source, int index)
+{
+	return !memcmp(output[index], netlmv2_get_binary(source), BINARY_SIZE);
+}
+
+/* We're essentially using three salts, but we're going to pack it into a single blob for now.
+   |Client Challenge (8 Bytes)|Server Challenge (8 Bytes)|Unicode(Username (<=20).Domain (<=15))
+*/
+static void *netlmv2_get_salt(char *ciphertext)
+{
+  static unsigned char *binary_salt;
+  unsigned char identity[USERNAME_LENGTH + DOMAIN_LENGTH + 1];
+  UTF16 identity_usc[USERNAME_LENGTH + DOMAIN_LENGTH + 1];
+  int i, identity_length;
+  int identity_usc_length;
+  char *pos = NULL;
+
+  if (!binary_salt) binary_salt = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);
+
+  /* Calculate identity length */
+  for (pos = ciphertext + 9; strncmp(pos, "$", 1) != 0; pos++);
+  identity_length = pos - (ciphertext + 9);
+
+  /* Convert identity (username + domain) string to NT unicode */
+  strnzcpy((char *)identity, ciphertext + 9, sizeof(identity));
+  identity_usc_length = plaintowcs((UTF16 *)identity_usc, USERNAME_LENGTH + DOMAIN_LENGTH, (UTF8 *)identity, identity_length) * sizeof(int16);
+
+  if (identity_usc_length < 0) // Truncated at Unicode conversion.
+	  identity_usc_length = strlen16((UTF16 *)identity_usc) * sizeof(int16);
+
+  binary_salt[16] = (unsigned char)identity_usc_length;
+  memcpy(&binary_salt[17], (char *)identity_usc, identity_usc_length);
+
+  /* Set server challenge */
+  ciphertext += 10 + identity_length;
+
+  for (i = 0; i < 8; i++)
+    binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+  /* Set client challenge */
+  ciphertext += 2 + CHALLENGE_LENGTH / 2 + CIPHERTEXT_LENGTH;
+
+  for (i = 0; i < 8; ++i)
+    binary_salt[i + 8] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+  /* Return a concatenation of the server and client challenges and the identity value */
+  return (void*)binary_salt;
+}
+
+static void netlmv2_set_salt(void *salt)
+{
+	challenge = salt;
+}
+
+static void netlmv2_set_key(char *key, int index)
+{
+	int len;
+#ifdef SPLIT_HMACMD5
+	unsigned char ntlm[16];
+#endif
+
+	len = strlen(key);
+	memcpy((char *)saved_plain[index], key, len + 1);
+
+#ifdef SPLIT_HMACMD5
+	/* Generate 16-byte NTLM hash */
+	len = E_md4hash(saved_plain[index], len, ntlm);
+
+	// We do key setup of the next HMAC_MD5 here. rest in crypt_all()
+	// &saved_key is now &ctx
+	hmac_md5_init_K16(ntlm, &saved_key[index]);
+#else
+	/* Generate 16-byte NTLM hash */
+	len = E_md4hash(saved_plain[index], len, saved_key[index]);
+#endif
+
+	if (len <= 0)
+		saved_plain[index][-len] = 0; // match truncation
+}
+
+static char *netlmv2_get_key(int index)
+{
+  return (char *)saved_plain[index];
+}
+
+static int salt_hash(void *salt)
+{
+	// Hash the client challenge (in case server salt was spoofed)
+	return (*(ARCH_WORD_32 *)salt+8) & (SALT_HASH_SIZE - 1);
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFFF;
+}
+
+struct fmt_main fmt_NETLMv2 = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALGORITHM_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP | FMT_UNICODE | FMT_UTF8,
+    tests
+  }, {
+    init,
+	netlmv2_prepare,
+    netlmv2_valid,
+    netlmv2_split,
+    netlmv2_get_binary,
+    netlmv2_get_salt,
+    {
+	    binary_hash_0,
+	    binary_hash_1,
+	    binary_hash_2,
+	    binary_hash_3,
+	    binary_hash_4
+    },
+    salt_hash,
+    netlmv2_set_salt,
+    netlmv2_set_key,
+    netlmv2_get_key,
+    fmt_default_clear_keys,
+    netlmv2_crypt_all,
+    {
+	    get_hash_0,
+	    get_hash_1,
+	    get_hash_2,
+	    get_hash_3,
+	    get_hash_4
+    },
+    netlmv2_cmp_all,
+    netlmv2_cmp_one,
+    netlmv2_cmp_exact
+  }
+};
diff -rupN john-1.7.8/src/NETNTLM_fmt_plug.c john-1.7.8-jumbo-2/src/NETNTLM_fmt_plug.c
--- john-1.7.8/src/NETNTLM_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NETNTLM_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,426 @@
+/*
+ * NETNTLM_fmt.c -- NTLM Challenge/Response
+ *
+ * Written by JoMo-Kun <jmk at foofus.net> in 2007
+ * and placed in the public domain.
+ *
+ * Modified for performance, support for Extended Session Security, OMP
+ * and UTF-8, by magnum 2010-2011. No rights reserved.
+ *
+ * This algorithm is designed for performing brute-force cracking of the NTLM
+ * (version 1) challenge/response pairs exchanged during network-based
+ * authentication attempts [1]. The captured challenge/response pairs from these
+ * attempts should be stored using the L0phtCrack 2.0 LC format, specifically:
+ * username:unused:unused:lm response:ntlm response:challenge. For example:
+ *
+ * CORP\Administrator:::25B2B477CE101D83648BB087CE7A1C217F51C7FC64C0EBB1:
+ * C8BD0C1630A9ECF7A95F494A8F0B2CB4A3F25B1225514304:1122334455667788
+ *
+ * It should be noted that a NTLM authentication response is not same as a NTLM
+ * password hash, which can be extracted using tools such as FgDump [2]. NTLM
+ * responses can be gathered via normal network capture or via tools which
+ * perform layer 2 attacks, such as Ettercap [3] and Cain [4]. The responses can
+ * also be harvested using a modified Samba service [5] in conjunction with
+ * some trickery to convince the user to connect to it. I leave what that
+ * trickery may actually be as an exercise for the reader (HINT: Karma, NMB
+ * broadcasts, IE, Outlook, social engineering, ...).
+ *
+ * [1] http://davenport.sourceforge.net/ntlm.html#theNtLmResponse
+ * [2] http://www.foofus.net/fizzgig/fgdump/
+ * [3] http://ettercap.sourceforge.net/
+ * [4] http://www.oxid.it/cain.html
+ * [5] http://www.foofus.net/jmk/smbchallenge.html
+ *
+ * This version supports Extended Session Security. This is what
+ * is used when the "LM" hash ends in 32 zeros:
+ *
+ * DOMAIN\User:::c70e4fb229437ef300000000000000000000000000000000:
+ * abf7762caf2b1bbfc5cfc1f46665249f049e0af72ae5b5a9:24ca92fdab441aa4
+ *
+ */
+
+#include <string.h>
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+
+#include "md5.h"
+#include <openssl/des.h>
+
+#include "unicode.h"
+
+#ifndef uchar
+#define uchar unsigned char
+#endif
+
+#define FORMAT_LABEL         "netntlm"
+#define FORMAT_NAME          "NTLMv1 C/R MD4 DES [ESS MD5]"
+#define ALGORITHM_NAME       "netntlm"
+#define BENCHMARK_COMMENT    ""
+#define BENCHMARK_LENGTH     0
+#define PLAINTEXT_LENGTH     54 /* ?127? */
+#define UTF8_PLAINTEXT_LEN   125
+#define BINARY_SIZE          24
+#define PARTIAL_BINARY_SIZE  8
+#define SALT_SIZE            8
+#define CIPHERTEXT_LENGTH    48
+#define TOTAL_LENGTH         (10 + 2 * 2 * SALT_SIZE + CIPHERTEXT_LENGTH)
+
+// these may be altered in init() if running OMP
+// and that formula is subject to change
+#define MIN_KEYS_PER_CRYPT	    1
+#define THREAD_RATIO            128
+#ifdef _OPENMP
+#define MAX_KEYS_PER_CRYPT	    0x10000
+#else
+#define MAX_KEYS_PER_CRYPT	    THREAD_RATIO
+#endif
+
+static struct fmt_tests tests[] = {
+  {"$NETNTLM$1122334455667788$BFCCAF26128EC95F9999C9792F49434267A1D9B0EF89BFFB", "g3rg3g3rg3g3rg3"},
+  {"$NETNTLM$1122334455667788$E463FAA5D868ECE20CAE622474A2F440A652D642156AF863", "M1xedC4se%^&*@)##(blahblah!@#"},
+  {"$NETNTLM$c75c20bff9baa71f4765f360625700b0$81f5ecd8a77fe819f7f6689a08a27ac705fc2e1bb00cecb2", "password"},
+  {"$NETNTLM$1122334455667788$35B62750E1B9B3205C50D6BA351092C12A1B9B3CDC65D44A", "FooBarGerg"},
+  {"$NETNTLM$1122334455667788$A4765EBFE83D345A7CB1660B8899251905164029F8086DDE", "visit www.foofus.net"},
+  {"$NETNTLM$24ca92fdab441aa4c70e4fb229437ef3$abf7762caf2b1bbfc5cfc1f46665249f049e0af72ae5b5a9", "longpassword"},
+  {"$NETNTLM$1122334455667788$B2B2220790F40C88BCFF347C652F67A7C4A70D3BEBD70233", "cory21"},
+  {"", "g3rg3g3rg3g3rg3",               {"User", "", "", "lm-hash", "BFCCAF26128EC95F9999C9792F49434267A1D9B0EF89BFFB", "1122334455667788"} },
+  {"", "M1xedC4se%^&*@)##(blahblah!@#", {"User", "", "", "lm-hash", "E463FAA5D868ECE20CAE622474A2F440A652D642156AF863", "1122334455667788"} },
+  {"", "FooBarGerg",                    {"User", "", "", "lm-hash", "35B62750E1B9B3205C50D6BA351092C12A1B9B3CDC65D44A", "1122334455667788"} },
+  {"", "visit www.foofus.net",          {"User", "", "", "lm-hash", "A4765EBFE83D345A7CB1660B8899251905164029F8086DDE", "1122334455667788"} },
+  {"", "password",                      {"ESS", "", "", "4765f360625700b000000000000000000000000000000000", "81f5ecd8a77fe819f7f6689a08a27ac705fc2e1bb00cecb2", "c75c20bff9baa71f"} },
+  {"", "cory21",                        {"User", "", "", "lm-hash", "B2B2220790F40C88BCFF347C652F67A7C4A70D3BEBD70233", "1122334455667788"} },
+  {NULL}
+};
+
+static char saved_plain[MAX_KEYS_PER_CRYPT][UTF8_PLAINTEXT_LEN+1];
+static uchar *challenge;
+static ARCH_WORD_32 output[MAX_KEYS_PER_CRYPT][PARTIAL_BINARY_SIZE/sizeof(ARCH_WORD_32)];
+static uchar saved_key[MAX_KEYS_PER_CRYPT][21]; // NT hash
+
+extern struct fmt_main fmt_NETNTLM;
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = MIN_KEYS_PER_CRYPT * omp_get_max_threads();
+	if (n < MIN_KEYS_PER_CRYPT)
+		n = MIN_KEYS_PER_CRYPT;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETNTLM.params.min_keys_per_crypt = n;
+	n = n * n * ((n >> 1) + 1) * THREAD_RATIO;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETNTLM.params.max_keys_per_crypt = n;
+#endif
+	if (options.flags & FLG_UTF8) {
+		// in utf-8, up to four bytes can compose one character
+		fmt_NETNTLM.params.plaintext_length = UTF8_PLAINTEXT_LEN;
+	}
+}
+
+static int netntlm_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *pos;
+
+	if ((strlen(ciphertext) != 74) && (strlen(ciphertext) != 90)) return 0;
+
+	if (strncmp(ciphertext, "$NETNTLM$", 9)!=0) return 0;
+	if ((ciphertext[25] != '$') && (ciphertext[41] != '$')) return 0;
+
+	for (pos = &ciphertext[9]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++);
+	if (*pos != '$') return 0;
+
+	for (pos++;atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++);
+	if (!*pos && ((pos - ciphertext - 26 == CIPHERTEXT_LENGTH) ||
+	              (pos - ciphertext - 42 == CIPHERTEXT_LENGTH)))
+		return 1;
+	else
+		return 0;
+}
+
+static char *netntlm_prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	char *cp;
+	char clientChal[17];
+
+	if (!strncmp(split_fields[1], "$NETNTLM$", 9))
+		return split_fields[1];
+	if (strlen(split_fields[4]) != CIPHERTEXT_LENGTH)
+		return split_fields[1];
+
+	// Handle ESS (8 byte client challenge in "LM" field padded with zeros)
+	if (strlen(split_fields[3]) == 48 && !strncmp(&split_fields[3][16],
+	    "00000000000000000000000000000000", 32)) {
+		memcpy(clientChal, split_fields[3],16);
+		clientChal[16] = 0;
+	}
+	else
+		clientChal[0] = 0;
+	cp = mem_alloc(9+strlen(split_fields[5])+strlen(clientChal)+1+strlen(split_fields[4])+1);
+	sprintf(cp, "$NETNTLM$%s%s$%s", split_fields[5], clientChal, split_fields[4]);
+
+	if (netntlm_valid(cp,pFmt)) {
+		char *cp2 = str_alloc_copy(cp);
+		free(cp);
+		return cp2;
+	}
+	free(cp);
+	return split_fields[1];
+}
+
+static char *netntlm_split(char *ciphertext, int index)
+{
+  static char out[TOTAL_LENGTH + 1];
+
+  memset(out, 0, TOTAL_LENGTH + 1);
+  memcpy(&out, ciphertext, TOTAL_LENGTH);
+  strlwr(&out[8]); /* Exclude: $NETNTLM$ */
+
+  return out;
+}
+
+static void *netntlm_get_binary(char *ciphertext)
+{
+	static uchar *binary;
+	int i;
+
+	if (!binary) binary = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	ciphertext = strrchr(ciphertext, '$') + 1;
+	for (i=0; i<BINARY_SIZE; i++) {
+		binary[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])])<<4;
+		binary[i] |= (atoi16[ARCH_INDEX(ciphertext[i*2+1])]);
+	}
+
+	return binary;
+}
+
+static inline void setup_des_key(unsigned char key_56[], DES_key_schedule *ks)
+{
+  DES_cblock key;
+
+  key[0] = key_56[0];
+  key[1] = (key_56[0] << 7) | (key_56[1] >> 1);
+  key[2] = (key_56[1] << 6) | (key_56[2] >> 2);
+  key[3] = (key_56[2] << 5) | (key_56[3] >> 3);
+  key[4] = (key_56[3] << 4) | (key_56[4] >> 4);
+  key[5] = (key_56[4] << 3) | (key_56[5] >> 5);
+  key[6] = (key_56[5] << 2) | (key_56[6] >> 6);
+  key[7] = (key_56[6] << 1);
+
+  DES_set_key(&key, ks);
+}
+
+static void netntlm_crypt_all(int count)
+{
+	DES_key_schedule ks;
+	int i;
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i, ks) shared(count, output, saved_key, challenge)
+#endif
+	for(i=0; i<count; i++) {
+		/* Just do the first DES operation, for a partial binary */
+		setup_des_key(saved_key[i], &ks);
+		DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)&output[i], &ks, DES_ENCRYPT);
+	}
+}
+
+static int netntlm_cmp_all(void *binary, int count)
+{
+	int index;
+	for(index=0; index<count; index++)
+		if (!memcmp(output[index], binary, PARTIAL_BINARY_SIZE))
+			return 1;
+	return 0;
+}
+
+static int netntlm_cmp_one(void *binary, int index)
+{
+	return !memcmp(output[index], binary, PARTIAL_BINARY_SIZE);
+}
+
+static int netntlm_cmp_exact(char *source, int index)
+{
+	DES_key_schedule ks;
+	uchar binary[24];
+
+	/* Hash is NULL padded to 21-bytes (postponed until now) */
+	memset(&saved_key[index][16], 0, 5);
+
+	/* Split into three 7-byte segments for use as DES keys
+	   Use each key to DES encrypt challenge
+	   Concatenate output to for 24-byte NTLM response */
+
+	setup_des_key(saved_key[index], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)binary, &ks, DES_ENCRYPT);
+	setup_des_key(&saved_key[index][7], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)&binary[8], &ks, DES_ENCRYPT);
+	setup_des_key(&saved_key[index][14], &ks);
+	DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)&binary[16], &ks, DES_ENCRYPT);
+
+	return !memcmp(binary, netntlm_get_binary(source), BINARY_SIZE);
+}
+
+static void *netntlm_get_salt(char *ciphertext)
+{
+	static uchar *binary_salt;
+	int i;
+
+	if (!binary_salt) binary_salt = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);
+
+	if (ciphertext[25] == '$') {
+		// Server challenge
+		ciphertext += 9;
+		for (i = 0; i < SALT_SIZE; ++i)
+			binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+	} else {
+		uchar es_salt[2*SALT_SIZE], k1[2*SALT_SIZE];
+		MD5_CTX ctx;
+
+		ciphertext += 9;
+		// Extended Session Security,
+		// Concatenate Server & Client challenges
+		for (i = 0;i < 2 * SALT_SIZE; ++i)
+			es_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+		// MD5 the concatenated challenges, result is our key
+		MD5_Init(&ctx);
+		MD5_Update(&ctx, es_salt, 16);
+		MD5_Final((void*)k1, &ctx);
+		memcpy(binary_salt, k1, SALT_SIZE); // but only 8 bytes of it
+	}
+	return (void*)binary_salt;
+}
+
+static void netntlm_set_salt(void *salt)
+{
+	challenge = salt;
+}
+
+static void netntlm_set_key(char *key, int index)
+{
+	int len = strlen(key);
+	memcpy(saved_plain[index], key, len + 1);
+
+	/* Generate 16-byte NTLM hash */
+	len = E_md4hash((uchar *) saved_plain[index], len, saved_key[index]);
+
+	if (len <= 0)
+		saved_plain[index][-len] = 0; // match truncation
+
+	/* Hash is NULL padded to 21-bytes in cmp_exact if needed */
+}
+
+static char *netntlm_get_key(int index)
+{
+	return saved_plain[index];
+}
+
+static int salt_hash(void *salt)
+{
+	return *(ARCH_WORD_32 *)salt & (SALT_HASH_SIZE - 1);
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFFF;
+}
+
+struct fmt_main fmt_NETNTLM = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALGORITHM_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP | FMT_UNICODE | FMT_UTF8,
+    tests
+  }, {
+    init,
+	netntlm_prepare,
+    netntlm_valid,
+    netntlm_split,
+    netntlm_get_binary,
+    netntlm_get_salt,
+    {
+	    binary_hash_0,
+	    binary_hash_1,
+	    binary_hash_2,
+	    binary_hash_3,
+	    binary_hash_4
+    },
+    salt_hash,
+    netntlm_set_salt,
+    netntlm_set_key,
+    netntlm_get_key,
+    fmt_default_clear_keys,
+    netntlm_crypt_all,
+    {
+	    get_hash_0,
+	    get_hash_1,
+	    get_hash_2,
+	    get_hash_3,
+	    get_hash_4
+    },
+    netntlm_cmp_all,
+    netntlm_cmp_one,
+    netntlm_cmp_exact
+  }
+};
diff -rupN john-1.7.8/src/NETNTLMv2_fmt_plug.c john-1.7.8-jumbo-2/src/NETNTLMv2_fmt_plug.c
--- john-1.7.8/src/NETNTLMv2_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NETNTLMv2_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,619 @@
+/*
+ * NETNTLMv2_fmt.c -- NTLMv2 Challenge/Response
+ *
+ * Written by JoMo-Kun <jmk at foofus.net> in 2009
+ * and placed in the public domain.
+ *
+ * Modified for performance, OMP and utf-8 support by magnum 2010-2011,
+ * no rights reserved
+ *
+ * This algorithm is designed for performing brute-force cracking of the NTLMv2
+ * challenge/response sets exchanged during network-based authentication
+ * attempts [1]. The captured challenge/response set from these attempts
+ * should be stored using the following format:
+ *
+ * USERNAME::DOMAIN:SERVER CHALLENGE:NTLMv2 RESPONSE:CLIENT CHALLENGE
+ *
+ * For example:
+ * ntlmv2test::WORKGROUP:1122334455667788:07659A550D5E9D02996DFD95C87EC1D5:0101000000000000006CF6385B74CA01B3610B02D99732DD000000000200120057004F0052004B00470052004F00550050000100200044004100540041002E00420049004E0043002D0053004500430055005200490000000000
+ *
+ * It should be noted that a NTLMv2 authentication response is not same as a NTLM
+ * password hash, which can be extracted using tools such as FgDump [2]. NTLMv2
+ * challenge/response authentication typically takes place when the GPO
+ * "Network Security: LAN Manager authentication level" is configured to a setting
+ * that enforces the use of NTLMv2, such as "Send NTLMv2 response only\refuse
+ * LM & NTLM."
+ *
+ * NTLMv2 responses can be gathered via normal network capture or via tools which
+ * perform layer 2 attacks, such as Ettercap [3] and Cain [4]. The responses can
+ * also be harvested using a modified Samba service [5] in conjunction with
+ * some trickery to convince the user to connect to it. I leave what that
+ * trickery may actually be as an exercise for the reader (HINT: Karma, NMB
+ * broadcasts, IE, Outlook, social engineering, ...).
+ *
+ * [1] http://davenport.sourceforge.net/ntlm.html#theNtlmv2Response
+ * [2] http://www.foofus.net/fizzgig/fgdump/
+ * [3] http://ettercap.sourceforge.net/
+ * [4] http://www.oxid.it/cain.html
+ * [5] http://www.foofus.net/jmk/smbchallenge.html
+ *
+ */
+
+#include <string.h>
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+
+#if 0
+#warning INFO: We are using OpenSSL HMAC_MD5
+#include <openssl/hmac.h>
+static void hmac_md5(const unsigned char *key, const unsigned char *data, int datalen, unsigned char *digest)
+{
+	HMAC(EVP_md5(), key, 16, data, datalen, digest, NULL);
+}
+#else
+#include "md5.h"
+#include "hmacmd5.h"
+// Move a hmac_md5_init() from crypt_all to set_key(),
+// and store &ctx in saved_key.
+//
+// Pro: saves another key setup using same key
+// Con: larger saved_key (288 bytes vs 16)
+//
+// This boosted performance with about 8%
+#define SPLIT_HMACMD5
+#endif
+
+#include "unicode.h"
+
+#ifndef uchar
+#define uchar unsigned char
+#endif
+
+#define FORMAT_LABEL         "netntlmv2"
+#define FORMAT_NAME          "NTLMv2 C/R MD4 HMAC-MD5"
+#define ALGORITHM_NAME       "netntlmv2"
+#define BENCHMARK_COMMENT    ""
+#define BENCHMARK_LENGTH     0
+#define PLAINTEXT_LENGTH     54 /* lmcons.h - PWLEN (256) ? 127 ? */
+#define UTF8_PLAINTEXT_LEN   125
+#define USERNAME_LENGTH      20 /* lmcons.h - UNLEN (256) / LM20_UNLEN (20) */
+#define DOMAIN_LENGTH        15 /* lmcons.h - CNLEN / DNLEN */
+#define BINARY_SIZE          16
+#define SERVER_CHALL_LENGTH  16
+#define CLIENT_CHALL_LENGTH_MAX  1024 /* FIXME - Max Target Information Size Unknown */
+#define SALT_SIZE_MAX        2 * USERNAME_LENGTH + 2 * DOMAIN_LENGTH + 3 + SERVER_CHALL_LENGTH/2 + CLIENT_CHALL_LENGTH_MAX/2
+#define CIPHERTEXT_LENGTH    32
+#define TOTAL_LENGTH         12 + USERNAME_LENGTH + DOMAIN_LENGTH + SERVER_CHALL_LENGTH + CLIENT_CHALL_LENGTH_MAX + CIPHERTEXT_LENGTH
+
+// these may be altered in init() if running OMP
+// and that formula is subject to change
+#define MIN_KEYS_PER_CRYPT	    1
+#define THREAD_RATIO            256
+#ifdef _OPENMP
+#define MAX_KEYS_PER_CRYPT	    0x10000
+#else
+#define MAX_KEYS_PER_CRYPT	    THREAD_RATIO
+#endif
+
+static struct fmt_tests tests[] = {
+  {"$NETNTLMv2$NTLMV2TESTWORKGROUP$1122334455667788$07659A550D5E9D02996DFD95C87EC1D5$0101000000000000006CF6385B74CA01B3610B02D99732DD000000000200120057004F0052004B00470052004F00550050000100200044004100540041002E00420049004E0043002D0053004500430055005200490000000000", "password"},
+  {"$NETNTLMv2$TESTUSERW2K3ADWIN7$1122334455667788$989B96DC6EAB529F72FCBA852C0D5719$01010000000000002EC51CEC91AACA0124576A744F198BDD000000000200120057004F0052004B00470052004F00550050000000000000000000", "testpass"},
+  {"$NETNTLMv2$USERW2K3ADWIN7$1122334455667788$5BD1F32D8AFB4FB0DD0B77D7DE2FF7A9$0101000000000000309F56FE91AACA011B66A7051FA48148000000000200120057004F0052004B00470052004F00550050000000000000000000", "password"},
+  {"$NETNTLMv2$USER1W2K3ADWIN7$1122334455667788$027EF88334DAA460144BDB678D4F988D$010100000000000092809B1192AACA01E01B519CB0248776000000000200120057004F0052004B00470052004F00550050000000000000000000", "SomeLongPassword1BlahBlah"},
+  {"$NETNTLMv2$TEST_USERW2K3ADWIN7$1122334455667788$A06EC5ED9F6DAFDCA90E316AF415BA71$010100000000000036D3A13292AACA01D2CD95757A0836F9000000000200120057004F0052004B00470052004F00550050000000000000000000", "TestUser's Password"},
+  {"$NETNTLMv2$USER1Domain$1122334455667788$5E4AB1BF243DCA304A00ADEF78DC38DF$0101000000000000BB50305495AACA01338BC7B090A62856000000000200120057004F0052004B00470052004F00550050000000000000000000", "password"},
+  {"", "password",                  {"TESTWORKGROUP\\NTlmv2", "", "",              "1122334455667788","07659A550D5E9D02996DFD95C87EC1D5","0101000000000000006CF6385B74CA01B3610B02D99732DD000000000200120057004F0052004B00470052004F00550050000100200044004100540041002E00420049004E0043002D0053004500430055005200490000000000"} },
+  {"", "password",                  {"NTlmv2",                "", "TESTWORKGROUP", "1122334455667788","07659A550D5E9D02996DFD95C87EC1D5","0101000000000000006CF6385B74CA01B3610B02D99732DD000000000200120057004F0052004B00470052004F00550050000100200044004100540041002E00420049004E0043002D0053004500430055005200490000000000"} },
+  {"", "testpass",                  {"TestUser",              "", "W2K3ADWIN7",    "1122334455667788","989B96DC6EAB529F72FCBA852C0D5719","01010000000000002EC51CEC91AACA0124576A744F198BDD000000000200120057004F0052004B00470052004F00550050000000000000000000"} },
+  {"", "password",                  {"user",                  "", "W2K3ADWIN7",    "1122334455667788","5BD1F32D8AFB4FB0DD0B77D7DE2FF7A9","0101000000000000309F56FE91AACA011B66A7051FA48148000000000200120057004F0052004B00470052004F00550050000000000000000000"} },
+  {"", "SomeLongPassword1BlahBlah", {"W2K3ADWIN7\\user1",     "", "",              "1122334455667788","027EF88334DAA460144BDB678D4F988D","010100000000000092809B1192AACA01E01B519CB0248776000000000200120057004F0052004B00470052004F00550050000000000000000000"} },
+  {"", "TestUser's Password",       {"W2K3ADWIN7\\TEST_USER", "", "",              "1122334455667788","A06EC5ED9F6DAFDCA90E316AF415BA71","010100000000000036D3A13292AACA01D2CD95757A0836F9000000000200120057004F0052004B00470052004F00550050000000000000000000"} },
+  {"", "password",                  {"USER1",                 "", "Domain",        "1122334455667788","5E4AB1BF243DCA304A00ADEF78DC38DF","0101000000000000BB50305495AACA01338BC7B090A62856000000000200120057004F0052004B00470052004F00550050000000000000000000"} },
+  {NULL}
+};
+
+static uchar saved_plain[MAX_KEYS_PER_CRYPT][UTF8_PLAINTEXT_LEN+1];
+static uchar *challenge;
+static ARCH_WORD_32 output[MAX_KEYS_PER_CRYPT][BINARY_SIZE/sizeof(ARCH_WORD_32)];
+#ifdef SPLIT_HMACMD5
+static HMACMD5Context saved_key[MAX_KEYS_PER_CRYPT];
+#else
+static unsigned char saved_key[MAX_KEYS_PER_CRYPT][16];
+#endif
+
+#if !defined(uint16) && !defined(HAVE_UINT16_FROM_RPC_RPC_H)
+#if (SIZEOF_SHORT == 4)
+#define uint16 __ERROR___CANNOT_DETERMINE_TYPE_FOR_INT16;
+#else /* SIZEOF_SHORT != 4 */
+#define uint16 unsigned short
+#endif /* SIZEOF_SHORT != 4 */
+#endif
+
+#if !defined(int16) && !defined(HAVE_INT16_FROM_RPC_RPC_H)
+#if (SIZEOF_SHORT == 4)
+#define int16 __ERROR___CANNOT_DETERMINE_TYPE_FOR_INT16;
+#else /* SIZEOF_SHORT != 4 */
+#define int16 short
+#endif /* SIZEOF_SHORT != 4 */
+#endif
+
+#include "byteorder.h"
+
+extern struct fmt_main fmt_NETNTLMv2;
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = MIN_KEYS_PER_CRYPT * omp_get_max_threads();
+	if (n < MIN_KEYS_PER_CRYPT)
+		n = MIN_KEYS_PER_CRYPT;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETNTLMv2.params.min_keys_per_crypt = n;
+	n = n * n * ((n >> 1) + 1) * THREAD_RATIO;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETNTLMv2.params.max_keys_per_crypt = n;
+#endif
+	if (options.flags & FLG_UTF8) {
+		// in utf-8, up to four bytes can compose one character
+		fmt_NETNTLMv2.params.plaintext_length = UTF8_PLAINTEXT_LEN;
+	}
+}
+
+static int netntlmv2_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+  char *pos, *pos2;
+
+  if (ciphertext == NULL) return 0;
+  else if (strncmp(ciphertext, "$NETNTLMv2$", 11)!=0) return 0;
+
+  pos = &ciphertext[11];
+
+  /* Validate Username and Domain Length */
+  for (pos2 = pos; strncmp(pos2, "$", 1) != 0; pos2++)
+    if ( (*pos2 < 0x20) || (*pos2 > 0x7E) )
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos <= USERNAME_LENGTH + DOMAIN_LENGTH)) )
+    return 0;
+
+  /* Validate Server Challenge Length */
+  pos2++; pos = pos2;
+  for (; strncmp(pos2, "$", 1) != 0; pos2++)
+    if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos == SERVER_CHALL_LENGTH)) )
+    return 0;
+
+  /* Validate NTLMv2 Response Length */
+  pos2++; pos = pos2;
+  for (; strncmp(pos2, "$", 1) != 0; pos2++)
+    if (atoi16[ARCH_INDEX(*pos2)] == 0x7F)
+      return 0;
+
+  if ( !(*pos2 && (pos2 - pos == CIPHERTEXT_LENGTH)) )
+    return 0;
+
+  /* Validate Client Challenge Length */
+  pos2++; pos = pos2;
+  for (; atoi16[ARCH_INDEX(*pos2)] != 0x7F; pos2++);
+  if ((pos2 - pos > CLIENT_CHALL_LENGTH_MAX) || (pos2 - pos < 28))
+	  return 0;
+
+  return 1;
+}
+
+static char *netntlmv2_prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+//	else if (options.format && ((strncmp(options.format, "netlmv2", 7)==0) ||
+//			(strncmp(options.format, "netntlmv2", 9)==0))) {
+//		char *srv_challenge = ldr_get_field(&line, db_options->field_sep_char);
+//		char *nethashv2 = ldr_get_field(&line, db_options->field_sep_char);
+//		char *cli_challenge = ldr_get_field(&line, db_options->field_sep_char);
+//		char *identity = NULL;
+//		int i;
+//
+//	/* DOMAIN\USER: -or- USER::DOMAIN: */
+//	if ((tmp = strstr(*login, "\\")) != NULL) {
+//		identity = (char *) mem_alloc(strlen(*login));
+//	  	strcpy(identity, tmp + 1);
+//
+//		/* Upper-Case Username - Not Domain */
+//		for(i=0; i<strlen(identity); i++)
+//		 if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+//
+//		  strncat(identity, *login, tmp - *login);
+//	}
+//	else {
+//		identity = (char *) mem_alloc(strlen(*login) + strlen(uid) + 1);
+//		strcpy(identity, *login);
+//
+//			for(i=0; i<strlen(identity); i++)
+//		if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+//
+//		strcat(identity, uid);
+//	}
+//	if (strncmp(options.format, "netlmv2", 7)==0) {
+//		  tmp = (char *) mem_alloc_tiny(9 + strlen(identity) + 1 + strlen(srv_challenge) + 1 + strlen(nethashv2) + 1 + strlen(cli_challenge) + 1, MEM_ALIGN_NONE);
+//		  sprintf(tmp, "$NETLMv2$%s$%s$%s$%s", identity, srv_challenge, nethashv2, cli_challenge);
+//		*ciphertext = tmp;
+//	}
+//	else {
+//		  tmp = (char *) mem_alloc_tiny(9 + strlen(identity) + 1 + strlen(srv_challenge) + 1 + strlen(nethashv2) + 1 + strlen(cli_challenge) + 1, MEM_ALIGN_NONE);
+//		  sprintf(tmp, "$NETNTLMv2$%s$%s$%s$%s", identity, srv_challenge, nethashv2, cli_challenge);
+//		  *ciphertext = tmp;
+//	}
+//
+//		MEM_FREE(identity);
+//	}
+
+	char *srv_challenge = split_fields[3];
+	char *nethashv2     = split_fields[4];
+	char *cli_challenge = split_fields[5];
+	char *login = split_fields[0];
+	char *uid = split_fields[2];
+	char *identity = NULL, *tmp;
+	int i;
+
+	if (!strncmp(split_fields[1], "$NETNTLMv2$", 11))
+		return split_fields[1];
+	/* DOMAIN\USER: -or- USER::DOMAIN: */
+	if ((tmp = strstr(login, "\\")) != NULL) {
+		identity = (char *) mem_alloc(strlen(login));
+	  	strcpy(identity, tmp + 1);
+
+		/* Upper-Case Username - Not Domain */
+		for(i=0; i<strlen(identity); i++)
+		 if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+
+		  strncat(identity, login, tmp - login);
+	}
+	else {
+		identity = (char *) mem_alloc(strlen(login) + strlen(uid) + 1);
+		strcpy(identity, login);
+
+			for(i=0; i<strlen(identity); i++)
+		if ((identity[i] >= 'a') && (identity[i] <= 'z')) identity[i] ^= 0x20;
+		strcat(identity, uid);
+	}
+	tmp = (char *) mem_alloc(11 + strlen(identity) + 1 + strlen(srv_challenge) + 1 + strlen(nethashv2) + 1 + strlen(cli_challenge) + 1);
+	sprintf(tmp, "$NETNTLMv2$%s$%s$%s$%s", identity, srv_challenge, nethashv2, cli_challenge);
+	MEM_FREE(identity);
+
+	if (netntlmv2_valid(tmp, pFmt)) {
+		char *cp = str_alloc_copy(tmp);
+		MEM_FREE(tmp);
+		return cp;
+	}
+	MEM_FREE(tmp);
+	return split_fields[1];
+}
+
+static char *netntlmv2_split(char *ciphertext, int index)
+{
+  static char out[TOTAL_LENGTH + 1];
+  char *pos = NULL;
+  int identity_length = 0;
+
+  /* Calculate identity length */
+  for (pos = ciphertext + 11; strncmp(pos, "$", 1) != 0; pos++);
+  identity_length = pos - (ciphertext + 11);
+
+  memset(out, 0, TOTAL_LENGTH + 1);
+  memcpy(&out, ciphertext, strlen(ciphertext));
+  strlwr(&out[12 + identity_length]); /* Exclude: $NETNTLMv2$USERDOMAIN$ */
+
+  return out;
+}
+
+static void *netntlmv2_get_binary(char *ciphertext)
+{
+  static uchar *binary;
+  char *pos = NULL;
+  int i, identity_length;
+
+  if (!binary) binary = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+  for (pos = ciphertext + 11; strncmp(pos, "$", 1) != 0; pos++);
+  identity_length = pos - (ciphertext + 11);
+
+  ciphertext += 11 + identity_length + 1 + SERVER_CHALL_LENGTH + 1;
+  for (i=0; i<BINARY_SIZE; i++)
+  {
+    binary[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])])<<4;
+    binary[i] |= (atoi16[ARCH_INDEX(ciphertext[i*2+1])]);
+  }
+
+  return binary;
+}
+
+/* Calculate the NTLMv2 response for the given challenge, using the
+   specified authentication identity (username and domain), password
+   and client nonce.
+
+   challenge: Identity length, Identity\0, Challenge Size, Server Challenge + Client Challenge
+*/
+static void netntlmv2_crypt_all(int count)
+{
+	unsigned char ntlm_v2_hash[16];
+	int identity_length, challenge_size;
+	int i;
+
+	/* --- HMAC #1 Calculations --- */
+	identity_length = challenge[0];
+	challenge_size = (*(challenge + 1 + identity_length + 1) << 8) | *(challenge + 1 + identity_length + 2);
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i, ntlm_v2_hash) shared(count, output, saved_key, challenge, challenge_size, identity_length)
+#endif
+	for(i=0; i<count; i++) {
+		/* Generate 16-byte NTLMv2 Hash */
+		/* HMAC-MD5(Username + Domain, NTLM Hash) */
+#ifdef SPLIT_HMACMD5
+		HMACMD5Context ctx; // can't be moved above the OMP pragma
+		memcpy(&ctx, &saved_key[i], sizeof(ctx));
+		hmac_md5_update((unsigned char *)&challenge[1], identity_length, &ctx);
+		hmac_md5_final(ntlm_v2_hash, &ctx);
+#else
+		hmac_md5(saved_key[i], (unsigned char *)&challenge[1], identity_length, ntlm_v2_hash);
+#endif
+		/* --- Blob Construction --- */
+
+		/*
+		    The blob consists of the target (from Type 2 message), client nonce and timestamp.
+		    This data was provided by the client during authentication and we can use it as is.
+		*/
+
+		/* --- HMAC #2 Caculations --- */
+
+		/*
+		  The (server) challenge from the Type 2 message is concatenated with the blob. The
+		  HMAC-MD5 message authentication code algorithm is applied to this value using the
+		  16-byte NTLMv2 hash (calculated above) as the key. This results in a 16-byte output
+		  value.
+		*/
+
+		/*
+		   Generate 16-byte non-client nonce portion of NTLMv2 Response
+		   HMAC-MD5(Challenge + Nonce, NTLMv2 Hash)
+
+		   The length of the challenge was set in netntlmv2_get_salt(). We find the server
+		   challenge and blob following the identity and challenge size value.
+		   challenge -> Identity length, Identity\0, Size (2 bytes), Server Challenge + Client Challenge (Blob)
+		*/
+		hmac_md5(ntlm_v2_hash, challenge + 1 + identity_length + 1 + 2, challenge_size, (unsigned char*)output[i]);
+	}
+}
+
+static int netntlmv2_cmp_all(void *binary, int count)
+{
+	int index;
+	for(index=0; index<count; index++)
+		if (!memcmp(output[index], binary, BINARY_SIZE))
+			return 1;
+	return 0;
+}
+
+static int netntlmv2_cmp_one(void *binary, int index)
+{
+	return !memcmp(output[index], binary, BINARY_SIZE);
+}
+
+static int netntlmv2_cmp_exact(char *source, int index)
+{
+	return !memcmp(output[index], netntlmv2_get_binary(source), BINARY_SIZE);
+}
+
+/*
+  We're essentially using three salts, but we're going to pack it into a single blob for now.
+
+  Input:  $NETNTLMv2$USER_DOMAIN$_SERVER_CHALLENGE_$_NTLMv2_RESP_$_CLIENT_CHALLENGE_
+    Username: <=20
+    Domain: <=15
+    Server Challenge: 8 bytes
+    Client Challenge: ???
+  Output: Identity length, Identity(UTF16)\0, Challenge Size, Server Challenge + Client Challenge
+*/
+static void *netntlmv2_get_salt(char *ciphertext)
+{
+  static unsigned char *binary_salt;
+  int i, identity_length, challenge_size;
+  char *pos = NULL;
+#if !ARCH_ALLOWS_UNALIGNED
+  static unsigned *bs2;
+  if (!bs2) bs2 = mem_alloc_tiny(SALT_SIZE_MAX, MEM_ALIGN_WORD);
+#endif
+
+  if (!binary_salt) binary_salt = mem_alloc_tiny(SALT_SIZE_MAX, MEM_ALIGN_WORD);
+
+  /* Calculate identity length */
+  for (pos = ciphertext + 11; strncmp(pos, "$", 1) != 0; pos++);
+
+  /* Convert identity (username + domain) string to NT unicode */
+#if !ARCH_ALLOWS_UNALIGNED
+  identity_length = plaintowcs((uint16 *)bs2, 2 * (USERNAME_LENGTH + DOMAIN_LENGTH), (uchar *)ciphertext + 11, pos - (ciphertext + 11)) * sizeof(int16);
+  if (identity_length < 0) // Truncated at Unicode conversion.
+	  identity_length = strlen16((UTF16 *)bs2) * sizeof(int16);
+  memcpy(&binary_salt[1], bs2, identity_length);
+#else
+  identity_length = plaintowcs((uint16 *)&binary_salt[1], 2 * (USERNAME_LENGTH + DOMAIN_LENGTH), (uchar *)ciphertext + 11, pos - (ciphertext + 11)) * sizeof(int16);
+  if (identity_length < 0) // Truncated at Unicode conversion.
+	  identity_length = strlen16((UTF16 *)&binary_salt[1]) * sizeof(int16);
+#endif
+
+  /* Set server and client challenge size */
+
+  /* Skip: $NETNTLMv2$USER_DOMAIN$ */
+  ciphertext = pos + 1;
+
+  /* SERVER_CHALLENGE$NTLMV2_RESPONSE$CLIENT_CHALLENGE --> SERVER_CHALLENGECLIENT_CHALLENGE */
+  /* CIPHERTEXT == NTLMV2_RESPONSE (16 bytes / 32 characters) */
+  challenge_size = (strlen(ciphertext) - CIPHERTEXT_LENGTH - 2) / 2;
+
+  /* Store identity length */
+  binary_salt[0] = identity_length;
+
+  /* Set challenge size in response - 2 bytes */
+  memset(binary_salt + 1 + identity_length, 0, 1);
+  memset(binary_salt + 1 + identity_length + 1, (challenge_size & 0xFF00) >> 8, 1);
+  memset(binary_salt + 1 + identity_length + 2, challenge_size & 0x00FF, 1);
+
+  /* Set server challenge */
+  for (i = 0; i < SERVER_CHALL_LENGTH / 2; i++)
+    binary_salt[identity_length + 1 + 2 + 1 + i] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+  /* Set client challenge */
+  ciphertext += SERVER_CHALL_LENGTH + 1 + CIPHERTEXT_LENGTH + 1;
+  for (i = 0; i < strlen(ciphertext) / 2; ++i)
+    binary_salt[identity_length + 1 + 2 + 1 + SERVER_CHALL_LENGTH / 2 + i] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+  /* Return a concatenation of the server and client challenges and the identity value */
+  return (void*)binary_salt;
+}
+
+static void netntlmv2_set_salt(void *salt)
+{
+	challenge = salt;
+}
+
+static void netntlmv2_set_key(char *key, int index)
+{
+	int len;
+#ifdef SPLIT_HMACMD5
+	unsigned char ntlm[16];
+#endif
+
+	len = strlen(key);
+	memcpy((char *)saved_plain[index], key, len + 1);
+
+#ifdef SPLIT_HMACMD5
+	/* Generate 16-byte NTLM hash */
+	len = E_md4hash(saved_plain[index], len, ntlm);
+
+	// We do key setup of the next HMAC_MD5 here. rest in crypt_all()
+	// &saved_key is now &ctx
+	hmac_md5_init_K16(ntlm, &saved_key[index]);
+#else
+	/* Generate 16-byte NTLM hash */
+	len = E_md4hash(saved_plain[index], len, saved_key[index]);
+#endif
+
+	if (len <= 0)
+		saved_plain[index][-len] = 0; // match truncation
+}
+
+static char *netntlmv2_get_key(int index)
+{
+	return (char *)saved_plain[index];
+}
+
+static int salt_hash(void *salt)
+{
+	// Hash the client challenge (in case server salt was spoofed)
+	int identity_length = ((char *)salt)[0];
+	return (*(ARCH_WORD_32 *)salt+1+identity_length+1+2+8) & (SALT_HASH_SIZE - 1);
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFFF;
+}
+
+struct fmt_main fmt_NETNTLMv2 = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALGORITHM_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE_MAX,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP | FMT_UNICODE | FMT_UTF8,
+    tests
+  }, {
+    init,
+	netntlmv2_prepare,
+    netntlmv2_valid,
+    netntlmv2_split,
+    netntlmv2_get_binary,
+    netntlmv2_get_salt,
+    {
+	    binary_hash_0,
+	    binary_hash_1,
+	    binary_hash_2,
+	    binary_hash_3,
+	    binary_hash_4
+    },
+    salt_hash,
+    netntlmv2_set_salt,
+    netntlmv2_set_key,
+    netntlmv2_get_key,
+    fmt_default_clear_keys,
+    netntlmv2_crypt_all,
+    {
+	    get_hash_0,
+	    get_hash_1,
+	    get_hash_2,
+	    get_hash_3,
+	    get_hash_4
+    },
+    netntlmv2_cmp_all,
+    netntlmv2_cmp_one,
+    netntlmv2_cmp_exact
+  }
+};
diff -rupN john-1.7.8/src/NETSPLITLM_fmt_plug.c john-1.7.8-jumbo-2/src/NETSPLITLM_fmt_plug.c
--- john-1.7.8/src/NETSPLITLM_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NETSPLITLM_fmt_plug.c	2011-06-02 17:19:48.000000000 +0200
@@ -0,0 +1,343 @@
+/*
+ * NETHALFLM_fmt.c
+ * Written by DSK (Based on NetLM/NetNTLM patch by JoMo-Kun)
+ * Performs brute-force cracking of the HalfLM challenge/response pairs.
+ *
+ * Modified for performance and OMP support by magnum 2011
+ *
+ * Storage Format:
+ * domain\username:::lm response:nt response:challenge
+ *
+ *  NOTE, in loader.c, the format appeared to be domain\username:::lm response:challenge
+ *  so that format has been built into the 'prepare' function (JimF).
+ *
+ * Code is in public domain.
+ */
+
+#include <string.h>
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+
+#include <openssl/des.h>
+
+#ifndef uchar
+#define uchar unsigned char
+#endif
+
+#define FORMAT_LABEL         "nethalflm"
+#define FORMAT_NAME          "HalfLM C/R DES"
+#define ALGORITHM_NAME       "nethalflm"
+#define BENCHMARK_COMMENT    ""
+#define BENCHMARK_LENGTH     0
+#define PLAINTEXT_LENGTH     7
+#define BINARY_SIZE          8
+#define SALT_SIZE            8
+#define CIPHERTEXT_LENGTH    48
+#define TOTAL_LENGTH         12 + 2 * SALT_SIZE + CIPHERTEXT_LENGTH
+
+// these may be altered in init() if running OMP
+// and that formula is subject to change
+#define MIN_KEYS_PER_CRYPT	    1
+#define THREAD_RATIO            256
+#ifdef _OPENMP
+#define MAX_KEYS_PER_CRYPT	    0x10000
+#else
+#define MAX_KEYS_PER_CRYPT	    THREAD_RATIO
+#endif
+
+static struct fmt_tests tests[] = {
+  {"$NETHALFLM$1122334455667788$6E1EC36D3417CE9E09A4424309F116C4C991948DAEB4ADAD", "G3RG3P00!"},
+  {"$NETHALFLM$1122334455667788$6E1EC36D3417CE9E09A4424309F116C4C991948DAEB4ADAD", "G3RG3P0"},
+  {"$NETHALFLM$1122334455667788$1354FD5ABF3B627B8B49587B8F2BBA0F9F6C5E420824E0A2", "ZEEEZ@1"},
+
+  {"", "G3RG3P00!", {"domain\\username", "", "", "6E1EC36D3417CE9E09A4424309F116C4C991948DAEB4ADAD", "", "1122334455667788"} },
+  {"", "G3RG3P0",   {"domain\\username", "", "", "6E1EC36D3417CE9E09A4424309F116C4C991948DAEB4ADAD", "", "1122334455667788"} },
+  {"", "ZEEEZ@1",   {"domain\\username", "", "", "1354FD5ABF3B627B8B49587B8F2BBA0F9F6C5E420824E0A2", "", "1122334455667788"} },
+
+  {NULL}
+};
+
+static uchar saved_plain[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1];
+static uchar saved_pre[MAX_KEYS_PER_CRYPT][8];
+static uchar *challenge;
+static uchar output[MAX_KEYS_PER_CRYPT][BINARY_SIZE];
+
+extern struct fmt_main fmt_NETHALFLM;
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = MIN_KEYS_PER_CRYPT * omp_get_max_threads();
+	if (n < MIN_KEYS_PER_CRYPT)
+		n = MIN_KEYS_PER_CRYPT;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETHALFLM.params.min_keys_per_crypt = n;
+	n = n * n * ((n >> 1) + 1) * THREAD_RATIO;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_NETHALFLM.params.max_keys_per_crypt = n;
+#endif
+}
+
+static int nethalflm_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+  char *pos;
+
+  if (strncmp(ciphertext, "$NETHALFLM$", 11)!=0) return 0;
+  if (ciphertext[27] != '$') return 0;
+
+  if (strncmp(&ciphertext[28 + 2 * SALT_SIZE],
+              "00000000000000000000000000000000", 32) == 0)
+	  return 0; // This is NTLM ESS C/R
+
+  for (pos = &ciphertext[28]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++);
+    if (!*pos && pos - ciphertext - 28 == CIPHERTEXT_LENGTH) {
+	    return 1;
+    }
+    else
+      return 0;
+}
+
+static char *nethalflm_prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	char *tmp;
+
+	if (!strncmp(split_fields[1], "$NETHALFLM$", 11))
+		return split_fields[1];
+	if (strlen(split_fields[3]) != CIPHERTEXT_LENGTH)
+		return split_fields[1];
+
+	// if LMresp == NTresp then it's NTLM-only, not LM
+	if (!strncmp(split_fields[3], split_fields[4], 48))
+		return split_fields[1];
+
+	tmp = (char *) mem_alloc(12 + strlen(split_fields[3]) + strlen(split_fields[5]) + 1);
+	sprintf(tmp, "$NETHALFLM$%s$%s", split_fields[5], split_fields[3]);
+
+	if (nethalflm_valid(tmp,pFmt)) {
+		char *cp2 = str_alloc_copy(tmp);
+		free(tmp);
+		return cp2;
+	}
+	free(tmp);
+	return split_fields[1];
+}
+
+static char *nethalflm_split(char *ciphertext, int index)
+{
+  static char out[TOTAL_LENGTH + 1] = {0};
+
+  memcpy(&out, ciphertext, TOTAL_LENGTH);
+  strlwr(&out[10]); /* Exclude: $NETHALFLM$ */
+  return out;
+}
+
+static void *nethalflm_get_binary(char *ciphertext)
+{
+  static uchar binary[BINARY_SIZE];
+  int i;
+
+  ciphertext+=28;
+  for (i=0; i<BINARY_SIZE; i++)
+  {
+    binary[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])])<<4;
+    binary[i] |= (atoi16[ARCH_INDEX(ciphertext[i*2+1])]);
+  }
+  return binary;
+}
+
+static inline void setup_des_key(unsigned char key_56[], DES_key_schedule *ks)
+{
+  DES_cblock key;
+
+  key[0] = key_56[0];
+  key[1] = (key_56[0] << 7) | (key_56[1] >> 1);
+  key[2] = (key_56[1] << 6) | (key_56[2] >> 2);
+  key[3] = (key_56[2] << 5) | (key_56[3] >> 3);
+  key[4] = (key_56[3] << 4) | (key_56[4] >> 4);
+  key[5] = (key_56[4] << 3) | (key_56[5] >> 5);
+  key[6] = (key_56[5] << 2) | (key_56[6] >> 6);
+  key[7] = (key_56[6] << 1);
+
+  DES_set_key(&key, ks);
+}
+
+static void nethalflm_crypt_all(int count)
+{
+	DES_key_schedule ks;
+	int i;
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i, ks) shared(count, output, challenge, saved_pre)
+#endif
+	for(i=0; i<count; i++) {
+		/* DES-encrypt challenge using the partial LM hash */
+		setup_des_key(saved_pre[i], &ks);
+		DES_ecb_encrypt((DES_cblock*)challenge, (DES_cblock*)output[i], &ks, DES_ENCRYPT);
+	}
+}
+
+static int nethalflm_cmp_all(void *binary, int count)
+{
+	int index;
+	for(index=0; index<count; index++)
+		if (!memcmp(output[index], binary, BINARY_SIZE))
+			return 1;
+	return 0;
+}
+
+static int nethalflm_cmp_one(void *binary, int index)
+{
+	return !memcmp(output[index], binary, BINARY_SIZE);
+}
+
+static int nethalflm_cmp_exact(char *source, int index)
+{
+	return !memcmp(output[index], nethalflm_get_binary(source), BINARY_SIZE);
+}
+
+static void *nethalflm_get_salt(char *ciphertext)
+{
+  static unsigned char binary_salt[SALT_SIZE];
+  int i;
+
+  ciphertext += 11;
+  for (i = 0; i < SALT_SIZE; ++i) {
+	  binary_salt[i] = (atoi16[ARCH_INDEX(ciphertext[i*2])] << 4) + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+  }
+  return (void*)binary_salt;
+}
+
+static void nethalflm_set_salt(void *salt)
+{
+	challenge = salt;
+}
+
+static void nethalflm_set_key(char *key, int index)
+{
+	const unsigned char magic[] = {0x4b, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25};
+	DES_key_schedule ks;
+	int i = 0;
+
+	strncpy((char *)saved_plain[index], key, sizeof(saved_plain[index]));
+
+	/* Upper-case password */
+	for(; i<PLAINTEXT_LENGTH && saved_plain[index][i] != 0 ; i++)
+		if ((saved_plain[index][i] >= 'a') && (saved_plain[index][i] <= 'z')) saved_plain[index][i] ^= 0x20;
+
+	/* Generate first 8-bytes of LM hash */
+	setup_des_key(saved_plain[index], &ks);
+	DES_ecb_encrypt((DES_cblock*)magic, (DES_cblock*)saved_pre[index], &ks, DES_ENCRYPT);
+}
+
+static char *nethalflm_get_key(int index)
+{
+	return (char *)saved_plain[index];
+}
+
+static int salt_hash(void *salt)
+{
+	return *(ARCH_WORD_32 *)salt & (SALT_HASH_SIZE - 1);
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return *(ARCH_WORD_32 *)output[index] & 0xFFFFF;
+}
+
+struct fmt_main fmt_NETHALFLM = {
+  {
+    FORMAT_LABEL,
+    FORMAT_NAME,
+    ALGORITHM_NAME,
+    BENCHMARK_COMMENT,
+    BENCHMARK_LENGTH,
+    PLAINTEXT_LENGTH,
+    BINARY_SIZE,
+    SALT_SIZE,
+    MIN_KEYS_PER_CRYPT,
+    MAX_KEYS_PER_CRYPT,
+    FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP,
+    tests
+  }, {
+    init,
+	nethalflm_prepare,
+    nethalflm_valid,
+    nethalflm_split,
+    nethalflm_get_binary,
+    nethalflm_get_salt,
+    {
+	    binary_hash_0,
+	    binary_hash_1,
+	    binary_hash_2,
+	    binary_hash_3,
+	    binary_hash_4
+    },
+    salt_hash,
+    nethalflm_set_salt,
+    nethalflm_set_key,
+    nethalflm_get_key,
+    fmt_default_clear_keys,
+    nethalflm_crypt_all,
+    {
+	    get_hash_0,
+	    get_hash_1,
+	    get_hash_2,
+	    get_hash_3,
+	    get_hash_4
+    },
+    nethalflm_cmp_all,
+    nethalflm_cmp_one,
+    nethalflm_cmp_exact
+  }
+};
diff -rupN john-1.7.8/src/NSLDAPS_fmt_plug.c john-1.7.8-jumbo-2/src/NSLDAPS_fmt_plug.c
--- john-1.7.8/src/NSLDAPS_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NSLDAPS_fmt_plug.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,330 @@
+// Fix for john the ripper 1.6.37 by Sun-Zero, 2004. 07. 26.
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 1996-98 by Solar Designer
+ *
+ * Minor performance enhancement by bartavelle at bandecon.com
+ */
+
+#include <string.h>
+
+#include "misc.h"
+#include "params.h"
+#include "formats.h"
+#include "common.h"
+
+#include "sha.h"
+#include "base64.h"
+
+#define FORMAT_LABEL			"ssha"
+#define FORMAT_NAME			"Netscape LDAP SSHA"
+#define SHA_TYPE                        "salted SHA-1"
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		40
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			8
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		MMX_COEF
+#define MAX_KEYS_PER_CRYPT		MMX_COEF
+#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) )
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+#define NSLDAP_MAGIC "{ssha}"
+#define NSLDAP_MAGIC_LENGTH 6
+
+static struct fmt_tests tests[] = {
+  {"{SSHA}WTT3B9Jjr8gOt0Q7WMs9/XvukyhTQj0Ns0jMKQ==", "Password9"},
+  {"{SSHA}ypkVeJKLzbXakEpuPYbn+YBnQvFmNmB+kQhmWQ==", "qVv3uQ45"},
+  {"{SSHA}cKFVqtf358j0FGpPsEIK1xh3T0mtDNV1kAaBNg==", "salles"},
+  {"{SSHA}W3ipFGmzS3+j6/FhT7ZC39MIfqFcct9Ep0KEGA==", "asddsa123"},
+  {"{SSHA}YbB2R1D2AlzYc9wk/YPtslG7NoiOWaoMOztLHA==", "ripthispassword"},
+#if 0
+/*
+ * These two were found in john-1.6-nsldaps4.diff.gz and apparently they were
+ * supported by that version of they code, but they are not anymore.
+ */
+  {"{SSHA}/EExmSfmhQSPHDJaTxwQSdb/uPpzYWx0ZXI=", "secret"},
+  {"{SSHA}gVK8WC9YyFT1gMsQHTGCgT3sSv5zYWx0", "secret"},
+#endif
+  {NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define buffer NSLDAPS_buffer
+#define crypt_key NSLDAPS_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) unsigned char buffer[80*4*MMX_COEF];
+__declspec(align(16)) char crypt_key[BINARY_SIZE*MMX_COEF];
+#else
+unsigned char buffer[80*4*MMX_COEF] __attribute__ ((aligned(16)));
+char crypt_key[BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+static char saved_key[(PLAINTEXT_LENGTH+SALT_SIZE+4+1)*MMX_COEF];
+static unsigned long total_len;
+static unsigned char out[PLAINTEXT_LENGTH + 1];
+#else
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static char saved_key[PLAINTEXT_LENGTH + 1];
+#endif
+
+#ifdef MMX_COEF
+static unsigned long length[MAX_KEYS_PER_CRYPT];
+#endif
+static char saved_salt[SALT_SIZE];
+
+static void * binary(char *ciphertext) {
+  static char *realcipher;
+  // align realcipher (it is the binary returned, and must be aligned for how we 'use' it later)
+  if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE + SALT_SIZE + 9, MEM_ALIGN_WORD);
+
+  /* stupid overflows */
+  memset(realcipher, 0, sizeof(realcipher));
+  base64_decode(NSLDAP_MAGIC_LENGTH+ciphertext, CIPHERTEXT_LENGTH, realcipher);
+  return (void *)realcipher;
+}
+
+static void * get_salt(char * ciphertext)
+{
+	static char realcipher[BINARY_SIZE + SALT_SIZE + 9];
+	memset(realcipher, 0, sizeof(realcipher));
+	base64_decode(NSLDAP_MAGIC_LENGTH+ciphertext, CIPHERTEXT_LENGTH, realcipher);
+	return (void*)&realcipher[BINARY_SIZE];
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	if(ciphertext && strlen(ciphertext) == CIPHERTEXT_LENGTH + NSLDAP_MAGIC_LENGTH)
+		return !strncasecmp(ciphertext, NSLDAP_MAGIC, NSLDAP_MAGIC_LENGTH);
+	return 0;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	return *((ARCH_WORD_32 *)salt) & (SALT_HASH_SIZE - 1);
+}
+
+static void set_key(char *key, int index)
+{
+#ifdef MMX_COEF
+	int len;
+	int i;
+
+	if(index==0)
+	{
+		total_len = 0;
+		memset(saved_key, 0, sizeof(saved_key));
+		memset(length, 0, sizeof(length));
+	}
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+
+	length[index] = len;
+
+	total_len += (len + SALT_SIZE) << ( ( (32/MMX_COEF) * index ) );
+	for(i=0;i<len;i++)
+		saved_key[GETPOS(i, index)] = key[i];
+
+	saved_key[GETPOS( (i+SALT_SIZE) , index)] = 0x80;
+#else
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+#endif
+}
+
+static void set_salt(void *salt)
+{
+	memcpy(saved_salt, salt, SALT_SIZE);
+
+}
+
+static char *get_key(int index)
+{
+#ifdef MMX_COEF
+	unsigned int i,s;
+
+	s = length[index];
+	for(i=0;i<s;i++)
+		out[i] = saved_key[ GETPOS(i, index) ];
+	out[i] = 0;
+	return (char *) out;
+#else
+  return saved_key;
+#endif
+}
+
+static int
+cmp_all(void *binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#endif
+		)
+			return 0;
+		i++;
+	}
+	return 1;
+#else
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int
+cmp_exact(char *source, int index)
+{
+  return 1;
+}
+
+static int cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+#else
+	return cmp_all(binary, index);
+#endif
+}
+
+
+static void crypt_all(int count)
+{
+#ifdef MMX_COEF
+	int i,idx;
+
+	for(idx=0;idx<MAX_KEYS_PER_CRYPT;idx++)
+		for(i=0;i<SALT_SIZE;i++)
+		{
+			saved_key[GETPOS(i+length[idx],idx)] = ((unsigned char *)saved_salt)[i];
+		}
+
+	memcpy(buffer, saved_key, (PLAINTEXT_LENGTH+SALT_SIZE+4)*MMX_COEF);
+	shammx((unsigned char *) crypt_key, buffer, total_len);
+#else
+	static SHA_CTX ctx;
+	SHA1_Init(&ctx);
+	SHA1_Update(&ctx, (unsigned char *) saved_key, strlen(saved_key));
+	SHA1_Update(&ctx, (unsigned char *) saved_salt, SALT_SIZE);
+	SHA1_Final((unsigned char *) crypt_key, &ctx);
+#endif
+}
+
+struct fmt_main fmt_NSLDAPS = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		SHA_TYPE,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		binary,
+		get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/NSLDAP_fmt_plug.c john-1.7.8-jumbo-2/src/NSLDAP_fmt_plug.c
--- john-1.7.8/src/NSLDAP_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NSLDAP_fmt_plug.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,283 @@
+// Fix for john the ripper 1.6.37 by Sun-Zero, 2004. 07. 26.
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 1996-98 by Solar Designer
+ *
+ * Minor performance enhancement by bartavelle at bandecon.com
+ */
+
+#include <string.h>
+
+#include "misc.h"
+#include "formats.h"
+#include "common.h"
+
+#include "sha.h"
+#include "base64.h"
+
+#define FORMAT_LABEL			"nsldap"
+#define FORMAT_NAME			"Netscape LDAP SHA"
+#define SHA_TYPE                        "SHA-1"
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		33
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			0
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		MMX_COEF
+#define MAX_KEYS_PER_CRYPT		MMX_COEF
+#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) )
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+#define NSLDAP_MAGIC "{sha}"
+#define NSLDAP_MAGIC_LENGTH 5
+
+static struct fmt_tests tests[] = {
+  {"{SHA}cMiB1KJphN3OeV9vcYF8nPRIDnk=", "aaaa"},
+  {"{SHA}iu0TIuVFC62weOH7YKgXod8loso=", "bbbb"},
+  {"{SHA}0ijZPTcJXMa+t2XnEbEwSOkvQu0=", "ccccccccc"},
+  {"{SHA}vNR9eUfJfcKmdkLDqNoKagho+qU=", "dddddddddd"},
+  {NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define buffer NSLDAP_buffer
+#define crypt_key NSLDAP_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) unsigned char buffer[80*4*MMX_COEF];
+__declspec(align(16)) char crypt_key[BINARY_SIZE*MMX_COEF];
+#else
+unsigned char buffer[80*4*MMX_COEF] __attribute__ ((aligned(16)));
+char crypt_key[BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+static char saved_key[(PLAINTEXT_LENGTH+4+1)*MMX_COEF]; // we add an extra DWORD to hold the 0x80 if the password is exactly PLAINTEXT_LENGTH bytes long)
+static unsigned long total_len;
+static unsigned char out[PLAINTEXT_LENGTH + 1];
+#else
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static char saved_key[PLAINTEXT_LENGTH + 1];
+#endif
+
+static void *
+binary(char *ciphertext) {
+  static char realcipher[BINARY_SIZE + 9];
+
+  /* stupid overflows */
+  memset(realcipher, 0, sizeof(realcipher));
+  base64_decode(NSLDAP_MAGIC_LENGTH+ciphertext, CIPHERTEXT_LENGTH, realcipher);
+  return (void *)realcipher;
+}
+
+static int
+valid(char *ciphertext, struct fmt_main *pFmt)
+{
+  if(ciphertext && strlen(ciphertext) == CIPHERTEXT_LENGTH)
+    return !strncasecmp(ciphertext, NSLDAP_MAGIC, NSLDAP_MAGIC_LENGTH);
+  return 0;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFFF;
+}
+
+static void set_key(char *key, int index)
+{
+#ifdef MMX_COEF
+	int len;
+	int i;
+
+	if(index==0)
+	{
+		total_len = 0;
+		memset(saved_key, 0, sizeof(saved_key));
+	}
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+
+	total_len += len << ( ( (32/MMX_COEF) * index ) );
+	for(i=0;i<len;i++)
+		saved_key[GETPOS(i, index)] = key[i];
+
+	saved_key[GETPOS(i, index)] = 0x80;
+#else
+  strnzcpy(saved_key, key, sizeof(saved_key));
+#endif
+}
+
+static char *get_key(int index)
+{
+#ifdef MMX_COEF
+	unsigned int i,s;
+
+	s = (total_len >> (((32/MMX_COEF)*(index)))) & 0xff;
+	for(i=0;i<s;i++)
+		out[i] = saved_key[ GETPOS(i, index) ];
+	out[i] = 0;
+	return (char *) out;
+#else
+  return saved_key;
+#endif
+}
+
+static int
+cmp_all(void *binary, int count)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#endif
+		)
+			return 0;
+		i++;
+	}
+	return 1;
+#else
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int
+cmp_exact(char *source, int index)
+{
+  return 1;
+}
+
+static int cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+#else
+	return cmp_all(binary, index);
+#endif
+}
+
+static void
+crypt_all(int count) {
+#ifdef MMX_COEF
+	memcpy(buffer, saved_key, (PLAINTEXT_LENGTH+4)*MMX_COEF);
+	shammx((unsigned char *) crypt_key, buffer, total_len);
+#else
+  static SHA_CTX ctx;
+  SHA1_Init(&ctx);
+  SHA1_Update(&ctx, (unsigned char *) saved_key, strlen(saved_key));
+  SHA1_Final((unsigned char *) crypt_key, &ctx);
+#endif
+}
+
+struct fmt_main fmt_NSLDAP = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		SHA_TYPE,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		binary,
+		fmt_default_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/NS_fmt_plug.c john-1.7.8-jumbo-2/src/NS_fmt_plug.c
--- john-1.7.8/src/NS_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NS_fmt_plug.c	2011-06-02 17:20:46.000000000 +0200
@@ -0,0 +1,307 @@
+/*
+ *  NS_fmt.c
+ *  Written by Samuel Monux <smonux at gmail.com> in 2008, and placed
+ *  in the public domain.  There's absolutely no warranty.
+ *
+ *  Netscreen OS password module. Passwords must be in this format
+ *  <username>:<username>$<cryptedpass>
+ *
+ *  which appear in Netscreen config file
+ *
+ *  set admin name "<username>"
+ *  set admin password "<cryptedpass>"
+ *
+ *  username is needed because is used as part of the salt.
+ *
+ *  Cryptedpass is generated this way (pseudocode):
+ *
+ *  b64 = array([A-Za-z0-9+/])
+ *  md5_binary = MD5("<username>:Administration Tools:<password>")
+ *
+ *  md5_ascii = ""
+ *  for every 16bits word "w" in md5_binary:
+ *  	append(md5_ascii, b64[ w >> 12 & 0xf ])
+ *  	append(md5_ascii, b64[ w >> 6  & 0x3f ])
+ *  	append(md5_ascii, b64[ w       & 0x3f ])
+ *
+ *  ciphertext = md5_ascii
+ *  for every c,p  ("nrcstn", [0, 6, 12, 17, 23, 29]):
+ *  	interpolate  character "c" in position "p" in ciphertext
+ *
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "md5.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL			"md5ns"
+#define FORMAT_NAME			"Netscreen MD5"
+#define NS_ALGORITHM_NAME               "NS MD5"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		25
+#define CIPHERTEXT_LENGTH		50
+
+#define BINARY_SIZE			16
+#define SALT_SIZE			32
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+
+static struct fmt_tests tests[] = {
+	{"admin$nMjFM0rdC9iOc+xIFsGEm3LtAeGZhn", "password"},
+	{"a$nMf9FkrCIgHGccRAxsBAwxBtDtPHfn", "netscreen"},
+	{NULL}
+};
+
+static unsigned short e64toshort[256];
+
+#define ADM_LEN 22
+static int salt_len, key_len;
+static char cipher_salt[ SALT_SIZE  ];
+static char cipher_key[ PLAINTEXT_LENGTH + 1 ];
+static char *adm = ":Administration Tools:";
+static char tocipher[ SALT_SIZE + ADM_LEN + PLAINTEXT_LENGTH ];
+static ARCH_WORD_32 crypted[4];
+
+
+static void NS_init(struct fmt_main *pFmt)
+{
+	int i;
+	static char *b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+	char *pos;
+	for (pos = b64, i = 0 ; *pos != 0 ; pos++, i++)
+		e64toshort[(int)*pos] = i;
+}
+
+static int NS_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *password;
+	static char *netscreen = "nrcstn" ;
+        static int  p[] = { 0, 6, 12, 17, 23, 29 };
+	int i;
+
+        password = ciphertext;
+
+        while ((*password != '$') && (*password != '\0' ))
+            password++;
+        if (*password == '\0') return 0;
+        password++;
+
+	if (strlen(password) != 30) return 0;
+	for (i = 0; i < 6 ; i++)
+		if (netscreen[i] != password[p[i]]) return 0;
+
+	for (i = 0; i < 30 ; i++) {
+		char c = password[i];
+		if (((c >= 'A') && ( c <= 'Z')) ||
+		     ((c >= 'a') && ( c <= 'z')) ||
+		     ((c >= '0') && ( c <= '9')) ||
+		     (c == '+')  || ( c == '/'))
+		continue;
+		return 0;
+	}
+	return 1;
+}
+
+static ARCH_WORD_32 *NS_std_get_binary(char *ciphertext)
+{
+	static ARCH_WORD_32 out[4];
+	char unscrambled[24];
+	int i;
+        MD5_u32plus a, b, c;
+        MD5_u32plus d, e, f;
+	char *pos;
+#if ARCH_LITTLE_ENDIAN
+        MD5_u32plus temp;
+#endif
+
+        pos = ciphertext;
+	while (*pos++ != '$');
+
+	memcpy(unscrambled, pos + 1, 6 );
+	memcpy(unscrambled + 5, pos + 7, 6 );
+	memcpy(unscrambled + 10, pos + 13, 5 );
+	memcpy(unscrambled + 14, pos + 18, 6 );
+	memcpy(unscrambled + 19, pos + 24, 5 );
+
+	for ( i = 0 ; i < 4 ; i++ ) {
+                a = e64toshort[ARCH_INDEX(unscrambled[6*i])];
+                b = e64toshort[ARCH_INDEX(unscrambled[6*i + 1 ])];
+                c = e64toshort[ARCH_INDEX(unscrambled[6*i + 2 ])];
+                d = e64toshort[ARCH_INDEX(unscrambled[6*i + 3 ])];
+                e = e64toshort[ARCH_INDEX(unscrambled[6*i + 4 ])];
+                f = e64toshort[ARCH_INDEX(unscrambled[6*i + 5 ])];
+#if ARCH_LITTLE_ENDIAN
+                temp = (((a << 12) | (b << 6) | (c)) << 16) |
+			    ((d << 12) | (e << 6) | (f));
+		out[i] = ((temp << 24) & 0xff000000 ) |
+		           ((temp << 8)  & 0x00ff0000 ) |
+		           ((temp >> 8)  & 0x0000ff00 ) |
+			   ((temp >> 24) & 0x000000ff );
+#else
+                out[i] = (((a << 12) | (b << 6) | (c)) << 16) |
+			    ((d << 12) | (e << 6) | (f));
+#endif
+	}
+
+	return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xf;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xff;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xfff;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xffff;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xfffff;
+}
+
+static int get_hash_0(int index)
+{
+	return crypted[0] & 0xf;
+}
+
+static int get_hash_1(int index)
+{
+	return crypted[0] & 0xff;
+}
+
+static int get_hash_2(int index)
+{
+	return crypted[0] & 0xfff;
+}
+
+static int get_hash_3(int index)
+{
+	return crypted[0] & 0xffff;
+}
+
+static int get_hash_4(int index)
+{
+	return crypted[0] & 0xfffff;
+}
+
+char *NS_std_get_salt(char *ciphertext)
+{
+	static char out[SALT_SIZE + 1];
+	char *ipos, *opos;
+
+	ipos = ciphertext;
+	opos = out;
+	while (*ipos != '$') *opos++ = *ipos++;
+	*opos = '\0';
+
+	return out;
+}
+
+void NS_std_set_salt (void *salt)
+{
+    salt_len = strlen((char *) salt);
+    memcpy(cipher_salt, salt , salt_len);
+}
+
+static void  NS_set_key(char *key, int index)
+{
+    key_len = strlen((char *) key);
+    if (key_len > PLAINTEXT_LENGTH)
+	key_len = PLAINTEXT_LENGTH;
+    memcpy(cipher_key, key, key_len);
+}
+
+static char *NS_get_key(int key)
+{
+    cipher_key[key_len] = 0;
+    return cipher_key;
+}
+
+static void NS_std_crypt(int key)
+{
+	MD5_CTX ctx;
+	MD5_Init(&ctx);
+	memcpy(tocipher, cipher_salt, salt_len);
+	memcpy(tocipher + salt_len, adm, ADM_LEN);
+	memcpy(tocipher + salt_len + ADM_LEN, cipher_key, key_len);
+	MD5_Update(&ctx , tocipher, salt_len + ADM_LEN + key_len);
+	MD5_Final((void*)crypted, &ctx);
+}
+
+static int NS_cmp_all(void *binary, int index)
+{
+	return !memcmp(binary, crypted, BINARY_SIZE);
+}
+
+static int NS_cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_NS = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		NS_ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		NS_init,
+		fmt_default_prepare,
+		NS_valid,
+		fmt_default_split,
+		(void *(*)(char *))NS_std_get_binary,
+		(void *(*)(char *))NS_std_get_salt,
+		{
+                    binary_hash_0,
+                    binary_hash_1,
+                    binary_hash_2,
+                    binary_hash_3,
+                    binary_hash_4
+		},
+		fmt_default_salt_hash,
+		NS_std_set_salt,
+		NS_set_key,
+		NS_get_key,
+		fmt_default_clear_keys,
+		NS_std_crypt,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		NS_cmp_all,
+		NS_cmp_all,
+		NS_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/NT_fmt_plug.c john-1.7.8-jumbo-2/src/NT_fmt_plug.c
--- john-1.7.8/src/NT_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/NT_fmt_plug.c	2011-06-06 10:15:05.000000000 +0200
@@ -0,0 +1,874 @@
+/* NTLM patch for john (performance improvement)
+ *
+ * Written by Alain Espinosa <alainesp at gmail.com> in 2007.  No copyright
+ * is claimed, and the software is hereby placed in the public domain.
+ * In case this attempt to disclaim copyright and place the software in the
+ * public domain is deemed null and void, then the software is
+ * Copyright (c) 2007 Alain Espinosa and it is hereby released to the
+ * general public under the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * There's ABSOLUTELY NO WARRANTY, express or implied.
+ *
+ * (This is a heavily cut-down "BSD license".)
+ *
+ * UTF-8 support and performance tweaks by magnum 2011, same terms as above.
+ *
+ */
+
+#include <string.h>
+#include "arch.h"
+#include "misc.h"
+#include "memory.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+#include "unicode.h"
+
+//Init values
+#define INIT_A 0x67452301
+#define INIT_B 0xefcdab89
+#define INIT_C 0x98badcfe
+#define INIT_D 0x10325476
+
+#define SQRT_2 0x5a827999
+#define SQRT_3 0x6ed9eba1
+
+
+#define FORMAT_LABEL			"nt"
+#define FORMAT_NAME			"NT MD4"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		27
+#define CIPHERTEXT_LENGTH		36
+
+// Note: the ISO-8859-1 plaintexts will be replaced in init() if running UTF-8
+static struct fmt_tests tests[] = {
+	{"$NT$b7e4b9022cd45f275334bbdb83bb5be5", "John the Ripper"},
+	{"$NT$8bd6e4fb88e01009818749c5443ea712", "\xFC"},         // German u-umlaut in 8859-1
+	{"$NT$cc1260adb6985ca749f150c7e0b22063", "\xFC\xFC"},     // two of them
+	{"$NT$2e583e8c210fb101994c19877ac53b89", "\xFC\xFC\xFC"}, // you get it
+	{"$NT$243bb98e7704797f92b1dd7ded6da0d0", "\xFC\xFC\xFC\xFC" },
+	{"$NT$31d6cfe0d16ae931b73c59d7e0c089c0", ""},
+	{"$NT$7a21990fcd3d759941e45c490f143d5f", "12345"},
+	{"$NT$f9e37e83b83c47a93c2f09f66408631b", "abc123"},
+	{"$NT$8846f7eaee8fb117ad06bdd830b7586c", "password"},
+	{"$NT$2b2ac2d1c7c8fda6cea80b5fad7563aa", "computer"},
+	{"$NT$32ed87bdb5fdc5e9cba88547376818d4", "123456"},
+	{"$NT$b7e0ea9fbffcf6dd83086e905089effd", "tigger"},
+	{"$NT$7ce21f17c0aee7fb9ceba532d0546ad6", "1234"},
+	{"$NT$b23a90d0aad9da3615fafc27a1b8baeb", "a1b2c3"},
+	{"$NT$2d20d252a479f485cdf5e171d93985bf", "qwerty"},
+	{"$NT$3dbde697d71690a769204beb12283678", "123"},
+	{"$NT$c889c75b7c1aae1f7150c5681136e70e", "xxx"},
+	{"$NT$d5173c778e0f56d9fc47e3b3c829aca7", "money"},
+	{"$NT$0cb6948805f797bf2a82807973b89537", "test"},
+	{"$NT$0569fcf2b14b9c7f3d3b5f080cbd85e5", "carmen"},
+	{"$NT$f09ab1733a528f430353834152c8a90e", "mickey"},
+	{"$NT$878d8014606cda29677a44efa1353fc7", "secret"},
+	{"$NT$85ac333bbfcbaa62ba9f8afb76f06268", "summer"},
+	{"$NT$5962cc080506d90be8943118f968e164", "internet"},
+	{"$NT$f07206c3869bda5acd38a3d923a95d2a", "service"},
+	{"$NT$d0dfc65e8f286ef82f6b172789a0ae1c", "canada"},
+	{"$NT$066ddfd4ef0e9cd7c256fe77191ef43c", "hello"},
+	{"$NT$39b8620e745b8aa4d1108e22f74f29e2", "ranger"},
+	{"$NT$8d4ef8654a9adc66d4f628e94f66e31b", "shadow"},
+	{"$NT$320a78179516c385e35a93ffa0b1c4ac", "baseball"},
+	{"$NT$e533d171ac592a4e70498a58b854717c", "donald"},
+	{"$NT$5eee54ce19b97c11fd02e531dd268b4c", "harley"},
+	{"$NT$6241f038703cbfb7cc837e3ee04f0f6b", "hockey"},
+	{"$NT$becedb42ec3c5c7f965255338be4453c", "letmein"},
+	{"$NT$ec2c9f3346af1fb8e4ee94f286bac5ad", "maggie"},
+	{"$NT$f5794cbd75cf43d1eb21fad565c7e21c", "mike"},
+	{"$NT$74ed32086b1317b742c3a92148df1019", "mustang"},
+	{"$NT$63af6e1f1dd9ecd82f17d37881cb92e6", "snoopy"},
+	{"$NT$58def5844fe58e8f26a65fff9deb3827", "buster"},
+	{"$NT$f7eb9c06fafaa23c4bcf22ba6781c1e2", "dragon"},
+	{"$NT$dd555241a4321657e8b827a40b67dd4a", "jordan"},
+	{"$NT$bb53a477af18526ada697ce2e51f76b3", "michael"},
+	{"$NT$92b7b06bb313bf666640c5a1e75e0c18", "michelle"},
+	{NULL}
+};
+
+#define BINARY_SIZE			16
+#define SALT_SIZE			0
+
+#if defined (NT_X86_64)
+	#define NT_NUM_KEYS	32
+
+#ifdef _MSC_VER
+	__declspec(align(16)) unsigned int nt_buffer8x[16*NT_NUM_KEYS];
+	__declspec(align(16)) unsigned int output8x[4*NT_NUM_KEYS];
+#else
+	unsigned int nt_buffer8x[16*NT_NUM_KEYS] __attribute__ ((aligned(16)));
+	unsigned int output8x[4*NT_NUM_KEYS] __attribute__ ((aligned(16)));
+#endif
+
+	#define ALGORITHM_NAME		"128/128 X2 SSE2-16"
+	#define NT_CRYPT_FUN		nt_crypt_all_x86_64
+	extern void nt_crypt_all_x86_64(int count);
+#elif defined (NT_SSE2)
+	#define NT_NUM_KEYS	40
+	#define NT_NUM_KEYS1	8
+	#define NT_NUM_KEYS4	32
+
+#ifdef _MSC_VER
+	__declspec(align(16)) unsigned int nt_buffer4x[64*NT_NUM_KEYS1];
+	__declspec(align(16)) unsigned int output4x[16*NT_NUM_KEYS1];
+#else
+	unsigned int nt_buffer4x[64*NT_NUM_KEYS1] __attribute__ ((aligned(16)));
+	unsigned int output4x[16*NT_NUM_KEYS1] __attribute__ ((aligned(16)));
+#endif
+
+	unsigned int nt_buffer1x[16*NT_NUM_KEYS1];
+	unsigned int output1x[4*NT_NUM_KEYS1];
+
+	#define ALGORITHM_NAME		"128/128 SSE2 + 32/32"
+	#define NT_CRYPT_FUN		nt_crypt_all_sse2
+	extern void nt_crypt_all_sse2(int count);
+#else
+	#define NT_NUM_KEYS		64
+	unsigned int nt_buffer1x[16*NT_NUM_KEYS];
+	unsigned int output1x[4*NT_NUM_KEYS];
+
+	#define ALGORITHM_NAME		"32/32"
+	#define NT_CRYPT_FUN		nt_crypt_all_generic
+	static void nt_crypt_all_generic(int count)
+	{
+		unsigned int a;
+		unsigned int b;
+		unsigned int c;
+		unsigned int d;
+		unsigned int i=0;
+
+		for(;i<NT_NUM_KEYS;i++)
+		{
+			/* Round 1 */
+			a = 		0xFFFFFFFF 		 +nt_buffer1x[i*16+0];a=(a<<3 )|(a>>29);
+			d = INIT_D+(INIT_C ^ (a & 0x77777777))   +nt_buffer1x[i*16+1];d=(d<<7 )|(d>>25);
+			c = INIT_C+(INIT_B ^ (d & (a ^ INIT_B))) +nt_buffer1x[i*16+2];c=(c<<11)|(c>>21);
+			b = INIT_B + (a ^ (c & (d ^ a))) 	 +nt_buffer1x[i*16+3];b=(b<<19)|(b>>13);
+
+			a += (d ^ (b & (c ^ d)))  +  nt_buffer1x[i*16+4]  ;a = (a << 3 ) | (a >> 29);
+			d += (c ^ (a & (b ^ c)))  +  nt_buffer1x[i*16+5]  ;d = (d << 7 ) | (d >> 25);
+			c += (b ^ (d & (a ^ b)))  +  nt_buffer1x[i*16+6]  ;c = (c << 11) | (c >> 21);
+			b += (a ^ (c & (d ^ a)))  +  nt_buffer1x[i*16+7]  ;b = (b << 19) | (b >> 13);
+
+			a += (d ^ (b & (c ^ d)))  +  nt_buffer1x[i*16+8]  ;a = (a << 3 ) | (a >> 29);
+			d += (c ^ (a & (b ^ c)))  +  nt_buffer1x[i*16+9]  ;d = (d << 7 ) | (d >> 25);
+			c += (b ^ (d & (a ^ b)))  +  nt_buffer1x[i*16+10] ;c = (c << 11) | (c >> 21);
+			b += (a ^ (c & (d ^ a)))  +  nt_buffer1x[i*16+11] ;b = (b << 19) | (b >> 13);
+
+			a += (d ^ (b & (c ^ d)))  +  nt_buffer1x[i*16+12] ;a = (a << 3 ) | (a >> 29);
+			d += (c ^ (a & (b ^ c)))  +  nt_buffer1x[i*16+13] ;d = (d << 7 ) | (d >> 25);
+			c += (b ^ (d & (a ^ b)))  +  nt_buffer1x[i*16+14] ;c = (c << 11) | (c >> 21);
+			b += (a ^ (c & (d ^ a)));b = (b << 19) | (b >> 13);
+
+			/* Round 2 */
+			a += ((b & (c | d)) | (c & d))+nt_buffer1x[i*16+0] +SQRT_2;a = (a<<3 ) | (a>>29);
+			d += ((a & (b | c)) | (b & c))+nt_buffer1x[i*16+4] +SQRT_2;d = (d<<5 ) | (d>>27);
+			c += ((d & (a | b)) | (a & b))+nt_buffer1x[i*16+8] +SQRT_2;c = (c<<9 ) | (c>>23);
+			b += ((c & (d | a)) | (d & a))+nt_buffer1x[i*16+12]+SQRT_2;b = (b<<13) | (b>>19);
+
+			a += ((b & (c | d)) | (c & d))+nt_buffer1x[i*16+1] +SQRT_2;a = (a<<3 ) | (a>>29);
+			d += ((a & (b | c)) | (b & c))+nt_buffer1x[i*16+5] +SQRT_2;d = (d<<5 ) | (d>>27);
+			c += ((d & (a | b)) | (a & b))+nt_buffer1x[i*16+9] +SQRT_2;c = (c<<9 ) | (c>>23);
+			b += ((c & (d | a)) | (d & a))+nt_buffer1x[i*16+13]+SQRT_2;b = (b<<13) | (b>>19);
+
+			a += ((b & (c | d)) | (c & d))+nt_buffer1x[i*16+2] +SQRT_2;a = (a<<3 ) | (a>>29);
+			d += ((a & (b | c)) | (b & c))+nt_buffer1x[i*16+6] +SQRT_2;d = (d<<5 ) | (d>>27);
+			c += ((d & (a | b)) | (a & b))+nt_buffer1x[i*16+10]+SQRT_2;c = (c<<9 ) | (c>>23);
+			b += ((c & (d | a)) | (d & a))+nt_buffer1x[i*16+14]+SQRT_2;b = (b<<13) | (b>>19);
+
+			a += ((b & (c | d)) | (c & d))+nt_buffer1x[i*16+3] +SQRT_2;a = (a<<3 ) | (a>>29);
+			d += ((a & (b | c)) | (b & c))+nt_buffer1x[i*16+7] +SQRT_2;d = (d<<5 ) | (d>>27);
+			c += ((d & (a | b)) | (a & b))+nt_buffer1x[i*16+11]+SQRT_2;c = (c<<9 ) | (c>>23);
+			b += ((c & (d | a)) | (d & a))			   +SQRT_2;b = (b<<13) | (b>>19);
+
+			/* Round 3 */
+			a += (d ^ c ^ b) + nt_buffer1x[i*16+0]  +  SQRT_3; a = (a << 3 ) | (a >> 29);
+			d += (c ^ b ^ a) + nt_buffer1x[i*16+8]  +  SQRT_3; d = (d << 9 ) | (d >> 23);
+			c += (b ^ a ^ d) + nt_buffer1x[i*16+4]  +  SQRT_3; c = (c << 11) | (c >> 21);
+			b += (a ^ d ^ c) + nt_buffer1x[i*16+12] +  SQRT_3; b = (b << 15) | (b >> 17);
+
+			a += (d ^ c ^ b) + nt_buffer1x[i*16+2]  +  SQRT_3; a = (a << 3 ) | (a >> 29);
+			d += (c ^ b ^ a) + nt_buffer1x[i*16+10] +  SQRT_3; d = (d << 9 ) | (d >> 23);
+			c += (b ^ a ^ d) + nt_buffer1x[i*16+6]  +  SQRT_3; c = (c << 11) | (c >> 21);
+			b += (a ^ d ^ c) + nt_buffer1x[i*16+14] +  SQRT_3; b = (b << 15) | (b >> 17);
+
+			a += (d ^ c ^ b) + nt_buffer1x[i*16+1]  +  SQRT_3; a = (a << 3 ) | (a >> 29);
+			d += (c ^ b ^ a) + nt_buffer1x[i*16+9]  +  SQRT_3; d = (d << 9 ) | (d >> 23);
+			c += (b ^ a ^ d) + nt_buffer1x[i*16+5]  +  SQRT_3; c = (c << 11) | (c >> 21);
+			b += (a ^ d ^ c) + nt_buffer1x[i*16+13];
+
+			output1x[4*i+0]=a;
+			output1x[4*i+1]=b;
+			output1x[4*i+2]=c;
+			output1x[4*i+3]=d;
+		}
+	}
+#endif
+
+static unsigned int last_i[NT_NUM_KEYS];
+
+#define MIN_KEYS_PER_CRYPT		NT_NUM_KEYS
+#define MAX_KEYS_PER_CRYPT		NT_NUM_KEYS
+
+static void set_key_utf8(char *_key, int index);
+static char *get_key_utf8(int index);
+extern struct fmt_main fmt_NT;
+
+static void fmt_NT_init(struct fmt_main *pFmt)
+{
+	memset(last_i,0,4*NT_NUM_KEYS);
+#if defined(NT_X86_64)
+	memset(nt_buffer8x,0,16*4*NT_NUM_KEYS);
+#elif defined(NT_SSE2)
+	memset(nt_buffer4x,0,64*4*NT_NUM_KEYS1);
+	memset(nt_buffer1x,0,16*4*NT_NUM_KEYS1);
+#else
+	memset(nt_buffer1x,0,16*4*NT_NUM_KEYS);
+#endif
+	if (options.flags & FLG_UTF8) {
+		/* This avoids an if clause for every set_key */
+		fmt_NT.methods.set_key = set_key_utf8;
+		fmt_NT.methods.get_key = get_key_utf8;
+		/* kick it up from 27. We will 'adjust' in the setkey_utf8 function.  */
+		fmt_NT.params.plaintext_length = 3 * PLAINTEXT_LENGTH;
+		tests[1].plaintext = "\xC3\xBC";         // German u-umlaut in UTF-8
+		tests[2].plaintext = "\xC3\xBC\xC3\xBC"; // two of them
+		tests[3].plaintext = "\xE2\x82\xAC";     // euro sign
+		tests[3].ciphertext = "$NT$030926b781938db4365d46adc7cfbcb8";
+		tests[4].plaintext = "\xE2\x82\xAC\xE2\x82\xAC";
+		tests[4].ciphertext = "$NT$682467b963bb4e61943e170a04f7db46";
+	}
+}
+
+static char * nt_split(char *ciphertext, int index)
+{
+	static char out[37];
+
+	if (!strncmp(ciphertext, "$NT$", 4))
+		ciphertext += 4;
+
+	out[0] = '$';
+	out[1] = 'N';
+	out[2] = 'T';
+	out[3] = '$';
+
+	memcpy(&out[4], ciphertext, 32);
+	out[36] = 0;
+
+	strlwr(&out[4]);
+
+	return out;
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+        char *pos;
+
+	if (strncmp(ciphertext, "$NT$", 4)!=0) return 0;
+
+        for (pos = &ciphertext[4]; atoi16[ARCH_INDEX(*pos)] != 0x7F; pos++);
+
+        if (!*pos && pos - ciphertext == CIPHERTEXT_LENGTH)
+		return 1;
+        else
+        	return 0;
+
+}
+
+// here to 'handle' the pwdump files:  user:gid:lmhash:ntlmhash:::
+// Note, we do NOT address the group id issues in the lm stuff, inside loader.
+static char *prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	extern struct options_main options;
+	if (!valid(split_fields[1], pFmt)) {
+		if (strlen(split_fields[3]) == 32) {
+			char *tmp = mem_alloc(32+5);
+			sprintf(tmp, "$NT$%s", split_fields[3]);
+			if (valid(tmp,pFmt)) {
+				char *cp = str_alloc_copy(tmp);
+				MEM_FREE(tmp);
+				return cp;
+			}
+			MEM_FREE(tmp);
+		}
+		if (options.format && !strcmp(options.format, "nt") && strlen(split_fields[1]) == 32) {
+			char *tmp = mem_alloc(32+5);
+			sprintf(tmp, "$NT$%s", split_fields[1]);
+			if (valid(tmp,pFmt)) {
+				char *cp = str_alloc_copy(tmp);
+				MEM_FREE(tmp);
+				return cp;
+			}
+			MEM_FREE(tmp);
+		}
+	}
+	return split_fields[1];
+}
+
+static void *get_binary(char *ciphertext)
+{
+	static unsigned int out[4];
+	unsigned int i=0;
+	unsigned int temp;
+
+	ciphertext+=4;
+	for (; i<4; i++)
+	{
+ 		temp  = (atoi16[ARCH_INDEX(ciphertext[i*8+0])])<<4;
+ 		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+1])]);
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+2])])<<12;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+3])])<<8;
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+4])])<<20;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+5])])<<16;
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+6])])<<28;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+7])])<<24;
+
+		out[i]=temp;
+	}
+
+	out[0] -= INIT_A;
+	out[1] -= INIT_B;
+	out[2] -= INIT_C;
+	out[3] -= INIT_D;
+
+	out[1]  = (out[1] >> 15) | (out[1] << 17);
+	out[1] -= SQRT_3 + (out[2] ^ out[3] ^ out[0]);
+	out[1]  = (out[1] >> 15) | (out[1] << 17);
+	out[1] -= SQRT_3;
+
+	return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((unsigned int *)binary)[1] & 0x0F;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((unsigned int *)binary)[1] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((unsigned int *)binary)[1] & 0x0FFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((unsigned int *)binary)[1] & 0x0FFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((unsigned int *)binary)[1] & 0x0FFFFF;
+}
+
+static int get_hash_0(int index)
+{
+#if defined(NT_X86_64)
+	return output8x[32*(index>>3)+8+index%8] & 0x0F;
+#elif defined(NT_SSE2)
+	if(index<NT_NUM_KEYS4)
+		return output4x[16*(index>>2)+4+index%4] & 0x0F;
+	else
+		return output1x[(index-NT_NUM_KEYS4)*4+1] & 0x0F;
+#else
+	return output1x[(index<<2)+1] & 0x0F;
+#endif
+}
+
+static int get_hash_1(int index)
+{
+#if defined(NT_X86_64)
+	return output8x[32*(index>>3)+8+index%8] & 0xFF;
+#elif defined(NT_SSE2)
+	if(index<NT_NUM_KEYS4)
+		return output4x[16*(index>>2)+4+index%4] & 0xFF;
+	else
+		return output1x[(index-NT_NUM_KEYS4)*4+1] & 0xFF;
+#else
+	return output1x[(index<<2)+1] & 0xFF;
+#endif
+}
+
+static int get_hash_2(int index)
+{
+#if defined(NT_X86_64)
+	return output8x[32*(index>>3)+8+index%8] & 0x0FFF;
+#elif defined(NT_SSE2)
+	if(index<NT_NUM_KEYS4)
+		return output4x[16*(index>>2)+4+index%4] & 0x0FFF;
+	else
+		return output1x[(index-NT_NUM_KEYS4)*4+1] & 0x0FFF;
+#else
+	return output1x[(index<<2)+1] & 0x0FFF;
+#endif
+}
+
+static int get_hash_3(int index)
+{
+#if defined(NT_X86_64)
+	return output8x[32*(index>>3)+8+index%8] & 0x0FFFF;
+#elif defined(NT_SSE2)
+	if(index<NT_NUM_KEYS4)
+		return output4x[16*(index>>2)+4+index%4] & 0x0FFFF;
+	else
+		return output1x[(index-NT_NUM_KEYS4)*4+1] & 0x0FFFF;
+#else
+	return output1x[(index<<2)+1] & 0x0FFFF;
+#endif
+}
+
+static int get_hash_4(int index)
+{
+#if defined(NT_X86_64)
+	return output8x[32*(index>>3)+8+index%8] & 0x0FFFFF;
+#elif defined(NT_SSE2)
+	if(index<NT_NUM_KEYS4)
+		return output4x[16*(index>>2)+4+index%4] & 0x0FFFFF;
+	else
+		return output1x[(index-NT_NUM_KEYS4)*4+1] & 0x0FFFFF;
+#else
+	return output1x[(index<<2)+1] & 0x0FFFFF;
+#endif
+}
+
+static int cmp_all(void *binary, int count)
+{
+	unsigned int i=0;
+	unsigned int b=((unsigned int *)binary)[1];
+
+#if defined(NT_X86_64)
+	for(;i<(NT_NUM_KEYS/8);i++)
+		if(b==output8x[i*32+8] || b==output8x[i*32+9] || b==output8x[i*32+10] || b==output8x[i*32+11] || b==output8x[i*32+12] || b==output8x[i*32+13] || b==output8x[i*32+14] || b==output8x[i*32+15])
+			return 1;
+#elif defined(NT_SSE2)
+	unsigned int pos=4;
+
+	for(;i<NT_NUM_KEYS1;i++,pos+=16)
+		if(b==output4x[pos] || b==output4x[pos+1] || b==output4x[pos+2] || b==output4x[pos+3])
+			return 1;
+	i=1;
+	for(;i<NT_NUM_KEYS4;i+=4)
+		if(b==output1x[i])
+			return 1;
+#else
+	for(;i<NT_NUM_KEYS;i++)
+		if(b==output1x[i*4+1])
+			return 1;
+#endif
+
+	return 0;
+}
+
+static int cmp_one(void * binary, int index)
+{
+	unsigned int *t=(unsigned int *)binary;
+	unsigned int a;
+	unsigned int b;
+	unsigned int c;
+	unsigned int d;
+
+	unsigned int * buffer;
+	int pos1;
+	int pos2;
+	int pos3;
+
+#if defined(NT_X86_64)
+	int temp;
+	buffer=nt_buffer8x;
+
+	temp=32*(index>>3)+index%8;
+
+	a=output8x[temp];
+	b=output8x[temp+8];
+	c=output8x[temp+16];
+	d=output8x[temp+24];
+
+	pos1=24+index%8+128*(index>>3);
+	pos2=64+pos1;
+	pos3=32+pos1;
+#elif defined(NT_SSE2)
+	int temp;
+
+	if(index<NT_NUM_KEYS4)
+	{
+		buffer=nt_buffer4x;
+
+		temp=16*(index>>2)+index%4;
+
+		a=output4x[temp];
+		b=output4x[temp+4];
+		c=output4x[temp+8];
+		d=output4x[temp+12];
+
+		pos1=12+index%4+64*(index>>2);
+		pos2=32+pos1;
+		pos3=16+pos1;
+	}
+	else
+	{
+		buffer=nt_buffer1x;
+
+		temp=4*(index-NT_NUM_KEYS4);
+
+		a=output1x[temp];
+		b=output1x[temp+1];
+		c=output1x[temp+2];
+		d=output1x[temp+3];
+
+		pos1=3+4*temp;
+		pos2=8+pos1;
+		pos3=4+pos1;
+	}
+#else
+	buffer=nt_buffer1x;
+
+	a=output1x[(index<<2)];
+	b=output1x[(index<<2)+1];
+	c=output1x[(index<<2)+2];
+	d=output1x[(index<<2)+3];
+
+	pos1=(index<<4)+3;
+	pos2=8+pos1;
+	pos3=4+pos1;
+#endif
+	if(b!=t[1])
+		return 0;
+	b += SQRT_3;b = (b << 15) | (b >> 17);
+
+	a += (b ^ c ^ d) + buffer[pos1] + SQRT_3; a = (a << 3 ) | (a >> 29);
+	if(a!=t[0])
+		return 0;
+
+	d += (a ^ b ^ c) + buffer[pos2] + SQRT_3; d = (d << 9 ) | (d >> 23);
+	if(d!=t[3])
+		return 0;
+
+	c += (d ^ a ^ b) + buffer[pos3] + SQRT_3; c = (c << 11) | (c >> 21);
+	return c==t[2];
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+// This is common code for the SSE/MMX/generic variants of non-UTF8 set_key
+static inline void set_key_helper(unsigned int * keybuffer,
+                                  unsigned int xBuf,
+                                  const unsigned char * key,
+                                  unsigned int lenStoreOffset,
+                                  unsigned int *last_length)
+{
+	unsigned int i=0;
+	unsigned int md4_size=0;
+	for(; key[md4_size] && md4_size < PLAINTEXT_LENGTH; i += xBuf, md4_size++)
+	{
+		unsigned int temp;
+		if ((temp = key[++md4_size]))
+		{
+			keybuffer[i] = key[md4_size-1] | (temp << 16);
+		}
+		else
+		{
+			keybuffer[i] = key[md4_size-1] | 0x800000;
+			goto key_cleaning;
+		}
+	}
+	keybuffer[i] = 0x80;
+
+key_cleaning:
+	i += xBuf;
+	for(;i <= *last_length; i += xBuf)
+		keybuffer[i] = 0;
+
+	if (xBuf==1)
+		*last_length = (md4_size >> 1) + 1;
+	else
+		*last_length = md4_size << (xBuf>>2);
+
+	keybuffer[lenStoreOffset] = md4_size << 4;
+}
+
+static void set_key(char *_key, int index)
+{
+#if defined(NT_X86_64)
+	set_key_helper(&nt_buffer8x[128 * (index >> 3) + index % 8], 8,
+	               (unsigned char *)_key, 112, &last_i[index]);
+#elif defined(NT_SSE2)
+	if(index < NT_NUM_KEYS4) {
+		set_key_helper(&nt_buffer4x[64 * (index >> 2) + index % 4], 4,
+		               (unsigned char *)_key, 56, &last_i[index]);
+	}
+	else
+		set_key_helper(&nt_buffer1x[16 * (index - NT_NUM_KEYS4)], 1,
+		               (unsigned char *)_key, 14, &last_i[index]);
+#else
+	set_key_helper(&nt_buffer1x[index << 4], 1, (unsigned char *)_key, 14,
+	               &last_i[index]);
+//	dump_stuff_msg("setkey ", (unsigned char*)&nt_buffer1x[index << 4], 40);
+//	exit(0);
+#endif
+}
+
+// We can get our key back from the key buffer instead of storing it
+// This is common code for the SSE/MMX/generic variants
+static inline char *get_key_helper(unsigned int * keybuffer, unsigned int xBuf)
+{
+	static unsigned char key[PLAINTEXT_LENGTH + 1];
+	unsigned int md4_size=0;
+	unsigned int i=0;
+
+	for(; md4_size < PLAINTEXT_LENGTH; i += xBuf, md4_size++)
+	{
+		key[md4_size] = keybuffer[i];
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+		key[++md4_size] = keybuffer[i] >> 16;
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+	}
+	return (char *) key;
+}
+
+static char *get_key(int index)
+{
+#if defined(NT_X86_64)
+	return get_key_helper(&nt_buffer8x[128 * (index >> 3) + index % 8], 8);
+#elif defined(NT_SSE2)
+	if(index < NT_NUM_KEYS4)
+		return get_key_helper(&nt_buffer4x[64 * (index >> 2) + index % 4], 4);
+	else
+		return get_key_helper(&nt_buffer1x[16 * (index - NT_NUM_KEYS4)], 1);
+#else
+	return get_key_helper(&nt_buffer1x[index << 4], 1);
+#endif
+}
+
+// UTF-8 conversion right into key buffer
+// This is common code for the SSE/MMX/generic variants
+static inline void set_key_helper_utf8(unsigned int * keybuffer, unsigned int xBuf,
+    const UTF8 * source, unsigned int lenStoreOffset, unsigned int *lastlen)
+{
+	unsigned int *target = keybuffer;
+	unsigned int *targetEnd = &keybuffer[xBuf * ((PLAINTEXT_LENGTH + 1) >> 1)];
+	UTF32 chl, chh = 0x80;
+	unsigned int outlen = 0;
+
+	while (*source) {
+		chl = *source;
+		if (chl >= 0xC0) {
+			unsigned int extraBytesToRead = opt_trailingBytesUTF8[chl & 0x3f];
+			switch (extraBytesToRead) {
+			case 2:
+				++source;
+				if (*source) {
+					chl <<= 6;
+					chl += *source;
+				} else {
+					*lastlen = ((27 >> 1) + 1) * xBuf;
+					return;
+				}
+			case 1:
+				++source;
+				if (*source) {
+					chl <<= 6;
+					chl += *source;
+				} else {
+					*lastlen = ((27 >> 1) + 1) * xBuf;
+					return;
+				}
+			case 0:
+				break;
+			default:
+				*lastlen = ((27 >> 1) + 1) * xBuf;
+				return;
+			}
+			chl -= offsetsFromUTF8[extraBytesToRead];
+		}
+		source++;
+		outlen++;
+		if (*source) {
+			chh = *source;
+			if (chh >= 0xC0) {
+				unsigned int extraBytesToRead =
+					opt_trailingBytesUTF8[chh & 0x3f];
+				switch (extraBytesToRead) {
+				case 2:
+					++source;
+					if (*source) {
+						chh <<= 6;
+						chh += *source;
+					} else {
+						*lastlen = ((27 >> 1) + 1) * xBuf;
+						return;
+					}
+				case 1:
+					++source;
+					if (*source) {
+						chh <<= 6;
+						chh += *source;
+					} else {
+						*lastlen = ((27 >> 1) + 1) * xBuf;
+						return;
+					}
+				case 0:
+					break;
+				default:
+					*lastlen = ((27 >> 1) + 1) * xBuf;
+					return;
+				}
+				chh -= offsetsFromUTF8[extraBytesToRead];
+			}
+			source++;
+			outlen++;
+		} else {
+			chh = 0x80;
+		}
+		*target = chh << 16 | chl;
+		target += xBuf;
+		if (*source == 0) {
+			break;
+		}
+		if (target >= targetEnd) {
+			break;
+		}
+	}
+	if (chh != 0x80 || outlen == 0) {
+		*target = 0x80;
+		target += xBuf;
+	}
+
+	while(target < &keybuffer[*lastlen]) {
+		*target = 0;
+		target += xBuf;
+	}
+
+	*lastlen = ((outlen >> 1) + 1) * xBuf;
+	keybuffer[lenStoreOffset] = outlen << 4;
+}
+
+static void set_key_utf8(char *_key, int index)
+{
+#if defined(NT_X86_64)
+	set_key_helper_utf8(&nt_buffer8x[128 * (index >> 3) + index % 8], 8,
+	                (UTF8 *)_key, 112, &last_i[index]);
+#elif defined(NT_SSE2)
+	if(index < NT_NUM_KEYS4)
+		set_key_helper_utf8(&nt_buffer4x[64 * (index >> 2) + index % 4], 4,
+		                (UTF8 *)_key, 56, &last_i[index]);
+	else
+		set_key_helper_utf8(&nt_buffer1x[16 * (index - NT_NUM_KEYS4)], 1,
+		                (UTF8 *)_key, 14, &last_i[index]);
+#else
+	set_key_helper_utf8(&nt_buffer1x[index << 4], 1, (UTF8 *)_key, 14,
+	                &last_i[index]);
+//	dump_stuff_msg("setkey utf8 ", (unsigned char*)&nt_buffer1x[index << 4], 40);
+//	exit(0);
+#endif
+}
+
+// Get the key back from the key buffer, from UCS-2
+// This is common code for the SSE/MMX/generic variants
+static inline UTF16 *get_key_helper_utf8(unsigned int * keybuffer, unsigned int xBuf)
+{
+	static UTF16 key[PLAINTEXT_LENGTH + 1];
+	unsigned int md4_size=0;
+	unsigned int i=0;
+
+	for(; md4_size < PLAINTEXT_LENGTH; i += xBuf, md4_size++)
+	{
+		key[md4_size] = keybuffer[i];
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+		key[++md4_size] = keybuffer[i] >> 16;
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+	}
+	return key;
+}
+
+static char *get_key_utf8(int index)
+{
+#if defined(NT_X86_64)
+	return utf16toutf8(get_key_helper_utf8(&nt_buffer8x[128 * (index >> 3) +
+	                                                   index % 8], 8));
+#elif defined(NT_SSE2)
+	if(index < NT_NUM_KEYS4)
+		return utf16toutf8(get_key_helper_utf8(&nt_buffer4x[64 * (index >> 2) +
+		                                                   index % 4], 4));
+	else
+		return utf16toutf8(get_key_helper_utf8(&nt_buffer1x[16 * (index -
+		                                                         NT_NUM_KEYS4)], 1));
+#else
+	return utf16toutf8(get_key_helper_utf8(&nt_buffer1x[index << 4], 1));
+#endif
+}
+
+struct fmt_main fmt_NT = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_UNICODE | FMT_UTF8,
+		tests
+	}, {
+		fmt_NT_init,
+		prepare,
+		valid,
+		nt_split,
+		get_binary,
+		fmt_default_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		NT_CRYPT_FUN,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/OPENLDAPS_fmt_plug.c john-1.7.8-jumbo-2/src/OPENLDAPS_fmt_plug.c
--- john-1.7.8/src/OPENLDAPS_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/OPENLDAPS_fmt_plug.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,326 @@
+// Fix for john the ripper 1.6.37 by Sun-Zero, 2004. 07. 26.
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 1996-98 by Solar Designer
+ *
+ * Minor performance enhancement by bartavelle at bandecon.com
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "params.h"
+#include "formats.h"
+#include "common.h"
+
+#include "sha.h"
+#include "base64.h"
+
+#undef MMX_COEF
+#undef MMX_TYPE
+
+#define FORMAT_LABEL			"openssha"
+#define FORMAT_NAME			"OpenLDAP SSHA"
+#define SHA_TYPE                        "salted SHA-1"
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		32
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			4
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		MMX_COEF
+#define MAX_KEYS_PER_CRYPT		MMX_COEF
+#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) )
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+#define NSLDAP_MAGIC "{ssha}"
+#define NSLDAP_MAGIC_LENGTH 6
+
+static struct fmt_tests tests[] = {
+	{"{SSHA}bPXG4M1KkwZh2Hbgnuoszvpat0T/OS86", "thales"},
+	{"{SSHA}hHSEPW3qeiOo5Pl2MpHQCXh0vgfyVR/X", "test1"},
+	{"{SSHA}pXp4yIiRmppvKYn7cKCT+lngG4qELq4h", "test2"},
+	{"{SSHA}Bv8tu3wB8WTMJj3tcOsl1usm5HzGwEmv", "test3"},
+	{"{SSHA}kXyh8wLCKbN+QRbL2F2aUbkP62BJ/bRg", "lapin"},
+	{"{SSHA}rnMVxsf1YJPg0L5CBhbVLIsJF+o/vkoE", "canard"},
+	{"{SSHA}Uf2x9YxSWZZNAi2t1QXbG2PmT07AtURl", "chien"},
+	{"{SSHA}XXGLZ7iKpYSBpF6EwoeTl27U0L/kYYsY", "hibou"},
+	{"{SSHA}HYRPmcQIIzIIg/c1L8cZKlYdNpyeZeml", "genou"},
+	{"{SSHA}Zm/0Wll7rLNpBU4HFUKhbASpXr94eSTc", "caillou"},
+	{"{SSHA}Qc9OB+aEFA/mJ5MNy0AB4hRIkNiAbqDb", "doudou"},
+	{NULL}
+};
+
+#ifdef MMX_COEF
+static char crypt_key[BINARY_SIZE*MMX_COEF];
+/* Cygwin would not guarantee the alignment for this static declaration, but
+ * this source file is not MMX-ready anyway (MMX_COEF is #undef'ed above). */
+static char saved_key[80*MMX_COEF*4] __attribute__ ((aligned(8*MMX_COEF)));
+static unsigned char out[PLAINTEXT_LENGTH + 1];
+#else
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static char saved_key[PLAINTEXT_LENGTH + 1];
+#endif
+
+#ifdef MMX_COEF
+static unsigned long length[MAX_KEYS_PER_CRYPT];
+#endif
+
+static char saved_salt[SALT_SIZE];
+
+static void * binary(char *ciphertext) {
+  static char *realcipher;
+
+  if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE + SALT_SIZE + 9, MEM_ALIGN_WORD);
+
+  /* stupid overflows */
+  memset(realcipher, 0, BINARY_SIZE + SALT_SIZE + 9);
+  base64_decode(NSLDAP_MAGIC_LENGTH+ciphertext, CIPHERTEXT_LENGTH, realcipher);
+#ifdef MMX_COEF
+  alter_endianity((unsigned char*)realcipher, BINARY_SIZE);
+#endif
+  return (void *)realcipher;
+}
+
+static void * get_salt(char * ciphertext)
+{
+	static char *realcipher;
+
+	if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE + SALT_SIZE + 9, MEM_ALIGN_WORD);
+
+	memset(realcipher, 0, BINARY_SIZE + SALT_SIZE + 9);
+	base64_decode(NSLDAP_MAGIC_LENGTH+ciphertext, CIPHERTEXT_LENGTH, realcipher);
+	return (void*)&realcipher[BINARY_SIZE];
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	if(ciphertext && strlen(ciphertext) == CIPHERTEXT_LENGTH + NSLDAP_MAGIC_LENGTH)
+		return !strncasecmp(ciphertext, NSLDAP_MAGIC, NSLDAP_MAGIC_LENGTH);
+	return 0;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	return *((ARCH_WORD_32 *)salt) & (SALT_HASH_SIZE - 1);
+}
+
+static void set_key(char *key, int index)
+{
+#ifdef MMX_COEF
+	int len;
+	int i;
+
+	if(index==0)
+	{
+		memset(saved_key, 0, sizeof(saved_key));
+	}
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+
+	length[index] = len;
+
+	for(i=0;i<len;i++)
+		saved_key[GETPOS(i, index)] = key[i];
+
+	saved_key[GETPOS( (i+SALT_SIZE) , index)] = 0x80;
+	((unsigned int *)saved_key)[15*MMX_COEF+index] = (len+SALT_SIZE)<<3;
+#else
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+#endif
+}
+
+static void set_salt(void *salt)
+{
+	memcpy(saved_salt, salt, SALT_SIZE);
+}
+
+static char *get_key(int index)
+{
+#ifdef MMX_COEF
+	unsigned int i,s;
+
+	s = length[index];
+	for(i=0;i<s;i++)
+		out[i] = saved_key[ GETPOS(i, index) ];
+	out[i] = 0;
+	return (char*)out;
+#else
+  return saved_key;
+#endif
+}
+
+static int
+cmp_all(void *binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#endif
+		)
+			return 0;
+		i++;
+	}
+	return 1;
+#else
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int
+cmp_exact(char *source, int index)
+{
+  return 1;
+}
+
+static int cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+#else
+	return cmp_all(binary, index);
+#endif
+}
+
+
+static void crypt_all(int count)
+{
+#ifdef MMX_COEF
+	int i,idx;
+
+	for(idx=0;idx<MAX_KEYS_PER_CRYPT;idx++)
+	{
+		for(i=0;i<SALT_SIZE;i++)
+			saved_key[GETPOS((i+length[idx]),idx)] = ((unsigned char *)saved_salt)[i];
+	}
+	shammx((unsigned char*)crypt_key, (unsigned char*)saved_key);
+#else
+	static SHA_CTX ctx;
+	SHA1_Init(&ctx);
+	SHA1_Update(&ctx, (unsigned char*)saved_key, strlen(saved_key));
+	SHA1_Update(&ctx, (unsigned char*)saved_salt, SALT_SIZE);
+	SHA1_Final((unsigned char*)crypt_key, &ctx);
+#endif
+}
+
+struct fmt_main fmt_OPENLDAPS = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		SHA_TYPE,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		binary,
+		get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/PHPS_fmt_plug.c john-1.7.8-jumbo-2/src/PHPS_fmt_plug.c
--- john-1.7.8/src/PHPS_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/PHPS_fmt_plug.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,175 @@
+/*
+ * PHPS_fmt.c
+ *
+ * Salted PHP on the form (php-code): $hash = MD5(MD5($pass).$salt);
+ * Based on salted IPB2 mode (by regenrecht at o2.pl).
+ *
+ * albert veli gmail com, 2007
+ *
+ * Convert hashes to the form username:$PHPS$salt$hash
+ * For instance, if the pw file has the form
+ * 1234<::>luser<::>luser@hotmail.com<::><::>1ea46bf1f5167b63d12bd47c8873050e<::>C9%
+ * it can be converted to the wanted form with the following perl script:
+ *
+ * #!/usr/bin/perl -w
+ * while (<>) {
+ *    my @fields = split(/<::>/, $_);
+ *    my $a =  substr $fields[5], 0, 1;
+ *    my $b =  substr $fields[5], 1, 1;
+ *    my $c =  substr $fields[5], 2, 1;
+ *    printf "%s:\$IPB2\$%02x%02x%02x\$%s\n", $fields[1], ord($a), ord($b), ord($c), $fields[4];
+ * }
+ *
+ * BUGS: Can't handle usernames with ':' in them.
+ *
+ * NOTE the new code 'hooks' into the generic MD5 code.  The 'Convert' call
+ * changes the data from the PHPS format, into md5_gen(6) format, and then
+ * linkes to the MD5-GEN functions.  MD5-GENERIC and 'linkage' by Jim Fougeron.
+ * the 'original' PHPS_fmt.c is saved into PHPS_fmt_orig.c   If you want the
+ * original code, simply replace this file with that PHPS_fmt_orig.c file.
+ *
+ */
+
+#include <string.h>
+
+#include "common.h"
+#include "formats.h"
+#include "md5_gen.h"
+
+#define FORMAT_LABEL		"phps"
+#define FORMAT_NAME			"PHPS MD5"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME		"MD5(MD5($pass).$salt) MMX"
+#else
+#define ALGORITHM_NAME		"MD5(MD5($pass).$salt) SSE2"
+#endif
+#else
+#define ALGORITHM_NAME		"MD5(MD5($pass).$salt) MD5"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH	0
+
+#define MD5_BINARY_SIZE		16
+#define MD5_HEX_SIZE		(MD5_BINARY_SIZE * 2)
+
+#define BINARY_SIZE			MD5_BINARY_SIZE
+
+#define SALT_SIZE			3
+#define PROCESSED_SALT_SIZE	SALT_SIZE
+
+#define PLAINTEXT_LENGTH	32
+#define CIPHERTEXT_LENGTH	(1 + 4 + 1 + SALT_SIZE * 2 + 1 + MD5_HEX_SIZE)
+
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+static struct fmt_tests phps_tests[] = {
+	{"$PHPS$433925$5d756853cd63acee76e6dcd6d3728447", "welcome"},
+	{NULL}
+};
+
+static char Conv_Buf[80];
+static struct fmt_main *pFmt_MD5_gen_6;
+static void phps_init(struct fmt_main *pFmt);
+
+/* this function converts a 'native' phps signature string into a md5_gen(6) syntax string */
+static char *Convert(char *Buf, char *ciphertext)
+{
+	unsigned long val, i;
+	char *cp = strchr(&ciphertext[7], '$');
+	if (!cp)
+		return "*";
+	sprintf(Buf, "md5_gen(6)%s$", &cp[1]);
+	for (i = 0; i < 3; ++i)
+	{
+		char bTmp[3];
+		bTmp[0] = ciphertext[6+i*2];
+		bTmp[1] = ciphertext[6+i*2+1];
+		bTmp[2] = 0;
+		val = strtoul(bTmp, 0, 16);
+		sprintf(bTmp, "%c", (unsigned char)val);
+		strcat(Buf, bTmp);
+	}
+	return Buf;
+}
+
+static int phps_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+	if (!ciphertext)
+		return 0;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+
+	if (strncmp(ciphertext, "$PHPS$", 6) != 0)
+		return 0;
+
+ 	if (ciphertext[12] != '$')
+		return 0;
+
+	for (i = 0;i < SALT_SIZE*2; ++i)
+		if (atoi16[ARCH_INDEX(ciphertext[i+6])] == 0x7F)
+			return 0;
+
+	for (i = 0;i < MD5_HEX_SIZE; ++i)
+		if (atoi16[ARCH_INDEX(ciphertext[i+6+1+SALT_SIZE*2])] == 0x7F)
+			return 0;
+
+	if (!pFmt_MD5_gen_6)
+		phps_init(pFmt);
+	return pFmt_MD5_gen_6->methods.valid(Convert(Conv_Buf, ciphertext), pFmt_MD5_gen_6);
+}
+
+
+static void * our_salt(char *ciphertext)
+{
+	return pFmt_MD5_gen_6->methods.salt(Convert(Conv_Buf, ciphertext));
+}
+static void * our_binary(char *ciphertext)
+{
+	return pFmt_MD5_gen_6->methods.binary(Convert(Conv_Buf, ciphertext));
+}
+
+struct fmt_main fmt_PHPS =
+{
+	{
+		// setup the labeling and stuff. NOTE the max and min crypts are set to 1
+		// here, but will be reset within our init() function.
+		FORMAT_LABEL, FORMAT_NAME, ALGORITHM_NAME, BENCHMARK_COMMENT, BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH, BINARY_SIZE, SALT_SIZE+1, 1, 1, FMT_CASE | FMT_8_BIT, phps_tests
+	},
+	{
+		/*  All we setup here, is the pointer to valid, and the pointer to init */
+		/*  within the call to init, we will properly set this full object      */
+		phps_init,
+		fmt_default_prepare,
+		phps_valid
+	}
+};
+
+
+static void phps_init(struct fmt_main *pFmt)
+{
+	if (pFmt->private.initialized == 0) {
+		pFmt_MD5_gen_6 = md5_gen_THIN_FORMAT_LINK(&fmt_PHPS, Convert(Conv_Buf, phps_tests[0].ciphertext), "phps");
+		fmt_PHPS.methods.salt   = our_salt;
+		fmt_PHPS.methods.binary = our_binary;
+		pFmt->private.initialized = 1;
+	}
+}
+
+/**
+ * GNU Emacs settings: K&R with 1 tab indent.
+ * Local Variables:
+ * c-file-style: "k&r"
+ * c-basic-offset: 8
+ * indent-tabs-mode: t
+ * End:
+ */
diff -rupN john-1.7.8/src/PO_fmt_plug.c john-1.7.8-jumbo-2/src/PO_fmt_plug.c
--- john-1.7.8/src/PO_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/PO_fmt_plug.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,248 @@
+/*
+ * Post.Office MD5 cracker.
+ * Uses a modified version of Solar Designer's MD5 routine.
+ *
+ * This file adapted from other code in this project.
+ *
+ * To extract these crypts from Post.Office, use something
+ * along the lines of:
+ *
+ *   /usr/local/post.office/cmdutils/listacct \
+ *	-i POP-Address,Account-ID,Password,Name | \
+ *	perl -ne 'chop;@a=split(/;/);print
+ *	(($a[0]?$a[0]:$a[1]).":".$a[2].":0:0:".$a[3]."::\n");'
+ *
+ * Then find any passwords ending in UNIX-PASSWORD and tidy
+ * them up (and crack as plain DES crypts); this module will
+ * handle the others.
+ *
+ * This crypt format may also be found in LDAP directories of
+ * users migrated from Post.Office, for example the crypt format
+ * can be supported by OpenWave and qmail-ldap.
+ *
+ * Copyright (c) 2005 David Luyer <david at luyer.net>
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5_go.h"
+
+typedef ARCH_WORD_32 MD5_word;
+typedef MD5_word MD5_binary[4];
+#if ARCH_LITTLE_ENDIAN
+#define MD5_out MD5_out_go
+#else
+#define MD5_out MD5_bitswapped_out_go
+#endif
+extern MD5_binary MD5_out;
+
+#define FORMAT_LABEL			"po"
+#define FORMAT_NAME			"Post.Office MD5"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		64
+#define CIPHERTEXT_LENGTH		64
+
+#define BINARY_SIZE			4
+#define SALT_SIZE			32
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests tests[] = {
+	{"550c41c11bab48f9dbd8203ed313eef0aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "abc123"},
+	{"0c78bdef7d5448105cfbbc9aaa490a44550c41c11bab48f9dbd8203ed313eef0", "abc123"},
+	{"9be296cf73d2f548dae3cccafaff1dd982916963c701200625cba2acd40d6569", "FRED"},
+	{"a0e2078f0354846ec5bc4c7d7be08a4682916963c701200625cba2acd40d6569", ""},
+	{NULL}
+};
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static int saved_key_len;
+static char po_buf[SALT_SIZE * 2 + 2 + PLAINTEXT_LENGTH + 128 /* MD5 scratch space */];
+
+static void po_init(struct fmt_main *pFmt) {
+	/* Do nothing */
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	if (strlen(ciphertext) == 64 &&
+	    strspn(ciphertext, "0123456789abcdef") == 64) {
+		return 1;
+	}
+	return 0;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(MD5_word *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(MD5_word *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(MD5_word *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(MD5_word *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(MD5_word *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return MD5_out[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return MD5_out[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return MD5_out[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return MD5_out[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return MD5_out[0] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	return
+		((int)atoi64[ARCH_INDEX(((char *)salt)[0])] |
+		((int)atoi64[ARCH_INDEX(((char *)salt)[1])] << 6)) & 0x3FF;
+}
+
+static void set_key(char *key, int index)
+{
+	strnfcpy(saved_key, key, PLAINTEXT_LENGTH);
+	saved_key_len = strlen(saved_key);
+}
+
+static char *get_key(int index)
+{
+	saved_key[PLAINTEXT_LENGTH] = 0;
+	return saved_key;
+}
+
+static int cmp_all(void *binary, int index)
+{
+	/* also used for cmp_one */
+	return *(MD5_word *)binary == MD5_out[0];
+}
+
+static int cmp_exact(char *source, int index)
+{
+        static char fullmd5[16];
+        int i;
+
+        for(i=0;i<16;i++)
+        {
+                fullmd5[i] = atoi16[ARCH_INDEX(source[i*2])]*16 + atoi16[ARCH_INDEX(source[i*2+1])];
+        }
+	return !memcmp(fullmd5, MD5_out, sizeof(MD5_binary));
+}
+
+static void *get_binary(char *ciphertext)
+{
+        static char binarycipher[BINARY_SIZE];
+        int i;
+
+        for(i=0;i<BINARY_SIZE;i++)
+        {
+                binarycipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2])]*16 + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+        }
+        return (void *)binarycipher;
+}
+
+static char *get_salt(char *ciphertext)
+{
+	return (ciphertext + 32);
+}
+
+static void set_salt(char *salt)
+{
+	memcpy(po_buf, salt, 32);
+}
+
+static void po_crypt(int count)
+{
+	po_buf[32] = 'Y';
+	memcpy(po_buf + 33, saved_key, saved_key_len);
+	po_buf[saved_key_len + 33] = 247;
+	memcpy(po_buf + saved_key_len + 34, po_buf, 32);
+	MD5_Go((unsigned char *)po_buf, saved_key_len + 66);
+}
+
+struct fmt_main fmt_PO = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		"STD",
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		po_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		get_binary,
+		(void *(*)(char *))get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		(void (*)(void *))set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		po_crypt,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_all,
+		cmp_exact
+	}
+};
+
+
diff -rupN john-1.7.8/src/SKEY_fmt.c john-1.7.8-jumbo-2/src/SKEY_fmt.c
--- john-1.7.8/src/SKEY_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/SKEY_fmt.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,258 @@
+/*
+  SKEY_fmt.c
+
+  S/Key dictionary attack module for Solar Designer's John the Ripper.
+
+  skeykeys files should be fed through sed 's/ /:/' first.
+
+  Copyright (c) 2000 Dug Song <dugsong@monkey.org>
+  All rights reserved, all wrongs reversed.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+  3. The name of author may not be used to endorse or promote products
+  derived from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifdef HAVE_SKEY
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <skey.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL		"skey"
+#define FORMAT_NAME		"S/Key"
+#define ALGORITHM_NAME		"MD4/MD5/SHA1/RMD160"
+#define BENCHMARK_COMMENT	""
+#define BENCHMARK_LENGTH	-1
+#define PLAINTEXT_LENGTH	32
+#define BINARY_SIZE		0
+#define SALT_SIZE		sizeof(struct skey_salt_st)
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+static struct fmt_tests skey_tests[] = {
+	{"0096 luky451004  b519dcfe18eb7aab", "w00w00 v00d00"},
+  	{"md5 0099 luky451001  93b3774544ba92a3", "swirling zagnuts"},
+	{"sha1 0042 luky451002  d4f0b50e17b29310", "abcdefg12345678"},
+	{"rmd160 0099 luky451006  2dbcbb728e8bb456", "squeamish ossifrage"},
+	{NULL}
+};
+
+/* Saved state. */
+static struct skey_salt_st {
+	int	num;
+	char	type[SKEY_MAX_HASHNAME_LEN + 1];
+	char	seed[SKEY_MAX_SEED_LEN + 1];
+	unsigned char	hash[SKEY_BINKEY_SIZE];
+} saved_salt;
+static unsigned char	saved_key[SKEY_BINKEY_SIZE];
+static char	saved_pass[PLAINTEXT_LENGTH];
+
+static int
+skey_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *p, *q, buf[24];
+
+	if (*ciphertext == '#')
+		return (0);
+
+	strnzcpy(buf, ciphertext, sizeof(buf));
+
+	if ((p = strchr(buf, ' ')) == NULL)
+		return (0);
+	*p++ = '\0';
+
+	if (isalpha(*buf)) {
+		if (skey_set_algorithm(buf) == NULL ||
+		    (q = strchr(p, ' ')) == NULL)
+			return (0);
+		*q = '\0';
+	}
+	else p = buf;
+
+	for ( ; *p; p++) {
+		if (!isdigit(*p))
+			return (0);
+	}
+	return (1);
+}
+
+static int
+hex_decode(char *src, unsigned char *dst, int outsize)
+{
+	char *p, *pe;
+	unsigned char *q, *qe, ch, cl;
+
+	pe = src + strlen(src);
+	qe = dst + outsize;
+
+	for (p = src, q = dst; p < pe && q < qe && isxdigit((int)*p); p += 2) {
+		ch = tolower(p[0]);
+		cl = tolower(p[1]);
+
+		if ((ch >= '0') && (ch <= '9')) ch -= '0';
+		else if ((ch >= 'a') && (ch <= 'f')) ch -= 'a' - 10;
+		else return (-1);
+
+		if ((cl >= '0') && (cl <= '9')) cl -= '0';
+		else if ((cl >= 'a') && (cl <= 'f')) cl -= 'a' - 10;
+		else return (-1);
+
+		*q++ = (ch << 4) | cl;
+	}
+	return (q - dst);
+}
+
+static void *
+skey_salt(char *ciphertext)
+{
+	static struct skey_salt_st salt;
+	static char buf[128];
+	char *p;
+
+	strnzcpy(buf, ciphertext, sizeof(buf));
+
+	if ((p = strtok(buf, " \t")) == NULL)
+		return (NULL);
+
+	if (isalpha(*p)) {
+		strnzcpy(salt.type, p, sizeof(salt.type));
+		if ((p = strtok(NULL, " \t")) == NULL)
+			return (NULL);
+	}
+	else strnzcpy(salt.type, "md4", sizeof(salt.type));
+
+	salt.num = atoi(p);
+
+	if ((p = strtok(NULL, " \t")) == NULL)
+		return (NULL);
+
+	strnzcpy(salt.seed, p, sizeof(salt.seed) - 1);
+
+	if ((p = strtok(NULL, " \t")) == NULL)
+		return (NULL);
+
+	hex_decode(p, salt.hash, sizeof(salt.hash));
+
+	return (&salt);
+}
+
+static void
+skey_set_salt(void *salt)
+{
+	memcpy(&saved_salt, salt, sizeof(saved_salt));
+}
+
+static void
+skey_set_key(char *key, int index)
+{
+	strnzcpy(saved_pass, key, sizeof(saved_pass) - 1);
+	hex_decode(key, saved_key, sizeof(saved_key));
+}
+
+static char *
+skey_get_key(int index)
+{
+	return (saved_pass);
+}
+
+static void
+skey_crypt_all(int count)
+{
+	int i;
+
+	skey_set_algorithm(saved_salt.type);
+
+	keycrunch(saved_key, saved_salt.seed, saved_pass);
+
+	for (i = 0; i < saved_salt.num; i++)
+		f(saved_key);
+}
+
+static int
+skey_cmp_all(void *binary, int count)
+{
+	return (memcmp(saved_key, saved_salt.hash, sizeof(saved_salt.hash)) == 0);
+}
+
+static int
+skey_cmp_one(void *binary, int count)
+{
+	return (1);	/* XXX - fallthrough from skey_cmp_all() */
+}
+
+static int
+skey_cmp_exact(char *source, int count)
+{
+	return (1);	/* XXX - fallthrough from skey_cmp_one() */
+}
+
+struct fmt_main fmt_SKEY = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		skey_tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		skey_valid,
+		fmt_default_split,
+		fmt_default_binary,
+		skey_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		skey_set_salt,
+		skey_set_key,
+		skey_get_key,
+		skey_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		skey_cmp_all,
+		skey_cmp_one,
+		skey_cmp_exact
+	}
+};
+
+#endif
diff -rupN john-1.7.8/src/SybaseASE_fmt.c john-1.7.8-jumbo-2/src/SybaseASE_fmt.c
--- john-1.7.8/src/SybaseASE_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/SybaseASE_fmt.c	2011-07-02 22:08:03.000000000 +0200
@@ -0,0 +1,267 @@
+/*
+ * Sybase ASE hash support patch, based on hmailserver patch by James Nobis.
+ * Sybase ASE hash format description : http://marcellmajor.com/sybase_sha256.html
+ * Hacked together by Dhiru Kholia in February, 2011.
+ *
+ * This patch Copyright (C) 2010 by James Nobis - quel
+ * quel NOSPAM quelrod NOSPAM net, and it is herby released to the general
+ * public under the follow terms:
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+
+ * Inspiration from the generic sha-1 and md5 (Copyright (c) 2010 by Solar Designer)
+ */
+
+#include <openssl/opensslv.h>
+#if OPENSSL_VERSION_NUMBER >= 0x00908000
+
+#include <string.h>
+
+#include <openssl/sha.h>
+
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+
+
+#define FORMAT_LABEL        "sybasease"
+#define FORMAT_NAME         "sybasease"
+
+#define ALGORITHM_NAME      "32/" ARCH_BITS_STR
+
+#define BENCHMARK_COMMENT   ""
+#define BENCHMARK_LENGTH    0
+
+#define PLAINTEXT_LENGTH    64
+#define CIPHERTEXT_LENGTH   (6 + 16 + 64)
+#define PREFIX_LENGTH       6
+
+#define BINARY_SIZE         32
+#define SALT_SIZE           8
+
+#define MIN_KEYS_PER_CRYPT  96
+#define MAX_KEYS_PER_CRYPT  96
+
+static struct fmt_tests SybaseASE_tests[] = {
+    {"0xc0074f9cc8c0d55d9803b0c0816e127f2a56ee080230af5b4ce3da1f3d9fcc5449fcfcf3fb9595eb8ea6", "test12"},
+    {"0xc0074BE393C06BE420AD541671aa5e6f1a19a4a73bb51c59f45790f0887cfb70e0599747c6844d4556b3", "a"},
+    {NULL}
+};
+
+static char saved_salt[SALT_SIZE];
+static char saved_key[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1];
+static ARCH_WORD_32 crypt_out[MAX_KEYS_PER_CRYPT][8];
+
+// TODO: strengthen checks
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+    if(strncmp(ciphertext, "0xc007", 6)!=0)
+        return 0;
+    if(strlen(ciphertext) != CIPHERTEXT_LENGTH)
+        return 0;
+
+    return 1;
+}
+
+static void *get_binary(char *ciphertext)
+{
+    static unsigned char *out;
+    int i;
+    char *p = ciphertext + PREFIX_LENGTH + SALT_SIZE * 2;
+
+    if (!out) out = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+    for (i = 0; i < BINARY_SIZE; i++) {
+        out[i] = (atoi16[ARCH_INDEX(*p)] << 4) | atoi16[ARCH_INDEX(p[1])];
+        p += 2;
+    }
+    return out;
+}
+
+static void *salt(char *ciphertext)
+{
+    static unsigned char out[SALT_SIZE];
+    int i;
+    char *p = ciphertext + PREFIX_LENGTH;
+    for (i = 0; i < sizeof(out); i++) {
+        out[i] = (atoi16[ARCH_INDEX(*p)] << 4) |atoi16[ARCH_INDEX(p[1])];
+        p += 2;
+    }
+    return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+    return crypt_out[index][0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+    return crypt_out[index][0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+    return crypt_out[index][0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+    return crypt_out[index][0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+    return crypt_out[index][0] & 0xFFFFF;
+}
+
+static void set_salt(void *salt)
+{
+    memcpy(saved_salt, salt, SALT_SIZE);
+}
+
+static void set_key(char *key, int index)
+{
+    int saved_key_length = strlen(key);
+    if(saved_key_length > PLAINTEXT_LENGTH)
+        saved_key_length = PLAINTEXT_LENGTH;
+    memcpy(saved_key[index], key, saved_key_length);
+    saved_key[index][saved_key_length] = 0;
+}
+
+static char *get_key(int index)
+{
+    return saved_key[index];
+}
+
+static void crypt_all(int count)
+{
+    int index;
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(index) shared(count, crypt_out, saved_key, saved_salt)
+#endif
+    for(index = 0; index < count; index++) {
+        unsigned char input[518] = {0};
+        int i;
+        unsigned char c;
+        int position = 1;
+        /* convert key to UTF-16 */
+        for(i = 0; (c = saved_key[index][i]); i++) {
+            input[position] = c;
+            position += 2;
+        }
+        /* append salt at offset 510 */
+        memcpy(input + 510, saved_salt, 8);
+        SHA256_CTX ctx;
+        SHA256_Init(&ctx);
+        SHA256_Update(&ctx, input, 518);
+        SHA256_Final((unsigned char *)crypt_out[index], &ctx);
+    }
+}
+
+static int cmp_all(void *binary, int count)
+{
+    return 1;
+}
+
+static int cmp_one(void *binary, int index)
+{
+    return !strncmp((char *)binary, (const char*)crypt_out[index], BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int index)
+{
+    return 1;
+}
+
+struct fmt_main fmt_SybaseASE = {
+    {
+        FORMAT_LABEL,
+        FORMAT_NAME,
+        ALGORITHM_NAME,
+        BENCHMARK_COMMENT,
+        BENCHMARK_LENGTH,
+        PLAINTEXT_LENGTH,
+        BINARY_SIZE,
+        SALT_SIZE,
+        MIN_KEYS_PER_CRYPT,
+        MAX_KEYS_PER_CRYPT,
+        FMT_CASE | FMT_8_BIT | FMT_OMP,
+        SybaseASE_tests
+    }, {
+        fmt_default_init,
+	fmt_default_prepare,
+        valid,
+        fmt_default_split,
+        get_binary,
+        salt,
+        {
+            binary_hash_0,
+            binary_hash_1,
+            binary_hash_2,
+            binary_hash_3,
+            binary_hash_4
+        },
+        fmt_default_salt_hash, // XXX: slow loading
+        set_salt,
+        set_key,
+        get_key,
+        fmt_default_clear_keys,
+        crypt_all,
+        {
+            get_hash_0,
+            get_hash_1,
+            get_hash_2,
+            get_hash_3,
+            get_hash_4
+        },
+        cmp_all,
+        cmp_one,
+        cmp_exact
+    }
+};
+
+#else
+#ifdef __GNUC__
+#warning Note: SybaseASE format disabled - it needs OpenSSL 0.9.8 or above
+#endif
+#endif
diff -rupN john-1.7.8/src/XSHA_fmt_plug.c john-1.7.8-jumbo-2/src/XSHA_fmt_plug.c
--- john-1.7.8/src/XSHA_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/XSHA_fmt_plug.c	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,228 @@
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 2008 by Solar Designer
+ */
+
+#include <string.h>
+#include <openssl/sha.h>
+
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL			"xsha"
+#define FORMAT_NAME			"Mac OS X 10.4+ salted SHA-1"
+#define ALGORITHM_NAME			"32/" ARCH_BITS_STR
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		51
+#define CIPHERTEXT_LENGTH		48
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			4
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests tests[] = {
+	{"12345678F9083C7F66F46A0A102E4CC17EC08C8AF120571B", "abc"},
+	{"12345678EB8844BFAF2A8CBDD587A37EF8D4A290680D5818", "azertyuiop1"},
+	{"3234C32AAA335FD20E3F95870E5851BDBE942B79CE4FDD92", "azertyuiop2"},
+	{"01295B67659E95F32931CEDB3BA50289E2826AF3D5A1422F", "apple"},
+	{"0E6A48F765D0FFFFF6247FA80D748E615F91DD0C7431E4D9", "macintosh"},
+	{"A320163F1E6DB42C3949F7E232888ACC7DB7A0A17E493DBA", "test"},
+	{NULL}
+};
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static int saved_key_length;
+static ARCH_WORD_32 saved_salt;
+static SHA_CTX ctx;
+static ARCH_WORD_32 crypt_out[5];
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *pos;
+
+	/* Require uppercase hex digits (assume ASCII) */
+	pos = ciphertext;
+	while (atoi16[ARCH_INDEX(*pos)] != 0x7F && *pos < 'a')
+		pos++;
+	return !*pos && pos - ciphertext == CIPHERTEXT_LENGTH;
+}
+
+static void *get_binary(char *ciphertext)
+{
+	static unsigned char out[BINARY_SIZE];
+	char *p;
+	int i;
+
+	p = ciphertext + 8;
+	for (i = 0; i < sizeof(out); i++) {
+		out[i] =
+		    (atoi16[ARCH_INDEX(*p)] << 4) |
+		    atoi16[ARCH_INDEX(p[1])];
+		p += 2;
+	}
+
+	return out;
+}
+
+static void *salt(char *ciphertext)
+{
+	static unsigned char out[SALT_SIZE];
+	char *p;
+	int i;
+
+	p = ciphertext;
+	for (i = 0; i < sizeof(out); i++) {
+		out[i] =
+		    (atoi16[ARCH_INDEX(*p)] << 4) |
+		    atoi16[ARCH_INDEX(p[1])];
+		p += 2;
+	}
+
+	return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return crypt_out[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return crypt_out[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return crypt_out[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return crypt_out[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return crypt_out[0] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	return *(ARCH_WORD_32 *)salt & 0x3FF;
+}
+
+static void set_salt(void *salt)
+{
+	saved_salt = *(ARCH_WORD_32 *)salt;
+}
+
+static void set_key(char *key, int index)
+{
+	saved_key_length = strlen(key);
+	if (saved_key_length > PLAINTEXT_LENGTH)
+		saved_key_length = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, saved_key_length);
+}
+
+static char *get_key(int index)
+{
+	saved_key[saved_key_length] = 0;
+	return saved_key;
+}
+
+static void crypt_all(int count)
+{
+	SHA1_Init(&ctx);
+	SHA1_Update(&ctx, &saved_salt, SALT_SIZE);
+	SHA1_Update(&ctx, saved_key, saved_key_length);
+	SHA1_Final((unsigned char *)crypt_out, &ctx);
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return !memcmp(binary, crypt_out, BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_XSHA = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		get_binary,
+		salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_all,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/base64.c john-1.7.8-jumbo-2/src/base64.c
--- john-1.7.8/src/base64.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/base64.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,74 @@
+
+#include <stdio.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+void base64_unmap(char *in_block) {
+  int i;
+  char *c;
+
+  for(i=0; i<4; i++) {
+    c = in_block + i;
+
+    if(*c>='A' && *c<='Z') {
+      *c -= 'A';
+      continue;
+    }
+
+    if(*c>='a' && *c<='z') {
+      *c -= 'a';
+      *c += 26;
+      continue;
+    }
+
+    if(*c == '+') {
+      *c = 62;
+      continue;
+    }
+
+    if(*c == '/') {
+      *c = 63;
+      continue;
+    }
+
+    if(*c == '=') {
+      *c = 0;
+    }
+
+    *c -= '0';
+    *c += 52;
+  }
+}
+
+int base64_decode(char *in, int inlen, char *out) {
+  int i;
+  char *in_block;
+  char *out_block;
+  char temp[4];
+
+  out_block = out;
+  in_block = in;
+
+  for(i=0; i<inlen; i+=4) {
+
+    if(*in_block == '=')
+      return 0;
+
+    memcpy(temp, in_block, 4);
+    memset(out_block, 0, 3);
+    base64_unmap(temp);
+
+    out_block[0] =
+      ((temp[0]<<2) & 0xfc) | ((temp[1]>>4) & 3);
+    out_block[1] =
+      ((temp[1]<<4) & 0xf0) | ((temp[2]>>2) & 0xf);
+    out_block[2] =
+      ((temp[2]<<6) & 0xc0) | ((temp[3]   ) & 0x3f);
+
+    out_block += 3;
+    in_block += 4;
+  }
+
+  return 0;
+}
diff -rupN john-1.7.8/src/base64.h john-1.7.8-jumbo-2/src/base64.h
--- john-1.7.8/src/base64.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/base64.h	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,6 @@
+#ifndef _BASE64_H
+#define _BASE64_H
+
+int base64_decode(char *in, int inlen, char *out);
+
+#endif
diff -rupN john-1.7.8/src/bench.c john-1.7.8-jumbo-2/src/bench.c
--- john-1.7.8/src/bench.c	2011-05-14 16:22:06.000000000 +0200
+++ john-1.7.8-jumbo-2/src/bench.c	2011-07-02 20:50:18.000000000 +0200
@@ -1,10 +1,16 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2003,2004,2006,2008-2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by JimF and magnum
  */
 
 #define _XOPEN_SOURCE 500 /* for setitimer(2) */
 
+#if defined (__MINGW32__) || defined (_MSC_VER)
+#define SIGALRM SIGFPE
+#endif
+
 #ifdef __ultrix__
 #define __POSIX
 #define _POSIX_SOURCE
@@ -14,12 +20,18 @@
 #include <limits.h>
 #endif
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#endif
 #include <string.h>
 #include <signal.h>
 #include <time.h>
+#ifndef _MSC_VER
 #include <sys/time.h>
+#endif
+#if !defined (__MINGW32__) && !defined (_MSC_VER)
 #include <sys/times.h>
+#endif
 
 #include "times.h"
 
@@ -32,6 +44,19 @@
 #include "formats.h"
 #include "bench.h"
 
+#ifndef _JOHN_BENCH_TMP
+#include "options.h"
+#endif
+
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#include "config.h"
+#endif /* HAVE_MPI */
+
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+
 long clk_tck = 0;
 
 void clk_tck_init(void)
@@ -95,8 +120,11 @@ char *benchmark_format(struct fmt_main *
 #if OS_TIMER
 	struct itimerval it;
 #endif
+	clock_t start_real, end_real;
+#if !defined (__MINGW32__) && !defined (_MSC_VER)
+	clock_t start_virtual, end_virtual;
 	struct tms buf;
-	clock_t start_real, start_virtual, end_real, end_virtual;
+#endif
 	unsigned ARCH_WORD count;
 	char *ciphertext;
 	void *salt, *two_salts[2];
@@ -158,9 +186,13 @@ char *benchmark_format(struct fmt_main *
 	sig_timer_emu_init(benchmark_time * clk_tck);
 #endif
 
+#if defined (__MINGW32__) || defined (_MSC_VER)
+	start_real = clock();
+#else
 	start_real = times(&buf);
 	start_virtual = buf.tms_utime + buf.tms_stime;
 	start_virtual += buf.tms_cutime + buf.tms_cstime;
+#endif
 	count = 0;
 
 	index = salts;
@@ -183,13 +215,17 @@ char *benchmark_format(struct fmt_main *
 #endif
 	} while (bench_running && !event_abort);
 
+#if defined (__MINGW32__) || defined (_MSC_VER)
+	end_real = clock();
+#else
 	end_real = times(&buf);
 	end_virtual = buf.tms_utime + buf.tms_stime;
 	end_virtual += buf.tms_cutime + buf.tms_cstime;
 	if (end_virtual == start_virtual) end_virtual++;
+	results->virtual = end_virtual - start_virtual;
+#endif
 
 	results->real = end_real - start_real;
-	results->virtual = end_virtual - start_virtual;
 	results->count = count * max;
 
 	for (index = 0; index < 2; index++)
@@ -207,6 +243,9 @@ void benchmark_cps(unsigned ARCH_WORD co
 	mul64by32(&tmp, clk_tck);
 	cps_hi = div64by32lo(&tmp, time);
 
+	if (cps_hi >= 1000000000)
+		sprintf(buffer, "%uM", cps_hi / 1000000);
+	else
 	if (cps_hi >= 1000000)
 		sprintf(buffer, "%uK", cps_hi / 1000);
 	else
@@ -219,6 +258,21 @@ void benchmark_cps(unsigned ARCH_WORD co
 	}
 }
 
+#ifdef HAVE_MPI
+void gather_results(struct bench_results *results)
+{
+	struct bench_results combined;
+	MPI_Reduce(&results->real, &combined.real, 1, MPI_LONG,
+		MPI_MAX, 0, MPI_COMM_WORLD);
+	MPI_Reduce(&results->virtual, &combined.virtual, 1, MPI_LONG,
+		MPI_MAX, 0, MPI_COMM_WORLD);
+	MPI_Reduce(&results->count, &combined.count, 1, MPI_UNSIGNED_LONG,
+		MPI_SUM, 0, MPI_COMM_WORLD);
+	if (mpi_id == 0)
+		memcpy(results, &combined, sizeof(struct bench_results));
+}
+#endif
+
 int benchmark_all(void)
 {
 	struct fmt_main *format;
@@ -228,14 +282,92 @@ int benchmark_all(void)
 	unsigned int total, failed;
 
 	total = failed = 0;
+#ifndef _JOHN_BENCH_TMP
+	options.field_sep_char = 31;
+#endif
 	if ((format = fmt_list))
 	do {
-		printf("Benchmarking: %s%s [%s]... ",
+#ifndef _JOHN_BENCH_TMP
+/* Silently skip DIGEST-MD5 (for which we have no tests), unless forced */
+		if (!format->params.tests && format != fmt_list)
+			continue;
+
+/* Just test the UTF-8 aware formats if --utf8 */
+		if ((options.flags & FLG_UTF8) && !(format->params.flags & FMT_UTF8)) {
+			if (options.format == NULL)
+				continue;
+			else {
+				if (format->params.flags & FMT_UNICODE) {
+					printf("The %s format does not yet support UTF-8 conversion.\n\n", format->params.label);
+					continue;
+				}
+				else {
+					printf("The %s format does not use internal charset conversion (--utf8 option).\n\n", format->params.label);
+					continue;
+				}
+			}
+		}
+#endif
+
+#if defined(HAVE_MPI) && defined(_OPENMP)
+		static int haveWarned = 0;
+		int ompt = omp_get_max_threads();
+		if (format->params.flags & FMT_OMP &&
+		    ompt > 1 && mpi_p > 1 && haveWarned++ == 0) {
+			if(cfg_get_bool(SECTION_OPTIONS, NULL, "MPIOMPmutex", 1)) {
+				if(cfg_get_bool(SECTION_OPTIONS, NULL, "MPIOMPverbose", 1) &&
+				   mpi_id == 0)
+					printf("MPI in use, disabling OMP (see doc/README.mpi)\n\n");
+			} else
+				if(cfg_get_bool(SECTION_OPTIONS, NULL, "MPIOMPverbose", 1) &&
+				   mpi_id == 0)
+					printf("Note: Running both MPI and OMP (see doc/README.mpi)\n\n");
+		}
+#endif
+		printf("Benchmarking: %s%s [%s]%s... ",
 			format->params.format_name,
 			format->params.benchmark_comment,
-			format->params.algorithm_name);
+			format->params.algorithm_name,
+#ifndef _JOHN_BENCH_TMP
+			(options.flags & FLG_UTF8) ? " in UTF-8 mode" : "");
+#else
+			"");
+#endif
 		fflush(stdout);
 
+#ifdef HAVE_MPI
+#ifdef _OPENMP
+		if (format->params.flags & FMT_OMP &&
+		    omp_get_max_threads() > 1 && mpi_p > 1)
+			if(cfg_get_bool(SECTION_OPTIONS, NULL, "MPIOMPmutex", 1)) {
+				omp_set_num_threads(1);
+				ompt = 1;
+			}
+#endif /* _OPENMP */
+		if (mpi_p > 1) {
+			printf("(%uxMPI", mpi_p);
+#ifdef _OPENMP
+			if (format->params.flags & FMT_OMP) {
+				if (ompt > 1)
+					printf(", %dxOMP", ompt);
+			}
+#endif /* _OPENMP */
+			printf(") ");
+#ifdef _OPENMP
+		} else {
+			if (format->params.flags & FMT_OMP && ompt > 1)
+				printf("(%dxOMP) ", ompt);
+#endif /* _OPENMP */
+		}
+		fflush(stdout);
+#else /* HAVE_MPI */
+#ifdef _OPENMP
+		int ompt = omp_get_max_threads();
+		if (format->params.flags & FMT_OMP && ompt > 1)
+			printf("(%dxOMP) ", ompt);
+		fflush(stdout);
+#endif /* _OPENMP */
+#endif /* HAVE_MPI */
 		switch (format->params.benchmark_length) {
 		case -1:
 			msg_m = "Raw";
@@ -271,9 +403,15 @@ int benchmark_all(void)
 
 		puts("DONE");
 
+#ifdef HAVE_MPI
+		if (mpi_p > 1) {
+			gather_results(&results_m);
+			gather_results(&results_1);
+		}
+#endif
 		benchmark_cps(results_m.count, results_m.real, s_real);
 		benchmark_cps(results_m.count, results_m.virtual, s_virtual);
-#if !defined(__DJGPP__) && !defined(__CYGWIN32__) && !defined(__BEOS__)
+#if !defined(__DJGPP__) && !defined(__CYGWIN32__) && !defined(__BEOS__) && !defined(__MINGW32__) && !defined (_MSC_VER)
 		printf("%s:\t%s c/s real, %s c/s virtual\n",
 			msg_m, s_real, s_virtual);
 #else
@@ -283,12 +421,13 @@ int benchmark_all(void)
 
 		if (!msg_1) {
 			putchar('\n');
+
 			continue;
 		}
 
 		benchmark_cps(results_1.count, results_1.real, s_real);
 		benchmark_cps(results_1.count, results_1.virtual, s_virtual);
-#if !defined(__DJGPP__) && !defined(__CYGWIN32__) && !defined(__BEOS__)
+#if !defined(__DJGPP__) && !defined(__CYGWIN32__) && !defined(__BEOS__) && !defined(__MINGW32__) && !defined (_MSC_VER)
 		printf("%s:\t%s c/s real, %s c/s virtual\n\n",
 			msg_1, s_real, s_virtual);
 #else
diff -rupN john-1.7.8/src/bf_tab.h john-1.7.8-jumbo-2/src/bf_tab.h
--- john-1.7.8/src/bf_tab.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/bf_tab.h	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,277 @@
+/* bf_tab.h: Blowfish P-box and S-box tables */
+#ifndef _H_TAB_BF
+#define _H_TAB_BF
+
+static UWORD_32bits initbf_P[bf_N + 2] =
+{
+  0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
+  0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
+  0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
+  0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
+  0x9216d5d9, 0x8979fb1b,
+};
+static UWORD_32bits initbf_S[4][256] =
+{
+  {
+    0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
+    0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
+    0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
+    0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
+    0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
+    0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
+    0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
+    0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
+    0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
+    0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
+    0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
+    0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
+    0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
+    0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
+    0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
+    0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
+    0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
+    0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
+    0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
+    0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
+    0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
+    0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
+    0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
+    0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
+    0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
+    0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
+    0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
+    0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
+    0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
+    0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
+    0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
+    0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
+    0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
+    0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
+    0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
+    0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
+    0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
+    0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
+    0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
+    0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
+    0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
+    0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
+    0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
+    0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
+    0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
+    0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
+    0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
+    0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
+    0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
+    0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
+    0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
+    0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
+    0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
+    0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
+    0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
+    0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
+    0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
+    0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
+    0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
+    0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
+    0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
+    0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
+    0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
+    0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a},
+  {
+    0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
+    0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
+    0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
+    0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
+    0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
+    0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
+    0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
+    0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
+    0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
+    0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
+    0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
+    0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
+    0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
+    0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
+    0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
+    0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
+    0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
+    0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
+    0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
+    0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
+    0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
+    0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
+    0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
+    0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
+    0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
+    0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
+    0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
+    0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
+    0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
+    0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
+    0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
+    0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
+    0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
+    0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
+    0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
+    0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
+    0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
+    0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
+    0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
+    0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
+    0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
+    0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
+    0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
+    0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
+    0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
+    0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
+    0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
+    0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
+    0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
+    0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
+    0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
+    0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
+    0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
+    0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
+    0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
+    0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
+    0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
+    0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
+    0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
+    0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
+    0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
+    0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
+    0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
+    0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7},
+  {
+    0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
+    0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
+    0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
+    0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
+    0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
+    0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
+    0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
+    0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
+    0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
+    0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
+    0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
+    0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
+    0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
+    0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
+    0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
+    0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
+    0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
+    0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
+    0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
+    0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
+    0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
+    0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
+    0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
+    0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
+    0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
+    0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
+    0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
+    0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
+    0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
+    0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
+    0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
+    0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
+    0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
+    0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
+    0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
+    0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
+    0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
+    0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
+    0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
+    0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
+    0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
+    0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
+    0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
+    0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
+    0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
+    0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
+    0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
+    0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
+    0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
+    0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
+    0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
+    0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
+    0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
+    0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
+    0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
+    0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
+    0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
+    0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
+    0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
+    0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
+    0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
+    0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
+    0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
+    0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0},
+  {
+    0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
+    0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
+    0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
+    0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
+    0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
+    0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
+    0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
+    0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
+    0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
+    0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
+    0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
+    0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
+    0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
+    0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
+    0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
+    0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
+    0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
+    0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
+    0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
+    0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
+    0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
+    0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
+    0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
+    0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
+    0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
+    0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
+    0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
+    0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
+    0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
+    0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
+    0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
+    0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
+    0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
+    0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
+    0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
+    0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
+    0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
+    0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
+    0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
+    0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
+    0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
+    0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
+    0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
+    0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
+    0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
+    0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
+    0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
+    0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
+    0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
+    0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
+    0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
+    0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
+    0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
+    0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
+    0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
+    0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
+    0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
+    0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
+    0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
+    0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
+    0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
+    0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
+    0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
+    0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6}
+};
+
+#endif
diff -rupN john-1.7.8/src/blowfish.c john-1.7.8-jumbo-2/src/blowfish.c
--- john-1.7.8/src/blowfish.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/blowfish.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,202 @@
+/*
+ * blowfish.c - part of blowfish.mod
+ * handles: encryption and decryption of passwords
+ */
+/*
+ * The first half of this is very lightly edited from public domain
+ * sourcecode.  For simplicity, this entire module will remain public
+ * domain.
+ */
+/*
+ * This is ripped from eggdrop 1.3.28's source files (blowfish.mod)
+ * Modified by Sun-Zero <sun-zero at freemail.hu>
+ * 2002-04-16
+*/
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "blowfish.h"
+#include "bf_tab.h"		/* P-box P-array, S-box */
+
+/* #define S(x,i) (bf_S[i][x.w.byte##i]) */
+#define S0(x) (bf_S[0][x.w.byte0])
+#define S1(x) (bf_S[1][x.w.byte1])
+#define S2(x) (bf_S[2][x.w.byte2])
+#define S3(x) (bf_S[3][x.w.byte3])
+#define bf_F(x) (((S0(x) + S1(x)) ^ S2(x)) + S3(x))
+#define ROUND(a,b,n) (a.word ^= bf_F(b) ^ bf_P[n])
+
+#include <time.h>
+
+#define USE_ALLOC
+/* keep a set of rotating P & S boxes */
+#ifdef USE_ALLOC
+static struct box_t {
+  UWORD_32bits *P;
+  UWORD_32bits **S;
+  char key[81];
+  char keybytes;
+} box;
+#endif
+
+#ifndef USE_ALLOC
+static UWORD_32bits bf_P[bf_N+2];
+static UWORD_32bits bf_S[4][256];
+#else
+static UWORD_32bits *bf_P;
+static UWORD_32bits **bf_S;
+#endif
+
+
+void blowfish_first_init(void) {
+#ifdef USE_ALLOC
+      box.P = NULL;
+      box.S = NULL;
+      box.key[0] = 0;
+#endif
+}
+
+static void blowfish_encipher(UWORD_32bits * xl, UWORD_32bits * xr)
+{
+  union aword Xl;
+  union aword Xr;
+
+  Xl.word = *xl;
+  Xr.word = *xr;
+
+  Xl.word ^= bf_P[0];
+  ROUND(Xr, Xl, 1);
+  ROUND(Xl, Xr, 2);
+  ROUND(Xr, Xl, 3);
+  ROUND(Xl, Xr, 4);
+  ROUND(Xr, Xl, 5);
+  ROUND(Xl, Xr, 6);
+  ROUND(Xr, Xl, 7);
+  ROUND(Xl, Xr, 8);
+  ROUND(Xr, Xl, 9);
+  ROUND(Xl, Xr, 10);
+  ROUND(Xr, Xl, 11);
+  ROUND(Xl, Xr, 12);
+  ROUND(Xr, Xl, 13);
+  ROUND(Xl, Xr, 14);
+  ROUND(Xr, Xl, 15);
+  ROUND(Xl, Xr, 16);
+  Xr.word ^= bf_P[17];
+
+  *xr = Xl.word;
+  *xl = Xr.word;
+}
+
+static void blowfish_init(UBYTE_08bits * key, short keybytes)
+{
+  int i, j;
+  UWORD_32bits data;
+  UWORD_32bits datal;
+  UWORD_32bits datar;
+  union aword temp;
+
+  /* is buffer already allocated for this? */
+#ifdef USE_ALLOC
+  // this whole alloc block is really not needed!! It runs slower, and never really frees the last few blocks in the end.
+  // without the continual allocs, we run about 10% faster.  I am not sure why there are there.  It does not appear that the
+  // 'matched' happens very often.
+  if (box.P != NULL) {
+      if ((box.keybytes == keybytes) &&
+	  (!strncmp((char *) (box.key), (char *) key, keybytes))) {
+	/* match! */
+//		  printf("matched\n");
+	bf_P = box.P;
+	bf_S = box.S;
+	return;
+      }
+//	  printf ("Freed\n");
+        free(box.P);
+        for (i = 0; i < 4; i++)
+          free(box.S[i]);
+        free(box.S);
+  }
+  /* initialize new buffer */
+  /* uh... this is over 4k */
+  box.P = (UWORD_32bits *) malloc((bf_N + 2) * sizeof(UWORD_32bits));
+  box.S = (UWORD_32bits **) malloc(4 * sizeof(UWORD_32bits *));
+  for (i = 0; i < 4; i++)
+    box.S[i] = (UWORD_32bits *) malloc(256 * sizeof(UWORD_32bits));
+  bf_P = box.P;
+  bf_S = box.S;
+  box.keybytes = keybytes;
+  strncpy(box.key, (char *) key, keybytes);
+#endif
+
+  /* robey: reset blowfish boxes to initial state */
+  /* (i guess normally it just keeps scrambling them, but here it's
+   * important to get the same encrypted result each time) */
+  for (i = 0; i < bf_N + 2; i++)
+    bf_P[i] = initbf_P[i];
+  for (i = 0; i < 4; i++)
+    for (j = 0; j < 256; j++)
+      bf_S[i][j] = initbf_S[i][j];
+
+  j = 0;
+  for (i = 0; i < bf_N + 2; ++i) {
+    temp.word = 0;
+    temp.w.byte0 = key[j];
+    temp.w.byte1 = key[(j + 1) % keybytes];
+    temp.w.byte2 = key[(j + 2) % keybytes];
+    temp.w.byte3 = key[(j + 3) % keybytes];
+    data = temp.word;
+    bf_P[i] = bf_P[i] ^ data;
+    j = (j + 4) % keybytes;
+  }
+  datal = 0x00000000;
+  datar = 0x00000000;
+  for (i = 0; i < bf_N + 2; i += 2) {
+    blowfish_encipher(&datal, &datar);
+    bf_P[i] = datal;
+    bf_P[i + 1] = datar;
+  }
+  for (i = 0; i < 4; ++i) {
+    for (j = 0; j < 256; j += 2) {
+      blowfish_encipher(&datal, &datar);
+      bf_S[i][j] = datal;
+      bf_S[i][j + 1] = datar;
+    }
+  }
+}
+
+/* stuff below this line was written by robey for eggdrop use */
+
+/* of course, if you change either of these, then your userfile will
+ * no longer be able to be shared. :) */
+#define SALT1  0xdeadd061
+#define SALT2  0x23f6b095
+
+/* convert 64-bit encrypted password to text for userfile */
+static char *base64 = "./0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
+
+static void blowfish_encrypt_pass(char *text, char *new)
+{
+  UWORD_32bits left, right;
+  int n;
+  char *p;
+
+  blowfish_init((UBYTE_08bits *) text, strlen(text));
+  left = SALT1;
+  right = SALT2;
+  blowfish_encipher(&left, &right);
+  p = new;
+  *p++ = '+';			/* + means encrypted pass */
+  n = 32;
+  while (n > 0) {
+    *p++ = base64[right & 0x3f];
+    right = (right >> 6);
+    n -= 6;
+  }
+  n = 32;
+  while (n > 0) {
+    *p++ = base64[left & 0x3f];
+    left = (left >> 6);
+    n -= 6;
+  }
+  *p = 0;
+}
diff -rupN john-1.7.8/src/blowfish.h john-1.7.8-jumbo-2/src/blowfish.h
--- john-1.7.8/src/blowfish.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/blowfish.h	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,55 @@
+/* modified 19jul1996 by robey -- uses autoconf values now */
+#ifndef _H_BLOWFISH
+#define _H_BLOWFISH
+
+#include "arch.h"
+
+#define bf_N             16
+#define noErr            0
+#define DATAERROR        -1
+
+#define UBYTE_08bits  unsigned char
+#define UWORD_16bits  unsigned short
+
+#define SIZEOF_INT 4
+
+#if SIZEOF_INT==4
+#define UWORD_32bits  unsigned int
+#else
+#if SIZEOF_LONG==4
+#define UWORD_32bits  unsigned long
+#endif
+#endif
+
+/* choose a byte order for your hardware */
+
+#if !ARCH_LITTLE_ENDIAN
+/* ABCD - big endian - motorola */
+union aword {
+  UWORD_32bits word;
+  UBYTE_08bits byte[4];
+  struct {
+    unsigned int byte0:8;
+    unsigned int byte1:8;
+    unsigned int byte2:8;
+    unsigned int byte3:8;
+  } w;
+};
+#endif				/* !ARCH_LITTLE_ENDIAN */
+
+#if ARCH_LITTLE_ENDIAN
+/* DCBA - little endian - intel */
+union aword {
+  UWORD_32bits word;
+  UBYTE_08bits byte[4];
+  struct {
+    unsigned int byte3:8;
+    unsigned int byte2:8;
+    unsigned int byte1:8;
+    unsigned int byte0:8;
+  } w;
+};
+
+#endif				/* ARCH_LITTLE_ENDIAN */
+
+#endif
diff -rupN john-1.7.8/src/byteorder.h john-1.7.8-jumbo-2/src/byteorder.h
--- john-1.7.8/src/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/byteorder.h	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,274 @@
+/*
+   Unix SMB/Netbios implementation.
+   Version 1.9.
+   SMB Byte handling
+   Copyright (C) Andrew Tridgell 1992-1998
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _BYTEORDER_H
+#define _BYTEORDER_H
+
+/*
+   This file implements macros for machine independent short and
+   int manipulation
+
+Here is a description of this file that I emailed to the samba list once:
+
+> I am confused about the way that byteorder.h works in Samba. I have
+> looked at it, and I would have thought that you might make a distinction
+> between LE and BE machines, but you only seem to distinguish between 386
+> and all other architectures.
+>
+> Can you give me a clue?
+
+sure.
+
+The distinction between 386 and other architectures is only there as
+an optimisation. You can take it out completely and it will make no
+difference. The routines (macros) in byteorder.h are totally byteorder
+independent. The 386 optimsation just takes advantage of the fact that
+the x86 processors don't care about alignment, so we don't have to
+align ints on int boundaries etc. If there are other processors out
+there that aren't alignment sensitive then you could also define
+CAREFUL_ALIGNMENT=0 on those processors as well.
+
+Ok, now to the macros themselves. I'll take a simple example, say we
+want to extract a 2 byte integer from a SMB packet and put it into a
+type called uint16 that is in the local machines byte order, and you
+want to do it with only the assumption that uint16 is _at_least_ 16
+bits long (this last condition is very important for architectures
+that don't have any int types that are 2 bytes long)
+
+You do this:
+
+#define CVAL(buf,pos) (((unsigned char *)(buf))[pos])
+#define PVAL(buf,pos) ((unsigned)CVAL(buf,pos))
+#define SVAL(buf,pos) (PVAL(buf,pos)|PVAL(buf,(pos)+1)<<8)
+
+then to extract a uint16 value at offset 25 in a buffer you do this:
+
+char *buffer = foo_bar();
+uint16 xx = SVAL(buffer,25);
+
+We are using the byteoder independence of the ANSI C bitshifts to do
+the work. A good optimising compiler should turn this into efficient
+code, especially if it happens to have the right byteorder :-)
+
+I know these macros can be made a bit tidier by removing some of the
+casts, but you need to look at byteorder.h as a whole to see the
+reasoning behind them. byteorder.h defines the following macros:
+
+SVAL(buf,pos) - extract a 2 byte SMB value
+IVAL(buf,pos) - extract a 4 byte SMB value
+SVALS(buf,pos) signed version of SVAL()
+IVALS(buf,pos) signed version of IVAL()
+
+SSVAL(buf,pos,val) - put a 2 byte SMB value into a buffer
+SIVAL(buf,pos,val) - put a 4 byte SMB value into a buffer
+SSVALS(buf,pos,val) - signed version of SSVAL()
+SIVALS(buf,pos,val) - signed version of SIVAL()
+
+RSVAL(buf,pos) - like SVAL() but for NMB byte ordering
+RSVALS(buf,pos) - like SVALS() but for NMB byte ordering
+RIVAL(buf,pos) - like IVAL() but for NMB byte ordering
+RIVALS(buf,pos) - like IVALS() but for NMB byte ordering
+RSSVAL(buf,pos,val) - like SSVAL() but for NMB ordering
+RSIVAL(buf,pos,val) - like SIVAL() but for NMB ordering
+RSIVALS(buf,pos,val) - like SIVALS() but for NMB ordering
+
+it also defines lots of intermediate macros, just ignore those :-)
+
+*/
+
+/* some switch macros that do both store and read to and from SMB buffers */
+
+#define RW_PCVAL(read,inbuf,outbuf,len) \
+	{ if (read) { PCVAL (inbuf,0,outbuf,len); } \
+	else      { PSCVAL(inbuf,0,outbuf,len); } }
+
+#define RW_PIVAL(read,big_endian,inbuf,outbuf,len) \
+	{ if (read) { if (big_endian) { RPIVAL(inbuf,0,outbuf,len); } else { PIVAL(inbuf,0,outbuf,len); } } \
+	else      { if (big_endian) { RPSIVAL(inbuf,0,outbuf,len); } else { PSIVAL(inbuf,0,outbuf,len); } } }
+
+#define RW_PSVAL(read,big_endian,inbuf,outbuf,len) \
+	{ if (read) { if (big_endian) { RPSVAL(inbuf,0,outbuf,len); } else { PSVAL(inbuf,0,outbuf,len); } } \
+	else      { if (big_endian) { RPSSVAL(inbuf,0,outbuf,len); } else { PSSVAL(inbuf,0,outbuf,len); } } }
+
+#define RW_CVAL(read, inbuf, outbuf, offset) \
+	{ if (read) { (outbuf) = CVAL (inbuf,offset); } \
+	else      { SCVAL(inbuf,offset,outbuf); } }
+
+#define RW_IVAL(read, big_endian, inbuf, outbuf, offset) \
+	{ if (read) { (outbuf) = ((big_endian) ? RIVAL(inbuf,offset) : IVAL (inbuf,offset)); } \
+	else      { if (big_endian) { RSIVAL(inbuf,offset,outbuf); } else { SIVAL(inbuf,offset,outbuf); } } }
+
+#define RW_SVAL(read, big_endian, inbuf, outbuf, offset) \
+	{ if (read) { (outbuf) = ((big_endian) ? RSVAL(inbuf,offset) : SVAL (inbuf,offset)); } \
+	else      { if (big_endian) { RSSVAL(inbuf,offset,outbuf); } else { SSVAL(inbuf,offset,outbuf); } } }
+
+#undef CAREFUL_ALIGNMENT
+
+/* we know that the 386 can handle misalignment and has the "right"
+   byteorder */
+#ifdef __i386__
+#define CAREFUL_ALIGNMENT 0
+#endif
+
+#ifndef CAREFUL_ALIGNMENT
+#define CAREFUL_ALIGNMENT 1
+#endif
+
+#define CVAL(buf,pos) (((unsigned char *)(buf))[pos])
+#define PVAL(buf,pos) ((unsigned)CVAL(buf,pos))
+#define SCVAL(buf,pos,val) (CVAL(buf,pos) = (val))
+
+
+#if CAREFUL_ALIGNMENT
+
+#define SVAL(buf,pos) (PVAL(buf,pos)|PVAL(buf,(pos)+1)<<8)
+#define IVAL(buf,pos) (SVAL(buf,pos)|SVAL(buf,(pos)+2)<<16)
+#define SSVALX(buf,pos,val) (CVAL(buf,pos)=(val)&0xFF,CVAL(buf,pos+1)=(val)>>8)
+#define SIVALX(buf,pos,val) (SSVALX(buf,pos,val&0xFFFF),SSVALX(buf,pos+2,val>>16))
+#define SVALS(buf,pos) ((int16)SVAL(buf,pos))
+#define IVALS(buf,pos) ((int32)IVAL(buf,pos))
+#define SSVAL(buf,pos,val) SSVALX((buf),(pos),((uint16)(val)))
+#define SIVAL(buf,pos,val) SIVALX((buf),(pos),((uint32)(val)))
+#define SSVALS(buf,pos,val) SSVALX((buf),(pos),((int16)(val)))
+#define SIVALS(buf,pos,val) SIVALX((buf),(pos),((int32)(val)))
+
+#else /* CAREFUL_ALIGNMENT */
+
+/* this handles things for architectures like the 386 that can handle
+   alignment errors */
+/*
+   WARNING: This section is dependent on the length of int16 and int32
+   being correct
+*/
+
+/* get single value from an SMB buffer */
+#define SVAL(buf,pos) (*(const uint16 *)((const char *)(buf) + (pos)))
+#define IVAL(buf,pos) (*(const uint32 *)((const char *)(buf) + (pos)))
+#define SVALS(buf,pos) (*(const int16 *)((const char *)(buf) + (pos)))
+#define IVALS(buf,pos) (*(const int32 *)((const char *)(buf) + (pos)))
+
+/* store single value in an SMB buffer */
+#define SVALMOD(buf,pos) (*(uint16 *)((char *)(buf) + (pos)))
+#define IVALMOD(buf,pos) (*(uint32 *)((char *)(buf) + (pos)))
+#define SVALSMOD(buf,pos) (*(int16 *)((char *)(buf) + (pos)))
+#define IVALSMOD(buf,pos) (*(int32 *)((char *)(buf) + (pos)))
+
+#define SSVAL(buf,pos,val) SVALMOD(buf,pos)=((uint16)(val))
+#define SIVAL(buf,pos,val) IVALMOD(buf,pos)=((uint32)(val))
+#define SSVALS(buf,pos,val) SVALSMOD(buf,pos)=((int16)(val))
+#define SIVALS(buf,pos,val) IVALSMOD(buf,pos)=((int32)(val))
+
+#endif /* CAREFUL_ALIGNMENT */
+
+/* macros for reading / writing arrays */
+
+#define SMBMACRO(macro,buf,pos,val,len,size) \
+{ uint32 l; for (l = 0; l < (uint32)(len); l++) (val)[l] = macro((buf), (pos) + (size)*l); }
+
+#define SSMBMACRO(macro,buf,pos,val,len,size) \
+{ uint32 l; for (l = 0; l < (uint32)(len); l++) macro((buf), (pos) + (size)*l, (val)[l]); }
+
+/* reads multiple data from an SMB buffer */
+#define PCVAL(buf,pos,val,len) SMBMACRO(CVAL,buf,pos,val,len,1)
+#define PSVAL(buf,pos,val,len) SMBMACRO(SVAL,buf,pos,val,len,2)
+#define PIVAL(buf,pos,val,len) SMBMACRO(IVAL,buf,pos,val,len,4)
+#define PCVALS(buf,pos,val,len) SMBMACRO(CVALS,buf,pos,val,len,1)
+#define PSVALS(buf,pos,val,len) SMBMACRO(SVALS,buf,pos,val,len,2)
+#define PIVALS(buf,pos,val,len) SMBMACRO(IVALS,buf,pos,val,len,4)
+
+/* stores multiple data in an SMB buffer */
+#define PSCVAL(buf,pos,val,len) SSMBMACRO(SCVAL,buf,pos,val,len,1)
+#define PSSVAL(buf,pos,val,len) SSMBMACRO(SSVAL,buf,pos,val,len,2)
+#define PSIVAL(buf,pos,val,len) SSMBMACRO(SIVAL,buf,pos,val,len,4)
+#define PSCVALS(buf,pos,val,len) SSMBMACRO(SCVALS,buf,pos,val,len,1)
+#define PSSVALS(buf,pos,val,len) SSMBMACRO(SSVALS,buf,pos,val,len,2)
+#define PSIVALS(buf,pos,val,len) SSMBMACRO(SIVALS,buf,pos,val,len,4)
+
+
+/* now the reverse routines - these are used in nmb packets (mostly) */
+#define SREV(x) ((((x)&0xFF)<<8) | (((x)>>8)&0xFF))
+#define IREV(x) ((SREV(x)<<16) | (SREV((x)>>16)))
+
+#define RSVAL(buf,pos) SREV(SVAL(buf,pos))
+#define RSVALS(buf,pos) SREV(SVALS(buf,pos))
+#define RIVAL(buf,pos) IREV(IVAL(buf,pos))
+#define RIVALS(buf,pos) IREV(IVALS(buf,pos))
+#define RSSVAL(buf,pos,val) SSVAL(buf,pos,SREV(val))
+#define RSSVALS(buf,pos,val) SSVALS(buf,pos,SREV(val))
+#define RSIVAL(buf,pos,val) SIVAL(buf,pos,IREV(val))
+#define RSIVALS(buf,pos,val) SIVALS(buf,pos,IREV(val))
+
+/* reads multiple data from an SMB buffer (big-endian) */
+#define RPSVAL(buf,pos,val,len) SMBMACRO(RSVAL,buf,pos,val,len,2)
+#define RPIVAL(buf,pos,val,len) SMBMACRO(RIVAL,buf,pos,val,len,4)
+#define RPSVALS(buf,pos,val,len) SMBMACRO(RSVALS,buf,pos,val,len,2)
+#define RPIVALS(buf,pos,val,len) SMBMACRO(RIVALS,buf,pos,val,len,4)
+
+/* stores multiple data in an SMB buffer (big-endian) */
+#define RPSSVAL(buf,pos,val,len) SSMBMACRO(RSSVAL,buf,pos,val,len,2)
+#define RPSIVAL(buf,pos,val,len) SSMBMACRO(RSIVAL,buf,pos,val,len,4)
+#define RPSSVALS(buf,pos,val,len) SSMBMACRO(RSSVALS,buf,pos,val,len,2)
+#define RPSIVALS(buf,pos,val,len) SSMBMACRO(RSIVALS,buf,pos,val,len,4)
+
+#define DBG_RW_PCVAL(charmode,string,depth,base,read,inbuf,outbuf,len) \
+	{ RW_PCVAL(read,inbuf,outbuf,len) \
+	DEBUG(5,("%s%04x %s: ", \
+             tab_depth(depth), base,string)); \
+    if (charmode) print_asc(5, (unsigned char*)(outbuf), (len)); else \
+	{ uint32 idx; for (idx = 0; idx < len; idx++) { DEBUG(5,("%02x ", (outbuf)[idx])); } } \
+	DEBUG(5,("\n")); }
+
+#define DBG_RW_PSVAL(charmode,string,depth,base,read,big_endian,inbuf,outbuf,len) \
+	{ RW_PSVAL(read,big_endian,inbuf,outbuf,len) \
+	DEBUG(5,("%s%04x %s: ", \
+             tab_depth(depth), base,string)); \
+    if (charmode) print_asc(5, (unsigned char*)(outbuf), 2*(len)); else \
+	{ uint32 idx; for (idx = 0; idx < len; idx++) { DEBUG(5,("%04x ", (outbuf)[idx])); } } \
+	DEBUG(5,("\n")); }
+
+#define DBG_RW_PIVAL(charmode,string,depth,base,read,big_endian,inbuf,outbuf,len) \
+	{ RW_PIVAL(read,big_endian,inbuf,outbuf,len) \
+	DEBUG(5,("%s%04x %s: ", \
+             tab_depth(depth), base,string)); \
+    if (charmode) print_asc(5, (unsigned char*)(outbuf), 4*(len)); else \
+	{ uint32 idx; for (idx = 0; idx < len; idx++) { DEBUG(5,("%08x ", (outbuf)[idx])); } } \
+	DEBUG(5,("\n")); }
+
+#define DBG_RW_CVAL(string,depth,base,read,inbuf,outbuf) \
+	{ RW_CVAL(read,inbuf,outbuf,0) \
+	DEBUG(5,("%s%04x %s: %02x\n", \
+             tab_depth(depth), base, string, outbuf)); }
+
+#define DBG_RW_SVAL(string,depth,base,read,big_endian,inbuf,outbuf) \
+	{ RW_SVAL(read,big_endian,inbuf,outbuf,0) \
+	DEBUG(5,("%s%04x %s: %04x\n", \
+             tab_depth(depth), base, string, outbuf)); }
+
+#define DBG_RW_IVAL(string,depth,base,read,big_endian,inbuf,outbuf) \
+	{ RW_IVAL(read,big_endian,inbuf,outbuf,0) \
+	DEBUG(5,("%s%04x %s: %08x\n", \
+             tab_depth(depth), base, string, outbuf)); }
+
+/* Alignment macros. */
+#define ALIGN4(p,base) ((p) + ((4 - (PTR_DIFF((p), (base)) & 3)) & 3))
+#define ALIGN2(p,base) ((p) + ((2 - (PTR_DIFF((p), (base)) & 1)) & 1))
+
+#endif /* _BYTEORDER_H */
diff -rupN john-1.7.8/src/c3_fmt.c john-1.7.8-jumbo-2/src/c3_fmt.c
--- john-1.7.8/src/c3_fmt.c	2011-04-27 20:00:16.000000000 +0200
+++ john-1.7.8-jumbo-2/src/c3_fmt.c	2011-05-23 20:50:58.000000000 +0200
@@ -25,6 +25,9 @@
 #include "memory.h"
 #include "common.h"
 #include "formats.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
 
 #define FORMAT_LABEL			"crypt"
 #define FORMAT_NAME			"generic crypt(3)"
@@ -61,7 +64,7 @@ static char crypt_out[MAX_KEYS_PER_CRYPT
 static struct crypt_data *crypt_data[MAX_THREADS];
 #endif
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	int length, count_base64, id, pw_length;
 	char pw[PLAINTEXT_LENGTH + 1], *new_ciphertext;
@@ -145,6 +148,9 @@ static int valid(char *ciphertext)
 	}
 
 	if (id != 10)
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Generic crypt(3) module: "
 		    "hash encoding string length %d, type id %c%c\n"
 		    "appears to be unsupported on this system; "
@@ -420,6 +426,7 @@ struct fmt_main fmt_crypt = {
 		tests
 	}, {
 		fmt_default_init,
+		fmt_default_prepare,
 		valid,
 		fmt_default_split,
 		binary,
diff -rupN john-1.7.8/src/calc_stat.c john-1.7.8-jumbo-2/src/calc_stat.c
--- john-1.7.8/src/calc_stat.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/calc_stat.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,173 @@
+#include <stdio.h>
+#include <stdlib.h>
+#if !defined (_MSC_VER)
+#include <unistd.h>
+#endif
+#include <math.h>
+#include <string.h>
+
+#define C2I(c) ((unsigned int)(unsigned char)(c))
+
+unsigned int * proba1;
+unsigned int * proba2;
+unsigned int * first;
+
+int main(int argc, char * * argv)
+{
+	FILE * fichier;
+	char * ligne;
+	int i;
+	int j;
+	int np;
+	int npflag;
+	int args;
+	unsigned int nb_lignes;
+	unsigned int nb_lettres;
+
+	FILE * statfile;
+
+	if( (argc!=3) && (argc!=4) )
+	{
+		fprintf(stderr, "Usage: %s [-p] dictionnary_file statfile\n\t-p: do use non printable characters\n", argv[0]);
+		return -1;
+	}
+
+	if(argc==4)
+	{
+		if(strcmp(argv[1], "-p"))
+		{
+			fprintf(stderr, "Usage: %s [-p] dictionnary_file statfile\n\t-p: do use non printable characters\n", argv[0]);
+			return -1;
+		}
+		args = 1;
+		npflag = 1;
+	}
+	else
+	{
+		args = 0;
+		npflag = 0;
+	}
+
+	fichier = fopen(argv[1+args], "r");
+	if(!fichier)
+	{
+		fprintf(stderr, "could not open %s\n", argv[1+args]);
+		return -1;
+	}
+
+	first = malloc( sizeof(int) * 256 );
+
+	ligne = malloc(4096);
+
+	proba2 = malloc(sizeof(unsigned int) * 256 * 256);
+	proba1 = malloc(sizeof(unsigned int) * 256 );
+	memset(proba2, 0, sizeof(unsigned int) * 256 * 256);
+	memset(proba1, 0, sizeof(unsigned int) * 256 );
+
+	statfile = fopen(argv[2+args], "w");
+
+	nb_lignes = 0;
+	while(fgets(ligne, 4096, fichier))
+	{
+		if (ligne[0] == 0)
+			continue;
+		i = strlen(ligne)-1;
+		while( (i>0) && ((ligne[i]=='\n') || (ligne[i]=='\r')) )
+		{
+			ligne[i]=0;
+			i--;
+		}
+		for(i=0;ligne[i];i++)
+		{
+			np = 0;
+			if(C2I(ligne[i])<32)
+			{
+				if (!npflag) fprintf(stderr, "Warning, non printable character line %d : %s\n", nb_lignes, ligne);
+				np += 1;
+			}
+			if(C2I(ligne[i])>127)
+			{
+				fprintf(stderr, "Warning, non US ascii character line %d : %s\n", nb_lignes, ligne);
+				np += 1;
+			}
+			if((i>0) && (C2I(ligne[i-1])<32))
+			{
+				np += 2;
+			}
+			if((i>0) && (C2I(ligne[i-1])>127))
+			{
+				np += 2;
+			}
+
+			if( (i==0) && ((np == 0) || (npflag == 1)) )
+				proba1[C2I(ligne[0])]++;
+			if( (i>0) && ((np == 0) || (npflag == 1)) )
+				proba2[C2I(ligne[i-1])*256 + C2I(ligne[i])]++;
+		}
+		nb_lignes++;
+	}
+
+	for(i=0;i<256;i++)
+	{
+		if ( (proba1[i] == 0 ) || (i==0) )
+		{
+			proba1[i] = 1000;
+		}
+		else
+		{
+			if( (unsigned int) (- 10*log( (double) proba1[i] / (double) nb_lignes )) == 0)
+			{
+				fprintf(stderr, "zero -10*log proba1[%d] (%d) / %d converted to 1\n", i, proba1[i], nb_lignes);
+				proba1[i] = 1;
+			}
+			else
+				proba1[i] = (unsigned int) (- 10*log( (double) proba1[i] / (double) nb_lignes ));
+			fprintf(statfile, "%d=proba1[%d]\n", proba1[i], i);
+		}
+
+		/* premiere passe : nb lettres */
+		nb_lettres = 0;
+		for(j=0;j<256;j++)
+		{
+			nb_lettres += proba2[i*256 + j];
+		}
+
+		first[i] = 255;
+
+		/* maintenant, calcul des stats */
+		for(j=0;j<256;j++)
+		{
+			if( proba2[i*256 + j] == 0 )
+			{
+				proba2[i*256 + j] = 1000;
+			}
+			else
+			{
+				if(first[i] == 255)
+					first[i] = j;
+				if((unsigned int) (- 10*log( (double) proba2[i*256+j] / (double) nb_lettres )) == 0)
+				{
+					fprintf(stderr, "zero -10*log proba2[%d*256+%d] (%d) / %d, converted to 1 to prevent infinite length candidates\n", i, j, proba2[i*256+j],nb_lettres );
+					proba2[i*256 + j] = 1;
+				}
+				else
+				{
+					proba2[i*256 + j] = (unsigned int) (- 10*log( (double) proba2[i*256+j] / (double) nb_lettres ));
+				}
+				fprintf(statfile, "%d=proba2[%d*256+%d]\n", proba2[i*256+j], i, j);
+			}
+		}
+	}
+
+	fclose(statfile);
+
+	free(proba1);
+	free(proba2);
+
+	free(first);
+
+	free(ligne);
+	fclose(fichier);
+
+	return 0;
+}
diff -rupN john-1.7.8/src/charset.c john-1.7.8-jumbo-2/src/charset.c
--- john-1.7.8/src/charset.c	2011-05-08 23:31:25.000000000 +0200
+++ john-1.7.8-jumbo-2/src/charset.c	2011-07-02 20:52:29.000000000 +0200
@@ -1,10 +1,16 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003,2005,2008,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by various authors
  */
 
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#else
+#define unlink _unlink
+#endif
 #include <string.h>
 
 #include "arch.h"
@@ -129,10 +135,10 @@ static int charset_new_length(int length
 		fflush(stdout);
 
 		if ((offset = ftell(file)) < 0) pexit("ftell");
-		header->offsets[length][0] = offset;
-		header->offsets[length][1] = offset >> 8;
-		header->offsets[length][2] = offset >> 16;
-		header->offsets[length][3] = offset >> 24;
+		header->offsets[length][0] = (unsigned char)((unsigned long)offset);
+		header->offsets[length][1] = (unsigned char)((unsigned long)(offset >> 8));
+		header->offsets[length][2] = (unsigned char)((unsigned long)(offset >> 16));
+		header->offsets[length][3] = (unsigned char)((unsigned long)(offset >> 24));
 	}
 
 	return result;
diff -rupN john-1.7.8/src/config.c john-1.7.8-jumbo-2/src/config.c
--- john-1.7.8/src/config.c	2009-12-25 18:10:08.000000000 +0100
+++ john-1.7.8-jumbo-2/src/config.c	2011-05-17 18:13:02.000000000 +0200
@@ -14,6 +14,9 @@
 #include "path.h"
 #include "memory.h"
 #include "config.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
 
 char *cfg_name = NULL;
 static struct cfg_section *cfg_database = NULL;
@@ -109,6 +112,9 @@ static int cfg_process_line(char *line,
 
 static void cfg_error(char *name, int number)
 {
+#ifdef HAVE_MPI
+	if (mpi_id == 0)
+#endif
 	fprintf(stderr, "Error in %s at line %d\n",
 		path_expand(name), number);
 	error();
diff -rupN john-1.7.8/src/cracker.c john-1.7.8-jumbo-2/src/cracker.c
--- john-1.7.8/src/cracker.c	2011-02-27 06:53:59.000000000 +0100
+++ john-1.7.8-jumbo-2/src/cracker.c	2011-05-17 18:13:02.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2003,2006,2010,2011 by Solar Designer
+ *
+ * ...with a change in the jumbo patch, by JimF
  */
 
 #include <string.h>
@@ -99,7 +101,7 @@ static int crk_process_guess(struct db_s
 	key = crk_methods.get_key(index);
 
 	log_guess(crk_db->options->flags & DB_LOGIN ? pw->login : "?",
-		dupe ? NULL : pw->source, key);
+		dupe ? NULL : pw->source, key, crk_db->options->field_sep_char);
 
 	crk_db->guess_count++;
 	status.guess_count++;
diff -rupN john-1.7.8/src/dummy.c john-1.7.8-jumbo-2/src/dummy.c
--- john-1.7.8/src/dummy.c	2011-03-26 06:49:27.000000000 +0100
+++ john-1.7.8-jumbo-2/src/dummy.c	2011-05-17 18:13:02.000000000 +0200
@@ -38,7 +38,7 @@ static struct fmt_tests tests[] = {
 
 static char saved_key[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1];
 
-static int valid(char *ciphertext)
+static int valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	char *p, *q, c;
 
@@ -259,6 +259,7 @@ struct fmt_main fmt_dummy = {
 		tests
 	}, {
 		fmt_default_init,
+		fmt_default_prepare,
 		valid,
 		fmt_default_split,
 		binary,
diff -rupN john-1.7.8/src/external.c john-1.7.8-jumbo-2/src/external.c
--- john-1.7.8/src/external.c	2006-02-27 04:58:02.000000000 +0100
+++ john-1.7.8-jumbo-2/src/external.c	2011-06-08 01:57:38.000000000 +0200
@@ -16,6 +16,11 @@
 #include "recovery.h"
 #include "config.h"
 #include "cracker.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+
+static unsigned long long mpi_line = 0;
+#endif
 
 static char int_word[PLAINTEXT_BUFFER_SIZE];
 static char rec_word[PLAINTEXT_BUFFER_SIZE];
@@ -36,6 +41,16 @@ struct c_ident *f_filter;
 static struct cfg_list *ext_source;
 static struct cfg_line *ext_line;
 static int ext_pos;
+static int progress = -1;
+
+static int get_progress(int *hundth_perc)
+{
+	// This is a dummy function just for getting the DONE
+	// timestamp from status.c - it will return -1 all
+	// the time except when a mode is finished
+	*hundth_perc = 0;
+	return progress;
+}
 
 static int ext_getchar(void)
 {
@@ -59,6 +74,9 @@ static void ext_rewind(void)
 void ext_init(char *mode)
 {
 	if (!(ext_source = cfg_get_list(SECTION_EXT, mode))) {
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Unknown external mode: %s\n", mode);
 		error();
 	}
@@ -66,6 +84,9 @@ void ext_init(char *mode)
 	if (c_compile(ext_getchar, ext_rewind, &ext_globals)) {
 		if (!ext_line) ext_line = ext_source->tail;
 
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Compiler error in %s at line %d: %s\n",
 			cfg_name, ext_line->number,
 			c_errors[c_errno]);
@@ -131,6 +152,9 @@ static int restore_state(FILE *file)
 	} while ((*internal++ = *external++ = c));
 
 	c_execute(c_lookup("restore"));
+#ifdef HAVE_MPI
+	mpi_line = mpi_id + 1;  // We just need the correct modulus
+#endif
 
 	return 0;
 }
@@ -147,8 +171,14 @@ void do_external_crack(struct db_main *d
 
 	log_event("Proceeding with external mode: %.100s", ext_mode);
 
+#ifdef HAVE_MPI
+	if (mpi_p > 1) log_event("MPI: each node will process 1/%u of candidates", mpi_p);
+#endif
 	if (!f_generate) {
 		log_event("! No generate() function defined");
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "No generate() for external mode: %s\n",
 			ext_mode);
 		error();
@@ -160,7 +190,7 @@ void do_external_crack(struct db_main *d
 		*internal++ = *external++;
 	*internal = 0;
 
-	status_init(NULL, 0);
+	status_init(&get_progress, 0);
 
 	rec_restore_mode(restore_state);
 	rec_init(db, save_state);
@@ -171,6 +201,10 @@ void do_external_crack(struct db_main *d
 		c_execute(f_generate);
 		if (!ext_word[0]) break;
 
+#ifdef HAVE_MPI
+		// MPI distribution
+		if (mpi_line++ % mpi_p != mpi_id) continue;
+#endif
 		c_execute(f_filter);
 		if (!ext_word[0]) continue;
 
@@ -183,6 +217,9 @@ void do_external_crack(struct db_main *d
 		if (crk_process_key(int_word)) break;
 	} while (1);
 
+	if (!event_abort)
+		progress = 100; // For reporting DONE after a no-ETA run
+
 	crk_done();
 	rec_done(event_abort);
 }
diff -rupN john-1.7.8/src/formats.c john-1.7.8-jumbo-2/src/formats.c
--- john-1.7.8/src/formats.c	2011-02-27 13:34:10.000000000 +0100
+++ john-1.7.8-jumbo-2/src/formats.c	2011-05-26 16:46:46.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2006,2008,2010,2011 by Solar Designer
+ *
+ * ...with a change in the jumbo patch, by JimF
  */
 
 #include <stdio.h>
@@ -23,7 +25,7 @@ void fmt_register(struct fmt_main *forma
 void fmt_init(struct fmt_main *format)
 {
 	if (!format->private.initialized) {
-		format->methods.init();
+		format->methods.init(format);
 		format->private.initialized = 1;
 	}
 }
@@ -39,7 +41,7 @@ char *fmt_self_test(struct fmt_main *for
 	if (format->params.plaintext_length > PLAINTEXT_BUFFER_SIZE - 3)
 		return "length";
 
-	if (format->methods.valid("*")) return "valid";
+	if (format->methods.valid("*",format)) return "valid";
 
 	fmt_init(format);
 
@@ -48,13 +50,19 @@ char *fmt_self_test(struct fmt_main *for
 	while ((current++)->ciphertext)
 		ntests++;
 	current = format->params.tests;
+	if (ntests==0) return NULL;
 
 	done = 0;
 	index = 0; max = format->params.max_keys_per_crypt;
 	do {
-		if (format->methods.valid(current->ciphertext) != 1)
+		char *prepared;
+		current->flds[1] = current->ciphertext;
+		prepared = format->methods.prepare(current->flds, format);
+		if (!prepared || strlen(prepared) < 7) // $dummy$ can be just 7 bytes long.
+			return "prepare";
+		if (format->methods.valid(prepared,format) != 1)
 			return "valid";
-		ciphertext = format->methods.split(current->ciphertext, 0);
+		ciphertext = format->methods.split(prepared, 0);
 		plaintext = current->plaintext;
 
 		binary = format->methods.binary(ciphertext);
@@ -77,16 +85,22 @@ char *fmt_self_test(struct fmt_main *for
 			return s_size;
 		}
 
-		if (!format->methods.cmp_all(binary, index + 1))
-			return "cmp_all";
-		if (!format->methods.cmp_one(binary, index))
-			return "cmp_one";
-		if (!format->methods.cmp_exact(ciphertext, index))
-			return "cmp_exact";
-
-		if (strncmp(format->methods.get_key(index), plaintext,
-		    format->params.plaintext_length))
-			return "get_key";
+		if (!format->methods.cmp_all(binary, index + 1)) {
+			sprintf(s_size, "cmp_all(%d)", index + 1);
+			return s_size;
+		}
+		if (!format->methods.cmp_one(binary, index)) {
+			sprintf(s_size, "cmp_one(%d)", index);
+			return s_size;
+		}
+		if (!format->methods.cmp_exact(ciphertext, index)) {
+			sprintf(s_size, "cmp_exact(%d)", index);
+			return s_size;
+		}
+		if (strncmp(format->methods.get_key(index), plaintext, format->params.plaintext_length)) {
+			sprintf(s_size, "get_key(%d)", index);
+			return s_size;
+		}
 
 /* Remove some old keys to better test cmp_all() */
 		if (index & 1)
@@ -119,11 +133,16 @@ char *fmt_self_test(struct fmt_main *for
 	return NULL;
 }
 
-void fmt_default_init(void)
+void fmt_default_init(struct fmt_main *pFmt)
+{
+}
+
+char *fmt_default_prepare(char *split_fields[10], struct fmt_main *pFmt)
 {
+	return split_fields[1];
 }
 
-int fmt_default_valid(char *ciphertext)
+int fmt_default_valid(char *ciphertext, struct fmt_main *pFmt)
 {
 	return 0;
 }
diff -rupN john-1.7.8/src/formats.h john-1.7.8-jumbo-2/src/formats.h
--- john-1.7.8/src/formats.h	2011-04-01 23:35:33.000000000 +0200
+++ john-1.7.8-jumbo-2/src/formats.h	2011-06-02 17:19:49.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2005,2010,2011 by Solar Designer
+ *
+ * ...with a change in the jumbo patch, by JimF
  */
 
 /*
@@ -12,6 +14,8 @@
 
 #include "params.h"
 
+struct fmt_main;
+
 /*
  * Format property flags.
  */
@@ -19,6 +23,10 @@
 #define FMT_CASE			0x00000001
 /* Supports 8-bit characters in passwords (does not ignore the 8th bit) */
 #define FMT_8_BIT			0x00000002
+/* Originally uses internal 8859-1 conversion (typically to Unicode) */
+#define FMT_UNICODE			0x00000004
+/* Honours the --utf8 flag (typically changes the 8859-1 behaviour above) */
+#define FMT_UTF8			0x00000008
 /* Uses a bitslice implementation */
 #define FMT_BS				0x00010000
 /* The split() method unifies the case of characters in hash encodings */
@@ -37,6 +45,7 @@
  */
 struct fmt_tests {
 	char *ciphertext, *plaintext;
+	char *flds[10];
 };
 
 /*
@@ -87,16 +96,25 @@ struct fmt_params {
  * should be word aligned; the functions may assume such alignment.
  */
 struct fmt_methods {
-/* Initializes the algorithm's internal structures; valid() and split() are
- * the only methods that are allowed to be called before a call to init().
+/* Initializes the algorithm's internal structures; valid() prepare() and split()
+ * are the only methods that are allowed to be called before a call to init().
  * Note that initializing an algorithm might de-initialize some others (if
  * a shared underlying resource is used). */
-	void (*init)(void);
+	void (*init)(struct fmt_main *);
+
+/* returns a prepared ciphertext if this format is 'possible' to be used.
+ * The 'split_fields array, is the actual contents of the fields, read from
+ * the The default returns split_fields[1].  However, this function CAN
+ * return significantly different data than is in field[1].  It may append
+ * a signature, it may put the user name into the ciphertext, etc.  This
+ * function (and valid) are/may be called prior to the calling the init()
+ * function. This function (and valid), MUST be able to stand on their own. */
+	char * (*prepare)(char *split_fields[10], struct fmt_main *pFmt);
 
 /* Checks if an ASCII ciphertext is valid for this format. Returns zero for
  * invalid ciphertexts, or a number of parts the ciphertext should be split
  * into (up to 9, will usually be 1). */
-	int (*valid)(char *ciphertext);
+	int (*valid)(char *ciphertext, struct fmt_main *);
 
 /* Splits a ciphertext into several pieces and returns the piece with given
  * index, starting from 0 (will usually return the ciphertext unchanged).
@@ -162,6 +180,7 @@ struct fmt_methods {
  */
 struct fmt_private {
 	int initialized;
+	void *data;
 };
 
 /*
@@ -198,8 +217,9 @@ extern char *fmt_self_test(struct fmt_ma
 /*
  * Default methods.
  */
-extern void fmt_default_init(void);
-extern int fmt_default_valid(char *ciphertext);
+extern void fmt_default_init(struct fmt_main *pFmt);
+extern char *fmt_default_prepare(char *split_fields[10], struct fmt_main *pFmt);
+extern int fmt_default_valid(char *ciphertext, struct fmt_main *pFmt);
 extern char *fmt_default_split(char *ciphertext, int index);
 extern void *fmt_default_binary(char *ciphertext);
 extern void *fmt_default_salt(char *ciphertext);
@@ -214,4 +234,12 @@ extern int fmt_default_get_hash(int inde
  */
 #define fmt_dummy_hash fmt_default_get_hash
 
+#ifdef _MSC_VER
+#pragma warning (disable : 4018 297 )
+#define strncasecmp _strnicmp
+#define strcasecmp _stricmp
+#define strlwr _strlwr
+#define inline _inline
+#endif
+
 #endif
diff -rupN john-1.7.8/src/genmkvpwd.c john-1.7.8-jumbo-2/src/genmkvpwd.c
--- john-1.7.8/src/genmkvpwd.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/genmkvpwd.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,287 @@
+#include <stdio.h>
+#include <stdlib.h>
+#ifndef _MSC_VER
+#include <unistd.h>
+#else
+#define atoll _atoi64
+#endif
+#include <math.h>
+#include <string.h>
+#include "params.h"
+#include "memory.h"
+#include "mkvlib.h"
+
+static void show_pwd_rnbs(struct s_pwd * pwd)
+{
+	unsigned long long i;
+	unsigned int k;
+	unsigned long lvl;
+
+	k=0;
+	i = nbparts[pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len];
+	pwd->len++;
+	lvl = pwd->level;
+	pwd->password[pwd->len] = 0;
+	while(i>1)
+	{
+		pwd->password[pwd->len-1] = charsorted[ pwd->password[pwd->len-2]*256 + k ];
+		pwd->level = lvl + proba2[ pwd->password[pwd->len-2]*256 + pwd->password[pwd->len-1] ];
+		i -= nbparts[ pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len ];
+		if(pwd->len<=gmax_len)
+		{
+			show_pwd_rnbs(pwd);
+		}
+		printf("%s\n", pwd->password);
+		gidx++;
+		k++;
+		if(gidx>gend)
+			return;
+	}
+	pwd->len--;
+	pwd->password[pwd->len] = 0;
+	pwd->level = lvl;
+}
+
+static void show_pwd_r(struct s_pwd * pwd, unsigned int bs)
+{
+	unsigned long long i;
+	unsigned int k;
+	unsigned long lvl;
+	unsigned char curchar;
+
+	k=0;
+	i = nbparts[pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len];
+	pwd->len++;
+	lvl = pwd->level;
+	if(bs)
+	{
+		while( (curchar=charsorted[ pwd->password[pwd->len-2]*256 + k ]) != pwd->password[pwd->len-1] )
+		{
+			i -= nbparts[ curchar + pwd->len*256 + (pwd->level + proba2[ pwd->password[pwd->len-2]*256 + curchar ])*256*gmax_len  ];
+			k++;
+		}
+		pwd->level += proba2[ pwd->password[pwd->len-2]*256 + pwd->password[pwd->len-1] ];
+		if(pwd->password[pwd->len]!=0)
+			show_pwd_r(pwd, 1);
+		i -= nbparts[ pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len ];
+		printf("%s\n", pwd->password);
+		gidx++;
+		k++;
+	}
+	pwd->password[pwd->len] = 0;
+	while(i>1)
+	{
+		pwd->password[pwd->len-1] = charsorted[ pwd->password[pwd->len-2]*256 + k ];
+		pwd->level = lvl + proba2[ pwd->password[pwd->len-2]*256 + pwd->password[pwd->len-1] ];
+		i -= nbparts[ pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len ];
+		if(pwd->len<=gmax_len)
+		{
+			show_pwd_r(pwd, 0);
+		}
+		printf("%s\n", pwd->password);
+		gidx++;
+		k++;
+		if(gidx>gend)
+			return;
+	}
+	pwd->len--;
+	pwd->password[pwd->len] = 0;
+	pwd->level = lvl;
+}
+
+static void show_pwd(unsigned long long start, unsigned long long end, unsigned int max_level, unsigned int max_len)
+{
+	struct s_pwd pwd;
+	unsigned int i;
+	unsigned int bs;
+
+	gmax_level = max_level;
+	gmax_len = max_len;
+	gend = end;
+	gidx = start;
+	i=0;
+	bs = 0;
+	if(start>0)
+		bs = 1;
+	if(bs)
+	{
+		print_pwd(start, &pwd, max_level, max_len);
+		while(charsorted[i] != pwd.password[0])
+			i++;
+		pwd.len = 1;
+		pwd.level = proba1[pwd.password[0]];
+		show_pwd_r(&pwd, 1);
+		printf("%s\n", pwd.password);
+		i++;
+	}
+	while(proba1[charsorted[i]]<=max_level)
+	{
+		if(gidx>gend)
+			return;
+		pwd.len = 1;
+		pwd.password[0] = charsorted[i];
+		pwd.level = proba1[pwd.password[0]];
+		pwd.password[1] = 0;
+		show_pwd_rnbs(&pwd);
+		printf("%s\n", pwd.password);
+		gidx++;
+		i++;
+	}
+}
+
+#if 0
+static void stupidsort(unsigned char * result, unsigned int * source, unsigned int size)
+{
+	unsigned char pivot;
+	unsigned char more[256];
+	unsigned char less[256];
+	unsigned char piv[256];
+	unsigned int i,m,l,p;
+
+	if(size<=1)
+		return;
+	i=0;
+	while( (source[result[i]]==1000) && (i<size))
+		i++;
+	if(i==size)
+		return;
+	pivot = result[i];
+	if(size<=1)
+		return;
+	m=0;
+	l=0;
+	p=0;
+	for(i=0;i<size;i++)
+	{
+		if(source[result[i]]==source[pivot])
+		{
+			piv[p] = result[i];
+			p++;
+		}
+		else if(source[result[i]]<=source[pivot])
+		{
+			less[l] = result[i];
+			l++;
+		}
+		else
+		{
+			more[m] = result[i];
+			m++;
+		}
+	}
+	stupidsort(less, source, l);
+	stupidsort(more, source, m);
+	memcpy(result, less, l);
+	memcpy(result+l, piv, p);
+	memcpy(result+l+p, more, m);
+}
+#endif
+
+int main(int argc, char * * argv)
+{
+	struct s_pwd pwd;
+	struct s_pwd pwd2;
+
+	unsigned int max_lvl, max_len;
+	unsigned long long start, end;
+
+	max_lvl = 0;
+	max_len = 0;
+	start = 0;
+	end = 0;
+
+	if((argc<3) || (argc>6))
+	{
+		printf("Usage: %s statfile max_lvl [max_len] [start] [end]\n", argv[0]);
+		return -1;
+	}
+
+	max_lvl = atoi(argv[2]);
+
+	if(argc>3)
+		max_len = atoi(argv[3]);
+	if(argc>4)
+		start = atoll(argv[4]);
+	if(argc>5)
+		end = atoll(argv[5]);
+
+	init_probatables(argv[1]);
+
+	if(max_len==0)
+	{
+		for(max_len=6;max_len<20;max_len++)
+		{
+			nbparts = mem_alloc(256*(max_lvl+1)*sizeof(long long)*(max_len+1));
+			printf("len=%u (%lu KB for nbparts) ", max_len, 256UL*(max_lvl+1)*(max_len+1)*sizeof(long long)/1024);
+			memset(nbparts, 0, 256*(max_lvl+1)*(max_len+1)*sizeof(long long));
+			nb_parts(0, 0, 0, max_lvl, max_len);
+			if(nbparts[0] > 1000000000)
+				printf("%lld G possible passwords (%lld)\n", nbparts[0] / 1000000000, nbparts[0]);
+			else if(nbparts[0] > 10000000)
+				printf("%lld M possible passwords (%lld)\n", nbparts[0] / 1000000, nbparts[0]);
+			else if(nbparts[0] > 10000)
+				printf("%lld K possible passwords (%lld)\n", nbparts[0] / 1000, nbparts[0]);
+			else
+				printf("%lld possible passwords\n", nbparts[0] );
+			free(nbparts);
+		}
+		goto fin;
+	}
+
+	if(max_lvl==0)
+	{
+		for(max_lvl=100;max_lvl<400;max_lvl++)
+		{
+			nbparts = mem_alloc(256*(max_lvl+1)*sizeof(long long)*(max_len+1));
+			printf("lvl=%u (%lu KB for nbparts) ", max_lvl, 256UL*(max_lvl+1)*(max_len+1)*sizeof(long long)/1024);
+			memset(nbparts, 0, 256*(max_lvl+1)*(max_len+1)*sizeof(long long));
+			nb_parts(0, 0, 0, max_lvl, max_len);
+			if(nbparts[0] > 1000000000)
+				printf("%lld G possible passwords (%lld)\n", nbparts[0] / 1000000000, nbparts[0]);
+			else if(nbparts[0] > 10000000)
+				printf("%lld M possible passwords (%lld)\n", nbparts[0] / 1000000, nbparts[0]);
+			else if(nbparts[0] > 10000)
+				printf("%lld K possible passwords (%lld)\n", nbparts[0] / 1000, nbparts[0]);
+			else
+				printf("%lld possible passwords\n", nbparts[0] );
+			free(nbparts);
+		}
+		goto fin;
+	}
+
+	nbparts = mem_alloc(256*(max_lvl+1)*sizeof(long long)*(max_len+1));
+	fprintf(stderr, "allocated %lu KB for nbparts\n", 256UL*(max_lvl+1)*(max_len+1)*sizeof(long long)/1024);
+	memset(nbparts, 0, 256*(max_lvl+1)*(max_len+1)*sizeof(long long));
+
+	nb_parts(0, 0, 0, max_lvl, max_len);
+	if(nbparts[0] > 1000000000)
+		fprintf(stderr, "%lld G possible passwords (%lld)\n", nbparts[0] / 1000000000, nbparts[0]);
+	else if(nbparts[0] > 10000000)
+		fprintf(stderr, "%lld M possible passwords (%lld)\n", nbparts[0] / 1000000, nbparts[0]);
+	else if(nbparts[0] > 10000)
+		fprintf(stderr, "%lld K possible passwords (%lld)\n", nbparts[0] / 1000, nbparts[0]);
+	else
+		fprintf(stderr, "%lld possible passwords\n", nbparts[0] );
+
+	if(end==0)
+		end = nbparts[0];
+
+	pwd.level = 0;
+	pwd.len = 0;
+	pwd.index = 0;
+	memset(pwd.password, 0, max_len+1);
+
+	print_pwd(start, &pwd, max_lvl, max_len);
+	print_pwd(start, &pwd2, max_lvl, max_len);
+
+	fprintf(stderr, "starting with %s (%lld to %lld, %f%% of the scope)\n", pwd.password, start, end, 100*((float) end-start)/((float) nbparts[0]) );
+
+	show_pwd(start, end, max_lvl, max_len);
+
+	free(nbparts);
+fin:
+	free(proba1);
+	free(proba2);
+	free(first);
+	return 0;
+}
diff -rupN john-1.7.8/src/getopt.c john-1.7.8-jumbo-2/src/getopt.c
--- john-1.7.8/src/getopt.c	2003-08-25 00:26:46.000000000 +0200
+++ john-1.7.8-jumbo-2/src/getopt.c	2011-05-17 18:13:02.000000000 +0200
@@ -10,6 +10,9 @@
 #include "memory.h"
 #include "list.h"
 #include "getopt.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
 
 static char *opt_errors[] = {
 	NULL,	/* No error */
@@ -124,6 +127,9 @@ void opt_process(struct opt_entry *list,
 	if (*(opt = argv))
 	while (*++opt)
 	if ((res = opt_process_one(list, flg, *opt))) {
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "%s: \"%s\"\n", opt_errors[res], *opt);
 		error();
 	}
@@ -137,6 +143,9 @@ void opt_check(struct opt_entry *list, o
 	if (*(opt = argv))
 	while (*++opt)
 	if ((res = opt_check_one(list, flg, *opt))) {
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "%s: \"%s\"\n", opt_errors[res], *opt);
 		error();
 	}
diff -rupN john-1.7.8/src/gladman_fileenc.h john-1.7.8-jumbo-2/src/gladman_fileenc.h
--- john-1.7.8/src/gladman_fileenc.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/gladman_fileenc.h	2011-07-03 00:11:25.000000000 +0200
@@ -0,0 +1,88 @@
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2002, Dr Brian Gladman <                 >, Worcester, UK.
+ All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 24/01/2003
+
+ This file contains the header file for fileenc.c, which implements password
+ based file encryption and authentication using AES in CTR mode, HMAC-SHA1
+ authentication and RFC2898 password based key derivation.
+*/
+
+/* fileenc.c is not included in JtR */
+
+#ifndef _FENC_H
+#define _FENC_H
+
+#include "gladman_hmac.h"
+#include "gladman_pwd2key.h"
+
+#define PASSWORD_VERIFIER
+
+#define MAX_KEY_LENGTH        32
+#define MAX_PWD_LENGTH       128
+#define MAX_SALT_LENGTH       16
+#define KEYING_ITERATIONS   1000
+
+#ifdef  PASSWORD_VERIFIER
+#define PWD_VER_LENGTH         2
+#else
+#define PWD_VER_LENGTH         0
+#endif
+
+#define GOOD_RETURN            0
+#define PASSWORD_TOO_LONG   -100
+#define BAD_MODE            -101
+
+/*
+    Field lengths (in bytes) versus File Encryption Mode (0 < mode < 4)
+
+    Mode Key Salt  MAC Overhead
+       1  16    8   10       18
+       2  24   12   10       22
+       3  32   16   10       26
+
+   The following macros assume that the mode value is correct.
+*/
+
+#define KEY_LENGTH(mode)        (8 * ((mode) & 3) + 8)
+#define SALT_LENGTH(mode)       (4 * ((mode) & 3) + 4)
+#define MAC_LENGTH(mode)        (10)
+
+/* the context for file encryption   */
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff -rupN john-1.7.8/src/gladman_hmac.c john-1.7.8-jumbo-2/src/gladman_hmac.c
--- john-1.7.8/src/gladman_hmac.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/gladman_hmac.c	2011-07-02 23:40:59.000000000 +0200
@@ -0,0 +1,145 @@
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2002, Dr Brian Gladman <                 >, Worcester, UK.
+ All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 24/01/2003
+
+ This is an implementation of HMAC, the FIPS standard keyed hash function
+*/
+
+#include "gladman_hmac.h"
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+/* initialise the HMAC context to zero */
+void hmac_sha1_begin(hmac_ctx cx[1])
+{
+    memset(cx, 0, sizeof(hmac_ctx));
+}
+
+/* input the HMAC key (can be called multiple times)    */
+int hmac_sha1_key(const unsigned char key[], unsigned long key_len, hmac_ctx cx[1])
+{
+    if(cx->klen == HMAC_IN_DATA)                /* error if further key input   */
+        return HMAC_BAD_MODE;                   /* is attempted in data mode    */
+
+    if(cx->klen + key_len > IN_BLOCK_LENGTH)    /* if the key has to be hashed  */
+    {
+        if(cx->klen <= IN_BLOCK_LENGTH)         /* if the hash has not yet been */
+        {                                       /* started, initialise it and   */
+            sha1_begin(cx->ctx);                /* hash stored key characters   */
+            sha1_hash(cx->key, cx->klen, cx->ctx);
+        }
+
+        sha1_hash(key, key_len, cx->ctx);       /* hash long key data into hash */
+    }
+    else                                        /* otherwise store key data     */
+        memcpy(cx->key + cx->klen, key, key_len);
+
+    cx->klen += key_len;                        /* update the key length count  */
+    return HMAC_OK;
+}
+
+/* input the HMAC data (can be called multiple times) - */
+/* note that this call terminates the key input phase   */
+void hmac_sha1_data(const unsigned char data[], unsigned long data_len, hmac_ctx cx[1])
+{   unsigned int i;
+
+    if(cx->klen != HMAC_IN_DATA)                /* if not yet in data phase */
+    {
+        if(cx->klen > IN_BLOCK_LENGTH)          /* if key is being hashed   */
+        {                                       /* complete the hash and    */
+            sha1_end((unsigned char *)cx->key, cx->ctx); /* store the result as the */
+            cx->klen = OUT_BLOCK_LENGTH;        /* key and set new length   */
+        }
+
+        /* pad the key if necessary */
+        memset(cx->key + cx->klen, 0, IN_BLOCK_LENGTH - cx->klen);
+
+        /* xor ipad into key value  */
+        for(i = 0; i < IN_BLOCK_LENGTH / sizeof(ARCH_WORD_32); ++i)
+            cx->key[i] ^= 0x36363636;
+
+        /* and start hash operation */
+        sha1_begin(cx->ctx);
+        sha1_hash(cx->key, IN_BLOCK_LENGTH, cx->ctx);
+
+        /* mark as now in data mode */
+        cx->klen = HMAC_IN_DATA;
+    }
+
+    /* hash the data (if any)       */
+    if(data_len)
+        sha1_hash(data, data_len, cx->ctx);
+}
+
+/* compute and output the MAC value */
+void hmac_sha1_end(unsigned char mac[], unsigned long mac_len, hmac_ctx cx[1])
+{   unsigned char dig[OUT_BLOCK_LENGTH];
+    unsigned int i;
+
+    /* if no data has been entered perform a null data phase        */
+    if(cx->klen != HMAC_IN_DATA)
+        hmac_sha1_data((const unsigned char*)0, 0, cx);
+
+    sha1_end(dig, cx->ctx);         /* complete the inner hash      */
+
+    /* set outer key value using opad and removing ipad */
+    for(i = 0; i < IN_BLOCK_LENGTH / sizeof(ARCH_WORD_32); ++i)
+        cx->key[i] ^= 0x36363636 ^ 0x5c5c5c5c;
+
+    /* perform the outer hash operation */
+    sha1_begin(cx->ctx);
+    sha1_hash(cx->key, IN_BLOCK_LENGTH, cx->ctx);
+    sha1_hash(dig, OUT_BLOCK_LENGTH, cx->ctx);
+    sha1_end(dig, cx->ctx);
+
+    /* output the hash value            */
+    for(i = 0; i < mac_len; ++i)
+        mac[i] = dig[i];
+}
+
+/* 'do it all in one go' subroutine     */
+void hmac_sha1(const unsigned char key[], unsigned int key_len,
+          const unsigned char data[], unsigned int data_len,
+          unsigned char mac[], unsigned int mac_len)
+{   hmac_ctx    cx[1];
+
+    hmac_sha1_begin(cx);
+    hmac_sha1_key(key, key_len, cx);
+    hmac_sha1_data(data, data_len, cx);
+    hmac_sha1_end(mac, mac_len, cx);
+}
+
+#if defined(__cplusplus)
+}
+#endif
diff -rupN john-1.7.8/src/gladman_hmac.h john-1.7.8-jumbo-2/src/gladman_hmac.h
--- john-1.7.8/src/gladman_hmac.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/gladman_hmac.h	2011-07-02 23:38:17.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2002, Dr Brian Gladman <                 >, Worcester, UK.
+ All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 24/01/2003
+
+ This is an implementation of HMAC, the FIPS standard keyed hash function
+*/
+
+#ifndef _HMAC_H
+#define _HMAC_H
+
+#include <memory.h>
+
+#include "gladman_sha1.h"
+
+#define IN_BLOCK_LENGTH     SHA1_BLOCK_SIZE
+#define OUT_BLOCK_LENGTH    SHA1_DIGEST_SIZE
+#define HMAC_IN_DATA        0xffffffff
+
+#define HMAC_OK               0
+#define HMAC_BAD_MODE        -1
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+#include "common.h"
+
+typedef struct
+{   ARCH_WORD_32    key[IN_BLOCK_LENGTH / sizeof(ARCH_WORD_32)];
+    sha1_ctx        ctx[1];
+    unsigned int    klen;
+} hmac_ctx;
+
+void hmac_sha1_begin(hmac_ctx cx[1]);
+
+int  hmac_sha1_key(const unsigned char key[], unsigned long key_len, hmac_ctx cx[1]);
+
+void hmac_sha1_data(const unsigned char data[], unsigned long data_len, hmac_ctx cx[1]);
+
+void hmac_sha1_end(unsigned char mac[], unsigned long mac_len, hmac_ctx cx[1]);
+
+void hmac_sha1(const unsigned char key[], unsigned int key_len,
+          const unsigned char data[], unsigned int data_len,
+          unsigned char mac[], unsigned int mac_len);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff -rupN john-1.7.8/src/gladman_pwd2key.c john-1.7.8-jumbo-2/src/gladman_pwd2key.c
--- john-1.7.8/src/gladman_pwd2key.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/gladman_pwd2key.c	2011-06-17 01:30:00.000000000 +0200
@@ -0,0 +1,159 @@
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2002, Dr Brian Gladman <                 >, Worcester, UK.
+ All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 24/01/2003
+
+ This is an implementation of RFC2898, which specifies key derivation from
+ a password and a salt value.
+*/
+
+#include <memory.h>
+#include "gladman_hmac.h"
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+void derive_key(const unsigned char pwd[],  /* the PASSWORD     */
+               unsigned int pwd_len,        /* and its length   */
+               const unsigned char salt[],  /* the SALT and its */
+               unsigned int salt_len,       /* length           */
+               unsigned int iter,   /* the number of iterations */
+               unsigned char key[], /* space for the output key */
+               unsigned int key_len)/* and its required length  */
+{
+    unsigned int    i, j, k, n_blk;
+    unsigned char uu[OUT_BLOCK_LENGTH], ux[OUT_BLOCK_LENGTH];
+    hmac_ctx c1[1], c2[1], c3[1];
+
+    /* set HMAC context (c1) for password               */
+    hmac_sha1_begin(c1);
+    hmac_sha1_key(pwd, pwd_len, c1);
+
+    /* set HMAC context (c2) for password and salt      */
+    memcpy(c2, c1, sizeof(hmac_ctx));
+    hmac_sha1_data(salt, salt_len, c2);
+
+    /* find the number of SHA blocks in the key         */
+    n_blk = 1 + (key_len - 1) / OUT_BLOCK_LENGTH;
+
+    for(i = 0; i < n_blk; ++i) /* for each block in key */
+    {
+        /* ux[] holds the running xor value             */
+        memset(ux, 0, OUT_BLOCK_LENGTH);
+
+        /* set HMAC context (c3) for password and salt  */
+        memcpy(c3, c2, sizeof(hmac_ctx));
+
+        /* enter additional data for 1st block into uu  */
+        uu[0] = (unsigned char)((i + 1) >> 24);
+        uu[1] = (unsigned char)((i + 1) >> 16);
+        uu[2] = (unsigned char)((i + 1) >> 8);
+        uu[3] = (unsigned char)(i + 1);
+
+        /* this is the key mixing iteration         */
+        for(j = 0, k = 4; j < iter; ++j)
+        {
+            /* add previous round data to HMAC      */
+            hmac_sha1_data(uu, k, c3);
+
+            /* obtain HMAC for uu[]                 */
+            hmac_sha1_end(uu, OUT_BLOCK_LENGTH, c3);
+
+            /* xor into the running xor block       */
+            for(k = 0; k < OUT_BLOCK_LENGTH; ++k)
+                ux[k] ^= uu[k];
+
+            /* set HMAC context (c3) for password   */
+            memcpy(c3, c1, sizeof(hmac_ctx));
+        }
+
+        /* compile key blocks into the key output   */
+        j = 0; k = i * OUT_BLOCK_LENGTH;
+        while(j < OUT_BLOCK_LENGTH && k < key_len)
+            key[k++] = ux[j++];
+    }
+}
+
+#ifdef TEST
+
+#include <stdio.h>
+
+struct
+{   unsigned int    pwd_len;
+    unsigned int    salt_len;
+    unsigned int    it_count;
+    unsigned char   *pwd;
+    unsigned char   salt[32];
+    unsigned char   key[32];
+} tests[] =
+{
+    {   8, 4, 5, (unsigned char*)"password",
+        {   0x12, 0x34, 0x56, 0x78 },
+        {   0x5c, 0x75, 0xce, 0xf0, 0x1a, 0x96, 0x0d, 0xf7,
+            0x4c, 0xb6, 0xb4, 0x9b, 0x9e, 0x38, 0xe6, 0xb5 } /* ... */
+    },
+    {   8, 8, 5, (unsigned char*)"password",
+        {   0x12, 0x34, 0x56, 0x78, 0x78, 0x56, 0x34, 0x12 },
+        {   0xd1, 0xda, 0xa7, 0x86, 0x15, 0xf2, 0x87, 0xe6,
+            0xa1, 0xc8, 0xb1, 0x20, 0xd7, 0x06, 0x2a, 0x49 } /* ... */
+    }
+};
+
+int main()
+{   unsigned int    i, j, key_len = 256;
+    unsigned char   key[256];
+
+    printf("\nTest of RFC2898 Password Based Key Derivation");
+    for(i = 0; i < 2; ++i)
+    {
+        derive_key(tests[i].pwd, tests[i].pwd_len, tests[i].salt,
+                    tests[i].salt_len, tests[i].it_count, key, key_len);
+
+        printf("\ntest %i: ", i + 1);
+        printf("key %s", memcmp(tests[i].key, key, 16) ? "is bad" : "is good");
+        for(j = 0; j < key_len && j < 64; j += 4)
+        {
+            if(j % 16 == 0)
+                printf("\n");
+            printf("0x%02x%02x%02x%02x ", key[j], key[j + 1], key[j + 2], key[j + 3]);
+        }
+        printf(j < key_len ? " ... \n" : "\n");
+    }
+    printf("\n");
+    return 0;
+}
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff -rupN john-1.7.8/src/gladman_pwd2key.h john-1.7.8-jumbo-2/src/gladman_pwd2key.h
--- john-1.7.8/src/gladman_pwd2key.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/gladman_pwd2key.h	2011-06-17 01:30:00.000000000 +0200
@@ -0,0 +1,58 @@
+/*
+ ---------------------------------------------------------------------------
+ Copyright (c) 2002, Dr Brian Gladman <                 >, Worcester, UK.
+ All rights reserved.
+
+ LICENSE TERMS
+
+ The free distribution and use of this software in both source and binary
+ form is allowed (with or without changes) provided that:
+
+   1. distributions of this source code include the above copyright
+      notice, this list of conditions and the following disclaimer;
+
+   2. distributions in binary form include the above copyright
+      notice, this list of conditions and the following disclaimer
+      in the documentation and/or other associated materials;
+
+   3. the copyright holder's name is not used to endorse products
+      built using this software without specific written permission.
+
+ ALTERNATIVELY, provided that this notice is retained in full, this product
+ may be distributed under the terms of the GNU General Public License (GPL),
+ in which case the provisions of the GPL apply INSTEAD OF those given above.
+
+ DISCLAIMER
+
+ This software is provided 'as is' with no explicit or implied warranties
+ in respect of its properties, including, but not limited to, correctness
+ and/or fitness for purpose.
+ ---------------------------------------------------------------------------
+ Issue Date: 24/01/2003
+
+ This is an implementation of RFC2898, which specifies key derivation from
+ a password and a salt value.
+*/
+
+#ifndef PWD2KEY_H
+#define PWD2KEY_H
+
+#if defined(__cplusplus)
+extern "C"
+{
+#endif
+
+void derive_key(
+        const unsigned char pwd[],   /* the PASSWORD, and   */
+        unsigned int pwd_len,        /*    its length       */
+        const unsigned char salt[],  /* the SALT and its    */
+        unsigned int salt_len,       /*    length           */
+        unsigned int iter,      /* the number of iterations */
+        unsigned char key[],    /* space for the output key */
+        unsigned int key_len);  /* and its required length  */
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif
diff -rupN john-1.7.8/src/gladman_sha1.h john-1.7.8-jumbo-2/src/gladman_sha1.h
--- john-1.7.8/src/gladman_sha1.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/gladman_sha1.h	2011-07-02 23:19:13.000000000 +0200
@@ -0,0 +1,18 @@
+#ifndef _G_SHA1_H
+#define _G_SHA1_H
+
+#include <openssl/sha.h>
+
+#define SHA1_BLOCK_SIZE  64
+#define SHA1_DIGEST_SIZE 20
+
+typedef SHA_CTX sha1_ctx;
+
+#define sha1_begin SHA1_Init
+
+#define sha1_hash(data, len, ctx) \
+	SHA1_Update(ctx, data, len)
+
+#define sha1_end SHA1_Final
+
+#endif
diff -rupN john-1.7.8/src/hmacMD5_fmt_plug.c john-1.7.8-jumbo-2/src/hmacMD5_fmt_plug.c
--- john-1.7.8/src/hmacMD5_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/hmacMD5_fmt_plug.c	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,333 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5.h"
+
+#define FORMAT_LABEL			"hmac-md5"
+#define FORMAT_NAME			"HMAC MD5"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME			"hmac-md5 MMX"
+#else
+#define ALGORITHM_NAME			"hmac-md5 SSE2"
+#endif
+#else
+#define ALGORITHM_NAME			"hmac-md5"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		64
+#define CIPHERTEXT_LENGTH		128
+
+#define BINARY_SIZE			16
+#define SALT_SIZE			64
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		MMX_COEF
+#define MAX_KEYS_PER_CRYPT		MMX_COEF
+#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + ((i)&3) )
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+static struct fmt_tests hmacmd5_tests[] = {
+	{"what do ya want for nothing?#750c783e6ab0b503eaa86e310a5db738", "Jefe"},
+	{NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define crypt_key hmacmd5_crypt_key
+#define opad hmacmd5_opad
+#define ipad hmacmd5_ipad
+#define cursalt hmacmd5_cursalt
+#define dump hmacmd5_dump
+#ifdef _MSC_VER
+__declspec(align(16)) char crypt_key[64*MMX_COEF];
+__declspec(align(16)) unsigned char opad[PLAINTEXT_LENGTH*MMX_COEF];
+__declspec(align(16)) unsigned char ipad[PLAINTEXT_LENGTH*MMX_COEF];
+__declspec(align(16)) unsigned char cursalt[SALT_SIZE*MMX_COEF];
+__declspec(align(16)) unsigned char dump[BINARY_SIZE*MMX_COEF];
+#else
+char crypt_key[64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char opad[PLAINTEXT_LENGTH*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char ipad[PLAINTEXT_LENGTH*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char cursalt[SALT_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char dump[BINARY_SIZE*MMX_COEF] __attribute__((aligned(16)));
+#endif
+static unsigned long total_len;
+#else
+static char crypt_key[BINARY_SIZE+1];
+static MD5_CTX ctx;
+static unsigned char opad[PLAINTEXT_LENGTH];
+static unsigned char ipad[PLAINTEXT_LENGTH];
+static unsigned char cursalt[SALT_SIZE];
+#endif
+static unsigned char out[PLAINTEXT_LENGTH + 1];
+
+static void hmacmd5_init(struct fmt_main *pFmt)
+{
+#ifdef MMX_COEF
+	memset(crypt_key, 0, sizeof(crypt_key));
+	crypt_key[GETPOS(BINARY_SIZE,0)] = 0x80;
+	crypt_key[GETPOS(BINARY_SIZE,1)] = 0x80;
+#if (MMX_COEF == 4)
+	crypt_key[GETPOS(BINARY_SIZE,2)] = 0x80;
+	crypt_key[GETPOS(BINARY_SIZE,3)] = 0x80;
+#endif
+#endif
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int pos, i;
+
+	for(i=0;(i<strlen(ciphertext)) && (ciphertext[i]!='#');i++) ;
+	if(i==strlen(ciphertext))
+		return 0;
+	pos = i+1;
+	if (strlen(ciphertext+pos) != BINARY_SIZE*2) return 0;
+	for (i = pos; i < BINARY_SIZE*2+pos; i++){
+		if (!(  (('0' <= ciphertext[i])&&(ciphertext[i] <= '9')) ||
+					(('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))
+					|| (('A' <= ciphertext[i])&&(ciphertext[i] <= 'F'))))
+			return 0;
+	}
+	return 1;
+}
+
+static void hmacmd5_set_salt(void *salt)
+{
+#ifdef MMX_COEF
+	total_len = 0;
+	while(((unsigned char *)salt)[total_len])
+	{
+		cursalt[GETPOS(total_len, 0)] = ((unsigned char *)salt)[total_len];
+		cursalt[GETPOS(total_len, 1)] = ((unsigned char *)salt)[total_len];
+#if (MMX_COEF == 4)
+		cursalt[GETPOS(total_len, 2)] = ((unsigned char *)salt)[total_len];
+		cursalt[GETPOS(total_len, 3)] = ((unsigned char *)salt)[total_len];
+#endif
+		total_len ++;
+	}
+	cursalt[GETPOS(total_len, 0)] = 0x80;
+	cursalt[GETPOS(total_len, 1)] = 0x80;
+#if (MMX_COEF == 4)
+	cursalt[GETPOS(total_len, 2)] = 0x80;
+	cursalt[GETPOS(total_len, 3)] = 0x80;
+#endif
+	{
+		int i;
+		for (i = total_len + 1; i < SALT_SIZE; i++) {
+			cursalt[GETPOS(i, 0)] = 0;
+			cursalt[GETPOS(i, 1)] = 0;
+#if (MMX_COEF == 4)
+			cursalt[GETPOS(i, 2)] = 0;
+			cursalt[GETPOS(i, 3)] = 0;
+#endif
+		}
+	}
+	//total_len += 64;
+	//total_len += (total_len<<16);
+#else
+	memcpy(cursalt, salt, SALT_SIZE);
+#endif
+}
+
+static void hmacmd5_set_key(char *key, int index) {
+	int i;
+	int len;
+
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+
+#ifdef MMX_COEF
+	if(index==0)
+	{
+		memset(ipad, 0x36, sizeof(ipad));
+		memset(opad, 0x5C, sizeof(opad));
+	}
+
+	for(i=0;i<len;i++)
+	{
+		ipad[GETPOS(i, index)] ^= key[i];
+		opad[GETPOS(i, index)] ^= key[i];
+	}
+#else
+	memset(ipad, 0x36, PLAINTEXT_LENGTH);
+	memset(opad, 0x5C, PLAINTEXT_LENGTH);
+	for(i=0;i<len;i++)
+	{
+		ipad[i] ^= key[i];
+		opad[i] ^= key[i];
+	}
+#endif
+}
+
+static char *hmacmd5_get_key(int index) {
+	unsigned int i;
+	for(i=0;i<PLAINTEXT_LENGTH;i++)
+#ifdef MMX_COEF
+		out[i] = ipad[ GETPOS(i, index) ] ^ 0x36;
+#else
+		out[i] = ipad[ i ] ^ 0x36;
+#endif
+	out[i] = 0;
+	return (char *) out;
+}
+
+static int hmacmd5_cmp_all(void *binary, int index) {
+	int i=0;
+#ifdef MMX_COEF
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#endif
+		)
+			return 0;
+		i++;
+	}
+#else
+	while(i<BINARY_SIZE)
+	{
+		if(((char *)binary)[i]!=((char *)crypt_key)[i])
+			return 0;
+		i++;
+	}
+#endif
+	return 1;
+}
+
+static int hmacmd5_cmp_exact(char *source, int count){
+  return (1);
+}
+
+static int hmacmd5_cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+#else
+	return hmacmd5_cmp_all(binary, index);
+#endif
+}
+
+static void hmacmd5_crypt_all(int count) {
+
+#ifdef MMX_COEF
+	int i;
+	i = mdfivemmx_nosizeupdate( dump, ipad, 64);
+	i = mdfivemmx_noinit_uniformsizeupdate( (unsigned char *) crypt_key, cursalt, total_len + 64);
+	i = mdfivemmx_nosizeupdate( dump, opad, 64);
+	i = mdfivemmx_noinit_uniformsizeupdate( (unsigned char *) crypt_key, (unsigned char *) crypt_key, BINARY_SIZE + 64);
+#else
+	MD5_Init( &ctx );
+	MD5_Update( &ctx, ipad, 64 );
+	MD5_Update( &ctx, cursalt, strlen( (char *) cursalt) );
+	MD5_Final( (unsigned char *) crypt_key, &ctx);
+	MD5_Init( &ctx );
+	MD5_Update( &ctx, opad, 64 );
+	MD5_Update( &ctx, crypt_key, BINARY_SIZE);
+	MD5_Final( (unsigned char *) crypt_key, &ctx);
+#endif
+
+}
+
+static void * hmacmd5_binary(char *ciphertext)
+{
+	static unsigned char realcipher[BINARY_SIZE];
+	int i,pos;
+
+	for(i=0;ciphertext[i]!='#';i++);
+	pos=i+1;
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2+pos])]*16 + atoi16[ARCH_INDEX(ciphertext[i*2+1+pos])];
+	}
+	return (void *)realcipher;
+}
+
+static void * hmacmd5_salt(char *ciphertext)
+{
+	static unsigned char salt[SALT_SIZE];
+	int i=0;
+	memset(salt, 0, SALT_SIZE);
+	while(ciphertext[i]!='#')
+	{
+		salt[i] = ciphertext[i];
+		i++;
+	}
+	salt[i]=0;
+	return salt;
+}
+
+struct fmt_main fmt_hmacMD5 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		hmacmd5_tests
+	}, {
+		hmacmd5_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		hmacmd5_binary,
+		hmacmd5_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		hmacmd5_set_salt,
+		hmacmd5_set_key,
+		hmacmd5_get_key,
+		fmt_default_clear_keys,
+		hmacmd5_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		hmacmd5_cmp_all,
+		hmacmd5_cmp_one,
+		hmacmd5_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/hmacmd5.c john-1.7.8-jumbo-2/src/hmacmd5.c
--- john-1.7.8/src/hmacmd5.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/hmacmd5.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,165 @@
+/*
+   Unix SMB/CIFS implementation.
+   HMAC MD5 code for use in NTLMv2
+   Copyright (C) Luke Kenneth Casson Leighton 1996-2000
+   Copyright (C) Andrew Tridgell 1992-2000
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+/* taken direct from rfc2104 implementation and modified for suitable use
+ * for ntlmv2.
+ *
+ * minor performance hacks by magnum, 2011
+ */
+
+#include "arch.h"
+#include "common.h"
+#include <string.h>
+
+#include "md5.h"
+#include "hmacmd5.h"
+
+#ifdef _MSC_VER
+#define inline _inline
+#endif
+
+/***********************************************************************
+ the rfc 2104 version of hmac_md5 initialisation.
+***********************************************************************/
+
+void hmac_md5_init_rfc2104(const unsigned char *key, int key_len, HMACMD5Context *ctx)
+{
+	unsigned char tk[16];
+	int i;
+
+	/* if key is longer than 64 bytes reset it to key=MD5(key) */
+	if (key_len > 64) {
+		MD5_CTX tctx;
+
+		MD5_Init(&tctx);
+		MD5_Update(&tctx, (void *)key, key_len);
+		MD5_Final(tk, &tctx);
+
+		key = tk;
+		key_len = 16;
+	}
+
+	memset(ctx->k_ipad, 0x36, sizeof(ctx->k_ipad));
+	memset(ctx->k_opad, 0x5c, sizeof(ctx->k_opad));
+	for (i = 0; i < key_len; i++) {
+		ctx->k_ipad[i] ^= key[i];
+		ctx->k_opad[i] ^= key[i];
+	}
+
+	MD5_Init(&ctx->ctx);
+	MD5_Update(&ctx->ctx, ctx->k_ipad, 64);
+}
+
+/***********************************************************************
+ the microsoft version of hmac_md5 initialisation.
+***********************************************************************/
+void hmac_md5_init_limK_to_64(const unsigned char* key, int key_len,
+			HMACMD5Context *ctx)
+{
+	int i;
+
+	/* if key is longer than 64 bytes truncate it */
+	if (key_len > 64)
+		key_len = 64;
+
+	memset(ctx->k_ipad, 0x36, sizeof(ctx->k_ipad));
+	memset(ctx->k_opad, 0x5c, sizeof(ctx->k_opad));
+	for (i = 0; i < key_len; i++) {
+		ctx->k_ipad[i] ^= key[i];
+		ctx->k_opad[i] ^= key[i];
+	}
+
+	MD5_Init(&ctx->ctx);
+	MD5_Update(&ctx->ctx, ctx->k_ipad, 64);
+}
+
+/***********************************************************************
+ Optimised version for fixed key length of 16
+***********************************************************************/
+inline void hmac_md5_init_K16(const unsigned char* key, HMACMD5Context *ctx)
+{
+	int i;
+
+	memset(ctx->k_ipad, 0x36, sizeof(ctx->k_ipad));
+	memset(ctx->k_opad, 0x5c, sizeof(ctx->k_opad));
+
+#if defined(_MSC_VER) || defined(__GNUC__)
+#if (ARCH_SIZE == 8)
+//#warning INFO: Using 64-bit xor
+	for (i = 0; i < 2; i++) {
+		((unsigned long long *)ctx->k_ipad)[i] ^= ((unsigned long long *)key)[i];
+		((unsigned long long *)ctx->k_opad)[i] ^= ((unsigned long long *)key)[i];
+	}
+#else
+//#warning INFO: Using 32-bit xor
+	for (i = 0; i < 4; i++) {
+		((ARCH_WORD_32 *)ctx->k_ipad)[i] ^= ((ARCH_WORD_32 *)key)[i];
+		((ARCH_WORD_32 *)ctx->k_opad)[i] ^= ((ARCH_WORD_32 *)key)[i];
+	}
+#endif
+#else
+//#warning INFO: Using 8-bit xor (always safe)
+	for (i = 0; i < 16; i++) {
+		ctx->k_ipad[i] ^= key[i];
+		ctx->k_opad[i] ^= key[i];
+	}
+#endif
+
+	MD5_Init(&ctx->ctx);
+	MD5_Update(&ctx->ctx, ctx->k_ipad, 64);
+}
+
+/***********************************************************************
+ update hmac_md5 "inner" buffer
+***********************************************************************/
+
+inline void hmac_md5_update(const unsigned char *text, int text_len, HMACMD5Context *ctx)
+{
+        MD5_Update(&ctx->ctx, (void *)text, text_len); /* then text of datagram */
+}
+
+/***********************************************************************
+ finish off hmac_md5 "inner" buffer and generate outer one.
+***********************************************************************/
+inline void hmac_md5_final(unsigned char *digest, HMACMD5Context *ctx)
+{
+	MD5_Final(digest, &ctx->ctx);
+
+	MD5_Init(&ctx->ctx);
+	MD5_Update(&ctx->ctx, ctx->k_opad, 64);
+	MD5_Update(&ctx->ctx, digest, 16);
+	MD5_Final(digest, &ctx->ctx);
+}
+
+/***********************************************************
+ single function to calculate an HMAC MD5 digest from data
+ using optimised hmacmd5 init method because the key is 16 bytes.
+************************************************************/
+void hmac_md5(const unsigned char *key, const unsigned char *data,
+              int data_len, unsigned char *digest)
+{
+	HMACMD5Context ctx;
+
+	hmac_md5_init_K16(key, &ctx);
+	if (data_len != 0)
+		hmac_md5_update(data, data_len, &ctx);
+	hmac_md5_final(digest, &ctx);
+}
diff -rupN john-1.7.8/src/hmacmd5.h john-1.7.8-jumbo-2/src/hmacmd5.h
--- john-1.7.8/src/hmacmd5.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/hmacmd5.h	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+   Unix SMB/CIFS implementation.
+   Interface header: Scheduler service
+   Copyright (C) Luke Kenneth Casson Leighton 1996-1999
+   Copyright (C) Andrew Tridgell 1992-1999
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#ifndef _HMAC_MD5_H
+
+#if defined(__SUNPRO_C)
+// In this case, align is for memcpy, not strictly needed
+//#warning INFO: using Solaris CC align pragma for HMACMD5Context
+#pragma align ARCH_SIZE (k_ipad, k_opad)
+#endif
+typedef struct {
+#ifdef _MSC_VER
+//#warning INFO: using Microsoft align pragma for HMACMD5Context
+	__declspec(align(ARCH_SIZE)) unsigned char k_ipad[64];
+	__declspec(align(ARCH_SIZE)) unsigned char k_opad[64];
+#elif defined (__GNUC__)
+//#warning INFO: using GNU align pragma for HMACMD5Context
+	unsigned char k_ipad[64] __attribute__ ((aligned(ARCH_SIZE)));
+	unsigned char k_opad[64] __attribute__ ((aligned(ARCH_SIZE)));
+#else
+//#warning INFO: using no align pragma for HMACMD5Context
+	unsigned char k_ipad[64];
+	unsigned char k_opad[64];
+#endif
+	MD5_CTX ctx;
+} HMACMD5Context;
+
+extern void hmac_md5_init_rfc2104(const unsigned char *key, int key_len, HMACMD5Context *ctx);
+extern void hmac_md5_init_limK_to_64(const unsigned char*, int, HMACMD5Context*);
+extern void hmac_md5_init_K16(const unsigned char*, HMACMD5Context*);
+extern void hmac_md5_update(const unsigned char*, int, HMACMD5Context*);
+extern void hmac_md5_final(unsigned char*, HMACMD5Context*);
+extern void hmac_md5(const unsigned char *key, const unsigned char *data, int data_len, unsigned char *digest);
+#endif /* _HMAC_MD5_H */
diff -rupN john-1.7.8/src/hmailserver_fmt.c john-1.7.8-jumbo-2/src/hmailserver_fmt.c
--- john-1.7.8/src/hmailserver_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/hmailserver_fmt.c	2011-07-02 22:08:31.000000000 +0200
@@ -0,0 +1,260 @@
+/*
+ * This patch Copyright (C) 2010 by James Nobis - quel
+ * - quel NOSPAM quelrod NOSPAM net, and it is herby released to the general
+ * public under the follow terms:
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * format specification
+ * http://www.hmailserver.com/forum/viewtopic.php?p=97515&sid=b2c1c6ba1e10c2f0654ca9421b2059e8#p97515
+ * inspiration from the generic sha-1 and md5
+ * Copyright (c) 2010 by Solar Designer
+ */
+
+#include <openssl/opensslv.h>
+#if OPENSSL_VERSION_NUMBER >= 0x00908000
+
+#include <string.h>
+#include <openssl/sha.h>
+
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL        "hmailserver"
+#define FORMAT_NAME         "hmailserver"
+
+#define ALGORITHM_NAME      "32/" ARCH_BITS_STR
+
+#define BENCHMARK_COMMENT   ""
+#define BENCHMARK_LENGTH    0
+
+#define PLAINTEXT_LENGTH    70
+#define CIPHERTEXT_LENGTH   64
+
+#define BINARY_SIZE         32
+#define SALT_SIZE           6
+
+#define MIN_KEYS_PER_CRYPT  1
+#define MAX_KEYS_PER_CRYPT  1
+
+static struct fmt_tests hmailserver_tests[] = {
+    {"cc06fa688a64cdeea43d3c0fb761fede7e3ccf00a9daea9c79f7d458e06f88327f16dd", "password"},
+    {"fee4fd4446aebcb3332aa5c61845b7bcbe5a3126fedf51a6359663d61b87d4f6ee87df", "12345678"},
+    {"2d7b784370c488b6548394ba11513e159220c83e2458ed01d8c7cdadd6bf486b433703", "1234"},
+    {"0926aadc8d49682c3f091af2dbf7f16f1cc7130b8e6dc86978d3f1bef914ce0096d4b3", "0123456789ABCDE"},
+    {NULL}
+};
+
+static char saved_salt[SALT_SIZE];
+static int saved_key_length;
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static SHA256_CTX ctx;
+static ARCH_WORD_32 crypt_out[8] = {0}; // 8 * 32 = 256
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+    int i;
+
+    if ( ciphertext == NULL )
+        return 0;
+
+    if ( strlen( ciphertext ) != PLAINTEXT_LENGTH )
+        return 0;
+
+    for ( i = 0; i < PLAINTEXT_LENGTH - 1; i++ )
+        if (!( (('0' <= ciphertext[i] ) && ( ciphertext[i] <= '9' ))
+                || (('a' <= ciphertext[i] ) && ( ciphertext[i] <= 'f' )) ))
+            return 0;
+
+    return 1;
+}
+
+static void *get_binary(char *ciphertext)
+{
+    static unsigned char *out;
+    char *p;
+    int i;
+
+    if (!out) out = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+    p = ciphertext + SALT_SIZE;
+    for (i = 0; i < BINARY_SIZE; i++) {
+        out[i] =
+            (atoi16[ARCH_INDEX(*p)] << 4) |
+            atoi16[ARCH_INDEX(p[1])];
+        p += 2;
+    }
+
+    return out;
+}
+
+static void *salt(char *ciphertext)
+{
+    static unsigned char out[SALT_SIZE];
+
+    memcpy(out, ciphertext, SALT_SIZE);
+
+    return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+    return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+    return crypt_out[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+    return crypt_out[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+    return crypt_out[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+    return crypt_out[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+    return crypt_out[0] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+    int x, y;
+    x = ((ARCH_WORD_32)(ARCH_INDEX(((unsigned char *)salt)[0])-' '));
+    y = (((ARCH_WORD_32)(ARCH_INDEX(((unsigned char *)salt)[1])-' ')<<4));
+    return (x+y) & 0x3FF;
+}
+
+static void set_salt(void *salt)
+{
+    memcpy(saved_salt, salt, SALT_SIZE);
+}
+
+static void set_key(char *key, int index)
+{
+    saved_key_length = strlen(key);
+    if (saved_key_length > PLAINTEXT_LENGTH)
+        saved_key_length = PLAINTEXT_LENGTH;
+    memcpy(saved_key, key, saved_key_length);
+}
+
+static char *get_key(int index)
+{
+    saved_key[saved_key_length] = 0;
+    return saved_key;
+}
+
+static void crypt_all(int count)
+{
+    SHA256_Init(&ctx);
+    SHA256_Update(&ctx, saved_salt, SALT_SIZE);
+    SHA256_Update(&ctx, saved_key, saved_key_length);
+    SHA256_Final((unsigned char *)crypt_out, &ctx);
+}
+
+static int cmp_all(void *binary, int count)
+{
+    return !memcmp(binary, crypt_out, BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int index)
+{
+    return 1;
+}
+
+struct fmt_main fmt_hmailserver = {
+    {
+        FORMAT_LABEL,
+        FORMAT_NAME,
+        ALGORITHM_NAME,
+        BENCHMARK_COMMENT,
+        BENCHMARK_LENGTH,
+        PLAINTEXT_LENGTH,
+        BINARY_SIZE,
+        SALT_SIZE,
+        MIN_KEYS_PER_CRYPT,
+        MAX_KEYS_PER_CRYPT,
+        FMT_CASE | FMT_8_BIT,
+        hmailserver_tests
+    }, {
+        fmt_default_init,
+	fmt_default_prepare,
+        valid,
+        fmt_default_split,
+        get_binary,
+        salt,
+        {
+            binary_hash_0,
+            binary_hash_1,
+            binary_hash_2,
+            binary_hash_3,
+            binary_hash_4
+        },
+        salt_hash,
+        set_salt,
+        set_key,
+        get_key,
+        fmt_default_clear_keys,
+        crypt_all,
+        {
+            get_hash_0,
+            get_hash_1,
+            get_hash_2,
+            get_hash_3,
+            get_hash_4
+        },
+        cmp_all,
+        cmp_all,
+        cmp_exact
+    }
+};
+
+#else
+#ifdef __GNUC__
+#warning Note: hmailserver format disabled - it needs OpenSSL 0.9.8 or above
+#endif
+#endif
diff -rupN john-1.7.8/src/idle.c john-1.7.8-jumbo-2/src/idle.c
--- john-1.7.8/src/idle.c	2011-05-04 21:20:10.000000000 +0200
+++ john-1.7.8-jumbo-2/src/idle.c	2011-07-02 20:57:38.000000000 +0200
@@ -1,10 +1,15 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2006,2009,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by various authors
  */
 
 #define _XOPEN_SOURCE /* for nice(2) */
+
+#ifndef _MSC_VER
 #include <unistd.h>
+#endif
 #include <stdio.h>
 
 #ifdef _POSIX_PRIORITY_SCHEDULING
@@ -15,6 +20,10 @@
 static int use_yield = 0;
 #endif
 
+#if defined (__MINGW32__) || defined (_MSC_VER)
+#include <windows.h>
+#endif
+
 #ifdef __CYGWIN32__
 extern int nice(int);
 #endif
@@ -58,7 +67,12 @@ void idle_init(struct fmt_main *format)
 
 	clk_tck_init();
 
-#ifndef __BEOS__
+#if defined(__MINGW32__) || defined (_MSC_VER)
+	SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS);
+	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_IDLE);
+#elif defined(__BEOS__)
+	set_thread_priority(getpid(), 1);
+#else
 /*
  * Normally, the range is -20 to 19, but some systems can do 20 as well (at
  * least some versions of Linux on Alpha), so we try 20.  We assume that we're
@@ -67,8 +81,6 @@ void idle_init(struct fmt_main *format)
  */
 	if (nice(20) == -1)
 		perror("nice");
-#else
-	set_thread_priority(getpid(), 1);
 #endif
 
 #if defined(_POSIX_PRIORITY_SCHEDULING) && defined(SCHED_IDLE)
diff -rupN john-1.7.8/src/inc.c john-1.7.8-jumbo-2/src/inc.c
--- john-1.7.8/src/inc.c	2011-05-04 21:39:12.000000000 +0200
+++ john-1.7.8-jumbo-2/src/inc.c	2011-07-02 20:42:27.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2006 by Solar Designer
+ *
+ * ...with a change in the jumbo patch, by JoMo-Kun
  */
 
 #include <stdio.h>
@@ -23,6 +25,32 @@
 #include "cracker.h"
 
 extern struct fmt_main fmt_LM;
+extern struct fmt_main fmt_NETLM;
+extern struct fmt_main fmt_NETHALFLM;
+
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
+#include <math.h>
+
+static unsigned long long try, cand;
+
+static int get_progress(int *hundth_perc)
+{
+	int hundredXpercent, percent;
+
+	if (!cand)
+		return -1;
+
+	if (try > 1844674407370955LL) {
+		*hundth_perc = percent = 99;
+	} else {
+		hundredXpercent = (int)((unsigned long long)(10000 * (try)) / (unsigned long long)cand);
+		percent = hundredXpercent / 100;
+		*hundth_perc = hundredXpercent - (percent*100);
+	}
+	return percent;
+}
 
 typedef char (*char2_table)
 	[CHARSET_SIZE + 1][CHARSET_SIZE + 1];
@@ -64,6 +92,7 @@ static int restore_state(FILE *file)
 		if ((unsigned int)rec_numbers[pos] >= CHARSET_SIZE) return 1;
 	}
 
+	cand = 0; // progress reporting don't work after resume so we mute it
 	return 0;
 }
 
@@ -76,6 +105,9 @@ static void fix_state(void)
 static void inc_format_error(char *charset)
 {
 	log_event("! Incorrect charset file format: %.100s", charset);
+#ifdef HAVE_MPI
+	if (mpi_id == 0)
+#endif
 	fprintf(stderr, "Incorrect charset file format: %s\n", charset);
 	error();
 }
@@ -311,6 +343,7 @@ update_last:
 	}
 
 	key = key_i;
+	try++;
 	if (!ext_mode || !f_filter || ext_filter_body(key_i, key = key_e))
 	if (crk_process_key(key)) return 1;
 
@@ -377,6 +410,10 @@ void do_incremental_crack(struct db_main
 	if (!mode) {
 		if (db->format == &fmt_LM)
 			mode = "LanMan";
+		else if (db->format == &fmt_NETLM)
+			mode = "LanMan";
+		else if (db->format == &fmt_NETHALFLM)
+			mode = "LanMan";
 		else
 			mode = "All";
 	}
@@ -385,6 +422,9 @@ void do_incremental_crack(struct db_main
 
 	if (!(charset = cfg_get_param(SECTION_INC, mode, "File"))) {
 		log_event("! No charset defined");
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "No charset defined for mode: %s\n", mode);
 		error();
 	}
@@ -400,6 +440,9 @@ void do_incremental_crack(struct db_main
 	if (min_length > max_length) {
 		log_event("! MinLen = %d exceeds MaxLen = %d",
 			min_length, max_length);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "MinLen = %d exceeds MaxLen = %d\n",
 			min_length, max_length);
 		error();
@@ -408,6 +451,9 @@ void do_incremental_crack(struct db_main
 	if (min_length > db->format->params.plaintext_length) {
 		log_event("! MinLen = %d is too large for this hash type",
 			min_length);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "MinLen = %d exceeds the maximum possible "
 			"length for the current hash type (%d)\n",
 			min_length, db->format->params.plaintext_length);
@@ -417,6 +463,9 @@ void do_incremental_crack(struct db_main
 	if (max_length > db->format->params.plaintext_length) {
 		log_event("! MaxLen = %d is too large for this hash type",
 			max_length);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Warning: "
 			"MaxLen = %d is too large for the current hash type, "
 			"reduced to %d\n",
@@ -427,6 +476,9 @@ void do_incremental_crack(struct db_main
 	if (max_length > CHARSET_LENGTH) {
 		log_event("! MaxLen = %d exceeds the compile-time limit of %d",
 			max_length, CHARSET_LENGTH);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr,
 			"\n"
 			"MaxLen = %d exceeds the compile-time limit of %d\n\n"
@@ -461,6 +513,9 @@ void do_incremental_crack(struct db_main
 	if (header->min != CHARSET_MIN || header->max != CHARSET_MAX ||
 	    header->length != CHARSET_LENGTH) {
 		log_event("! Incompatible charset file: %.100s", charset);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Incompatible charset file: %s\n", charset);
 		error();
 	}
@@ -493,6 +548,9 @@ void do_incremental_crack(struct db_main
 		log_event("! Extra characters not in compile-time "
 			"specified range ('\\x%02x' to '\\x%02x')",
 			CHARSET_MIN, CHARSET_MAX);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Extra characters not in compile-time "
 			"specified range ('\\x%02x' to '\\x%02x')\n",
 			CHARSET_MIN, CHARSET_MAX);
@@ -511,10 +569,16 @@ void do_incremental_crack(struct db_main
 
 	if ((unsigned int)max_count > real_count) {
 		log_event("! Only %u characters available", real_count);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Warning: only %u characters available\n",
 			real_count);
 	}
 
+	for (pos = min_length; pos <= max_length; pos++)
+		cand += pow(real_count, pos);
+
 	if (!(db->format->params.flags & FMT_CASE))
 	switch (is_mixedcase(allchars)) {
 	case -1:
@@ -523,6 +587,9 @@ void do_incremental_crack(struct db_main
 	case 1:
 		log_event("! Mixed-case charset, "
 			"but the hash type is case-insensitive");
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Warning: mixed-case charset, "
 			"but the current hash type is case-insensitive;\n"
 			"some candidate passwords may be unnecessarily "
@@ -540,12 +607,16 @@ void do_incremental_crack(struct db_main
 	rec_entry = 0;
 	memset(rec_numbers, 0, sizeof(rec_numbers));
 
-	status_init(NULL, 0);
+	status_init(get_progress, 0);
 
 	rec_restore_mode(restore_state);
 	rec_init(db, save_state);
 
 	ptr = header->order + (entry = rec_entry) * 3;
+#ifdef HAVE_MPI
+	/* *ptr has to start at different positions so they don't overlap */
+	ptr += (3 * mpi_id * (mpi_p - 1));
+#endif
 	memcpy(numbers, rec_numbers, sizeof(numbers));
 
 	crk_init(db, fix_state, NULL);
@@ -557,6 +628,11 @@ void do_incremental_crack(struct db_main
 		entry++;
 		length = *ptr++; fixed = *ptr++; count = *ptr++;
 
+#ifdef HAVE_MPI
+		/* increment *ptr with the number of processors after this */
+		ptr = ptr + (3 * (mpi_p - 1));
+		entry = entry + mpi_p - 1;
+#endif
 		if (length >= CHARSET_LENGTH ||
 			fixed > length ||
 			count >= CHARSET_SIZE) inc_format_error(charset);
@@ -581,6 +657,9 @@ void do_incremental_crack(struct db_main
 
 		if (!length && !min_length) {
 			min_length = 1;
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
 			if (crk_process_key("")) break;
 		}
 
@@ -591,6 +670,9 @@ void do_incremental_crack(struct db_main
 			break;
 	}
 
+	if (!event_abort)
+		try = cand = 100; // For reporting DONE after a no-ETA run
+
 	crk_done();
 	rec_done(event_abort);
 
diff -rupN john-1.7.8/src/john-mpi.c john-1.7.8-jumbo-2/src/john-mpi.c
--- john-1.7.8/src/john-mpi.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/john-mpi.c	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,35 @@
+#include "john-mpi.h"
+#include <string.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <omp.h>
+
+int mpi_p, mpi_id, namesize;
+char mpi_name[MPI_MAX_PROCESSOR_NAME + 1];
+
+/* Fixed version of id2string to correct a memory leak
+ * Submitted by Carsten G
+ */
+char *id2string() {
+	static char id_string[12] = "";
+	if (strlen(id_string)) return id_string;
+	snprintf(id_string, 11, "%d", mpi_id);
+	id_string[11] = 0x00;
+	return id_string;
+}
+
+void mpi_teardown(void){
+	if (nice(20) < 0) fprintf(stderr, "nice() failed\n");
+	MPI_Finalize();
+}
+
+void mpi_setup(int argc, char **argv) {
+	MPI_Init(&argc, &argv);
+	MPI_Comm_rank(MPI_COMM_WORLD, &mpi_id);
+	MPI_Comm_size(MPI_COMM_WORLD, &mpi_p);
+	MPI_Get_processor_name(mpi_name, &namesize);
+	if (mpi_id != 0)
+		close(1);
+	atexit(mpi_teardown);
+}
diff -rupN john-1.7.8/src/john-mpi.h john-1.7.8-jumbo-2/src/john-mpi.h
--- john-1.7.8/src/john-mpi.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/john-mpi.h	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,15 @@
+#ifndef JOHN_MPI_INCLUDE
+#define JOHN_MPI_INCLUDE
+
+#include <mpi.h>
+
+extern int mpi_p, mpi_id;
+extern char mpi_name[MPI_MAX_PROCESSOR_NAME + 1];
+
+/* returns the ascii representation of mpi_id */
+extern char *id2string();
+
+/* MPI initialization stuff, registers atexit() as well */
+extern void mpi_setup(int argc, char **argv);
+extern void mpi_teardown(void);
+#endif
diff -rupN john-1.7.8/src/john.c john-1.7.8-jumbo-2/src/john.c
--- john-1.7.8/src/john.c	2011-02-27 13:31:36.000000000 +0100
+++ john-1.7.8-jumbo-2/src/john.c	2011-07-03 16:03:58.000000000 +0200
@@ -1,10 +1,18 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2004,2006,2009-2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by various authors
  */
 
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#else
+#define CRTDBG_MAP_ALLOC
+#include <stdlib.h>
+#include <crtdbg.h>
+#endif
 #include <string.h>
 #include <stdlib.h>
 #include <sys/stat.h>
@@ -30,8 +38,17 @@
 #include "single.h"
 #include "wordlist.h"
 #include "inc.h"
+#include "mkv.h"
 #include "external.h"
 #include "batch.h"
+#include "md5_gen.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#ifdef _OPENMP
+#include <omp.h>
+#endif /* _OPENMP */
+#endif /* HAVE_MPI */
+#include <openssl/opensslv.h>
 
 #if CPU_DETECT
 extern int CPU_detect(void);
@@ -44,9 +61,32 @@ extern struct fmt_main fmt_crypt;
 #endif
 extern struct fmt_main fmt_dummy;
 
+extern struct fmt_main fmt_MD5gen;
+
+#if OPENSSL_VERSION_NUMBER >= 0x00908000
+extern struct fmt_main fmt_hmailserver;
+extern struct fmt_main fmt_SybaseASE;
+#endif
+
+#ifdef HAVE_SKEY
+extern struct fmt_main fmt_SKEY;
+#endif
+
+extern struct fmt_main fmt_ssh;
+extern struct fmt_main fmt_pdf;
+extern struct fmt_main rar_fmt;
+extern struct fmt_main zip_fmt;
+
+#include "fmt_externs.h"
+
+extern int unique(int argc, char **argv);
 extern int unshadow(int argc, char **argv);
 extern int unafs(int argc, char **argv);
-extern int unique(int argc, char **argv);
+extern int undrop(int argc, char **argv);
+extern int ssh2john(int argc, char **argv);
+extern int pdf2john(int argc, char **argv);
+extern int rar2john(int argc, char **argv);
+extern int zip2john(int argc, char **argv);
 
 static struct db_main database;
 static struct fmt_main dummy_format;
@@ -63,20 +103,52 @@ static void john_register_one(struct fmt
 
 static void john_register_all(void)
 {
+	int i, cnt;
+	struct fmt_main *pFmts;
+
 	if (options.format) strlwr(options.format);
 
+	// NOTE, this MUST happen, before ANY format that links a 'thin' format to md5-gen.
+	// Since gen(27) and gen(28) are MD5 and MD5a formats, we build the
+	// generic format first
+	cnt = md5_gen_Register_formats(&pFmts);
+
 	john_register_one(&fmt_DES);
 	john_register_one(&fmt_BSDI);
 	john_register_one(&fmt_MD5);
 	john_register_one(&fmt_BF);
 	john_register_one(&fmt_AFS);
 	john_register_one(&fmt_LM);
+
+#if OPENSSL_VERSION_NUMBER >= 0x00908000
+	john_register_one(&fmt_hmailserver);
+	john_register_one(&fmt_SybaseASE);
+#endif
+
+	for (i = 0; i < cnt; ++i)
+		john_register_one(&(pFmts[i]));
+
 #ifdef HAVE_CRYPT
 	john_register_one(&fmt_crypt);
 #endif
+
+#ifdef HAVE_SKEY
+	john_register_one(&fmt_SKEY);
+#endif
+
+	john_register_one(&fmt_ssh);
+	john_register_one(&fmt_pdf);
+	john_register_one(&rar_fmt);
+	john_register_one(&zip_fmt);
+
+#include "fmt_registers.h"
+
 	john_register_one(&fmt_dummy);
 
 	if (!fmt_list) {
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Unknown ciphertext format name requested\n");
 		error();
 	}
@@ -86,10 +158,14 @@ static void john_log_format(void)
 {
 	int min_chunk, chunk;
 
+#ifdef HAVE_MPI
+	if (mpi_p > 1)
+		log_event("- MPI mode: %u nodes, this one running on %s", mpi_p, mpi_name);
+#endif
 	log_event("- Hash type: %.100s (lengths up to %d%s)",
 		database.format->params.format_name,
 		database.format->params.plaintext_length,
-		database.format->methods.split != fmt_default_split ?
+		(database.format == &fmt_DES || database.format == &fmt_LM) ?
 		", longer passwords split" : "");
 
 	log_event("- Algorithm: %.100s",
@@ -104,6 +180,8 @@ static void john_log_format(void)
 			"tried in chunks of %d",
 			min_chunk > 1 ? "will" : "may",
 			chunk);
+	if (options.flags & FLG_UTF8 && database.format->params.flags & FMT_UTF8)
+		log_event("- UTF-8 conversion enabled");
 }
 
 static char *john_loaded_counts(void)
@@ -127,7 +205,9 @@ static void john_load(void)
 {
 	struct list_entry *current;
 
+#ifndef _MSC_VER
 	umask(077);
+#endif
 
 	if (options.flags & FLG_EXTERNAL_CHK)
 		ext_init(options.external);
@@ -137,7 +217,7 @@ static void john_load(void)
 		ldr_init_database(&database, &options.loader);
 
 		if (options.flags & FLG_PASSWD) {
-			ldr_show_pot_file(&database, POT_NAME);
+			ldr_show_pot_file(&database, options.loader.activepot);
 
 			database.options->flags |= DB_PLAINTEXTS;
 			if ((current = options.passwd->head))
@@ -146,7 +226,7 @@ static void john_load(void)
 			} while ((current = current->next));
 		} else {
 			database.options->flags |= DB_PLAINTEXTS;
-			ldr_show_pot_file(&database, POT_NAME);
+			ldr_show_pot_file(&database, options.loader.activepot);
 		}
 
 		return;
@@ -167,7 +247,7 @@ static void john_load(void)
 			options.loader.flags |= DB_CRACKED;
 			ldr_init_database(&database, &options.loader);
 
-			ldr_show_pot_file(&database, POT_NAME);
+			ldr_show_pot_file(&database, options.loader.activepot);
 
 			if ((current = options.passwd->head))
 			do {
@@ -188,8 +268,10 @@ static void john_load(void)
 		    status.pass <= 1)
 			options.loader.flags |= DB_WORDS;
 		else
-		if (mem_saving_level)
+		if (mem_saving_level) {
 			options.loader.flags &= ~DB_LOGIN;
+			options.loader.max_wordfile_memory = 0;
+		}
 		ldr_init_database(&database, &options.loader);
 
 		if ((current = options.passwd->head))
@@ -197,6 +279,13 @@ static void john_load(void)
 			ldr_load_pw_file(&database, current->data);
 		} while ((current = current->next));
 
+		if (options.flags & FLG_UTF8 && database.password_count &&
+		    database.format->params.flags & FMT_UNICODE &&
+		    !(database.format->params.flags & FMT_UTF8)) {
+			fprintf(stderr, "This format does not yet support UTF-8 conversion\n");
+			error();
+		}
+
 		if ((options.flags & FLG_CRACKING_CHK) &&
 		    database.password_count) {
 			log_init(LOG_NAME, NULL, options.session);
@@ -212,7 +301,7 @@ static void john_load(void)
 		}
 
 		total = database.password_count;
-		ldr_load_pot_file(&database, POT_NAME);
+		ldr_load_pot_file(&database, options.loader.activepot);
 		ldr_fix_database(&database);
 
 		if (!database.password_count) {
@@ -232,8 +321,14 @@ static void john_load(void)
 static void john_init(char *name, int argc, char **argv)
 {
 	int make_check = (argc == 2 && !strcmp(argv[1], "--make_check"));
-	if (make_check)
+	if (make_check) {
 		argv[1] = "--test=0";
+#if defined (__MINGW32__) || defined (__CYGWIN32__) || defined (_MSC_VER)
+		argv[2] = "--conf=../run/john.conf";
+		argv[3] = NULL;
+		++argc;
+#endif
+	}
 
 #if CPU_DETECT
 	if (!CPU_detect()) {
@@ -256,9 +351,23 @@ static void john_init(char *name, int ar
 	}
 #endif
 
-	if (!make_check) {
+	// This if is busted. If it is there, then make check will NOT work.
+	//if (!make_check) {
 		path_init(argv);
 
+    status_init(NULL, 1);
+
+    if (argc < 2)
+	    john_register_all();    // auto format list in opt_init needs this
+    opt_init(name, argc, argv); // this will then exit if argc < 2
+
+    if (options.flags & FLG_CONFIG_CLI)
+    {
+      cfg_init(options.config, 1);
+      cfg_init(CFG_ALT_NAME, 0);
+    }
+    else
+    {
 #if JOHN_SYSTEMWIDE
 		cfg_init(CFG_PRIVATE_FULL_NAME, 1);
 		cfg_init(CFG_PRIVATE_ALT_NAME, 1);
@@ -266,9 +375,7 @@ static void john_init(char *name, int ar
 		cfg_init(CFG_FULL_NAME, 1);
 		cfg_init(CFG_ALT_NAME, 0);
 	}
-
-	status_init(NULL, 1);
-	opt_init(name, argc, argv);
+	//}
 
 	john_register_all();
 	common_init();
@@ -291,7 +398,7 @@ static void john_run(void)
 
 		if (!(options.flags & FLG_STDOUT)) {
 			status_init(NULL, 1);
-			log_init(LOG_NAME, POT_NAME, options.session);
+			log_init(LOG_NAME, options.loader.activepot, options.session);
 			john_log_format();
 			if (idle_requested(database.format))
 				log_event("- Configured to use otherwise idle "
@@ -299,6 +406,20 @@ static void john_run(void)
 		}
 		tty_init(options.flags & FLG_STDIN_CHK);
 
+#if defined(HAVE_MPI) && defined(_OPENMP)
+		if (database.format->params.flags & FMT_OMP &&
+		    omp_get_max_threads() > 1 && mpi_p > 1) {
+			if(cfg_get_bool(SECTION_OPTIONS, NULL, "MPIOMPmutex", 1)) {
+				if(cfg_get_bool(SECTION_OPTIONS, NULL, "MPIOMPverbose", 1) &&
+				   mpi_id == 0)
+					fprintf(stderr, "MPI in use, disabling OMP (see doc/README.mpi)\n");
+				omp_set_num_threads(1);
+			} else
+				if(cfg_get_bool(SECTION_OPTIONS, NULL, "MPIOMPverbose", 1) &&
+				   mpi_id == 0)
+					fprintf(stderr, "Note: Running both MPI and OMP (see doc/README.mpi)\n");
+		}
+#endif
 		if (options.flags & FLG_SINGLE_CHK)
 			do_single_crack(&database);
 		else
@@ -309,6 +430,9 @@ static void john_run(void)
 		if (options.flags & FLG_INC_CHK)
 			do_incremental_crack(&database, options.charset);
 		else
+		if (options.flags & FLG_MKV_CHK)
+			do_markov_crack(&database, options.mkv_level, options.mkv_start, options.mkv_end, options.mkv_maxlen, options.mkv_minlevel, options.mkv_minlen);
+		else
 		if (options.flags & FLG_EXTERNAL_CHK)
 			do_external_crack(&database);
 		else
@@ -325,15 +449,27 @@ static void john_run(void)
 			switch (database.options->flags &
 			    (DB_SPLIT | DB_NODUP)) {
 			case DB_SPLIT:
+#ifdef HAVE_MPI
+				if (mpi_id == 0)
+#endif
 				fprintf(stderr, "%s%s\n", might, partial);
 				break;
 			case DB_NODUP:
+#ifdef HAVE_MPI
+				if (mpi_id == 0)
+#endif
 				fprintf(stderr, "%s%s\n", might, not_all);
 				break;
 			case (DB_SPLIT | DB_NODUP):
+#ifdef HAVE_MPI
+				if (mpi_id == 0)
+#endif
 				fprintf(stderr, "%s%s and%s\n",
 				    might, partial, not_all);
 			}
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
 			fputs("Use the \"--show\" option to display all of "
 			    "the cracked passwords reliably\n", stderr);
 		}
@@ -353,12 +489,23 @@ static void john_done(void)
 	}
 	log_done();
 	check_abort(0);
+	cleanup_tiny_memory();
 }
 
 int main(int argc, char **argv)
 {
 	char *name;
 
+#ifdef _MSC_VER
+   // Send all reports to STDOUT
+   _CrtSetReportMode( _CRT_WARN, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_WARN, _CRTDBG_FILE_STDOUT );
+   _CrtSetReportMode( _CRT_ERROR, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_ERROR, _CRTDBG_FILE_STDOUT );
+   _CrtSetReportMode( _CRT_ASSERT, _CRTDBG_MODE_FILE );
+   _CrtSetReportFile( _CRT_ASSERT, _CRTDBG_FILE_STDOUT );
+#endif
+
 #ifdef __DJGPP__
 	if (--argc <= 0) return 1;
 	if ((name = strrchr(argv[0], '/')))
@@ -372,28 +519,55 @@ int main(int argc, char **argv)
 	else
 	if ((name = strrchr(argv[0], '/')))
 		name++;
+#if defined(__CYGWIN32__) || defined (__MINGW32__) || defined (_MSC_VER)
+	else
+	if ((name = strrchr(argv[0], '\\')))
+		name++;
+#endif
 	else
 		name = argv[0];
 #endif
 
-#ifdef __CYGWIN32__
+#if defined(__CYGWIN32__) || defined (__MINGW32__) || defined (_MSC_VER)
 	strlwr(name);
 	if (strlen(name) > 4 && !strcmp(name + strlen(name) - 4, ".exe"))
 		name[strlen(name) - 4] = 0;
 #endif
 
+	if (!strcmp(name, "unique"))
+		return unique(argc, argv);
+
 	if (!strcmp(name, "unshadow"))
 		return unshadow(argc, argv);
 
 	if (!strcmp(name, "unafs"))
 		return unafs(argc, argv);
 
-	if (!strcmp(name, "unique"))
-		return unique(argc, argv);
+	if (!strcmp(name, "undrop"))
+               return undrop(argc, argv);
 
+ 	if (!strcmp(name, "ssh2john"))
+		return ssh2john(argc, argv);
+
+ 	if (!strcmp(name, "pdf2john"))
+		return pdf2john(argc, argv);
+
+	if (!strcmp(name, "rar2john"))
+		return rar2john(argc, argv);
+
+	if (!strcmp(name, "zip2john"))
+		return zip2john(argc, argv);
+
+#ifdef HAVE_MPI
+	mpi_setup(argc, argv);
+#endif
 	john_init(name, argc, argv);
 	john_run();
 	john_done();
 
+#ifdef _MSC_VER
+	_CrtDumpMemoryLeaks();
+#endif
+
 	return exit_status;
 }
diff -rupN john-1.7.8/src/loader.c john-1.7.8-jumbo-2/src/loader.c
--- john-1.7.8/src/loader.c	2011-06-04 18:51:28.000000000 +0200
+++ john-1.7.8-jumbo-2/src/loader.c	2011-07-02 21:11:54.000000000 +0200
@@ -1,11 +1,17 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2000,2003,2005,2010,2011 by Solar Designer
+ *
+ * ...with heavy changes in the jumbo patch, by various authors
  */
 
 #include <stdio.h>
 #include <sys/stat.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#else
+#define S_ISDIR(a) ((a) & _S_IFDIR)
+#endif
 #include <errno.h>
 #include <string.h>
 
@@ -18,6 +24,10 @@
 #include "signals.h"
 #include "formats.h"
 #include "loader.h"
+#include "options.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
 
 #ifdef HAVE_CRYPT
 extern struct fmt_main fmt_crypt;
@@ -155,13 +165,13 @@ static void ldr_init_password_hash(struc
 	memset(db->password_hash, 0, size);
 }
 
-static char *ldr_get_field(char **ptr)
+static char *ldr_get_field(char **ptr, char field_sep_char)
 {
 	char *res, *pos;
 
 	if (!*ptr) return "";
 
-	if ((pos = strchr(res = *ptr, ':'))) {
+	if ((pos = strchr(res = *ptr, field_sep_char))) {
 		*pos++ = 0; *ptr = pos;
 	} else {
 		pos = res;
@@ -210,32 +220,41 @@ static int ldr_check_shells(struct list_
 	return 0;
 }
 
+static char *trimwhite(char *Str) {
+	char *p = &Str[strlen(Str)-1];
+	while ( p > Str && (*p == ' ' || *p == '\t')) {
+		*p = 0;
+		--p;
+	}
+	while (*Str == ' ' || *Str == '\t')
+		++Str;
+	return Str;
+}
+
 static int ldr_split_line(char **login, char **ciphertext,
 	char **gecos, char **home,
 	char *source, struct fmt_main **format,
-	struct db_options *options, char *line)
+	struct db_options *db_options, char *line)
 {
 	struct fmt_main *alt;
 	char *uid = NULL, *gid = NULL, *shell = NULL;
-	int retval;
+	char *split_fields[10];
+	int i, retval, valid;
 
-	*login = ldr_get_field(&line);
-	*ciphertext = ldr_get_field(&line);
-
-/* Check for NIS stuff */
-	if ((!strcmp(*login, "+") || !strncmp(*login, "+@", 2)) &&
-	    strlen(*ciphertext) < 13 && strncmp(*ciphertext, "$dummy$", 7))
-		return 0;
+	// Note, only 7 are 'defined' in the passwd format.  We load 10, so that
+	// other formats can add specific extra stuff.
+	for (i = 0; i < 10; ++i) {
+		split_fields[i] = ldr_get_field(&line, db_options->field_sep_char);
+		if (!line && i == 1 && split_fields[1][0] == 0) {
+			/* allow a file of 'raw' hashes to work properly */
+			if (strlen(split_fields[0]) < 13 && strncmp(split_fields[0], "$dummy$", 7))
+				return 0;
+			split_fields[1] = trimwhite(split_fields[0]);
+			split_fields[0] = no_username;
 
-	if (!**ciphertext && !line) {
-/* Possible hash on a line on its own (no colons) */
-		char *p = *login;
-/* Skip leading and trailing whitespace */
-		while (*p == ' ' || *p == '\t') p++;
-		*ciphertext = p;
-		p += strlen(p) - 1;
-		while (p > *ciphertext && (*p == ' ' || *p == '\t')) p--;
-		p++;
+// this code was from orignal block.  Not sure exactly what is wanted, so I will
+// leave this hear, but commented out.
+#if 0
 /* Some valid dummy hashes may be shorter than 13 characters, so don't subject
  * them to the length checks. */
 		if (strncmp(*ciphertext, "$dummy$", 7)) {
@@ -249,44 +268,34 @@ static int ldr_split_line(char **login,
 			if (p - *ciphertext < 13)
 				return 0;
 		}
-		*p = 0;
-		*login = no_username;
+#endif
+		}
+		if (i == 1 && source)
+			strcpy(source, line ? line : "");
 	}
 
-	if (source) strcpy(source, line ? line : "");
-
-	uid = ldr_get_field(&line);
-
-	if (strlen(uid) == 32) {
-		char *tmp = *ciphertext;
-		*ciphertext = uid;
-		uid = tmp;
+	*login = split_fields[0];
+	*ciphertext = split_fields[1];
 
-		if (!strncmp(*ciphertext, "NO PASSWORD", 11))
-			*ciphertext = "";
-
-		if (source) sprintf(source, "%s:%s", uid, line);
-	}
+/* Check for NIS stuff */
+	if ((!strcmp(*login, "+") || !strncmp(*login, "+@", 2)) &&
+	    strlen(*ciphertext) < 13 && strncmp(*ciphertext, "$dummy$", 7))
+		return 0;
 
-	if ((options->flags & DB_WORDS) || options->shells->head) {
-		gid = ldr_get_field(&line);
-		do {
-			*gecos = ldr_get_field(&line);
-			*home = ldr_get_field(&line);
-			shell = ldr_get_field(&line);
-		} while (!**gecos &&
-			!strcmp(*home, "0") && !strcmp(shell, "0"));
-	} else
-	if (options->groups->head) {
-		gid = ldr_get_field(&line);
-	}
+	uid = split_fields[2];
+	gid = split_fields[3];
 
-	if (ldr_check_list(options->users, *login, uid)) return 0;
-	if (ldr_check_list(options->groups, gid, gid)) return 0;
-	if (ldr_check_shells(options->shells, shell)) return 0;
+	*gecos = split_fields[4];
+	*home = split_fields[5];
+	shell = split_fields[6];
+
+	if (ldr_check_list(db_options->users, *login, uid)) return 0;
+	if (ldr_check_list(db_options->groups, gid, gid)) return 0;
+	if (ldr_check_shells(db_options->shells, shell)) return 0;
 
 	if (*format) {
-		int valid = (*format)->methods.valid(*ciphertext);
+		*ciphertext = (*format)->methods.prepare(split_fields, *format);
+		valid = (*format)->methods.valid(*ciphertext, *format);
 		if (!valid) {
 			alt = fmt_list;
 			do {
@@ -304,8 +313,11 @@ static int ldr_split_line(char **login,
 				    strncmp(*ciphertext, "$6$", 3))
 					continue;
 #endif
-				if (alt->methods.valid(*ciphertext)) {
+				if (alt->methods.valid(*ciphertext,alt)) {
 					alt->params.flags |= FMT_WARNED;
+#ifdef HAVE_MPI
+					if (mpi_id == 0)
+#endif
 					fprintf(stderr,
 					    "Warning: only loading hashes "
 					    "of type \"%s\", but also saw "
@@ -328,6 +340,9 @@ static int ldr_split_line(char **login,
 	if ((alt = fmt_list))
 	do {
 		int valid;
+		char *prepared_CT = alt->methods.prepare(split_fields, alt);
+		if (!prepared_CT || !*prepared_CT)
+			continue;
 #ifdef HAVE_CRYPT
 /*
  * Only probe for support by the current system's crypt(3) if this is forced
@@ -338,18 +353,19 @@ static int ldr_split_line(char **login,
 		if (alt == &fmt_crypt &&
 		    fmt_list != &fmt_crypt /* not forced */ &&
 #ifdef __sun
-		    strncmp(*ciphertext, "$md5$", 5) &&
-		    strncmp(*ciphertext, "$md5,", 5) &&
+		    strncmp(prepared_CT, "$md5$", 5) &&
+		    strncmp(prepared_CT, "$md5,", 5) &&
 #endif
-		    strncmp(*ciphertext, "$5$", 3) &&
-		    strncmp(*ciphertext, "$6$", 3))
+		    strncmp(prepared_CT, "$5$", 3) &&
+		    strncmp(prepared_CT, "$6$", 3))
 			continue;
 #endif
-		if (!(valid = alt->methods.valid(*ciphertext)))
+		if (!(valid = alt->methods.valid(prepared_CT, alt)))
 			continue;
 		if (retval < 0) {
 			fmt_init(*format = alt);
 			retval = valid;
+			*ciphertext = prepared_CT;
 #ifdef LDR_WARN_AMBIGUOUS
 			if (!source) /* not --show */
 				continue;
@@ -357,6 +373,9 @@ static int ldr_split_line(char **login,
 			break;
 		}
 #ifdef LDR_WARN_AMBIGUOUS
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr,
 		    "Warning: detected hash type \"%s\", but the string is "
 		    "also recognized as \"%s\"\n"
@@ -467,6 +486,9 @@ static void ldr_load_pw_line(struct db_m
 				}
 				if (++collisions <= LDR_HASH_COLLISIONS_MAX)
 					continue;
+#ifdef HAVE_MPI
+				if (mpi_id == 0) {
+#endif
 				if (format->params.binary_size)
 					fprintf(stderr, "Warning: "
 					    "excessive partial hash "
@@ -480,6 +502,9 @@ static void ldr_load_pw_line(struct db_m
 					fprintf(stderr, "Warning: "
 					    "check for duplicates partially "
 					    "bypassed to speedup loading\n");
+#ifdef HAVE_MPI
+				}
+#endif
 				skip_dupe_checking = 1;
 				current_pw = NULL; /* no match */
 				break;
@@ -575,8 +600,8 @@ static void ldr_load_pot_line(struct db_
 	int hash;
 	struct db_password *current;
 
-	ciphertext = ldr_get_field(&line);
-	if (format->methods.valid(ciphertext) != 1) return;
+	ciphertext = ldr_get_field(&line, db->options->field_sep_char);
+	if (format->methods.valid(ciphertext,format) != 1) return;
 
 	ciphertext = format->methods.split(ciphertext, 0);
 	binary = format->methods.binary(ciphertext);
@@ -643,8 +668,11 @@ static void ldr_remove_marked(struct db_
 					last_pw->next = current_pw->next;
 				else
 					current_salt->list = current_pw->next;
-			} else
+			} else {
 				last_pw = current_pw;
+				if (db->options->showuncracked)
+					printf("%s%c%s\n",current_pw->login,db->options->field_sep_char,current_pw->source);
+			}
 		} while ((current_pw = current_pw->next));
 
 		if (!current_salt->list) {
@@ -787,6 +815,9 @@ void ldr_fix_database(struct db_main *db
 	ldr_init_hash(db);
 
 	db->loaded = 1;
+
+	if (db->options->showuncracked)
+		exit(0);
 }
 
 /*
@@ -872,12 +903,12 @@ static void ldr_show_pot_line(struct db_
 	int hash;
 	struct db_cracked *current, *last;
 
-	ciphertext = ldr_get_field(&line);
+	ciphertext = ldr_get_field(&line, db->options->field_sep_char);
 
 	if (line) {
 /* If just one format was forced on the command line, insist on it */
 		if (!fmt_list->next &&
-		    !fmt_list->methods.valid(ciphertext))
+		    !fmt_list->methods.valid(ciphertext,fmt_list))
 			return;
 
 		pos = line;
@@ -942,7 +973,7 @@ static void ldr_show_pw_line(struct db_m
 
 	if (!*ciphertext) {
 		found = 1;
-		if (show) printf("%s:NO PASSWORD", login);
+		if (show) printf("%s%cNO PASSWORD", login, db->options->field_sep_char);
 
 		db->guess_count++;
 	} else
@@ -963,7 +994,7 @@ static void ldr_show_pw_line(struct db_m
  * versions of John and contributed patches where split() didn't unify the
  * case of hex-encoded hashes. */
 			if (unify &&
-			    format->methods.valid(current->ciphertext) == 1 &&
+			    format->methods.valid(current->ciphertext,format) == 1 &&
 			    !strcmp(split(current->ciphertext, 0), piece))
 				break;
 		} while ((current = current->next));
@@ -995,14 +1026,14 @@ static void ldr_show_pw_line(struct db_m
 		} else
 		if (current) {
 			found = 1;
-			if (show) printf("%s:", login);
+			if (show) printf("%s%c", login, db->options->field_sep_char);
 			break;
 		}
 	}
 
 	if (found && show) {
 		if (source[0])
-			printf(":%s", source);
+			printf("%c%s", db->options->field_sep_char, source);
 		else
 			putchar('\n');
 	}
diff -rupN john-1.7.8/src/loader.h john-1.7.8-jumbo-2/src/loader.h
--- john-1.7.8/src/loader.h	2011-02-26 11:31:44.000000000 +0100
+++ john-1.7.8-jumbo-2/src/loader.h	2011-05-17 18:13:02.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-98,2010,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by various authors
  */
 
 /*
@@ -159,6 +161,28 @@ struct db_options {
 
 /* Requested passwords per salt */
 	int min_pps, max_pps;
+
+/* Maximum size of a wordlist file to be 'preloaded' into memory  */
+	unsigned max_wordfile_memory;
+
+/* number of times fix_state_delay is called in wordfile.c before  any fseek() is done. */
+	unsigned max_fix_state_delay;
+
+/* the wordlist rules section (default if none entered is Wordlist) */
+	char *activewordlistrules;
+
+/* the 'single' rules section (default if none entered is Single) */
+	char *activesinglerules;
+
+/* the pot file used (default if none entered is $JOHN/john.pot or JOHN_PRIVATE_HOME/john.pot
+   depending upon compile defines) */
+	char *activepot;
+
+/* if --show=left is used, this is set, and john dumps the non-cracked hashes and exits */
+	int showuncracked;
+
+/* by default will be ':', but -field-separator-char=c can over ride the default */
+	char field_sep_char;
 };
 
 /*
diff -rupN john-1.7.8/src/logger.c john-1.7.8-jumbo-2/src/logger.c
--- john-1.7.8/src/logger.c	2011-03-20 15:56:16.000000000 +0100
+++ john-1.7.8-jumbo-2/src/logger.c	2011-06-08 01:43:11.000000000 +0200
@@ -1,14 +1,29 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003,2004,2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC and
+ * introducing field_sep, by JimF.
+ *
+ * ...and with even more changes in the jumbo patch for MPI support, by magnum.
  */
 
 #define _XOPEN_SOURCE /* for fileno(3) and fsync(2) */
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#include <sys/file.h>
+#else
+#include <io.h>
+#pragma warning ( disable : 4996 )
+#define S_IRUSR _S_IREAD
+#define S_IWUSR _S_IWRITE
+#endif
 #include <sys/types.h>
 #include <sys/stat.h>
+#ifndef _MSC_VER
 #include <sys/file.h>
+#endif
 #include <fcntl.h>
 #include <errno.h>
 #include <stdarg.h>
@@ -21,6 +36,10 @@
 #include "memory.h"
 #include "status.h"
 #include "config.h"
+#include "options.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
 
 static int cfg_beep;
 
@@ -37,6 +56,11 @@ struct log_file {
 	int fd;
 };
 
+#ifdef _MSC_VER
+// In release mode, the log() function gets in the way of our log struct object
+#define log local_log_struct
+#endif
+
 static struct log_file log = {NULL, NULL, NULL, 0, -1};
 static struct log_file pot = {NULL, NULL, NULL, 0, -1};
 
@@ -44,6 +68,7 @@ static int in_logger = 0;
 
 static void log_file_init(struct log_file *f, char *name, int size)
 {
+	if (f == &log && (options.flags & FLG_NOLOG)) return;
 	f->name = name;
 
 	if (chmod(path_expand(name), S_IRUSR | S_IWUSR))
@@ -79,6 +104,7 @@ static void log_file_flush(struct log_fi
 
 static int log_file_write(struct log_file *f)
 {
+	if (f->fd < 0) return 0;
 	if (f->ptr - f->buffer > f->size) {
 		log_file_flush(f);
 		return 1;
@@ -92,7 +118,7 @@ static void log_file_fsync(struct log_fi
 	if (f->fd < 0) return;
 
 	log_file_flush(f);
-#ifndef __CYGWIN32__
+#if !defined(__CYGWIN32__) && !defined(__MINGW32__) && !defined(_MSC_VER)
 	if (fsync(f->fd)) pexit("fsync");
 #endif
 }
@@ -114,6 +140,13 @@ static int log_time(void)
 
 	time = pot.fd >= 0 ? status_get_time() : status_restored_time;
 
+#ifdef HAVE_MPI
+	if (mpi_p > 1)
+		return (int)sprintf(log.ptr, "%u %u:%02u:%02u:%02u ", mpi_id,
+		    time / 86400, time % 86400 / 3600,
+		    time % 3600 / 60, time % 60);
+	else
+#endif
 	return (int)sprintf(log.ptr, "%u:%02u:%02u:%02u ",
 		time / 86400, time % 86400 / 3600,
 		time % 3600 / 60, time % 60);
@@ -139,10 +172,16 @@ void log_init(char *log_name, char *pot_
 	in_logger = 0;
 }
 
-void log_guess(char *login, char *ciphertext, char *plaintext)
+void log_guess(char *login, char *ciphertext, char *plaintext, char field_sep)
 {
 	int count1, count2;
 
+#ifdef HAVE_MPI
+	// All but node 0 has stdout closed
+	if (mpi_p > 1)
+		fprintf(stderr, "%-16s (%s)\n", plaintext, login);
+	else
+#endif
 	printf("%-16s (%s)\n", plaintext, login);
 
 	in_logger = 1;
@@ -150,7 +189,7 @@ void log_guess(char *login, char *cipher
 	if (pot.fd >= 0 && ciphertext &&
 	    strlen(ciphertext) + strlen(plaintext) <= LINE_BUFFER_SIZE - 3) {
 		count1 = (int)sprintf(pot.ptr,
-			"%s:%s\n", ciphertext, plaintext);
+			"%s%c%s\n", ciphertext, field_sep, plaintext);
 		if (count1 > 0) pot.ptr += count1;
 	}
 
@@ -219,6 +258,7 @@ void log_event(char *format, ...)
 
 void log_discard(void)
 {
+	if ((options.flags & FLG_NOLOG)) return;
 	log.ptr = log.buffer;
 }
 
diff -rupN john-1.7.8/src/logger.h john-1.7.8-jumbo-2/src/logger.h
--- john-1.7.8/src/logger.h	2003-09-06 22:30:26.000000000 +0200
+++ john-1.7.8-jumbo-2/src/logger.h	2011-05-17 18:13:02.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003 by Solar Designer
+ *
+ * ...with field_sep introduced in the jumbo patch, by JimF.
  */
 
 /*
@@ -19,7 +21,7 @@ extern void log_init(char *log_name, cha
  * Prints a guessed password to stdout and logs it to john.pot (unless
  * ciphertext is NULL) and other related information to the log file.
  */
-extern void log_guess(char *login, char *ciphertext, char *plaintext);
+extern void log_guess(char *login, char *ciphertext, char *plaintext, char field_sep);
 
 /*
  * Logs an arbitrary event.
diff -rupN john-1.7.8/src/lotus5_fmt_plug.c john-1.7.8-jumbo-2/src/lotus5_fmt_plug.c
--- john-1.7.8/src/lotus5_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/lotus5_fmt_plug.c	2011-07-02 22:46:01.000000000 +0200
@@ -0,0 +1,248 @@
+//original work by Jeff Fay
+//some optimisations by bartavelle at bandecon.com
+
+#include <stdio.h>
+#include <string.h>
+#include "misc.h"
+#include "formats.h"
+#include "common.h"
+
+/*preprocessor constants that John The Ripper likes*/
+#define FORMAT_LABEL                   "lotus5"
+#define FORMAT_NAME                    "Lotus5"
+#define ALGORITHM_NAME			"Lotus v5 Proprietary"
+#define BENCHMARK_COMMENT              ""
+#define BENCHMARK_LENGTH               -1
+#define PLAINTEXT_LENGTH               16
+#define CIPHERTEXT_LENGTH              32
+#define BINARY_SIZE                    16
+#define SALT_SIZE                      0
+#define MIN_KEYS_PER_CRYPT             1
+#define MAX_KEYS_PER_CRYPT             1
+
+/*A struct used for JTR's benchmarks*/
+static struct fmt_tests tests[] = {
+  {"06E0A50B579AD2CD5FFDC48564627EE7", "secret"},
+  {"355E98E7C7B59BD810ED845AD0FD2FC4", "password"},
+  {"CD2D90E8E00D8A2A63A81F531EA8A9A3", "lotus"},
+  {"69D90B46B1AC0912E5CCF858094BBBFC", "dirtydog"},
+  {NULL}
+};
+
+static const unsigned char lotus_magic_table[256] = {
+  0xbd, 0x56, 0xea, 0xf2, 0xa2, 0xf1, 0xac, 0x2a,
+  0xb0, 0x93, 0xd1, 0x9c, 0x1b, 0x33, 0xfd, 0xd0,
+  0x30, 0x04, 0xb6, 0xdc, 0x7d, 0xdf, 0x32, 0x4b,
+  0xf7, 0xcb, 0x45, 0x9b, 0x31, 0xbb, 0x21, 0x5a,
+  0x41, 0x9f, 0xe1, 0xd9, 0x4a, 0x4d, 0x9e, 0xda,
+  0xa0, 0x68, 0x2c, 0xc3, 0x27, 0x5f, 0x80, 0x36,
+  0x3e, 0xee, 0xfb, 0x95, 0x1a, 0xfe, 0xce, 0xa8,
+  0x34, 0xa9, 0x13, 0xf0, 0xa6, 0x3f, 0xd8, 0x0c,
+  0x78, 0x24, 0xaf, 0x23, 0x52, 0xc1, 0x67, 0x17,
+  0xf5, 0x66, 0x90, 0xe7, 0xe8, 0x07, 0xb8, 0x60,
+  0x48, 0xe6, 0x1e, 0x53, 0xf3, 0x92, 0xa4, 0x72,
+  0x8c, 0x08, 0x15, 0x6e, 0x86, 0x00, 0x84, 0xfa,
+  0xf4, 0x7f, 0x8a, 0x42, 0x19, 0xf6, 0xdb, 0xcd,
+  0x14, 0x8d, 0x50, 0x12, 0xba, 0x3c, 0x06, 0x4e,
+  0xec, 0xb3, 0x35, 0x11, 0xa1, 0x88, 0x8e, 0x2b,
+  0x94, 0x99, 0xb7, 0x71, 0x74, 0xd3, 0xe4, 0xbf,
+  0x3a, 0xde, 0x96, 0x0e, 0xbc, 0x0a, 0xed, 0x77,
+  0xfc, 0x37, 0x6b, 0x03, 0x79, 0x89, 0x62, 0xc6,
+  0xd7, 0xc0, 0xd2, 0x7c, 0x6a, 0x8b, 0x22, 0xa3,
+  0x5b, 0x05, 0x5d, 0x02, 0x75, 0xd5, 0x61, 0xe3,
+  0x18, 0x8f, 0x55, 0x51, 0xad, 0x1f, 0x0b, 0x5e,
+  0x85, 0xe5, 0xc2, 0x57, 0x63, 0xca, 0x3d, 0x6c,
+  0xb4, 0xc5, 0xcc, 0x70, 0xb2, 0x91, 0x59, 0x0d,
+  0x47, 0x20, 0xc8, 0x4f, 0x58, 0xe0, 0x01, 0xe2,
+  0x16, 0x38, 0xc4, 0x6f, 0x3b, 0x0f, 0x65, 0x46,
+  0xbe, 0x7e, 0x2d, 0x7b, 0x82, 0xf9, 0x40, 0xb5,
+  0x1d, 0x73, 0xf8, 0xeb, 0x26, 0xc7, 0x87, 0x97,
+  0x25, 0x54, 0xb1, 0x28, 0xaa, 0x98, 0x9d, 0xa5,
+  0x64, 0x6d, 0x7a, 0xd4, 0x10, 0x81, 0x44, 0xef,
+  0x49, 0xd6, 0xae, 0x2e, 0xdd, 0x76, 0x5c, 0x2f,
+  0xa7, 0x1c, 0xc9, 0x09, 0x69, 0x9a, 0x83, 0xcf,
+  0x29, 0x39, 0xb9, 0xe9, 0x4c, 0xff, 0x43, 0xab,
+};
+
+/*Some more JTR variables*/
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static char saved_key[PLAINTEXT_LENGTH + 1];
+
+/*Utility function to convert hex to bin */
+static void * binary (char *ciphertext)
+{
+  static char realcipher[BINARY_SIZE];
+  int i;
+  for (i = 0; i < BINARY_SIZE; i++)
+      realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2])]*16 + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+  return ((void *) realcipher);
+}
+
+/*Another function required by JTR: decides whether we have a valid
+ * ciphertext */
+static int
+valid (char *ciphertext, struct fmt_main *pFmt)
+{
+  int i;
+
+  for (i = 0; i < CIPHERTEXT_LENGTH; i++)
+	  if (!(((ciphertext[i] >= '0') && (ciphertext[i] <= '9'))
+				  || ((ciphertext[i] >= 'a') && (ciphertext[i] <= 'f'))
+				  || ((ciphertext[i] >= 'A') && (ciphertext[i] <= 'F'))))
+	  {
+		  return 0;
+	  }
+  return !ciphertext[i];
+}
+
+/*sets the value of saved_key so we can play with it*/
+static void set_key (char *key, int index)
+{
+  strnzcpy (saved_key, key, PLAINTEXT_LENGTH + 1);
+}
+
+/*retrieves the saved key; used by JTR*/
+static char * get_key (int index)
+{
+	return saved_key;
+}
+
+static int cmp_all (void *binary, int index)
+{
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+}
+
+static int cmp_exact (char *source, int index)
+{
+	return 1;
+}
+
+
+/*Beginning of private functions*/
+/* Takes the plaintext password and generates the second row of our
+ * working matrix for the final call to the mixing function*/
+void
+lotus_transform_password (unsigned char *inpass, unsigned char *outh)
+{
+  unsigned char prevbyte;
+  int i;
+
+  prevbyte = 0x00;
+  for (i = 0; i < 16; i++)
+    {
+      *outh = lotus_magic_table[ARCH_INDEX((*inpass) ^ prevbyte)];
+      prevbyte = *outh;
+      ++outh;
+      ++inpass;
+    }
+}
+
+/* The mixing function: perturbs the first three rows of the matrix*/
+void lotus_mix (unsigned char *lotus_matrix)
+{
+  int i, j;
+  unsigned char prevbyte;
+  unsigned char *temp;
+
+  prevbyte = 0x00;
+
+  for (i = 18; i > 0; i--)
+    {
+      temp = lotus_matrix;
+      for (j = 48; j > 0; j--)
+	{
+	  *temp = *temp ^ lotus_magic_table[ARCH_INDEX((j + prevbyte) & 0xff)];
+	  prevbyte = *temp;
+	  temp++;
+	}
+    }
+}
+
+
+/*the last public function; generates ciphertext*/
+static void crypt_all (int count)
+{
+  unsigned char password[PLAINTEXT_LENGTH];
+  unsigned char lotus_matrix[64], *lotus_matrix1, *lotus_matrix2, *lotus_matrix3, *lotus_matrix4;
+  int i;
+  int password_length;
+
+  password_length = strlen (saved_key);
+  memset (password, (PLAINTEXT_LENGTH - password_length), PLAINTEXT_LENGTH);
+  lotus_matrix1 = lotus_matrix;
+  lotus_matrix2 = lotus_matrix1 + 16;
+  lotus_matrix3 = lotus_matrix2 + 16;
+  lotus_matrix4 = lotus_matrix3 + 16;
+  memcpy (password, saved_key, password_length);
+
+  memset (lotus_matrix1, 0, 16);
+  memcpy (lotus_matrix2, password, 16);
+  memcpy (lotus_matrix3, password, 16);
+  lotus_transform_password (lotus_matrix2, lotus_matrix4);
+  lotus_mix (lotus_matrix);
+  memcpy (lotus_matrix2, lotus_matrix4, 16);
+  for (i = 0; i < 16; i++)
+    {
+      lotus_matrix3[i] = lotus_matrix1[i] ^ lotus_matrix2[i];
+    }
+  lotus_mix (lotus_matrix);
+  memcpy (crypt_key, lotus_matrix1, BINARY_SIZE);
+}
+
+static int get_hash1(int index) { return crypt_key[0] & 0xf; }
+static int get_hash2(int index) { return crypt_key[0] & 0xff; }
+static int get_hash3(int index) { return crypt_key[0] & 0xfff; }
+static int get_hash4(int index) { return crypt_key[0] & 0xffff; }
+static int get_hash5(int index) { return crypt_key[0] & 0xfffff; }
+static int binary_hash1(void * binary) { return *(ARCH_WORD_32 *)binary & 0xf; }
+static int binary_hash2(void * binary) { return *(ARCH_WORD_32 *)binary & 0xff; }
+static int binary_hash3(void * binary) { return *(ARCH_WORD_32 *)binary & 0xfff; }
+static int binary_hash4(void * binary) { return *(ARCH_WORD_32 *)binary & 0xffff; }
+static int binary_hash5(void * binary) { return *(ARCH_WORD_32 *)binary & 0xfffff; }
+
+/* C's version of a class specifier */
+struct fmt_main fmt_lotus5 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		binary,
+		fmt_default_salt,
+		{
+			binary_hash1,
+			binary_hash2,
+			binary_hash3,
+			binary_hash4,
+			binary_hash5
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash1,
+			get_hash2,
+			get_hash3,
+			get_hash4,
+			get_hash5
+		},
+		cmp_all,
+		cmp_all,
+		cmp_exact}
+};
diff -rupN john-1.7.8/src/md4.c john-1.7.8-jumbo-2/src/md4.c
--- john-1.7.8/src/md4.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md4.c	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,262 @@
+/*
+ * This is an OpenSSL-compatible implementation of the RSA Data Security,
+ * Inc. MD4 Message-Digest Algorithm (RFC 1320).
+ *
+ * Written by Solar Designer <solar at openwall.com> in 2001, and placed
+ * in the public domain.  There's absolutely no warranty.
+ *
+ * This differs from Colin Plumb's older public domain implementation in
+ * that no 32-bit integer data type is required, there's no compile-time
+ * endianness configuration, and the function prototypes match OpenSSL's.
+ * The primary goals are portability and ease of use.
+ *
+ * This implementation is meant to be fast, but not as fast as possible.
+ * Some known optimizations are not included to reduce source code size
+ * and avoid compile-time configuration.
+ *
+ * ... MD4_Final() has been modified in revision of this code found in the
+ * JtR jumbo patch, dropping the memset() call.  You will likely want to undo
+ * this change if you reuse the code for another purpose.  Or better yet,
+ * download the original from:
+ * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md4
+ */
+
+#ifndef HAVE_OPENSSL
+
+#include <string.h>
+
+#include "md4.h"
+
+/*
+ * The basic MD4 functions.
+ *
+ * F and G are optimized compared to their RFC 1320 definitions, with the
+ * optimization for F borrowed from Colin Plumb's MD5 implementation.
+ */
+#define F(x, y, z)			((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z)			(((x) & ((y) | (z))) | ((y) & (z)))
+#define H(x, y, z)			((x) ^ (y) ^ (z))
+
+/*
+ * The MD4 transformation for all three rounds.
+ */
+#define STEP(f, a, b, c, d, x, s) \
+	(a) += f((b), (c), (d)) + (x); \
+	(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s))));
+
+/*
+ * SET reads 4 input bytes in little-endian byte order and stores them
+ * in a properly aligned word in host byte order.
+ *
+ * The check for little-endian architectures that tolerate unaligned
+ * memory accesses is just an optimization.  Nothing will break if it
+ * doesn't work.
+ */
+#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)
+#define SET(n) \
+	(*(MD4_u32plus *)&ptr[(n) * 4])
+#define GET(n) \
+	SET(n)
+#else
+#define SET(n) \
+	(ctx->block[(n)] = \
+	(MD4_u32plus)ptr[(n) * 4] | \
+	((MD4_u32plus)ptr[(n) * 4 + 1] << 8) | \
+	((MD4_u32plus)ptr[(n) * 4 + 2] << 16) | \
+	((MD4_u32plus)ptr[(n) * 4 + 3] << 24))
+#define GET(n) \
+	(ctx->block[(n)])
+#endif
+
+/*
+ * This processes one or more 64-byte data blocks, but does NOT update
+ * the bit counters.  There are no alignment requirements.
+ */
+static void *body(MD4_CTX *ctx, void *data, unsigned long size)
+{
+	unsigned char *ptr;
+	MD4_u32plus a, b, c, d;
+	MD4_u32plus saved_a, saved_b, saved_c, saved_d;
+
+	ptr = data;
+
+	a = ctx->a;
+	b = ctx->b;
+	c = ctx->c;
+	d = ctx->d;
+
+	do {
+		saved_a = a;
+		saved_b = b;
+		saved_c = c;
+		saved_d = d;
+
+/* Round 1 */
+		STEP(F, a, b, c, d, SET(0), 3)
+		STEP(F, d, a, b, c, SET(1), 7)
+		STEP(F, c, d, a, b, SET(2), 11)
+		STEP(F, b, c, d, a, SET(3), 19)
+		STEP(F, a, b, c, d, SET(4), 3)
+		STEP(F, d, a, b, c, SET(5), 7)
+		STEP(F, c, d, a, b, SET(6), 11)
+		STEP(F, b, c, d, a, SET(7), 19)
+		STEP(F, a, b, c, d, SET(8), 3)
+		STEP(F, d, a, b, c, SET(9), 7)
+		STEP(F, c, d, a, b, SET(10), 11)
+		STEP(F, b, c, d, a, SET(11), 19)
+		STEP(F, a, b, c, d, SET(12), 3)
+		STEP(F, d, a, b, c, SET(13), 7)
+		STEP(F, c, d, a, b, SET(14), 11)
+		STEP(F, b, c, d, a, SET(15), 19)
+
+/* Round 2 */
+		STEP(G, a, b, c, d, GET(0) + 0x5a827999, 3)
+		STEP(G, d, a, b, c, GET(4) + 0x5a827999, 5)
+		STEP(G, c, d, a, b, GET(8) + 0x5a827999, 9)
+		STEP(G, b, c, d, a, GET(12) + 0x5a827999, 13)
+		STEP(G, a, b, c, d, GET(1) + 0x5a827999, 3)
+		STEP(G, d, a, b, c, GET(5) + 0x5a827999, 5)
+		STEP(G, c, d, a, b, GET(9) + 0x5a827999, 9)
+		STEP(G, b, c, d, a, GET(13) + 0x5a827999, 13)
+		STEP(G, a, b, c, d, GET(2) + 0x5a827999, 3)
+		STEP(G, d, a, b, c, GET(6) + 0x5a827999, 5)
+		STEP(G, c, d, a, b, GET(10) + 0x5a827999, 9)
+		STEP(G, b, c, d, a, GET(14) + 0x5a827999, 13)
+		STEP(G, a, b, c, d, GET(3) + 0x5a827999, 3)
+		STEP(G, d, a, b, c, GET(7) + 0x5a827999, 5)
+		STEP(G, c, d, a, b, GET(11) + 0x5a827999, 9)
+		STEP(G, b, c, d, a, GET(15) + 0x5a827999, 13)
+
+/* Round 3 */
+		STEP(H, a, b, c, d, GET(0) + 0x6ed9eba1, 3)
+		STEP(H, d, a, b, c, GET(8) + 0x6ed9eba1, 9)
+		STEP(H, c, d, a, b, GET(4) + 0x6ed9eba1, 11)
+		STEP(H, b, c, d, a, GET(12) + 0x6ed9eba1, 15)
+		STEP(H, a, b, c, d, GET(2) + 0x6ed9eba1, 3)
+		STEP(H, d, a, b, c, GET(10) + 0x6ed9eba1, 9)
+		STEP(H, c, d, a, b, GET(6) + 0x6ed9eba1, 11)
+		STEP(H, b, c, d, a, GET(14) + 0x6ed9eba1, 15)
+		STEP(H, a, b, c, d, GET(1) + 0x6ed9eba1, 3)
+		STEP(H, d, a, b, c, GET(9) + 0x6ed9eba1, 9)
+		STEP(H, c, d, a, b, GET(5) + 0x6ed9eba1, 11)
+		STEP(H, b, c, d, a, GET(13) + 0x6ed9eba1, 15)
+		STEP(H, a, b, c, d, GET(3) + 0x6ed9eba1, 3)
+		STEP(H, d, a, b, c, GET(11) + 0x6ed9eba1, 9)
+		STEP(H, c, d, a, b, GET(7) + 0x6ed9eba1, 11)
+		STEP(H, b, c, d, a, GET(15) + 0x6ed9eba1, 15)
+
+		a += saved_a;
+		b += saved_b;
+		c += saved_c;
+		d += saved_d;
+
+		ptr += 64;
+	} while (size -= 64);
+
+	ctx->a = a;
+	ctx->b = b;
+	ctx->c = c;
+	ctx->d = d;
+
+	return ptr;
+}
+
+void MD4_Init(MD4_CTX *ctx)
+{
+	ctx->a = 0x67452301;
+	ctx->b = 0xefcdab89;
+	ctx->c = 0x98badcfe;
+	ctx->d = 0x10325476;
+
+	ctx->lo = 0;
+	ctx->hi = 0;
+}
+
+void MD4_Update(MD4_CTX *ctx, void *data, unsigned long size)
+{
+	MD4_u32plus saved_lo;
+	unsigned long used, free;
+
+	saved_lo = ctx->lo;
+	if ((ctx->lo = (saved_lo + size) & 0x1fffffff) < saved_lo)
+		ctx->hi++;
+	ctx->hi += size >> 29;
+
+	used = saved_lo & 0x3f;
+
+	if (used) {
+		free = 64 - used;
+
+		if (size < free) {
+			memcpy(&ctx->buffer[used], data, size);
+			return;
+		}
+
+		memcpy(&ctx->buffer[used], data, free);
+		data = (unsigned char *)data + free;
+		size -= free;
+		body(ctx, ctx->buffer, 64);
+	}
+
+	if (size >= 64) {
+		data = body(ctx, data, size & ~(unsigned long)0x3f);
+		size &= 0x3f;
+	}
+
+	memcpy(ctx->buffer, data, size);
+}
+
+void MD4_Final(unsigned char *result, MD4_CTX *ctx)
+{
+	unsigned long used, free;
+
+	used = ctx->lo & 0x3f;
+
+	ctx->buffer[used++] = 0x80;
+
+	free = 64 - used;
+
+	if (free < 8) {
+		memset(&ctx->buffer[used], 0, free);
+		body(ctx, ctx->buffer, 64);
+		used = 0;
+		free = 64;
+	}
+
+	memset(&ctx->buffer[used], 0, free - 8);
+
+	ctx->lo <<= 3;
+	ctx->buffer[56] = ctx->lo;
+	ctx->buffer[57] = ctx->lo >> 8;
+	ctx->buffer[58] = ctx->lo >> 16;
+	ctx->buffer[59] = ctx->lo >> 24;
+	ctx->buffer[60] = ctx->hi;
+	ctx->buffer[61] = ctx->hi >> 8;
+	ctx->buffer[62] = ctx->hi >> 16;
+	ctx->buffer[63] = ctx->hi >> 24;
+
+	body(ctx, ctx->buffer, 64);
+
+	result[0] = ctx->a;
+	result[1] = ctx->a >> 8;
+	result[2] = ctx->a >> 16;
+	result[3] = ctx->a >> 24;
+	result[4] = ctx->b;
+	result[5] = ctx->b >> 8;
+	result[6] = ctx->b >> 16;
+	result[7] = ctx->b >> 24;
+	result[8] = ctx->c;
+	result[9] = ctx->c >> 8;
+	result[10] = ctx->c >> 16;
+	result[11] = ctx->c >> 24;
+	result[12] = ctx->d;
+	result[13] = ctx->d >> 8;
+	result[14] = ctx->d >> 16;
+	result[15] = ctx->d >> 24;
+
+#if 0
+	memset(ctx, 0, sizeof(*ctx));
+#endif
+}
+
+#endif
diff -rupN john-1.7.8/src/md4.h john-1.7.8-jumbo-2/src/md4.h
--- john-1.7.8/src/md4.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md4.h	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+ * This is an OpenSSL-compatible implementation of the RSA Data Security,
+ * Inc. MD4 Message-Digest Algorithm (RFC 1320).
+ *
+ * Written by Solar Designer <solar at openwall.com> in 2001, and placed
+ * in the public domain.  There's absolutely no warranty.
+ *
+ * See md4.c for more information.
+ */
+
+#ifdef HAVE_OPENSSL
+#include <openssl/md4.h>
+#elif !defined(_MD4_H)
+#define _MD4_H
+
+/* Any 32-bit or wider unsigned integer data type will do */
+typedef unsigned int MD4_u32plus;
+
+typedef struct {
+	MD4_u32plus lo, hi;
+	MD4_u32plus a, b, c, d;
+	unsigned char buffer[64];
+	MD4_u32plus block[16];
+} MD4_CTX;
+
+extern void MD4_Init(MD4_CTX *ctx);
+extern void MD4_Update(MD4_CTX *ctx, void *data, unsigned long size);
+extern void MD4_Final(unsigned char *result, MD4_CTX *ctx);
+
+#endif
diff -rupN john-1.7.8/src/md4_gen_fmt_plug.c john-1.7.8-jumbo-2/src/md4_gen_fmt_plug.c
--- john-1.7.8/src/md4_gen_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md4_gen_fmt_plug.c	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,253 @@
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 2010 by Solar Designer
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+#include "md4.h"
+
+#define FORMAT_LABEL			"md4-gen"
+#define FORMAT_NAME			"Generic salted MD4"
+#define ALGORITHM_NAME			"32/" ARCH_BITS_STR
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		125
+#define CIPHERTEXT_LENGTH		32
+
+#define BINARY_SIZE			16
+#define SALT_SIZE			64 /* length + type + 62 chars */
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests tests[] = {
+	{"$MD4p$salt$15ad2b7a23e5088942f9d3772181b384", "password"},
+	{"$MD4s$salt$fb483dbef17c51c13e2322fcbec5da79", "password"},
+	{NULL}
+};
+
+static char saved_salt[SALT_SIZE];
+static int saved_key_length;
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static MD4_CTX ctx;
+static ARCH_WORD_32 crypt_out[4];
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *p, *q;
+
+	if (strncmp(ciphertext, "$MD4", 4) ||
+	    (ciphertext[4] != 'p' && ciphertext[4] != 's') ||
+	    ciphertext[5] != '$')
+		return 0;
+
+	p = strrchr(ciphertext, '$');
+	if (!p || /* can't happen */
+	    p - ciphertext < 6 || /* must not be the 1st or 2nd '$' */
+	    p - ciphertext > 6 + SALT_SIZE - 2)
+		return 0;
+
+	q = ++p;
+	while (atoi16[ARCH_INDEX(*q)] != 0x7F)
+		q++;
+	return !*q && q - p == CIPHERTEXT_LENGTH;
+}
+
+static void *get_binary(char *ciphertext)
+{
+	static unsigned char out[BINARY_SIZE];
+	char *p;
+	int i;
+
+	p = strrchr(ciphertext, '$') + 1;
+	for (i = 0; i < sizeof(out); i++) {
+		out[i] =
+		    (atoi16[ARCH_INDEX(*p)] << 4) |
+		    atoi16[ARCH_INDEX(p[1])];
+		p += 2;
+	}
+
+	return out;
+}
+
+static void *salt(char *ciphertext)
+{
+	static unsigned char out[SALT_SIZE];
+	char *p;
+	int length;
+
+	memset(out, 0, sizeof(out));
+	p = ciphertext + 6;
+	length = strrchr(ciphertext, '$') - p;
+	out[0] = length;
+	out[1] = ciphertext[4];
+	memcpy(out + 2, p, length);
+
+	return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return crypt_out[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return crypt_out[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return crypt_out[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return crypt_out[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return crypt_out[0] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	unsigned int hash = 0;
+	char *p = (char *)salt;
+
+	while (*p) {
+		hash <<= 1;
+		hash += (unsigned char)*p++;
+		if (hash >> 10) {
+			hash ^= hash >> 10;
+			hash &= 0x3FF;
+		}
+	}
+
+	hash ^= hash >> 10;
+	hash &= 0x3FF;
+
+	return hash;
+}
+
+static void set_salt(void *salt)
+{
+	memcpy(saved_salt, salt, *(unsigned char *)salt + 2);
+}
+
+static void set_key(char *key, int index)
+{
+	saved_key_length = strlen(key);
+	if (saved_key_length > PLAINTEXT_LENGTH)
+		saved_key_length = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, saved_key_length);
+}
+
+static char *get_key(int index)
+{
+	saved_key[saved_key_length] = 0;
+	return saved_key;
+}
+
+static void crypt_all(int count)
+{
+	MD4_Init(&ctx);
+	if (saved_salt[1] == 'p') {
+		MD4_Update(&ctx, &saved_salt[2], (unsigned char)saved_salt[0]);
+		MD4_Update(&ctx, saved_key, saved_key_length);
+	} else {
+		MD4_Update(&ctx, saved_key, saved_key_length);
+		MD4_Update(&ctx, &saved_salt[2], (unsigned char)saved_salt[0]);
+	}
+	MD4_Final((unsigned char *)crypt_out, &ctx);
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return !memcmp(binary, crypt_out, BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_md4_gen = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		get_binary,
+		salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_all,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/md5-mmx.S john-1.7.8-jumbo-2/src/md5-mmx.S
--- john-1.7.8/src/md5-mmx.S	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5-mmx.S	2011-06-02 17:20:33.000000000 +0200
@@ -0,0 +1,386 @@
+#include "arch.h"
+
+// extern int mdfourmmx(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+
+#ifdef UNDERSCORES
+#define mdfivemmx	_mdfivemmx
+#define mdfivemmx_noinit_sizeupdate _mdfivemmx_noinit_sizeupdate
+#define mdfivemmx_noinit_uniformsizeupdate _mdfivemmx_noinit_uniformsizeupdate
+#define mdfivemmx_nosizeupdate _mdfivemmx_nosizeupdate
+// These are the VC 'param marshalling' function stubs.  They are __fastcall functions, and have
+// to be 'properly' decorated with the @'s   The @12 trailing is due to 12 bytes of params.
+#ifdef __MINGW32__
+#define mdfivemmx_VC @mdfivemmx_VC@12
+#define mdfivemmx_nosizeupdate_VC @mdfivemmx_nosizeupdate_VC@12
+#define mdfivemmx_noinit_sizeupdate_VC @mdfivemmx_noinit_sizeupdate_VC@12
+#define mdfivemmx_noinit_uniformsizeupdate_VC @mdfivemmx_noinit_uniformsizeupdate_VC@12
+#endif
+#endif
+.globl mdfivemmx
+.globl mdfivemmx_noinit_sizeupdate
+.globl mdfivemmx_noinit_uniformsizeupdate
+.globl mdfivemmx_nosizeupdate
+#ifdef __MINGW32__
+.globl mdfivemmx_VC
+.globl mdfivemmx_nosizeupdate_VC
+.globl mdfivemmx_noinit_sizeupdate_VC
+.globl mdfivemmx_noinit_uniformsizeupdate_VC
+#endif
+
+.data
+#if defined (MD5_SSE_PARA) && !defined (MMX_COEF)
+#define MMX_COEF 4
+#endif
+
+// align of 2*MMX_COEF was crashing on SSE2 builds (at least cross compiling from 64 bit linux)
+.align(4*MMX_COEF)
+
+#if (MMX_COEF == 2)
+const_init_a: ; .long 0x67452301 ; .long 0x67452301
+const_init_b: ; .long 0xefcdab89 ; .long 0xefcdab89
+const_init_c: ; .long 0x98badcfe ; .long 0x98badcfe
+const_init_d: ; .long 0x10325476 ; .long 0x10325476
+storea: ; .long 0 ; .long 0
+storeb: ; .long 0 ; .long 0
+storec: ; .long 0 ; .long 0
+stored: ; .long 0 ; .long 0
+#define REGMM0 %mm0
+#define REGMM1 %mm1
+#define REGMM2 %mm2
+#define REGMM3 %mm3
+#define REGMM4 %mm4
+#define REGMM5 %mm5
+#define REGMM6 %mm6
+#define REGMM7 %mm7
+#define MMXMOVE movq
+#include "stages_mmx_md5.S"
+#else
+const_init_a: ; .long 0x67452301 ; .long 0x67452301 ; .long 0x67452301 ; .long 0x67452301
+const_init_b: ; .long 0xefcdab89 ; .long 0xefcdab89 ; .long 0xefcdab89 ; .long 0xefcdab89
+const_init_c: ; .long 0x98badcfe ; .long 0x98badcfe ; .long 0x98badcfe ; .long 0x98badcfe
+const_init_d: ; .long 0x10325476 ; .long 0x10325476 ; .long 0x10325476 ; .long 0x10325476
+storea: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+storeb: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+storec: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+stored: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+#define REGMM0 %xmm0
+#define REGMM1 %xmm1
+#define REGMM2 %xmm2
+#define REGMM3 %xmm3
+#define REGMM4 %xmm4
+#define REGMM5 %xmm5
+#define REGMM6 %xmm6
+#define REGMM7 %xmm7
+#define MMXMOVE movapd
+#include "stages_sse2_md5.S"
+#endif
+
+
+#define ctxa REGMM0
+#define ctxb REGMM1
+#define ctxc REGMM2
+#define ctxd REGMM3
+#define tmp1 REGMM4
+#define tmp2 REGMM5
+#define tmp3 REGMM6
+#define tmp4 REGMM7
+
+
+//#define F_MMX(x, y, z)			(z ^ (x & (y ^ z)))
+
+#define F(x,y,z) \
+	MMXMOVE y, tmp1; \
+	pxor z, tmp1; \
+	pand x, tmp1; \
+	pxor z, tmp1
+
+//#define G_MMX(x, y, z)			(y ^ (z & (x ^ y)))
+
+#define G(x,y,z) \
+	MMXMOVE y, tmp1; \
+	pxor x, tmp1; \
+	pand z, tmp1; \
+	pxor y, tmp1
+
+//#define H_MMX(x, y, z)			(x ^ y ^ z)
+#define H(x,y,z) \
+	MMXMOVE y, tmp1; \
+	pxor z, tmp1; \
+	pxor x, tmp1
+
+//#define I(x, y, z)			(y ^ (x | ~z))
+#define I(x, y, z) \
+	MMXMOVE z, tmp1; \
+	pandn tmp4, tmp1; \
+	por x, tmp1; \
+	pxor y, tmp1;
+
+
+//#define STEP_MMX(f, a, b, c, d, x, s) \
+//	(a) += f((b), (c), (d)) + (x); \
+//	(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s))));
+
+//#define STEP(f, a, b, c, d, x, t, s) \
+//	(a) += f((b), (c), (d)) + (x) + (t); \
+//	(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \
+//	(a) += (b);
+
+
+#define STEP(f, a, b, c, d, x, t, s) \
+	f(b, c, d); \
+	paddd (x*4*MMX_COEF)(%edx), tmp1; \
+	paddd t, a; \
+	paddd tmp1, a; \
+	MMXMOVE a, tmp3; \
+	psrld $(32-s), tmp3; \
+	pslld $s, a; \
+	por tmp3, a; \
+	paddd b, a
+
+#define STEPD(f, a, b, c, d, x, t, s) \
+	f(b, c, d); \
+	paddd (x*4*MMX_COEF)(%edx), tmp1; \
+	paddd t, a; \
+	paddd tmp1, a; \
+	MMXMOVE a, tmp3; \
+	psrld $(32-s), tmp3; \
+	pslld $s, a; \
+	por tmp3, a; \
+	paddd b, a
+
+
+.text
+/*
+ * Try to do some asm md4 w/ mmx
+ * %eax ptr -> out
+ * %edx ptr -> in
+ * %ecx n
+ */
+
+init:
+	MMXMOVE const_init_a, ctxa
+	MMXMOVE const_init_b, ctxb
+	MMXMOVE const_init_c, ctxc
+	MMXMOVE const_init_d, ctxd
+	ret;
+
+sizeupdate:
+#if (MMX_COEF == 2)
+	shl $3, %ecx
+	mov %ecx, %ebx
+	and $0xffff, %ecx
+	shrl $16,  %ebx
+	mov %ecx, (14*4*MMX_COEF)(%edx)
+	mov %ebx, (14*4*MMX_COEF+4)(%edx)
+#else
+	mov %ecx, %ebx
+        shr $8, %ecx
+        and $0xff, %ebx
+        shl $3, %ebx
+        mov %ebx, (14*16)(%edx)
+
+        mov %ecx, %ebx
+        shr $8, %ecx
+        and $0xff, %ebx
+        shl $3, %ebx
+        mov %ebx, (14*16+4)(%edx)
+
+        mov %ecx, %ebx
+        shr $8, %ecx
+        and $0xff, %ebx
+        shl $3, %ebx
+        mov %ebx, (14*16+8)(%edx)
+
+        and $0xff, %ecx
+        shl $3, %ecx
+        mov %ecx, (14*16+12)(%edx)
+#endif
+	ret
+
+uniformsizeupdate:
+	shl $3, %ecx
+	mov %ecx, (14*4*MMX_COEF)(%edx)
+	mov %ecx, (14*4*MMX_COEF+4)(%edx)
+#if (MMX_COEF == 4)
+	mov %ecx, (14*4*MMX_COEF+8)(%edx)
+	mov %ecx, (14*4*MMX_COEF+12)(%edx)
+#endif
+	ret
+
+//entry points
+mdfivemmx_noinit_sizeupdate:
+	pusha
+	call sizeupdate
+	jmp mdfivemmx_noinit
+
+mdfivemmx_noinit_uniformsizeupdate:
+	pusha
+	call uniformsizeupdate
+	jmp mdfivemmx_noinit
+
+mdfivemmx:
+	pusha
+	call sizeupdate
+	call init
+	jmp mdfivemmx_noinit
+
+mdfivemmx_nosizeupdate:
+	pusha
+	call init
+	jmp mdfivemmx_noinit
+//end entry points
+
+#ifdef __MINGW32__
+// These are 'magic' param marshalling calls.  I am using VC with __fastcall
+// syntax.  For that, the edx is correct.  The stack has what should go into
+// ecx on it, THEN the return.  Thus, since we do the pusha here, the popa
+// at the end of the mdfilemmx_noinit function, and return from there, we
+// MUST return back here, and handle the return with a ret $4.  Thus the
+// small amount of monkeying around.  The overhead is very minimal, only an
+// op or 2 more than the 'native' __atribute(param(3)) type.
+mdfivemmx_VC:
+    lea mdfivemmx_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call sizeupdate
+    call init
+    jmp mdfivemmx_noinit
+mdfivemmx_VC_exit:
+    ret $4
+
+mdfivemmx_nosizeupdate_VC:
+    lea mdfivemmx_nosizeupdate_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call init
+    jmp mdfivemmx_noinit
+mdfivemmx_nosizeupdate_VC_exit:
+    ret $4
+
+mdfivemmx_noinit_sizeupdate_VC:
+    lea mdfivemmx_noinit_sizeupdate_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call sizeupdate
+    jmp mdfivemmx_noinit
+    mdfivemmx_noinit_sizeupdate_VC_exit:
+    ret $4
+
+mdfivemmx_noinit_uniformsizeupdate_VC:
+    lea mdfivemmx_noinit_uniformsizeupdate_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call uniformsizeupdate
+    jmp mdfivemmx_noinit
+mdfivemmx_noinit_uniformsizeupdate_VC_exit:
+    ret $4
+
+//end entry points
+#endif
+
+mdfivemmx_noinit:
+	pcmpeqd tmp4, tmp4;
+	MMXMOVE ctxa, storea
+	MMXMOVE ctxb, storeb
+	MMXMOVE ctxc, storec
+	MMXMOVE ctxd, stored
+
+	STEP(F, ctxa, ctxb, ctxc, ctxd, 0, const_stage_1, 7)
+	STEP(F, ctxd, ctxa, ctxb, ctxc, 1, const_stage_2, 12)
+	STEP(F, ctxc, ctxd, ctxa, ctxb, 2, const_stage_3, 17)
+	STEP(F, ctxb, ctxc, ctxd, ctxa, 3, const_stage_4, 22)
+	STEP(F, ctxa, ctxb, ctxc, ctxd, 4, const_stage_5, 7)
+	STEP(F, ctxd, ctxa, ctxb, ctxc, 5, const_stage_6, 12)
+	STEP(F, ctxc, ctxd, ctxa, ctxb, 6, const_stage_7, 17)
+	STEP(F, ctxb, ctxc, ctxd, ctxa, 7, const_stage_8, 22)
+	STEP(F, ctxa, ctxb, ctxc, ctxd, 8, const_stage_9, 7)
+	STEP(F, ctxd, ctxa, ctxb, ctxc, 9, const_stage_10, 12)
+	STEP(F, ctxc, ctxd, ctxa, ctxb, 10, const_stage_11, 17)
+	STEP(F, ctxb, ctxc, ctxd, ctxa, 11, const_stage_12, 22)
+	STEP(F, ctxa, ctxb, ctxc, ctxd, 12, const_stage_13, 7)
+	STEP(F, ctxd, ctxa, ctxb, ctxc, 13, const_stage_14, 12)
+	STEP(F, ctxc, ctxd, ctxa, ctxb, 14, const_stage_15, 17)
+	STEP(F, ctxb, ctxc, ctxd, ctxa, 15, const_stage_16, 22)
+
+	STEP(G, ctxa, ctxb, ctxc, ctxd, 1, const_stage_17, 5)
+	STEP(G, ctxd, ctxa, ctxb, ctxc, 6, const_stage_18, 9)
+	STEP(G, ctxc, ctxd, ctxa, ctxb, 11, const_stage_19, 14)
+	STEP(G, ctxb, ctxc, ctxd, ctxa, 0, const_stage_20, 20)
+	STEP(G, ctxa, ctxb, ctxc, ctxd, 5, const_stage_21, 5)
+	STEP(G, ctxd, ctxa, ctxb, ctxc, 10, const_stage_22, 9)
+	STEP(G, ctxc, ctxd, ctxa, ctxb, 15, const_stage_23, 14)
+	STEP(G, ctxb, ctxc, ctxd, ctxa, 4, const_stage_24, 20)
+	STEP(G, ctxa, ctxb, ctxc, ctxd, 9, const_stage_25, 5)
+	STEP(G, ctxd, ctxa, ctxb, ctxc, 14, const_stage_26, 9)
+	STEP(G, ctxc, ctxd, ctxa, ctxb, 3, const_stage_27, 14)
+	STEP(G, ctxb, ctxc, ctxd, ctxa, 8, const_stage_28, 20)
+	STEP(G, ctxa, ctxb, ctxc, ctxd, 13, const_stage_29, 5)
+	STEP(G, ctxd, ctxa, ctxb, ctxc, 2, const_stage_30, 9)
+	STEP(G, ctxc, ctxd, ctxa, ctxb, 7, const_stage_31, 14)
+	STEP(G, ctxb, ctxc, ctxd, ctxa, 12, const_stage_32, 20)
+
+	STEP(H, ctxa, ctxb, ctxc, ctxd, 5, const_stage_33, 4)
+	STEP(H, ctxd, ctxa, ctxb, ctxc, 8, const_stage_34, 11)
+	STEP(H, ctxc, ctxd, ctxa, ctxb, 11, const_stage_35, 16)
+	STEP(H, ctxb, ctxc, ctxd, ctxa, 14, const_stage_36, 23)
+	STEP(H, ctxa, ctxb, ctxc, ctxd, 1, const_stage_37, 4)
+	STEP(H, ctxd, ctxa, ctxb, ctxc, 4, const_stage_38, 11)
+	STEP(H, ctxc, ctxd, ctxa, ctxb, 7, const_stage_39, 16)
+	STEP(H, ctxb, ctxc, ctxd, ctxa, 10, const_stage_40, 23)
+	STEP(H, ctxa, ctxb, ctxc, ctxd, 13, const_stage_41, 4)
+	STEP(H, ctxd, ctxa, ctxb, ctxc, 0, const_stage_42, 11)
+	STEP(H, ctxc, ctxd, ctxa, ctxb, 3, const_stage_43, 16)
+	STEP(H, ctxb, ctxc, ctxd, ctxa, 6, const_stage_44, 23)
+	STEP(H, ctxa, ctxb, ctxc, ctxd, 9, const_stage_45, 4)
+	STEP(H, ctxd, ctxa, ctxb, ctxc, 12, const_stage_46, 11)
+	STEP(H, ctxc, ctxd, ctxa, ctxb, 15, const_stage_47, 16)
+	STEP(H, ctxb, ctxc, ctxd, ctxa, 2, const_stage_48, 23)
+
+	STEP(I, ctxa, ctxb, ctxc, ctxd, 0, const_stage_49, 6)
+	STEP(I, ctxd, ctxa, ctxb, ctxc, 7, const_stage_50, 10)
+	STEP(I, ctxc, ctxd, ctxa, ctxb, 14, const_stage_51, 15)
+	STEP(I, ctxb, ctxc, ctxd, ctxa, 5, const_stage_52, 21)
+	STEP(I, ctxa, ctxb, ctxc, ctxd, 12, const_stage_53, 6)
+	STEP(I, ctxd, ctxa, ctxb, ctxc, 3, const_stage_54, 10)
+	STEP(I, ctxc, ctxd, ctxa, ctxb, 10, const_stage_55, 15)
+	STEP(I, ctxb, ctxc, ctxd, ctxa, 1, const_stage_56, 21)
+	STEP(I, ctxa, ctxb, ctxc, ctxd, 8, const_stage_57, 6)
+	STEP(I, ctxd, ctxa, ctxb, ctxc, 15, const_stage_58, 10)
+	STEP(I, ctxc, ctxd, ctxa, ctxb, 6, const_stage_59, 15)
+	STEP(I, ctxb, ctxc, ctxd, ctxa, 13, const_stage_60, 21)
+	STEP(I, ctxa, ctxb, ctxc, ctxd, 4, const_stage_61, 6)
+	STEP(I, ctxd, ctxa, ctxb, ctxc, 11, const_stage_62, 10)
+	STEP(I, ctxc, ctxd, ctxa, ctxb, 2, const_stage_63, 15)
+	STEP(I, ctxb, ctxc, ctxd, ctxa, 9, const_stage_64, 21)
+
+	paddd storea, ctxa
+	paddd storeb, ctxb
+	paddd storec, ctxc
+	paddd stored, ctxd
+
+	MMXMOVE ctxa, 0(%eax)
+	MMXMOVE ctxa, storea
+	MMXMOVE ctxb, (4*MMX_COEF)(%eax)
+	MMXMOVE ctxb, storeb
+	MMXMOVE ctxc, (8*MMX_COEF)(%eax)
+	MMXMOVE ctxc, storec
+	MMXMOVE ctxd, (12*MMX_COEF)(%eax)
+	MMXMOVE ctxd, stored
+
+	popa
+
+	emms
+
+	ret
+
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",@progbits
+#endif
diff -rupN john-1.7.8/src/md5.c john-1.7.8-jumbo-2/src/md5.c
--- john-1.7.8/src/md5.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5.c	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,289 @@
+/*
+ * This is an OpenSSL-compatible implementation of the RSA Data Security,
+ * Inc. MD5 Message-Digest Algorithm (RFC 1321).
+ *
+ * Written by Solar Designer <solar at openwall.com> in 2001, and placed
+ * in the public domain.  There's absolutely no warranty.
+ *
+ * This differs from Colin Plumb's older public domain implementation in
+ * that no 32-bit integer data type is required, there's no compile-time
+ * endianness configuration, and the function prototypes match OpenSSL's.
+ * The primary goals are portability and ease of use.
+ *
+ * This implementation is meant to be fast, but not as fast as possible.
+ * Some known optimizations are not included to reduce source code size
+ * and avoid compile-time configuration.
+ *
+ * ... MD5_Final() has been modified in revision of this code found in the
+ * JtR jumbo patch, separating a portion of the code into MD5_PreFinal() and
+ * dropping the memset() call.  You will likely want to undo this change if
+ * you reuse the code for another purpose.
+ * Or better yet, download the original from:
+ * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
+ */
+
+#ifndef HAVE_OPENSSL
+
+#include <string.h>
+
+#include "md5.h"
+
+/*
+ * The basic MD5 functions.
+ *
+ * F and G are optimized compared to their RFC 1321 definitions for
+ * architectures that lack an AND-NOT instruction, just like in Colin Plumb's
+ * implementation.
+ */
+#define F(x, y, z)			((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z)			((y) ^ ((z) & ((x) ^ (y))))
+#define H(x, y, z)			((x) ^ (y) ^ (z))
+#define I(x, y, z)			((y) ^ ((x) | ~(z)))
+
+/*
+ * The MD5 transformation for all four rounds.
+ */
+#define STEP(f, a, b, c, d, x, t, s) \
+	(a) += f((b), (c), (d)) + (x) + (t); \
+	(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \
+	(a) += (b);
+
+/*
+ * SET reads 4 input bytes in little-endian byte order and stores them
+ * in a properly aligned word in host byte order.
+ *
+ * The check for little-endian architectures that tolerate unaligned
+ * memory accesses is just an optimization.  Nothing will break if it
+ * doesn't work.
+ */
+#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)
+#define SET(n) \
+	(*(MD5_u32plus *)&ptr[(n) * 4])
+#define GET(n) \
+	SET(n)
+#else
+#define SET(n) \
+	(ctx->block[(n)] = \
+	(MD5_u32plus)ptr[(n) * 4] | \
+	((MD5_u32plus)ptr[(n) * 4 + 1] << 8) | \
+	((MD5_u32plus)ptr[(n) * 4 + 2] << 16) | \
+	((MD5_u32plus)ptr[(n) * 4 + 3] << 24))
+#define GET(n) \
+	(ctx->block[(n)])
+#endif
+
+/*
+ * This processes one or more 64-byte data blocks, but does NOT update
+ * the bit counters.  There are no alignment requirements.
+ */
+static void *body(MD5_CTX *ctx, void *data, unsigned long size)
+{
+	unsigned char *ptr;
+	MD5_u32plus a, b, c, d;
+	MD5_u32plus saved_a, saved_b, saved_c, saved_d;
+
+	ptr = data;
+
+	a = ctx->a;
+	b = ctx->b;
+	c = ctx->c;
+	d = ctx->d;
+
+	do {
+		saved_a = a;
+		saved_b = b;
+		saved_c = c;
+		saved_d = d;
+
+/* Round 1 */
+		STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)
+		STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)
+		STEP(F, c, d, a, b, SET(2), 0x242070db, 17)
+		STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)
+		STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)
+		STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)
+		STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)
+		STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)
+		STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)
+		STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)
+		STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)
+		STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)
+		STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)
+		STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)
+		STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)
+		STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)
+
+/* Round 2 */
+		STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)
+		STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)
+		STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)
+		STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)
+		STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)
+		STEP(G, d, a, b, c, GET(10), 0x02441453, 9)
+		STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)
+		STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)
+		STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)
+		STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)
+		STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)
+		STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)
+		STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)
+		STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)
+		STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)
+		STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)
+
+/* Round 3 */
+		STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)
+		STEP(H, d, a, b, c, GET(8), 0x8771f681, 11)
+		STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)
+		STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)
+		STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)
+		STEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)
+		STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)
+		STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)
+		STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)
+		STEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)
+		STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)
+		STEP(H, b, c, d, a, GET(6), 0x04881d05, 23)
+		STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)
+		STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)
+		STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)
+		STEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)
+
+/* Round 4 */
+		STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)
+		STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)
+		STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)
+		STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)
+		STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)
+		STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)
+		STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)
+		STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)
+		STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)
+		STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)
+		STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)
+		STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)
+		STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)
+		STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)
+		STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)
+		STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)
+
+		a += saved_a;
+		b += saved_b;
+		c += saved_c;
+		d += saved_d;
+
+		ptr += 64;
+	} while (size -= 64);
+
+	ctx->a = a;
+	ctx->b = b;
+	ctx->c = c;
+	ctx->d = d;
+
+	return ptr;
+}
+
+void MD5_Init(MD5_CTX *ctx)
+{
+	ctx->a = 0x67452301;
+	ctx->b = 0xefcdab89;
+	ctx->c = 0x98badcfe;
+	ctx->d = 0x10325476;
+
+	ctx->lo = 0;
+	ctx->hi = 0;
+}
+
+void MD5_Update(MD5_CTX *ctx, void *data, unsigned long size)
+{
+	MD5_u32plus saved_lo;
+	unsigned long used, free;
+
+	saved_lo = ctx->lo;
+	if ((ctx->lo = (saved_lo + size) & 0x1fffffff) < saved_lo)
+		ctx->hi++;
+	ctx->hi += size >> 29;
+
+	used = saved_lo & 0x3f;
+
+	if (used) {
+		free = 64 - used;
+
+		if (size < free) {
+			memcpy(&ctx->buffer[used], data, size);
+			return;
+		}
+
+		memcpy(&ctx->buffer[used], data, free);
+		data = (unsigned char *)data + free;
+		size -= free;
+		body(ctx, ctx->buffer, 64);
+	}
+
+	if (size >= 64) {
+		data = body(ctx, data, size & ~(unsigned long)0x3f);
+		size &= 0x3f;
+	}
+
+	memcpy(ctx->buffer, data, size);
+}
+
+void MD5_PreFinal(MD5_CTX *ctx)
+{
+	unsigned long used, free;
+
+	used = ctx->lo & 0x3f;
+
+	ctx->buffer[used++] = 0x80;
+
+	free = 64 - used;
+
+	if (free < 8) {
+		memset(&ctx->buffer[used], 0, free);
+		body(ctx, ctx->buffer, 64);
+		used = 0;
+		free = 64;
+	}
+
+	memset(&ctx->buffer[used], 0, free - 8);
+
+	ctx->lo <<= 3;
+	ctx->buffer[56] = ctx->lo;
+	ctx->buffer[57] = ctx->lo >> 8;
+	ctx->buffer[58] = ctx->lo >> 16;
+	ctx->buffer[59] = ctx->lo >> 24;
+	ctx->buffer[60] = ctx->hi;
+	ctx->buffer[61] = ctx->hi >> 8;
+	ctx->buffer[62] = ctx->hi >> 16;
+	ctx->buffer[63] = ctx->hi >> 24;
+
+	body(ctx, ctx->buffer, 64);
+}
+
+void MD5_Final(unsigned char *result, MD5_CTX *ctx)
+{
+	MD5_PreFinal(ctx);
+
+	result[0] = ctx->a;
+	result[1] = ctx->a >> 8;
+	result[2] = ctx->a >> 16;
+	result[3] = ctx->a >> 24;
+	result[4] = ctx->b;
+	result[5] = ctx->b >> 8;
+	result[6] = ctx->b >> 16;
+	result[7] = ctx->b >> 24;
+	result[8] = ctx->c;
+	result[9] = ctx->c >> 8;
+	result[10] = ctx->c >> 16;
+	result[11] = ctx->c >> 24;
+	result[12] = ctx->d;
+	result[13] = ctx->d >> 8;
+	result[14] = ctx->d >> 16;
+	result[15] = ctx->d >> 24;
+
+#if 0
+	memset(ctx, 0, sizeof(*ctx));
+#endif
+}
+
+#endif
diff -rupN john-1.7.8/src/md5.h john-1.7.8-jumbo-2/src/md5.h
--- john-1.7.8/src/md5.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5.h	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,61 @@
+/*
+ * This is an OpenSSL-compatible implementation of the RSA Data Security,
+ * Inc. MD5 Message-Digest Algorithm (RFC 1321).
+ *
+ * Written by Solar Designer <solar at openwall.com> in 2001, and placed
+ * in the public domain.  There's absolutely no warranty.
+ *
+ * See md5.c for more information.
+ *
+ * This file has been modified in the JtR jumbo patch.
+ * If you reuse the code for another purpose, please download the original from:
+ * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
+ */
+
+#ifdef HAVE_OPENSSL
+#include <openssl/md5.h>
+#elif !defined(_MD5_H)
+#define _MD5_H
+
+/* Any 32-bit or wider unsigned integer data type will do */
+typedef unsigned int MD5_u32plus;
+
+typedef struct {
+	MD5_u32plus lo, hi;
+	MD5_u32plus a, b, c, d;
+	unsigned char buffer[64];
+	MD5_u32plus block[16];
+} MD5_CTX;
+
+extern void MD5_Init(MD5_CTX *ctx);
+extern void MD5_Update(MD5_CTX *ctx, void *data, unsigned long size);
+extern void MD5_PreFinal(MD5_CTX *ctx);
+extern void MD5_Final(unsigned char *result, MD5_CTX *ctx);
+
+#ifdef MMX_COEF
+#ifdef _MSC_VER
+// NOTE, in VC, void __fastcall f(unsigned char *out, unsigned char *in, int n)
+//
+// puts these registers:
+//  n   -> pushed on stack
+//  ECX -> out
+//  EDX -> in
+//  Thus to get into this code, we ECX -> EAX and get ECX from the stack (minus the return push)
+//  Also do a ret 4 after the emms in the mdfivemmx_noinit (to pop the push of eax)
+int __fastcall mdfivemmx_VC(unsigned char *out, unsigned char *in, int n);
+int __fastcall mdfivemmx_nosizeupdate_VC(unsigned char *out, unsigned char *in, int n);
+int __fastcall mdfivemmx_noinit_sizeupdate_VC(unsigned char *out, unsigned char *in, int n);
+int __fastcall mdfivemmx_noinit_uniformsizeupdate_VC(unsigned char *out, unsigned char *in, int n);
+
+#define mdfivemmx mdfivemmx_VC
+#define mdfivemmx_nosizeupdate mdfivemmx_nosizeupdate_VC
+#define mdfivemmx_noinit_sizeupdate mdfivemmx_noinit_sizeupdate_VC
+#define mdfivemmx_noinit_uniformsizeupdate mdfivemmx_noinit_uniformsizeupdate_VC
+#else
+extern int mdfivemmx(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+extern int mdfivemmx_nosizeupdate(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+extern int mdfivemmx_noinit_sizeupdate(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+extern int mdfivemmx_noinit_uniformsizeupdate(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+#endif
+#endif
+#endif
diff -rupN john-1.7.8/src/md5_eq.c john-1.7.8-jumbo-2/src/md5_eq.c
--- john-1.7.8/src/md5_eq.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_eq.c	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,328 @@
+/*
+ * This is an OpenSSL-compatible implementation of the RSA Data Security,
+ * Inc. MD5 Message-Digest Algorithm.
+ *
+ * Written by Solar Designer <solar at openwall.com> in 2001, and placed in
+ * the public domain.  There's absolutely no warranty.
+ *
+ * This differs from Colin Plumb's older public domain implementation in
+ * that no 32-bit integer data type is required, there's no compile-time
+ * endianness configuration, and the function prototypes match OpenSSL's.
+ * The primary goals are portability and ease of use.
+ *
+ * This implementation is meant to be fast, but not as fast as possible.
+ * Some known optimizations are not included to reduce source code size
+ * and avoid compile-time configuration.
+ *
+ * This file has been modified by David Luyer <david at luyer.net> to introduce
+ * some performance improvements, at the cost of its general-purpose use.
+ * See the caveats documented above the MD5_Go() routine.
+ *
+ * New performance improvements by Balzs Bucsay.  It only works up to 54
+ * characters, but it is just enough.
+ * http://www.rycon.hu/ - earthquake at rycon.hu
+ *
+ * If you reuse the code for another purpose, please download the original from:
+ * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+
+#define CIPHERTEXT_LENGTH		32
+#define MAX_KEYS_PER_CRYPT		64
+
+/* Output words */
+
+#define MD5_out MD5_out_eq
+#define MD5_bitswapped_out MD5_bitswapped_out_eq
+
+ARCH_WORD_32 MD5_out[MAX_KEYS_PER_CRYPT];
+char MD5_tmp[MAX_KEYS_PER_CRYPT][CIPHERTEXT_LENGTH + 1];
+ARCH_WORD_32 MD5_bitswapped_out2[4];
+#if !ARCH_LITTLE_ENDIAN
+	ARCH_WORD_32 MD5_bitswapped_out[MAX_KEYS_PER_CRYPT];
+#endif
+
+/* Bit-swapped output words */
+
+#if !defined(_MD5_GO_H)
+#define _MD5_GO_H
+
+/* Any 32-bit or wider unsigned integer data type will do */
+typedef unsigned int MD5_u32plus;
+
+#endif
+
+
+/*
+ * The basic MD5 functions.
+ *
+ * F and G are optimized compared to their RFC 1321 definitions for
+ * architectures that lack an AND-NOT instruction, just like in Colin Plumb's
+ * implementation.
+ */
+#define F(x, y, z)			((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z)			((y) ^ ((z) & ((x) ^ (y))))
+#define H(x, y, z)			((x) ^ (y) ^ (z))
+#define I(x, y, z)			((y) ^ ((x) | ~(z)))
+
+/*
+ * The MD5 transformation for all four rounds.
+ */
+#define STEP(f, a, b, c, d, x, t, s) \
+	(a) += f((b), (c), (d)) + (x) + (t); \
+	(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \
+	(a) += (b);
+
+/*
+ * SET reads 4 input bytes in little-endian byte order and stores them
+ * in a properly aligned word in host byte order.
+ *
+ * The check for little-endian architectures that tolerate unaligned
+ * memory accesses is just an optimization.  Nothing will break if it
+ * doesn't work.
+ */
+#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)
+#define SET(n) \
+	(*(MD5_u32plus *)&ptr[(n) * 4])
+#define GET(n) \
+	SET(n)
+#else
+static MD5_u32plus work[16];
+#define SET(n) \
+	(work[(n)] = \
+	(MD5_u32plus)ptr[(n) * 4] | \
+	((MD5_u32plus)ptr[(n) * 4 + 1] << 8) | \
+	((MD5_u32plus)ptr[(n) * 4 + 2] << 16) | \
+	((MD5_u32plus)ptr[(n) * 4 + 3] << 24))
+#define GET(n) \
+	(work[(n)])
+#endif
+
+/*
+ * This processes one or more 64-byte data blocks, but does NOT update
+ * the bit counters.  There are no alignment requirements.
+ */
+static void body2_eq(void *data, int index)
+{
+	unsigned char *ptr;
+	MD5_u32plus a, b, c, d;
+
+	ptr = data;
+
+	a = 0x67452301;
+	b = 0xefcdab89;
+	c = 0x98badcfe;
+	d = 0x10325476;
+
+/* Round 1 */
+	STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)
+	STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)
+	STEP(F, c, d, a, b, SET(2), 0x242070db, 17)
+	STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)
+	STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)
+	STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)
+	STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)
+	STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)
+	STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)
+	STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)
+	STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)
+	STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)
+	STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)
+	STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)
+	STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)
+	STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)
+
+/* Round 2 */
+	STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)
+	STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)
+	STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)
+	STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)
+	STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)
+	STEP(G, d, a, b, c, GET(10), 0x02441453, 9)
+	STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)
+	STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)
+	STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)
+	STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)
+	STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)
+	STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)
+	STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)
+	STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)
+	STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)
+	STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)
+
+/* Round 3 */
+	STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)
+	STEP(H, d, a, b, c, GET(8), 0x8771f681, 11)
+	STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)
+	STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)
+	STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)
+	STEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)
+	STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)
+	STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)
+	STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)
+	STEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)
+	STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)
+	STEP(H, b, c, d, a, GET(6), 0x04881d05, 23)
+	STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)
+	STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)
+	STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)
+	STEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)
+
+/* Round 4 */
+	STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)
+	STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)
+	STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)
+	STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)
+	STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)
+	STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)
+	STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)
+	STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)
+	STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)
+	STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)
+	STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)
+	STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)
+	STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)
+	STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)
+	STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)
+	STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)
+
+	a += 0x67452301;
+	b += 0xefcdab89;
+	c += 0x98badcfe;
+	d += 0x10325476;
+
+        MD5_bitswapped_out2[0] = (a << 24) |
+				(a >> 24) |
+				((a << 8) & 0x00ff0000) |
+				((a >> 8) & 0x0000ff00);
+        MD5_bitswapped_out2[1] = (b << 24) |
+				(b >> 24) |
+				((b << 8) & 0x00ff0000) |
+				((b >> 8) & 0x0000ff00);
+        MD5_bitswapped_out2[2] = (c << 24) |
+				(c >> 24) |
+				((c << 8) & 0x00ff0000) |
+				((c >> 8) & 0x0000ff00);
+        MD5_bitswapped_out2[3] = (d << 24) |
+				(d >> 24) |
+				((d << 8) & 0x00ff0000) |
+				((d >> 8) & 0x0000ff00);
+
+        sprintf(MD5_tmp[index], "%08x%08x%08x%08x", (unsigned int)MD5_bitswapped_out2[0], (unsigned int)MD5_bitswapped_out2[1], (unsigned int)MD5_bitswapped_out2[2], (unsigned int)MD5_bitswapped_out2[3]);
+}
+
+static void body_eq(void *data, int index)
+{
+	unsigned char *ptr;
+	MD5_u32plus a, b, c, d;
+
+	ptr = data;
+
+	a = 0x67452301;
+	b = 0xefcdab89;
+	c = 0x98badcfe;
+	d = 0x10325476;
+
+/* Round 1 */
+	STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)
+	STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)
+	STEP(F, c, d, a, b, SET(2), 0x242070db, 17)
+	STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)
+	STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)
+	STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)
+	STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)
+	STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)
+	STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)
+	STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)
+	STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)
+	STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)
+	STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)
+	STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)
+	STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)
+	STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)
+
+/* Round 2 */
+	STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)
+	STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)
+	STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)
+	STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)
+	STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)
+	STEP(G, d, a, b, c, GET(10), 0x02441453, 9)
+	STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)
+	STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)
+	STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)
+	STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)
+	STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)
+	STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)
+	STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)
+	STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)
+	STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)
+	STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)
+
+/* Round 3 */
+	STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)
+	STEP(H, d, a, b, c, GET(8), 0x8771f681, 11)
+	STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)
+	STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)
+	STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)
+	STEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)
+	STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)
+	STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)
+	STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)
+	STEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)
+	STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)
+	STEP(H, b, c, d, a, GET(6), 0x04881d05, 23)
+	STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)
+	STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)
+	STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)
+	STEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)
+
+/* Round 4 */
+	STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)
+	STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)
+	STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)
+	STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)
+	STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)
+	STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)
+	STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)
+	STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)
+	STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)
+	STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)
+	STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)
+	STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)
+	STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)
+
+	MD5_out[index] = a + 0x67452301;
+
+}
+
+
+void MD5_Go_eq(unsigned char *data, unsigned int len, int index)
+{
+	data[len] = 0x80;
+	memset(&data[len+1], 0, 63 - len);
+	data[56] = len << 3;
+	data[57] = len >> 5;
+	body_eq(data, index);
+
+#if !ARCH_LITTLE_ENDIAN
+        MD5_bitswapped_out[index] = (MD5_out[index] << 24) |
+				(MD5_out[index] >> 24) |
+				((MD5_out[index] << 8) & 0x00ff0000) |
+				((MD5_out[index] >> 8) & 0x0000ff00);
+#endif
+}
+
+void MD5_Go2_eq(unsigned char *data, unsigned int len, int index)
+{
+  	data[len] = 0x80;
+	memset(&data[len+1], 0, 63 - len);
+	data[56] = len << 3;
+	data[57] = len >> 5;
+	body2_eq(data, index);
+}
diff -rupN john-1.7.8/src/md5_gen.h john-1.7.8-jumbo-2/src/md5_gen.h
--- john-1.7.8/src/md5_gen.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_gen.h	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,273 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Generic MD5 hashes cracker
+ *
+ * Interface functions and data structures required to make this
+ * work, since it is split over multiple .c source files.
+ *
+ */
+
+#if !defined (__MD5_GEN___H)
+#define __MD5_GEN___H
+
+typedef void(*MD5_GEN_primitive_funcp)();
+
+typedef struct MD5_GEN_Constants_t
+{
+	char *Const;
+} MD5_GEN_Constants;
+
+// These are the 'flags' that specify certain characterstics of the format.
+// Things like salted, not sse2, and special 'loading' of the keys.
+#define MGF_NO_FLAG                  0x0000000
+#define MGF_NOTSSE2Safe              0x0000001
+#define MGF_ColonNOTValid            0x0000002
+#define MGF_SALTED                   0x0000004
+#define MGF_SALTED2                  0x0000008
+#define MGF_USERNAME                 0x0000010
+#define MGF_USERNAME_UPCASE         (0x0000020|MGF_USERNAME)
+#define MGF_USERNAME_LOCASE         (0x0000040|MGF_USERNAME)
+#define MGF_INPBASE64		         0x0000080
+#define MGF_SALT_AS_HEX		        (0x0000100|MGF_SALTED)
+#define MGF_INPBASE64_4x6			 0x0000200
+#define MGF_StartInX86Mode           0x0000400
+#define MGF_SALT_AS_HEX_TO_SALT2    (0x0000800|MGF_SALTED)
+#define MGF_SALT_UNICODE_B4_CRYPT    0x0001000
+#define MGF_BASE_16_OUTPUT_UPCASE    0x0002000
+#define MGF_HDAA_SALT               (0x0004000|MGF_SALTED)
+#define MGF_FLD0                     0x0008000
+#define MGF_FLD1                     0x0010000
+#define MGF_FLD2                     0x0020000
+#define MGF_FLD3                     0x0040000
+#define MGF_FLD4                     0x0080000
+#define MGF_FLD5                     0x0100000
+#define MGF_FLD6                     0x0200000
+#define MGF_FLD7                     0x0400000
+#define MGF_FLD8                     0x0800000
+#define MGF_FLD9                     0x1000000
+#define MGF_SHA1_40_BYTE_FINISH      0x2000000
+#define MGF_INPBASE64a		         0x4000000
+
+// These are special loader flags.  They specify that keys loads are 'special', and
+// do MORE than simply load keys into the keys[] array.  They may preload the keys
+// into input, may load keys into keys, but call crypt, may do that and call base16
+// convert, and may even point different functions than 'defalt' (such as phpass).
+// If high bit of flags is set, then at least ONE of these flags has been used
+#define MGF_KEYS_INPUT                   0x0001
+#define MGF_KEYS_CRYPT_IN2               0x0002
+#define MGF_KEYS_BASE16_IN1              0x0004
+#define MGF_KEYS_BASE16_IN1_Offset32     0x0008
+#define MGF_KEYS_BASE16_X86_IN1          0x0010
+#define MGF_KEYS_BASE16_X86_IN1_Offset32 0x0020
+// the unicode_b4_crypt does a unicode convert, prior to crypt_in2, base16-in1, etc.  It can NOT be used with KEYS_INPUT.
+#define MGF_KEYS_UNICODE_B4_CRYPT        0x1000
+#define MGF_PHPassSetup                  0x0040
+#define MGF_POSetup                      0x0080
+#define MGF_FreeBSDMD5Setup              0x0100
+#define MGF_RAW_SHA1_INPUT               0x0200
+#define MGF_KEYS_INPUT_BE_SAFE           0x0400
+
+typedef struct MD5_GEN_Setup_t
+{
+	char *szFORMAT_NAME;  // md5(md5($p).$s) etc
+
+	// Ok, this will be the functions to 'use'.
+	// This should be a 'null' terminated list.  5000 is MAX.
+	MD5_GEN_primitive_funcp *pFuncs;
+	struct fmt_tests *pPreloads;
+	MD5_GEN_Constants *pConstants;
+	unsigned flags;
+	unsigned startFlags;
+	int SaltLen;
+	int MaxInputLen;
+} MD5_GEN_Setup;
+
+int md5_gen_SETUP(MD5_GEN_Setup *, struct fmt_main *pFmt);
+int md5_gen_IS_VALID(int i);
+void md5_gen_RESET(struct fmt_main *);
+void md5_gen_DISPLAY_ALL_FORMATS();
+
+// Function used to 'link' a thin format into md5-gen.  See PHPS_fmt.c for an example.
+struct fmt_main *md5_gen_THIN_FORMAT_LINK(struct fmt_main *pFmt, char *ciphertext, char *orig_sig);
+
+// We need access to this global to get functions and data which we 'link' to
+//extern struct fmt_main fmt_MD5gen;
+int md5_gen_Register_formats(struct fmt_main **ptr);
+
+int md5_gen_RESERVED_PRELOAD_SETUP(int cnt, struct fmt_main *pFmt);
+char *md5_gen_PRELOAD_SIGNATURE(int cnt);
+int md5_gen_IS_PARSER_VALID(int which);
+
+// Here are the 'parser' functions (i.e. user built stuff in john.conf)
+int  md5_gen_LOAD_PARSER_FUNCTIONS(int which, struct fmt_main *pFmt);
+char *md5_gen_LOAD_PARSER_SIGNATURE(int which);
+
+// extern demange.  Turns \xF7 into 1 char.  Turns \x1BCA into "esc C A" string (3 bytes).  Turns abc\\123 into abc\123, etc.
+char *md5_gen_Demangle(char *Line);
+
+#define ARRAY_COUNT(a) (sizeof(a)/sizeof(a[0]))
+
+//
+// These functions MUST be of type:   void function()
+// these are the 'base' predicate functions used in
+// building a generic MD5 attack algorithm.
+//
+
+extern void MD5GenBaseFunc__clean_input();
+extern void MD5GenBaseFunc__clean_input_kwik();
+extern void MD5GenBaseFunc__clean_input_full();
+extern void MD5GenBaseFunc__append_keys();
+extern void MD5GenBaseFunc__crypt();
+extern void MD5GenBaseFunc__append_from_last_output_as_base16();
+extern void MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix();
+extern void MD5GenBaseFunc__append_salt();
+extern void MD5GenBaseFunc__set_input_len_16();
+extern void MD5GenBaseFunc__set_input_len_32();
+extern void MD5GenBaseFunc__set_input_len_64();
+
+extern void MD5GenBaseFunc__clean_input2();
+extern void MD5GenBaseFunc__clean_input2_kwik();
+extern void MD5GenBaseFunc__clean_input2_full();
+extern void MD5GenBaseFunc__append_keys2();
+extern void MD5GenBaseFunc__crypt2();
+extern void MD5GenBaseFunc__append_from_last_output2_as_base16();
+extern void MD5GenBaseFunc__overwrite_from_last_output2_as_base16_no_size_fix();
+extern void MD5GenBaseFunc__append_from_last_output_to_input2_as_base16();
+extern void MD5GenBaseFunc__overwrite_from_last_output_to_input2_as_base16_no_size_fix();
+extern void MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16();
+extern void MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix();
+extern void MD5GenBaseFunc__append_salt2();
+extern void MD5GenBaseFunc__set_input2_len_16();
+extern void MD5GenBaseFunc__set_input2_len_32();
+extern void MD5GenBaseFunc__set_input2_len_64();
+
+extern void MD5GenBaseFunc__append_from_last_output2_as_raw();
+extern void MD5GenBaseFunc__append2_from_last_output2_as_raw();
+extern void MD5GenBaseFunc__append_from_last_output1_as_raw();
+extern void MD5GenBaseFunc__append2_from_last_output1_as_raw();
+
+extern void MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix();
+extern void MD5GenBaseFunc__overwrite_salt_to_input2_no_size_fix();
+
+extern void MD5GenBaseFunc__append_input_from_input2();
+extern void MD5GenBaseFunc__append_input2_from_input();
+
+extern void MD5GenBaseFunc__append_2nd_salt();
+extern void MD5GenBaseFunc__append_2nd_salt2();
+extern void MD5GenBaseFunc__append_userid();
+extern void MD5GenBaseFunc__append_userid2();
+
+extern void MD5GenBaseFunc__crypt_in1_to_out2();
+extern void MD5GenBaseFunc__crypt_in2_to_out1();
+
+extern void MD5GenBaseFunc__append_input1_from_CONST1();
+extern void MD5GenBaseFunc__append_input1_from_CONST2();
+extern void MD5GenBaseFunc__append_input1_from_CONST3();
+extern void MD5GenBaseFunc__append_input1_from_CONST4();
+extern void MD5GenBaseFunc__append_input1_from_CONST5();
+extern void MD5GenBaseFunc__append_input1_from_CONST6();
+extern void MD5GenBaseFunc__append_input1_from_CONST7();
+extern void MD5GenBaseFunc__append_input1_from_CONST8();
+
+extern void MD5GenBaseFunc__append_input2_from_CONST1();
+extern void MD5GenBaseFunc__append_input2_from_CONST2();
+extern void MD5GenBaseFunc__append_input2_from_CONST3();
+extern void MD5GenBaseFunc__append_input2_from_CONST4();
+extern void MD5GenBaseFunc__append_input2_from_CONST5();
+extern void MD5GenBaseFunc__append_input2_from_CONST6();
+extern void MD5GenBaseFunc__append_input2_from_CONST7();
+extern void MD5GenBaseFunc__append_input2_from_CONST8();
+
+extern void MD5GenBaseFunc__append_fld0();
+extern void MD5GenBaseFunc__append_fld1();
+extern void MD5GenBaseFunc__append_fld2();
+extern void MD5GenBaseFunc__append_fld3();
+extern void MD5GenBaseFunc__append_fld4();
+extern void MD5GenBaseFunc__append_fld5();
+extern void MD5GenBaseFunc__append_fld6();
+extern void MD5GenBaseFunc__append_fld7();
+extern void MD5GenBaseFunc__append_fld8();
+extern void MD5GenBaseFunc__append_fld9();
+extern void MD5GenBaseFunc__append2_fld0();
+extern void MD5GenBaseFunc__append2_fld1();
+extern void MD5GenBaseFunc__append2_fld2();
+extern void MD5GenBaseFunc__append2_fld3();
+extern void MD5GenBaseFunc__append2_fld4();
+extern void MD5GenBaseFunc__append2_fld5();
+extern void MD5GenBaseFunc__append2_fld6();
+extern void MD5GenBaseFunc__append2_fld7();
+extern void MD5GenBaseFunc__append2_fld8();
+extern void MD5GenBaseFunc__append2_fld9();
+
+// These are no-ops if built in x86 mode.  But in SSE2 builds, they do
+// allow us to switch back and forth from SSE to X86 mode (and back again)
+// they also convert data (only convert the NEEDED) stored data.  Additional
+// fields will cost time, and are not needed.
+extern void MD5GenBaseFunc__SSEtoX86_switch_input1();
+extern void MD5GenBaseFunc__SSEtoX86_switch_input2();
+extern void MD5GenBaseFunc__SSEtoX86_switch_output1();
+extern void MD5GenBaseFunc__SSEtoX86_switch_output2();
+extern void MD5GenBaseFunc__X86toSSE_switch_input1();
+extern void MD5GenBaseFunc__X86toSSE_switch_input2();
+extern void MD5GenBaseFunc__X86toSSE_switch_output1();
+extern void MD5GenBaseFunc__X86toSSE_switch_output2();
+extern void MD5GenBaseFunc__ToSSE();
+extern void MD5GenBaseFunc__ToX86();
+// set unicode mode.
+extern void MD5GenBaseFunc__setmode_unicode();
+extern void MD5GenBaseFunc__setmode_normal();
+// Changing upper case and lower case base-16 conversion routines
+extern void MD5GenBaseFunc__base16_convert_locase();
+extern void MD5GenBaseFunc__base16_convert_upcase();
+
+extern void MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16();
+extern void MD5GenBaseFunc__SHA1_crypt_input2_append_input1_base16();
+extern void MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input1_base16();
+extern void MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16();
+extern void MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input2_base16();
+extern void MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input1_base16();
+extern void MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL();
+extern void MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL();
+
+
+// These 3 dump the raw crypt back into input (only at the head of it).
+// they are for phpass, wordpress, etc.
+extern void MD5GenBaseFunc__crypt_to_input_raw();
+extern void MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen();
+// NOTE, the below line is called 'one' time.  It calls the 'normal' crypt mdfivemmx (and intrinsic loading)
+// for the lengths.  The lengths are not modified, but are need to be set ONCE.  From that point on,
+// we simply call the MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen and it calls mdfivemmx_nosizeupdate
+// which is a faster call (and the intrincs do NOT call SSE_Intrinsics_LoadLens within the
+// MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen function)   Splitting this up into 2, gives
+// us a 1 or 2% speed increase.
+extern void MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen_but_setlen_in_SSE();
+
+// special for phpass
+extern void MD5GenBaseFunc__PHPassCrypt();
+// special for PO
+extern void MD5GenBaseFunc__POCrypt();
+// special for OpenBSD MD5 and Apache MD5
+extern void MD5GenBaseFunc__FreeBSDMD5Crypt();
+
+// End of generic md5 'types' and helpers
+
+// Depricated 'functions'  These are now 'flags'. We handle them by 'adding' the proper flags, but allow the script
+// to run IF the user has these fake functions as the first function.
+extern void MD5GenBaseFunc__PHPassSetup();
+extern void MD5GenBaseFunc__InitialLoadKeysToInput();
+extern void MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2();
+extern void MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1();
+extern void MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1_offset32();
+
+
+#endif // __MD5_GEN___H
diff -rupN john-1.7.8/src/md5_gen_fmt.c john-1.7.8-jumbo-2/src/md5_gen_fmt.c
--- john-1.7.8/src/md5_gen_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_gen_fmt.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,6547 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Generic MD5 hashes cracker
+ *
+ * It uses the openSSL md5 for x86, and MMX/SSE2 md5 from md5-mmx.S
+ *
+ *  TODO's
+ *    1.  (DONE!!) in the MMX/SSE2 builds, ALSO make sure native x86 (using OpenSSL), is built.
+ *        Then if the format is a NON-SSE safe format, link the functions to the non-x86 versions.
+ *        In x86 mode, we DO NOT need to have the SSE2 code, since it is not valid to call anyway.
+ *    2.  (DONE) Add SSE Intrisic code.  MD5_PARA (as built by simon), IS now working.
+ *    3.  Start making 'thin' _fmt.c files for other 'formats'.
+ *          Easy formats:
+ *            DMD5               (Is a challenge/response, so may need to simply be 'redone'
+ *            MD5_apache_fmt.c   (harder)
+ *            md5_fmt.c          (harder)
+ *            HDAA_fmt.c         (DONE)
+ *            pixMD5_fmt.c       (DONE)
+ *            raw_md5_fmt.c      (DONE)
+ *            PO_fmt.c           (DONE)
+ *            phpassMD5_fmt.c    (DONE)
+ *            PHPS_fmt.c         (DONE)
+ *            IPB2_fmt.c         (DONE)
+ *    4.  Made 10 primatives which allow us to switch back and forth from SSE (1 MD5 buffer), to X86, multiple buffers. Thus, we
+ *        can write SSE formats, and when they overflow, switch to x86, perform the MD5, and switch back.  A good example is type
+ *        md5_gen(13) md5(md5($p).md5($s))   Here, we preload $s, so it does not play a part in the runtime.  However, the
+ *        first md5($p) CAN be done in SSE mode. Then we switch to x86, and perform the MD5 of the 64 byte string.  This increases
+ *        throughput about 150%.
+ *    5.  Found and fixed a bug in the MMX string concatentation code.
+ *    6.  Generated a 'test-suite' format.
+ *
+ * Only valid up to 54 bytes max string length (salts, rehashes,
+ * passwords, etc) if using SSE2.  96 byte keys (appended salts,
+ * keys, re-hashes, etc), if running under x86 mode.  NOTE some
+ * hashes will NOT run properly under SSE2.  A hash such as
+ * md5(md5($p).md5($s)) would fail under SSE2, since it always
+ * would need at least 64 bytes to complete but even md5($p) would
+ * fail in SSE2 if the password is over 54 bytes.  NOTE no run-time
+ * checks are made so if you provide data too large, it will not find
+ * the hash, and will 'overwrite' some of the hashes being worked on,
+ * and cause them to have invalid results. This is a bug that 'might'
+ * be worked on, but I do not want do slow the cracking down performing
+ * checks.
+ *
+ * This code has gone through a few iterations, and now is quite a bit
+ * more mature.  It has been designed with an array for keys (which
+ * is optionally used), a slot for the current salt, 2 arrays for
+ * input buffers (there is optional loading that loads keys directly
+ * into input buffer #1 as an optimization for certain formats), and
+ * a pair of arrays for crypt outputs.  The 'first' output buffer array
+ * is used to return the final results.  There is also 2 arrays of lengths
+ * of input buffers.  There are then 'primative' functions. These can
+ * append keys, append salts, blank out keys, move from input 1 to input
+ * 2, crypt input 1 -> output 1, (or from 1->2 or 2->2 or 2->1, etc).
+ * There are functions that do base 16 conversions of the outputs back
+ * into inputs (O1->I1 in base 16, 1->2 2->2 2->1, etc).  There are
+ * functions that over write the start of an input buffer from outputs
+ * without 'adjusting' the lengths.  There are a few special functions
+ * to do phpass work.
+ *
+ * Then there are helper functions which allow another format to 'use'
+ * the generic MD5 code.  So, we can make a VERY thin raw-md5 (or phpass
+ * md5), where it simply has a format structure (which does not need to be
+ * 'heavily' filled out, and that format only needs to implement a few
+ * functions on its own.  It would need to implement init, valid, salt
+ * and binary.  Then there needs to be a 'conversion' function that
+ * converts from the 'native' format, into the native GENERIC format.
+ * Then, within the init function, that format would hook into the
+ * generic md5, by calling the md5_gen_RESET_LINK() function, passing
+ * in its Format structure to have functions pointed into the md5 generic
+ * stuff.  The conversion function is likely very trivial. For phpass, we
+ * convert from
+ * $H$9aaaaaSXBjgypwqm.JsMssPLiS8YQ00
+ * to
+ * md5_gen(17)jgypwqm.JsMssPLiS8YQ00$9aaaaaSXB
+ *
+ *  Here is that convert function:
+ * static char *Convert(char *Buf, char *ciphertext) {
+ *    sprintf(Buf, "md5_gen(17)%s%10.10s", &ciphertext[3+8+1], &ciphertext[2]);
+ *    return Buf;
+ * }
+ *
+ *
+ * Generic MD5 can now be user expanded.  The first 1000 md5_gen(#) are
+ * reserved as 'built-in' functions for john. Above 1000 is free to use
+ * for anyone wanting to do so.  NO programming changes are needed to
+ * add a format. All that is needed is modifcations to john.conf.  There is
+ * FULL documentation about how to do this in doc/MD5_GENERIC.  There is
+ * no parser 'generation' logic.  A person would have to understand the
+ * primitive functions and how they work.  But the format can be added
+ * without a rebuild of john.  There are 7 (or 8) examples already done
+ * in john.conf at this time, which should make it pretty easy for someone
+ * wanting to do a new or obscure format.
+ *
+ * Recent additions / fixes
+ *
+ *   SSE2 intrinsics
+ *   Faster (double speed) for a couple formats
+ *   Addition of PO format (Native and using constants)
+ *   Addition of 8 'constant' fields'
+ *   In MD5_COEF builds, the not-SSE-safe formats now work (using x86 code)
+ *   MD5_go functions used (10% faster than OpenSSL).
+ *
+ */
+
+#include <string.h>
+#include <time.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5.h"
+#include "md5_gen.h"
+#include "options.h"
+#include "config.h"
+#include "sha.h"
+#include "memory.h"
+
+extern struct fmt_main fmt_MD5gen;
+static struct fmt_main *pFmts;
+static int nFmts;
+static int force_md5_ctx;
+
+/* these are 'low level' inner loop data maniplation functions. Some work */
+/* faster on certain CPU, and some on other CPU's.  At this time, simply  */
+/* use #defines to select the 'fastest' one.   When benching, the 'raw'   */
+/* timings are shown, and the fastest one can then be selected            */
+/*  On my core2, __SSE_append_output_base16_to_input_2 is fastest         */
+/*  On my Ath64, __SSE_append_output_base16_to_input_3 is fastest (32 bit mode */
+#define LOW_BASE16_INPUT_TYPE 3
+#define LOW_BASE16_INPUT_SEMI0_TYPE 2
+#define LOW_BASE16_INPUT_SEMI2_TYPE 1
+
+#define __SSE_append_output_base16_to_input __SSE_append_output_base16_to_input_3
+#define __SSE_append_output_base16_to_input_semi_aligned_0 __SSE_append_output_base16_to_input_semi_aligned0_2
+#define __SSE_append_output_base16_to_input_semi_aligned_2 __SSE_append_output_base16_to_input_semi_aligned2_1
+//NOTE, for the 'DEEP_TIME_TEST' to be used, you MUST have timer.c and timer.h
+//#define DEEP_TIME_TEST
+
+typedef ARCH_WORD_32 MD5_word;
+
+typedef struct {
+	union {
+		double dummy;
+		MD5_word w[4];
+		char b[16];
+		unsigned char B[16];
+	}x1;
+#if MD5_X2
+	union {
+		double dummy2;
+		MD5_word w2[4];
+		char b2[16];
+		unsigned char B2[16];
+	}x2;
+#endif
+} MD5_OUT;
+typedef union {
+	double dummy;
+	MD5_word w[5];
+	char b[20];
+	unsigned char B[16];
+} SHA1_OUT;
+
+#if ARCH_LITTLE_ENDIAN
+// MD5_go is SUPER slow on big endian. In the case of bigendian, we simply
+// fall back, and use OpenSSL MD5 calls, which are usually MUCH faster.
+#define USE_MD5_Go
+#define ROTATE_LEFT(x, n) (x) = (((x)<<(n))|((MD5_word)(x)>>(32-(n))))
+#define MD5_swap(x, y, count)
+#define MD5_swap2(a,b,c,d,e)
+#ifdef SHA1_SSE_PARA
+static void SHA1_swap(MD5_word *x, MD5_word *y, int count)
+{
+	MD5_word tmp;
+	do {
+		tmp = *x++;
+		ROTATE_LEFT(tmp, 16);
+		*y++ = ((tmp & 0x00FF00FF) << 8) | ((tmp >> 8) & 0x00FF00FF);
+	} while (--count);
+}
+#endif
+#else
+extern char *MD5_DumpHexStr(void *p);
+#define ROTATE_LEFT(x, n) (x) = (((x)<<(n))|((MD5_word)(x)>>(32-(n))))
+static void MD5_swap(MD5_word *x, MD5_word *y, int count)
+{
+	MD5_word tmp;
+	do {
+		tmp = *x++;
+		ROTATE_LEFT(tmp, 16);
+		*y++ = ((tmp & 0x00FF00FF) << 8) | ((tmp >> 8) & 0x00FF00FF);
+	} while (--count);
+}
+#if MD5_X2
+static void MD5_swap2(MD5_word *x, MD5_word *x2, MD5_word *y, MD5_word *y2, int count)
+{
+	MD5_word tmp, tmp2;
+	do {
+		tmp = *x++;
+		tmp2 = *x2++;
+		ROTATE_LEFT(tmp, 16);
+		ROTATE_LEFT(tmp2, 16);
+		*y++ = ((tmp & 0x00FF00FF) << 8) | ((tmp >> 8) & 0x00FF00FF);
+		*y2++ = ((tmp2 & 0x00FF00FF) << 8) | ((tmp2 >> 8) & 0x00FF00FF);
+	} while (--count);
+}
+#endif
+#define SHA1_swap(x,y,z)
+#endif
+
+#ifdef DEEP_TIME_TEST
+static int __SSE_gen_bBenchThisTime;
+static void __SSE_gen_BenchLowLevelFunctions();
+#endif
+
+#ifdef MD5_SSE_PARA
+#undef MMX_COEF
+#define MMX_COEF 4
+#define shammx(a,b,c)
+#endif
+
+#define FORMAT_LABEL		"md5-gen"
+#define FORMAT_NAME         "Generic MD5"
+
+#ifdef MMX_COEF
+
+#ifdef MD5_SSE_PARA
+#define BSD_BLKS (MD5_SSE_PARA)
+#else
+#define BSD_BLKS 1
+#endif
+
+#if (MMX_COEF == 2)
+#define BLOCK_LOOPS			64
+#define ALGORITHM_NAME		"MMX 64x2 (.S)"
+#else // MMX_COEF != 2
+#define BLOCK_LOOPS			32
+#ifdef MD5_SSE_PARA
+#include "sse-intrinsics.h"
+#if (MD5_SSE_PARA==1)
+#define ALGORITHM_NAME		"SSE2 32x4x1 (intr)"
+#elif (MD5_SSE_PARA==2)
+#define ALGORITHM_NAME		"SSE2 16x4x2 (intr)"
+#elif (MD5_SSE_PARA==3)
+#define ALGORITHM_NAME		"SSE2 10x4x3 (intr)"
+#elif (MD5_SSE_PARA==4)
+#define ALGORITHM_NAME		"SSE2 8x4x4 (intr)"
+#elif (MD5_SSE_PARA==5)
+#define ALGORITHM_NAME		"SSE2 6x4x5 (intr)"
+#elif (MD5_SSE_PARA==6)
+#define ALGORITHM_NAME		"SSE2 5x4x6 (intr)"
+#else //if (MD5_SSE_PARA==8)
+#define ALGORITHM_NAME		"SSE2 4x4x8 (intr)"
+#endif // MD5_SSE_PARA
+#else  // !MD5_SSE_PARA
+#define ALGORITHM_NAME		"SSE2 32x4 (.S)"
+#endif // PARA
+#endif // MMX_COEF == 4
+
+#define PLAINTEXT_LENGTH	55
+#define MIN_KEYS_PER_CRYPT	1
+#ifdef MD5_SSE_PARA
+// gives us 16 'loops' for para=2 and 10 loops for para==3 (or max of 128 for 2 and 120 for 3)
+#define MAX_KEYS_PER_CRYPT	(((MMX_COEF*BLOCK_LOOPS)/(MD5_SSE_PARA*4))*(MD5_SSE_PARA*4))
+#else
+#define MAX_KEYS_PER_CRYPT	MMX_COEF*BLOCK_LOOPS
+#endif
+#define GETPOS(i, index)		( (index)*4 + ((i) & (0xffffffff-3) )*MMX_COEF + ((i)&3) )
+#define SHAGETPOS(i, index)		( (index)*4 + ((i) & (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) ) //for endianity conversion
+#endif 	// MMX_COEF
+// Would LOVE to go to 128 bytes (would allow md5(md5($p).md5($p).md5($p).md5($p)) but
+// due to other parts of john, we can only go to 128-3 as max sized plaintext.
+#define PLAINTEXT_LENGTH_X86		124
+
+#ifdef USE_MD5_Go
+#define MIN_KEYS_PER_CRYPT_X86	1
+#define MAX_KEYS_PER_CRYPT_X86	128
+extern void MD5_Go2 (unsigned char *data, unsigned int len, unsigned char *result);
+#if MD5_X2
+#define ALGORITHM_NAME_X86		"64x2 (MD5_Body)"
+//extern void MD5_bodyX(MD5_word x[15], MD5_word x2[15], MD5_word out[4], MD5_word out2[4]);
+//#define DoMD5(A,L,C) do{if(!force_md5_ctx&&(L[0])<55&&(L[1])<55) {A.x1.b[L[0]]=0x80;A.x2.b2[L[1]]=0x80;A.x1.w[14]=(L[0]<<3);A.x2.w2[14]=(L[1]<<3);MD5_swap(A.x1.w,A.x1.w,(L[0]+4)>>2);MD5_swap(A.x2.w2,A.x2.w2,(L[1]+4)>>2);MD5_bodyX(A.x1.w,A.x2.w2,C.x1.w,C.x2.w2);MD5_swap2(C.x1.w,C.x2.w2,C.x1.w,C.x2.w2,4);} else {MD5_Go2(A.x1.B,L[0],C.x1.B); MD5_Go2(A.x2.B2,L[1],C.x2.B2);} }while(0)
+//#define DoMD5o(A,L,C) do{if((L[0])<55&&(L[1])<55) {MD5_bodyX(A.x1.w,A.x2.w2,C.x1.w,C.x2.w2);} else {MD5_Go2(A.x1.B,L[0],C.x1.B); MD5_Go2(A.x2.B2,L[1],C.x2.B2);} }while(0)
+extern void MD5_body(MD5_word x[15], MD5_word x2[15], MD5_word out[4], MD5_word out2[4]);
+#define DoMD5(A,L,C) do{if(!force_md5_ctx&&(L[0])<55&&(L[1])<55) {A.x1.b[L[0]]=0x80;A.x2.b2[L[1]]=0x80;A.x1.w[14]=(L[0]<<3);A.x2.w2[14]=(L[1]<<3);MD5_swap(A.x1.w,A.x1.w,(L[0]+4)>>2);MD5_swap(A.x2.w2,A.x2.w2,(L[1]+4)>>2);MD5_body(A.x1.w,A.x2.w2,C.x1.w,C.x2.w2);MD5_swap2(C.x1.w,C.x2.w2,C.x1.w,C.x2.w2,4);} else {MD5_Go2(A.x1.B,L[0],C.x1.B); MD5_Go2(A.x2.B2,L[1],C.x2.B2);} }while(0)
+#define DoMD5o(A,L,C) do{if((L[0])<55&&(L[1])<55) {MD5_body(A.x1.w,A.x2.w2,C.x1.w,C.x2.w2);} else {MD5_Go2(A.x1.B,L[0],C.x1.B); MD5_Go2(A.x2.B2,L[1],C.x2.B2);} }while(0)
+#if ARCH_LITTLE_ENDIAN
+//#define DoMD5a(A,L,C) MD5_bodyX(A->x1.w,A->x2.w2,C->x1.w,C->x2.w2)
+//#define DoMD5a2(A,L,C,D) MD5_bodyX(A->x1.w,A->x2.w2, (ARCH_WORD_32*)D[0], (ARCH_WORD_32*)D[1])
+#define DoMD5a(A,L,C) MD5_body(A->x1.w,A->x2.w2,C->x1.w,C->x2.w2)
+#define DoMD5a2(A,L,C,D) MD5_body(A->x1.w,A->x2.w2, (ARCH_WORD_32*)D[0], (ARCH_WORD_32*)D[1])
+#else
+#define DoMD5a(A,L,C) do{MD5_body(A->x1.w,A->x2.w2,C->x1.w,C->x2.w2);MD5_swap2(C->x1.w,C->x2.w2,C->x1.w,C->x2.w2,4);}while(0)
+#define DoMD5a2(A,L,C,D) do{MD5_body(A->x1.w,A->x2.w2,tmpOut.x1.w,tmpOut.x2.w2);MD5_swap2(tmpOut.x1.w,tmpOut.x2.w2,tmpOut.x1.w,tmpOut.x2.w2,4);memcpy(&(C->x1.b[D[0]]),tmpOut.x1.b,16);memcpy(&(C->x2.b2[D[1]]),tmpOut.x2.b2,16);}while(0)
+#endif
+#else
+#define ALGORITHM_NAME_X86		"128x1 (MD5_Body)"
+extern void MD5_body(ARCH_WORD_32 x[15], ARCH_WORD_32 out[4]);
+#define DoMD5(A,L,C) do{if(!force_md5_ctx&&(L)<55) {A.x1.b[L]=0x80;A.x1.w[14]=(L<<3);MD5_swap(A.x1.w,A.x1.w,((L+4)>>2));MD5_body(A.x1.w,C.x1.w);MD5_swap(C.x1.w,C.x1.w,4);} else MD5_Go2(A.x1.B,L,C.x1.B); }while(0)
+#define DoMD5o(A,L,C) do{if((L)<55) {MD5_body(A.x1.w,C.x1.w);} else MD5_Go2(A.x1.B,L,C.x1.B); }while(0)
+#if ARCH_LITTLE_ENDIAN
+#define DoMD5a(A,L,C) MD5_body(A->x1.w,C->x1.w)
+#define DoMD5a2(A,L,C,D) MD5_body(A->x1.w,(ARCH_WORD_32*)D)
+#else
+static MD5_OUT tmpOut;
+#define DoMD5a(A,L,C) do{MD5_body(A->x1.w,C->x1.w);MD5_swap(C->x1.w,C->x1.w,4);}while(0)
+#define DoMD5a2(A,L,C,D) do{MD5_body(A->x1.w,tmpOut.x1.w);MD5_swap(tmpOut.x1.w,tmpOut.x1.w,4);memcpy(&(C->x1.b[D[0]]),tmpOut.x1.b,16);}while(0)
+#endif
+#endif
+#else // !USE_MD5_Go
+static MD5_OUT tmpOut;
+#define MIN_KEYS_PER_CRYPT_X86	1
+#define MAX_KEYS_PER_CRYPT_X86	128
+#if MD5_X2
+#define ALGORITHM_NAME_X86		"64x2 (MD5_body)"
+void MD5_body(ARCH_WORD_32 x1[15], ARCH_WORD_32 x2[15], ARCH_WORD_32 out1[4], ARCH_WORD_32 out2[4]);
+#define DoMD5(A,L,C) do{if(!force_md5_ctx&&(L[0])<55&&(L[1])<55) {A.x1.b[L[0]]=0x80;A.x2.b2[L[1]]=0x80;A.x1.w[14]=(L[0]<<3);A.x2.w2[14]=(L[1]<<3);MD5_swap(A.x1.w,A.x1.w,(L[0]+4)>>2);MD5_swap(A.x2.w2,A.x2.w2,(L[1]+4)>>2);MD5_body(A.x1.w,A.x2.w2,C.x1.w,C.x2.w2);MD5_swap2(C.x1.w,C.x2.w2,C.x1.w,C.x2.w2,4);} else {MD5_CTX ctx; MD5_Init(&ctx); MD5_Update(&ctx,A.x1.b,L[0]); MD5_Final((unsigned char *)(C.x1.b),&ctx); MD5_Init(&ctx); MD5_Update(&ctx,A.x2.b2,L[1]); MD5_Final((unsigned char *)(C.x2.b2),&ctx);} }while(0)
+#define DoMD5o(A,L,C) do{if((L[0])<55&&(L[1])<55) {MD5_body(A.x1.w,A.x2.w2,C.x1.w,C.x2.w2);} else {MD5_CTX ctx; MD5_Init(&ctx); MD5_Update(&ctx,A.x1.b,L[0]); MD5_Final((unsigned char *)(C.x1.b),&ctx); MD5_Init(&ctx); MD5_Update(&ctx,A.x2.b2,L[1]); MD5_Final((unsigned char *)(C.x2.b2),&ctx);} }while(0)
+#define DoMD5a(A,L,C) do{MD5_body(A->x1.w,A->x2.w2,C->x1.w,C->x2.w2);}while(0)
+#define DoMD5a2(A,L,C,D) do{MD5_body(A->x1.w,A->x2.w2,tmpOut.x1.w,tmpOut.x2.w2);MD5_swap(C->x1.w,C->x1.w,(D[0]+21)>>2);MD5_swap(C->x2.w2,C->x2.w2,(D[1]+21)>>2);MD5_swap(tmpOut.x1.w,tmpOut.x1.w,4);MD5_swap(tmpOut.x2.w2,tmpOut.x2.w2,4);memcpy(&(C->x1.b[D[0]]),tmpOut.x1.b,16);memcpy(&(C->x2.b2[D[1]]),tmpOut.x2.b2,16);MD5_swap(C->x1.w,C->x1.w,(D[0]+21)>>2);MD5_swap(C->x2.w2,C->x2.w2,(D[1]+21)>>2);}while(0)
+#else
+#define ALGORITHM_NAME_X86		"128x1 (MD5_body)"
+extern void MD5_body(MD5_word x[15],MD5_word out[4]);
+#define DoMD5(A,L,C) do{if(!force_md5_ctx&&(L)<55) {A.x1.b[L]=0x80;A.x1.w[14]=(L<<3);MD5_swap(A.x1.w,A.x1.w,((L+4)>>2));MD5_body(A.x1.w,C.x1.w);MD5_swap(C.x1.w,C.x1.w,4);} else {MD5_CTX ctx; MD5_Init(&ctx); MD5_Update(&ctx,A.x1.b,L); MD5_Final((unsigned char *)(C.x1.b),&ctx); } }while(0)
+#define DoMD5o(A,L,C) do{if((L)<55) {MD5_body(A.x1.w,C.x1.w);} else {MD5_CTX ctx; MD5_Init(&ctx); MD5_Update(&ctx,A.x1.b,L); MD5_Final((unsigned char *)(C.x1.b),&ctx); } }while(0)
+#define DoMD5a(A,L,C) do{MD5_body(A->x1.w,C->x1.w);}while(0)
+#define DoMD5a2(A,L,C,D)  do{MD5_body(A->x1.w,tmpOut.x1.w);MD5_swap(C->x1.w,C->x1.w,(D+5)>>2);memcpy(&(C->x1.b[D]),tmpOut.x1.b,16); MD5_swap(C->x1.w,C->x1.w,(D+5)>>2);}while(0)
+#endif
+#endif
+SHA_CTX sha_ctx;
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT	MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+
+#define BENCHMARK_LENGTH		-1
+#define CIPHERTEXT_LENGTH		32
+#define BINARY_SIZE				16
+#define BINARY_SIZE_SHA         20
+
+// Computation for 'salt_size'  The salt (and salt2) is appended to the end of the hash entry.
+//    The format of a salted entry is:   md5_gen(#)hash$SALT_VAL[$$2SALT2_VAL]
+// salt 64 bytes,
+// salt2 64 bytes,
+// salt signature $ 1 byte
+// salt2 signature $$2 3 bytes
+// null termination 1 byte.  This this allows 2 64 byte salt's.
+// Note, we now have up to 10 of these.
+#define SALT_SIZE				(64*4+1+3+1)
+
+// slots to do 24 'tests'. Note, we copy the
+// same 3 tests over and over again.  Simply to validate that
+// tests use 'multiple' blocks.
+static struct fmt_tests md5_gen_tests[] = {
+	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
+	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},
+	{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL},{NULL}
+};
+
+#ifdef MMX_COEF
+// SSE2 works only with 54 byte keys. Thus, md5(md5($p).md5($s)) can NOT be used
+// with the SSE2, since that final md5 will be over a 64 byte block of data.
+#ifndef _DEBUG
+#define input_buf  genMD5_input_buf
+#define input_buf2 genMD5_input_buf2
+#define crypt_key  genMD5_crypt_key
+#define crypt_key2 genMD5_crypt_key2
+#define sinput_buf  genMD5_sinput_buf
+#define scrypt_key  genMD5_scrypt_key
+#endif
+#ifdef SHA1_SSE_PARA
+#define SHA_BLOCKS SHA1_SSE_PARA
+#else
+#define SHA_BLOCKS 1
+#endif
+#ifdef _MSC_VER
+__declspec(align(16)) unsigned char input_buf[BLOCK_LOOPS][64*MMX_COEF];
+__declspec(align(16)) unsigned char input_buf2[BLOCK_LOOPS][64*MMX_COEF];
+__declspec(align(16)) unsigned char crypt_key[BLOCK_LOOPS+1][BINARY_SIZE*MMX_COEF]; // the +1 is so we can directly dump sha1 crypts here. We need an extra buffer on the end, to hold the last buffer overwrite
+__declspec(align(16)) unsigned char crypt_key2[BLOCK_LOOPS][BINARY_SIZE*MMX_COEF];
+// SHA keyspace
+__declspec(align(16)) unsigned char sinput_buf[SHA_BLOCKS][80*4*MMX_COEF];
+__declspec(align(16)) unsigned char scrypt_key[SHA_BLOCKS][BINARY_SIZE_SHA*MMX_COEF];
+#else
+unsigned char input_buf[BLOCK_LOOPS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char input_buf2[BLOCK_LOOPS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char crypt_key[BLOCK_LOOPS+1][BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));  // the +1 is so we can directly dump sha1 crypts here. We need an extra buffer on the end, to hold the last buffer overwrite
+unsigned char crypt_key2[BLOCK_LOOPS][BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+// SHA keyspace
+unsigned char sinput_buf[SHA_BLOCKS][80*4*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char scrypt_key[SHA_BLOCKS][BINARY_SIZE_SHA*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+static unsigned int total_len[BLOCK_LOOPS];
+static unsigned int total_len2[BLOCK_LOOPS];
+#endif
+// Allows us to work with up to 96 byte keys in the non-sse2 code
+
+typedef struct {
+	union {
+		double dummy;
+		MD5_word w[(PLAINTEXT_LENGTH_X86+96)/4];
+		char b[PLAINTEXT_LENGTH_X86+96];
+		unsigned char B[PLAINTEXT_LENGTH_X86+96];
+	}x1;
+#if MD5_X2
+	union {
+		double dummy2;
+		MD5_word w2[(PLAINTEXT_LENGTH_X86+96)/4];
+		char b2[PLAINTEXT_LENGTH_X86+96];
+		unsigned char B2[PLAINTEXT_LENGTH_X86+96];
+	}x2;
+#endif
+} MD5_IN;
+
+static MD5_OUT crypt_key_X86[MAX_KEYS_PER_CRYPT_X86>>MD5_X2];
+static MD5_OUT crypt_key2_X86[MAX_KEYS_PER_CRYPT_X86>>MD5_X2];
+
+static MD5_IN input_buf_X86[MAX_KEYS_PER_CRYPT_X86>>MD5_X2];
+static MD5_IN input_buf2_X86[MAX_KEYS_PER_CRYPT_X86>>MD5_X2];
+
+static unsigned int total_len_X86[MAX_KEYS_PER_CRYPT_X86];
+static unsigned int total_len2_X86[MAX_KEYS_PER_CRYPT_X86];
+
+static int keys_dirty;
+// We store the salt here
+static char cursalt[SALT_SIZE+1];
+// length of salt (so we don't have to call strlen() all the time.
+static int saltlen;
+// This array is for the 2nd salt in the hash.  I know of no hashes with double salts,
+// but test type md5_gen(16) (which is 'fake') has 2 salts, and this is the data/code to
+// handle double salts.
+static char cursalt2[64+1];
+static int saltlen2;
+
+static char username[64+1];
+static int usernamelen;
+
+static char flds[10][64+1];
+static int fld_lens[10];
+
+static char itoa16_up[16] = "0123456789ABCDEF";
+static char *md5gen_itoa16 = itoa16;
+static unsigned short itoa16_w2_u[256], itoa16_w2_l[256], *itoa16_w2=itoa16_w2_l;
+
+// array of the keys.  Also lengths of the keys. NOTE if store_keys_in_input, then the
+// key array will NOT be used (but the length array still is).
+#ifndef MAX_KEYS_PER_CRYPT
+#define MAX_KEYS_PER_CRYPT MAX_KEYS_PER_CRYPT_X86
+#endif
+#ifndef PLAINTEXT_LENGTH
+#define PLAINTEXT_LENGTH PLAINTEXT_LENGTH_X86
+#endif
+static char saved_key[MAX_KEYS_PER_CRYPT>MAX_KEYS_PER_CRYPT_X86?MAX_KEYS_PER_CRYPT:MAX_KEYS_PER_CRYPT_X86][PLAINTEXT_LENGTH>PLAINTEXT_LENGTH_X86?PLAINTEXT_LENGTH:PLAINTEXT_LENGTH_X86+1];
+static int saved_key_len[MAX_KEYS_PER_CRYPT>MAX_KEYS_PER_CRYPT_X86?MAX_KEYS_PER_CRYPT:MAX_KEYS_PER_CRYPT_X86];
+
+// Used in 'get_key' if we are running in store_keys_in_input mode
+static char out[PLAINTEXT_LENGTH>PLAINTEXT_LENGTH_X86?PLAINTEXT_LENGTH:PLAINTEXT_LENGTH_X86+1];
+
+// This is the GLOBAL count of keys. ALL of the primitives which deal with a count
+// will read from this variable.
+static int m_count;
+
+// If we are run in 'specific' mode (say, -format=md5-gen -subformat=md5_gen(0), then we
+// want to 'allow' raw hashes to be 'valid'. This is how we will do this.  We have a boolean
+// that if set to true, we will perform a 1 time check within the valid function. If at
+// that time we find out that we are cracking (or showing, etc) that we will accept lines
+// that are either format of md5_gen(0)hhhhhh...32 or simply in the format of hhhhhhh..32
+static int m_allow_rawhash_fixup = 0;
+
+// this one IS in the private_dat, but since it is accessed SO much, we pull it
+// out prior to 'internal' processing. The others are accessed right from
+// the structure, since there are accessed infrequently enough to not matter.
+static int md5_gen_use_sse;
+
+// If set to 1, then do unicode conversion is many string setting functions.
+static int md5_unicode_convert;
+
+typedef struct private_subformat_data
+{
+	// If compiled in SSE, AND the format allows SSE, then this will be set to 1.
+	int md5_gen_use_sse;
+	int md5_startup_in_x86;
+
+	// if the format is non-base16 (i.e. base-64), then this flag is set, and
+	// a the hash loading function uses it.
+	int md5_gen_base64_inout;
+	// if we want 'upper-case' in our base-16 conversions.
+	int md5_gen_base16_upcase;
+	// if set, then we load keys directly into input1 and NOT into the saved_key buffers
+	int store_keys_in_input;
+	int store_keys_in_input_unicode_convert;
+	int store_keys_normal_but_precompute_md5_to_output2;
+	int store_keys_normal_but_precompute_md5_to_output2_base16_to_input1;
+	int store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32;
+	int md5_gen_salt_as_hex;
+	int force_md5_ctx;
+
+	// This array is for the 2nd salt in the hash.  I know of no hashes with double salts,
+	// but test type md5_gen(16) (which is 'fake') has 2 salts, and this is the data/code to
+	// handle double salts.
+	int b2Salts;
+	int bUserName;
+	unsigned FldMask;
+	// Special HDAA salt function
+	int md5_gen_hdaa_salt;
+	// if the external hash is sha1()  (such as sha1(md5($p)) then we want 40 byte input hashes.
+	// We only 'use' 32 bytes of it to compare, but we should only run against 40byte hashes.
+	int md5_gen_40_byte_sha1;
+	// Some formats have 'constants'.  A good example is the MD5 Post Office format md5_gen(18)
+	// There can be 8 constants which can be put into the strings being built.  Most formats do
+	// not have constants.
+	char *Consts[8];
+	int ConstsLen[8];
+	int nConsts;
+
+	char md5_gen_WHICH_TYPE_SIG[40];
+	// this 'will' be replaced, and will 'replace' FORMAT_NAME
+	int md5_gen_FIXED_SALT_SIZE;
+	int md5_gen_SALT_OFFSET;
+	int md5_gen_HASH_OFFSET;
+	MD5_GEN_primitive_funcp *md5_gen_FUNCTIONS;
+
+} private_subformat_data;
+
+static private_subformat_data curdat;
+
+// Helper function that loads out 256 unsigned short array that does base-16 conversions
+// This function is called at the 'validation' call that loads our preloads (i.e. only
+// called one time, pre 'run' (but will be called multiple times when benchmarking, but
+// will NOT impact benchmark times.)   Loading a word at a time (2 bytes), sped up
+// the overall run time of md5_gen(2) almost 5%, thus this conversion is MUCH faster than
+// the fastest byte by byte I could put together.  I tested several ways to  access this
+// array of unsigned shorts, and the best way was a 2 step method into an array of long
+// integer pointers (thus, load 1/2 the 32 bit word, then the other 1/2, into a 32 bit word).
+
+/*********************************************************************************
+ *********************************************************************************
+ * Start of the 'normal' *_fmt code for md5-gen
+ *********************************************************************************
+ *********************************************************************************/
+
+/*********************************************************************************
+ * Detects a 'valid' md5-gen format. This function is NOT locked to anything. It
+ * takes it's detection logic from the provided fmt_main pointer. Within there,
+ * is a 'private' data pointer.  When john first loads the md5-gen, it calls a
+ * function which builds proper 'private' data for EACH type of md5-gen. Then
+ * john will call valid on EACH of those formats, asking each one if a string is
+ * valid. Each format has a 'private' properly setup data object.
+ *********************************************************************************/
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i, cipherTextLen;
+	char *cp;
+	private_subformat_data *pPriv = pFmt->private.data;
+
+	if (!pPriv)
+		return 0;
+
+	if (strncmp(ciphertext, pPriv->md5_gen_WHICH_TYPE_SIG, strlen(pPriv->md5_gen_WHICH_TYPE_SIG)))
+		return 0;
+	cp = &ciphertext[strlen(pPriv->md5_gen_WHICH_TYPE_SIG)];
+
+	if (pPriv->md5_gen_base64_inout == 1)
+	{
+		// jgypwqm.JsMssPLiS8YQ00$BaaaaaSX
+		int i;
+		for (i = 0; i < 22; ++i)
+			if (atoi64[ARCH_INDEX(cp[i])] == 0x7F)
+				return 0;
+		if (pPriv->md5_gen_FIXED_SALT_SIZE && cp[22] != '$')
+			return 0;
+		if (pPriv->md5_gen_FIXED_SALT_SIZE > 0 && strlen(&cp[23]) != pPriv->md5_gen_FIXED_SALT_SIZE)
+			return 0;
+		return 1;
+	}
+	if (pPriv->md5_gen_base64_inout == 2)
+	{
+		// h3mJrcH0901pqX/m$alex
+		int i;
+		for (i = 0; i < 16; ++i)
+			if (atoi64[ARCH_INDEX(cp[i])] == 0x7F)
+				return 0;
+		if (pPriv->md5_gen_FIXED_SALT_SIZE && cp[16] != '$')
+			return 0;
+		if (pPriv->md5_gen_FIXED_SALT_SIZE > 0 && strlen(&cp[17]) != pPriv->md5_gen_FIXED_SALT_SIZE)
+			return 0;
+		return 1;
+	}
+
+	if (pPriv->md5_gen_base64_inout == 1)
+	{
+		if (strlen(cp) < 22)
+			return 0;
+	}
+	else if (pPriv->md5_gen_base64_inout == 2)
+	{
+		if (strlen(cp) < 16)
+			return 0;
+	}
+	else
+	{
+		if (strlen(cp) < 32)
+			return 0;
+	}
+	cipherTextLen = CIPHERTEXT_LENGTH;
+	if (pPriv->md5_gen_40_byte_sha1)
+		cipherTextLen = 40;
+	for (i = 0; i < cipherTextLen; i++){
+		if (!(  (('0' <= cp[i])&&(cp[i] <= '9')) ||
+			 	(('a' <= cp[i])&&(cp[i] <= 'f')) ||
+				(('A' <= cp[i])&&(cp[i] <= 'F'))
+			))
+			return 0;
+	}
+	if (cp[cipherTextLen] && cp[cipherTextLen] != '$')
+		return 0;
+	if (pPriv->md5_gen_FIXED_SALT_SIZE && ciphertext[pPriv->md5_gen_SALT_OFFSET-1] != '$')
+		return 0;
+	if (pPriv->md5_gen_FIXED_SALT_SIZE > 0 && strlen(&ciphertext[pPriv->md5_gen_SALT_OFFSET]) != pPriv->md5_gen_FIXED_SALT_SIZE) {
+		// check if there is a 'salt-2' or 'username', etc  That is valid.
+		if (strncmp(&ciphertext[pPriv->md5_gen_SALT_OFFSET+pPriv->md5_gen_FIXED_SALT_SIZE], "$$", 2))
+			return 0;
+	}
+	if (pPriv->b2Salts==1 && !strstr(&ciphertext[pPriv->md5_gen_SALT_OFFSET-1], "$$2"))
+		return 0;
+	if (pPriv->bUserName && !strstr(&ciphertext[pPriv->md5_gen_SALT_OFFSET-1], "$$U"))
+		return 0;
+	for (i = 0; i < 10; ++i) {
+		char Fld[5];
+		sprintf(Fld, "$$F%d", i);
+		if ( (pPriv->FldMask & (MGF_FLD0<<i)) == (MGF_FLD0<<i) && !strstr(&ciphertext[pPriv->md5_gen_SALT_OFFSET-1], Fld))
+			return 0;
+	}
+
+	return 1;
+}
+
+static char *FixupIfNeeded(char *ciphertext, private_subformat_data *pPriv);
+static char *HandleCase(char *cp, int caseType);
+/*********************************************************************************
+ * This function will add a md5_gen() IF there is not one, and if we have a specific
+ * format requested.  Also, it will add things like UserID, Domain, Fld3, Fld4,
+ * Fld5, etc.
+ *********************************************************************************/
+static char *prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	char Tmp[80];
+	int i;
+	private_subformat_data *pPriv = pFmt->private.data;
+	char *cpBuilding=split_fields[1], *cpTmp=NULL;
+
+	if (!pPriv)
+		return split_fields[1];
+
+	if (pFmt->params.salt_size && !strchr(split_fields[1], '$'))
+		return split_fields[1];
+
+	cpBuilding = FixupIfNeeded(cpBuilding, pPriv);
+	if (strncmp(cpBuilding, "md5_gen(", 8))
+		return split_fields[1];
+
+	if (pPriv->bUserName && !strstr(cpBuilding, "$$U")) {
+		char *userName=split_fields[0], *cp;
+		// assume field[0] is in format: username OR DOMAIN\\username  If we find a \\, then  use the username 'following' it.
+		cp = strchr(split_fields[0], '\\');
+		if (cp)
+			userName = &cp[1];
+		userName = HandleCase(userName, pPriv->bUserName);
+		cpTmp = mem_alloc_tiny(strlen(cpBuilding) + 1 + 3 + strlen(userName), MEM_ALIGN_NONE);
+		sprintf (cpTmp, "%s$$U%s", cpBuilding, userName);
+		cpBuilding = cpTmp;
+	}
+	for (i = 0; i <= 8; ++i) {
+		sprintf(Tmp, "$$F%d", i);
+		if ( split_fields[i] &&  (pPriv->FldMask&(MGF_FLD0<<i)) && !strstr(cpBuilding, Tmp)) {
+			cpTmp = mem_alloc_tiny(strlen(cpBuilding) + 1 + 4 + strlen(split_fields[i]), MEM_ALIGN_NONE);
+			sprintf (cpTmp, "%s$$F%d%s", cpBuilding, i, split_fields[i]);
+			cpBuilding = cpTmp;
+		}
+	}
+	return cpBuilding;
+}
+
+/*********************************************************************************
+ * init() here does nothing. NOTE many formats LINKING into us will have a valid
+ * that DOES do something, but ours does nothing.
+ *********************************************************************************/
+static void init(struct fmt_main *pFmt)
+{
+	private_subformat_data *pPriv = pFmt->private.data;
+	int i;
+
+	md5_gen_RESET(pFmt);
+
+	if (!pPriv)
+		return;
+
+	memcpy(&curdat, pPriv, sizeof(private_subformat_data));
+	md5_gen_use_sse = curdat.md5_gen_use_sse;
+	force_md5_ctx = curdat.force_md5_ctx;
+
+	fmt_MD5gen.params.max_keys_per_crypt = pFmt->params.max_keys_per_crypt;
+	fmt_MD5gen.params.min_keys_per_crypt = pFmt->params.min_keys_per_crypt;
+	fmt_MD5gen.params.format_name        = pFmt->params.format_name;
+	fmt_MD5gen.params.algorithm_name     = pFmt->params.algorithm_name;
+	fmt_MD5gen.params.benchmark_comment  = pFmt->params.benchmark_comment;
+	fmt_MD5gen.params.benchmark_length   = pFmt->params.benchmark_length;
+	fmt_MD5gen.params.plaintext_length   = pFmt->params.plaintext_length;
+	fmt_MD5gen.params.salt_size          = pFmt->params.salt_size;
+	fmt_MD5gen.params.flags              = pFmt->params.flags;
+
+	fmt_MD5gen.methods.cmp_all    = pFmt->methods.cmp_all;
+	fmt_MD5gen.methods.cmp_one    = pFmt->methods.cmp_one;
+	fmt_MD5gen.methods.cmp_exact  = pFmt->methods.cmp_exact;
+	fmt_MD5gen.methods.set_salt   = pFmt->methods.set_salt;
+	fmt_MD5gen.methods.salt       = pFmt->methods.salt;
+	fmt_MD5gen.methods.salt_hash  = pFmt->methods.salt_hash;
+	fmt_MD5gen.methods.split      = pFmt->methods.split;
+	fmt_MD5gen.methods.set_key    = pFmt->methods.set_key;
+	fmt_MD5gen.methods.get_key    = pFmt->methods.get_key;
+	fmt_MD5gen.methods.clear_keys = pFmt->methods.clear_keys;
+	fmt_MD5gen.methods.crypt_all  = pFmt->methods.crypt_all;
+	for (i = 0; i < 5; ++i)
+	{
+		fmt_MD5gen.methods.binary_hash[i] = pFmt->methods.binary_hash[i];
+		fmt_MD5gen.methods.get_hash[i]    = pFmt->methods.get_hash[i];
+	}
+
+#if !MD5_IMM
+	{
+		extern void MD5_std_init(struct fmt_main *pFmt);
+		MD5_std_init(pFmt);
+	}
+#endif
+}
+
+/*********************************************************************************
+ * Stores the new salt provided into our 'working' salt
+ *********************************************************************************/
+static void set_salt(void *salt)
+{
+	char *cp;
+	memset(cursalt, 0, sizeof(cursalt));
+	strnzcpy(cursalt, salt, sizeof(cursalt));
+
+	// find user, salt2, domain, host, etc, etc.
+	cp = &cursalt[saltlen=strlen(cursalt)];
+	while (--cp > cursalt)
+	{
+		if (*cp == '$' && cp[-1] == '$')
+		{
+			// found an 'additional' salt.
+			--cp;
+			*cp = 0;
+			// re-adjust salt len.
+			saltlen = cp-cursalt;
+			switch (cp[2])
+			{
+				case '2':
+					// salt2
+					strnzcpy(cursalt2, &cp[3], sizeof(cursalt2));
+					saltlen2 = strlen(cursalt2);
+					break;
+				case 'U':
+					// username
+					strnzcpy(username, &cp[3], sizeof(username));
+					usernamelen = strlen(username);
+					break;
+				case 'F':
+					{
+						// Fld flags
+						int which = cp[3] - '0';
+						if (which < 0 || which > 9)
+							exit(fprintf(stderr, "Error, unknown salt string  $%s\n", &cp[1]));
+						strnzcpy(flds[which], &cp[4], sizeof(flds[0]));
+						fld_lens[which] = strlen(flds[which]);
+					}
+					break;
+				default:
+					exit(fprintf(stderr, "Error, unknown salt string  $%s\n", &cp[1]));
+			}
+		}
+	}
+}
+
+/*********************************************************************************
+ * init() here does nothing. NOTE many formats LINKING into us will have a valid that
+ * NOTE specific for phpass.  We internally look at a salt as 8 bytes, but external
+ * it is 9. NOTE in the crypt, we DO use that last byte. It tells crypt how many
+ * times to loop.  However, within ALL of the primitive functions, they only work
+ * with the first 8 bytes of the salt (the true salt value), and ignore that 9th
+ * byte.
+ *********************************************************************************/
+static void set_salt_phpass(void *salt)
+{
+	strncpy(cursalt, salt, saltlen+1);
+	cursalt[saltlen+1] = 0;
+}
+
+/*********************************************************************************
+ * Sets this key. It will either be dropped DIRECTLY into the input buffer
+ * number 1, or put into an array of keys.  Which one happens depends upon
+ * HOW the generic functions were laid out for this type. Not all types can
+ * load into the input.  If not they MUST use the key array. Using the input
+ * buffer is faster, when it can be safely done.
+ *********************************************************************************/
+static void set_key(char *key, int index)
+{
+	if (curdat.store_keys_in_input==2)
+		md5_gen_use_sse = 3;
+	else if (curdat.md5_startup_in_x86)
+		md5_gen_use_sse = 2;
+	else if (md5_gen_use_sse==2)
+		md5_gen_use_sse = 1;
+//		MD5GenBaseFunc__clean_input();
+
+	if (curdat.store_keys_in_input)
+	{
+		unsigned int len = strlen(key);
+#ifdef MMX_COEF
+		if (md5_gen_use_sse==1) {
+			unsigned int i, cnt;
+			unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+			ARCH_WORD_32 *pi = (ARCH_WORD_32 *)key;
+			ARCH_WORD_32 *po = &((ARCH_WORD_32 *)(&(input_buf[idx])))[index&(MMX_COEF-1)];
+			if(index==0)
+				MD5GenBaseFunc__clean_input();
+			if (len > 55)
+				len = 55;
+			cnt = len>>2;
+			for (i = 0; i < cnt; ++i)
+			{
+				*po = *pi++;
+				po += MMX_COEF;
+			}
+			for(i=cnt<<2;i<len;i++)
+				input_buf[idx][GETPOS(i, index&(MMX_COEF-1))] = key[i];
+			input_buf[idx][GETPOS(i, index&(MMX_COEF-1))] = 0x80;
+			total_len[idx] += ( len << ( ( (32/MMX_COEF) * (index&(MMX_COEF-1)) ) ));
+			saved_key_len[index] = len;
+			return;
+		}
+		if (md5_gen_use_sse==3) {
+			unsigned int i; //, cnt;
+//			unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+//			ARCH_WORD_32 *pi = (ARCH_WORD_32 *)key;
+//			ARCH_WORD_32 *po = &((ARCH_WORD_32 *)(&(input_buf[idx])))[index&(MMX_COEF-1)];
+			if(index==0) {
+				memset(sinput_buf, 0, 64*MMX_COEF);
+				total_len[0] = 0;
+			}
+			if (len > 55)
+				len = 55;
+//			cnt = len>>2;
+//			for (i = 0; i < cnt; ++i)
+//			{
+//				*po = *pi++;
+//				po += MMX_COEF;
+//			}
+//			for(i=cnt<<2;i<len;i++)
+			for(i = 0; i < len; ++i)
+				sinput_buf[0][SHAGETPOS(i, index)] = key[i];
+			sinput_buf[0][SHAGETPOS(i, index&(MMX_COEF-1))] = 0x80;
+			total_len[0] += ( len << ( ( (32/MMX_COEF) * index ) ));
+			saved_key_len[index] = len;
+			return;
+		}
+#endif
+		if(index==0) {
+			//fprintf (stderr, "FULL Cleaning keys\n");
+			MD5GenBaseFunc__clean_input_full();
+		}
+#if MD5_X2
+		if (index & 1)
+			strnzcpy(input_buf_X86[index>>MD5_X2].x2.b2, key, PLAINTEXT_LENGTH_X86);
+		else
+#endif
+			strnzcpy(input_buf_X86[index>>MD5_X2].x1.b, key, PLAINTEXT_LENGTH_X86);
+		saved_key_len[index] = total_len_X86[index] = len;
+	}
+	else
+	{
+		if(index==0) {
+			//fprintf (stderr, "FULL Cleaning keys\n");
+			MD5GenBaseFunc__clean_input_full();
+		}
+		keys_dirty = 1;
+		strnzcpy(((char*)(saved_key[index])), key, 55+1);
+		saved_key_len[index] = strlen(saved_key[index]);
+	}
+}
+
+
+/*********************************************************************************
+ * Returns the key.  NOTE how it gets it depends upon if we are storing
+ * into the array of keys (there we simply return it), or if we are
+ * loading into input buffer #1. If in input buffer, we have to re-create
+ * the key, prior to returning it.
+ *********************************************************************************/
+static char *get_key(int index)
+{
+	if (curdat.store_keys_in_input)
+	{
+		unsigned int i;
+		unsigned char *cp;
+#ifdef MMX_COEF
+		//if (md5_gen_use_sse==1) {
+		// Note, if we are not in
+		if (md5_gen_use_sse && !curdat.md5_startup_in_x86) {
+			unsigned int s;
+			unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+
+			s = saved_key_len[index];
+			if (md5_gen_use_sse==3) {
+				for(i=0;i<s;i++)
+					out[i] = sinput_buf[idx][ SHAGETPOS(i, index&(MMX_COEF-1)) ];
+			} else {
+				for(i=0;i<s;i++)
+					out[i] = input_buf[idx][ GETPOS(i, index&(MMX_COEF-1)) ];
+			}
+			out[i] = 0;
+			return (char*)out;
+		}
+#endif
+#if MD5_X2
+		if (index & 1)
+			cp = input_buf_X86[index>>MD5_X2].x2.B2;
+		else
+#endif
+			cp = input_buf_X86[index>>MD5_X2].x1.B;
+
+		for(i=0;i<saved_key_len[index];++i)
+			out[i] = cp[i];
+		out[i] = 0;
+		return (char*)out;
+	}
+	else
+	{
+		saved_key[index][saved_key_len[index]] = '\0';
+		return saved_key[index];
+	}
+}
+
+/*********************************************************************************
+ * Looks for ANY key that was cracked.
+ *********************************************************************************/
+static int cmp_all(void *binary, int count)
+{
+	unsigned int i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse&1) {
+		unsigned int cnt = ( ((unsigned)count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+		{
+			if(( *((ARCH_WORD_32 *)binary) == ((ARCH_WORD_32 *)&(crypt_key[i]))[0])
+			|| ( *((ARCH_WORD_32 *)binary) == ((ARCH_WORD_32 *)&(crypt_key[i]))[1])
+#if (MMX_COEF > 3)
+			|| ( *((ARCH_WORD_32 *)binary) == ((ARCH_WORD_32 *)&(crypt_key[i]))[2])
+			|| ( *((ARCH_WORD_32 *)binary) == ((ARCH_WORD_32 *)&(crypt_key[i]))[3])
+#endif
+			)
+				return 1;
+		}
+		return 0;
+	}
+#endif
+	for (i = 0; i < count; i++) {
+#if MD5_X2
+		if (i&1) {
+			if (!(((ARCH_WORD_32 *)binary)[0] - crypt_key_X86[i>>MD5_X2].x2.w2[0]))
+				return 1;
+		}
+		else
+#endif
+		if (!(((ARCH_WORD_32 *)binary)[0] - crypt_key_X86[i>>MD5_X2].x1.w[0]))
+			return 1;
+	}
+	return 0;
+}
+
+#if ARCH_LITTLE_ENDIAN
+#define MASK_4x6 0x00ffffff
+#else
+#define MASK_4x6 0xffffff00
+#endif
+static int cmp_all_64_4x6(void *binary, int count)
+{
+	unsigned int i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned int cnt = ( ((unsigned)count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+		{
+			if(( *((ARCH_WORD_32 *)binary) == (((ARCH_WORD_32 *)&(crypt_key[i]))[0] & MASK_4x6))
+			|| ( *((ARCH_WORD_32 *)binary) == (((ARCH_WORD_32 *)&(crypt_key[i]))[1] & MASK_4x6))
+#if (MMX_COEF > 3)
+			|| ( *((ARCH_WORD_32 *)binary) == (((ARCH_WORD_32 *)&(crypt_key[i]))[2] & MASK_4x6))
+			|| ( *((ARCH_WORD_32 *)binary) == (((ARCH_WORD_32 *)&(crypt_key[i]))[3] & MASK_4x6))
+#endif
+			)
+				return 1;
+		}
+		return 0;
+	}
+#endif
+	for (i = 0; i < count; i++) {
+#if MD5_X2
+		if (i&1) {
+			if (!(((ARCH_WORD_32 *)binary)[0] - (crypt_key_X86[i>>MD5_X2].x2.w2[0]&MASK_4x6)))
+				return 1;
+		}
+		else
+#endif
+		if (!(((ARCH_WORD_32 *)binary)[0] - (crypt_key_X86[i>>MD5_X2].x1.w[0]&MASK_4x6)))
+			return 1;
+	}
+	return 0;
+}
+
+/*********************************************************************************
+ * In this code, we always do exact compare, so if this function is called, it
+ * simply returns true.
+ *********************************************************************************/
+static int cmp_exact(char *binary, int index)
+{
+	return 1;
+}
+
+/*********************************************************************************
+ * There was 'something' that was possibly hit. Now john will ask us to check
+ * each one of the data items, for an 'exact' match.
+ *********************************************************************************/
+static int cmp_one(void *binary, int index)
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse&1) {
+		unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+		if( (((ARCH_WORD_32 *)binary)[0] == ((ARCH_WORD_32 *)&(crypt_key[idx]))[0*MMX_COEF+(index&(MMX_COEF-1))]) &&
+			(((ARCH_WORD_32 *)binary)[1] == ((ARCH_WORD_32 *)&(crypt_key[idx]))[1*MMX_COEF+(index&(MMX_COEF-1))]) &&
+			(((ARCH_WORD_32 *)binary)[2] == ((ARCH_WORD_32 *)&(crypt_key[idx]))[2*MMX_COEF+(index&(MMX_COEF-1))]) &&
+			(((ARCH_WORD_32 *)binary)[3] == ((ARCH_WORD_32 *)&(crypt_key[idx]))[3*MMX_COEF+(index&(MMX_COEF-1))]))
+			return 1;
+		return 0;
+	}
+#endif
+
+#if MD5_X2
+	if (index & 1) {
+		if ( (((ARCH_WORD_32 *)binary)[0] == crypt_key_X86[index>>MD5_X2].x2.w2[0] ) &&
+             (((ARCH_WORD_32 *)binary)[1] == crypt_key_X86[index>>MD5_X2].x2.w2[1] ) &&
+             (((ARCH_WORD_32 *)binary)[2] == crypt_key_X86[index>>MD5_X2].x2.w2[2] ) &&
+             (((ARCH_WORD_32 *)binary)[3] == crypt_key_X86[index>>MD5_X2].x2.w2[3] ) )
+			 return 1;
+		return 0;
+	}
+#endif
+	if ( (((ARCH_WORD_32 *)binary)[0] == crypt_key_X86[index>>MD5_X2].x1.w[0] ) &&
+		 (((ARCH_WORD_32 *)binary)[1] == crypt_key_X86[index>>MD5_X2].x1.w[1] ) &&
+		 (((ARCH_WORD_32 *)binary)[2] == crypt_key_X86[index>>MD5_X2].x1.w[2] ) &&
+		 (((ARCH_WORD_32 *)binary)[3] == crypt_key_X86[index>>MD5_X2].x1.w[3] ) )
+		 return 1;
+	return 0;
+}
+static int cmp_one_64_4x6(void *binary, int index)
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+		if( (((ARCH_WORD_32 *)binary)[0] == (((ARCH_WORD_32 *)&(crypt_key[idx]))[0*MMX_COEF+(index&(MMX_COEF-1))] & MASK_4x6)) &&
+			(((ARCH_WORD_32 *)binary)[1] == (((ARCH_WORD_32 *)&(crypt_key[idx]))[1*MMX_COEF+(index&(MMX_COEF-1))] & MASK_4x6)) &&
+			(((ARCH_WORD_32 *)binary)[2] == (((ARCH_WORD_32 *)&(crypt_key[idx]))[2*MMX_COEF+(index&(MMX_COEF-1))] & MASK_4x6)) &&
+			(((ARCH_WORD_32 *)binary)[3] == (((ARCH_WORD_32 *)&(crypt_key[idx]))[3*MMX_COEF+(index&(MMX_COEF-1))] & MASK_4x6)))
+			return 1;
+		return 0;
+	}
+#endif
+#if MD5_X2
+	if (index & 1) {
+		if ( (((ARCH_WORD_32*)binary)[0] == (crypt_key_X86[index>>MD5_X2].x2.w2[0] & MASK_4x6)) &&
+			 (((ARCH_WORD_32*)binary)[1] == (crypt_key_X86[index>>MD5_X2].x2.w2[1] & MASK_4x6)) &&
+			 (((ARCH_WORD_32*)binary)[2] == (crypt_key_X86[index>>MD5_X2].x2.w2[2] & MASK_4x6)) &&
+			 (((ARCH_WORD_32*)binary)[3] == (crypt_key_X86[index>>MD5_X2].x2.w2[3] & MASK_4x6)) )
+			return 1;
+		return 0;
+	}
+#endif
+	if ( (((ARCH_WORD_32*)binary)[0] == (crypt_key_X86[index>>MD5_X2].x1.w[0] & MASK_4x6)) &&
+		 (((ARCH_WORD_32*)binary)[1] == (crypt_key_X86[index>>MD5_X2].x1.w[1] & MASK_4x6)) &&
+		 (((ARCH_WORD_32*)binary)[2] == (crypt_key_X86[index>>MD5_X2].x1.w[2] & MASK_4x6)) &&
+		 (((ARCH_WORD_32*)binary)[3] == (crypt_key_X86[index>>MD5_X2].x1.w[3] & MASK_4x6)) )
+		return 1;
+	return 0;
+}
+
+/*********************************************************************************
+ *********************************************************************************
+ *  This is the real 'engine'.  It simply calls functions one
+ *  at a time from the array of functions.
+ *********************************************************************************
+ *********************************************************************************/
+static void crypt_all(int count)
+{
+	int i;
+	MD5_GEN_primitive_funcp *pFuncs;
+
+	// set m_count.  This is our GLOBAL value, used by ALL of the script functions to know how
+	// many keys are loaded, and how much work we do.
+	m_count = count;
+
+	// If this format is MMX built, but is supposed to start in X86 (but be switchable), then we
+	// set that value here.
+	if (curdat.store_keys_in_input==2)
+		md5_gen_use_sse = 3;
+	else if (curdat.md5_startup_in_x86)
+		md5_gen_use_sse = 2;
+	else if (md5_gen_use_sse==2)
+		md5_gen_use_sse = 1;
+
+	md5_unicode_convert = 0;
+
+	if (curdat.md5_gen_base16_upcase) {
+		md5gen_itoa16 = itoa16_up;
+		itoa16_w2=itoa16_w2_u;
+	}
+	else {
+		md5gen_itoa16 = itoa16;
+		itoa16_w2=itoa16_w2_l;
+	}
+
+	// There may have to be some 'prelim' work done with the keys.  This is so that if we 'know' that keys were
+	// loaded into the keys[] array, but that we should do something like md5 and base-16 put them into an
+	// input slot, then we do that FIRST, prior to calling the script functions.  Thus for a format such as
+	// md5(md5($p).$s)  we could md5 the pass, and base-16 put it into a input buffer.  Then when john sets salt
+	// and calls crypt all, the crypt script would simply set the input len to 32, append the salt and call a
+	// single crypt.  That eliminates almost 1/2 of the calls to md5_crypt() for the format show in this example.
+	if (keys_dirty)
+	{
+		if (curdat.store_keys_normal_but_precompute_md5_to_output2)
+		{
+			keys_dirty = 0;
+			MD5GenBaseFunc__clean_input2();
+			if (curdat.store_keys_in_input_unicode_convert)
+				md5_unicode_convert = 1;
+			MD5GenBaseFunc__append_keys2();
+			md5_unicode_convert = 0;
+			MD5GenBaseFunc__crypt2();
+
+			if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1)
+			{
+				if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1==2)
+					MD5GenBaseFunc__SSEtoX86_switch_output2();
+				MD5GenBaseFunc__clean_input();
+				MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16();
+			}
+			if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32)
+			{
+#ifndef MMX_COEF
+				if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32==2)
+#endif
+					MD5GenBaseFunc__SSEtoX86_switch_output2();
+				MD5GenBaseFunc__clean_input();
+				MD5GenBaseFunc__set_input_len_32();
+				MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16();
+			}
+		}
+	}
+
+	// Ok, now we 'run' the script. We simply call 1 function right after the other.
+	// ALL functions are void f(void).  They use the globals:
+	//   input_buf1[] input_buf2[]
+	//   total_len1[] total_len2[]
+	//   crypt1[] crypt2[]
+	//   saved_key[]
+	//   saved_key_len[]
+	//   cursalt, cursalt2
+	//   saltlen, saltlen2
+	//   m_count
+	//   nConsts
+	//   Consts[], ConstsLen[]
+
+	// Since this array is in a structure, we assign a simple pointer to it
+	// before walking.  Trivial improvement, but every cycle counts :)
+	pFuncs = curdat.md5_gen_FUNCTIONS;
+	for (i = 0; pFuncs[i]; ++i)
+		(*(pFuncs[i]))();
+}
+
+/*********************************************************************************
+ * 'normal' hashing functions
+ *********************************************************************************/
+//#define DUMP_WORDS 1
+//int DUMP_WORDS=0;
+extern char *MD5_DumpHexStr(void *p);
+static int binary_hash_0(void * binary) {
+#if DUMP_WORDS
+	static int X_DBG=0;
+	fprintf(stderr, "bin_hash - %s\n", MD5_DumpHexStr(binary));
+	if (++X_DBG == 16)
+		exit(0);
+#endif
+	return ((ARCH_WORD_32 *)binary)[0] & 0xf; }
+static int binary_hash_1(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xff; }
+static int binary_hash_2(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfff; }
+static int binary_hash_3(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xffff; }
+static int binary_hash_4(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfffff; }
+
+#if !ARCH_LITTLE_ENDIAN
+// the lower 8 bits is zero on the binary (but filled in on the hash).  We need to dump the low 8
+static int binary_hash_0_64x4(void * binary) {
+#if DUMP_WORDS
+	static int X_DBG=0;
+	fprintf(stderr, "bin_hash - %s\n", MD5_DumpHexStr(binary));
+	if (++X_DBG == 16)
+		exit(0);
+#endif
+	return (((ARCH_WORD_32 *)binary)[0]>>8) & 0xf; }
+static int binary_hash_1_64x4(void * binary) { return (((ARCH_WORD_32 *)binary)[0]>>8) & 0xff; }
+static int binary_hash_2_64x4(void * binary) { return (((ARCH_WORD_32 *)binary)[0]>>8) & 0xfff; }
+static int binary_hash_3_64x4(void * binary) { return (((ARCH_WORD_32 *)binary)[0]>>8) & 0xffff; }
+static int binary_hash_4_64x4(void * binary) { return (((ARCH_WORD_32 *)binary)[0]>>8) & 0xfffff; }
+int get_hash_0_64x4(int index) {
+#if DUMP_WORDS
+#if MD5_X2
+	if (index & 1)
+		fprintf(stderr, "get_hash - %s\n", MD5_DumpHexStr(crypt_key_X86[index>>MD5_X2].x2.b2));
+	else
+#endif
+	fprintf(stderr, "get_hash - %s\n", MD5_DumpHexStr(crypt_key_X86[index>>MD5_X2].x1.b));
+#endif
+#if MD5_X2
+	if (index & 1) return (crypt_key_X86[index>>MD5_X2].x2.w2[0]>>8) & 0xf;
+#endif
+	return (crypt_key_X86[index>>MD5_X2].x1.w[0]>>8) & 0xf;}
+int get_hash_1_64x4(int index) {
+#if MD5_X2
+	if (index & 1) return (crypt_key_X86[index>>MD5_X2].x2.w2[0]>>8) & 0xff;
+#endif
+	return (crypt_key_X86[index>>MD5_X2].x1.w[0]>>8) & 0xff;}
+int get_hash_2_64x4(int index) {
+#if MD5_X2
+	if (index & 1) return (crypt_key_X86[index>>MD5_X2].x2.w2[0]>>8) & 0xfff;
+#endif
+	return (crypt_key_X86[index>>MD5_X2].x1.w[0]>>8) & 0xfff;}
+int get_hash_3_64x4(int index) {
+#if MD5_X2
+	if (index & 1) return (crypt_key_X86[index>>MD5_X2].x2.w2[0]>>8) & 0xffff;
+#endif
+	return (crypt_key_X86[index>>MD5_X2].x1.w[0]>>8) & 0xffff;}
+int get_hash_4_64x4(int index) {
+#if MD5_X2
+	if (index & 1) return (crypt_key_X86[index>>MD5_X2].x2.w2[0]>>8) & 0xfffff;
+#endif
+	return (crypt_key_X86[index>>MD5_X2].x1.w[0]>>8) & 0xfffff;}
+
+#endif
+
+int get_hash_0(int index)
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse&1) {
+		unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+		return ((ARCH_WORD_32 *)&(crypt_key[idx]))[index&(MMX_COEF-1)] & 0xf;
+	}
+#endif
+#if DUMP_WORDS
+#if MD5_X2
+	if (index & 1)
+		fprintf(stderr, "get_hash - %s\n", MD5_DumpHexStr(crypt_key_X86[index>>MD5_X2].x2.b2));
+	else
+#endif
+	fprintf(stderr, "get_hash - %s\n", MD5_DumpHexStr(crypt_key_X86[index>>MD5_X2].x1.b));
+#endif
+#if MD5_X2
+	if (index & 1)
+		return crypt_key_X86[index>>MD5_X2].x2.w2[0] & 0xf;
+#endif
+	return crypt_key_X86[index>>MD5_X2].x1.w[0] & 0xf;
+}
+
+int get_hash_1(int index)
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse&1) {
+		unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+		return ((ARCH_WORD_32 *)&(crypt_key[idx]))[index&(MMX_COEF-1)] & 0xff;
+	}
+#endif
+#if MD5_X2
+	if (index & 1)
+		return crypt_key_X86[index>>MD5_X2].x2.w2[0] & 0xff;
+#endif
+	return crypt_key_X86[index>>MD5_X2].x1.w[0] & 0xff;
+}
+
+int get_hash_2(int index)
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse&1) {
+		unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+		return ((ARCH_WORD_32 *)&(crypt_key[idx]))[index&(MMX_COEF-1)] & 0xfff;
+	}
+#endif
+#if MD5_X2
+	if (index & 1)
+		return crypt_key_X86[index>>MD5_X2].x2.w2[0] & 0xfff;
+#endif
+	return crypt_key_X86[index>>MD5_X2].x1.w[0] & 0xfff;
+}
+
+int get_hash_3(int index)
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse&1) {
+		unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+		return ((ARCH_WORD_32 *)&(crypt_key[idx]))[index&(MMX_COEF-1)] & 0xffff;
+	}
+#endif
+#if MD5_X2
+	if (index & 1)
+		return crypt_key_X86[index>>MD5_X2].x2.w2[0] & 0xffff;
+#endif
+	return crypt_key_X86[index>>MD5_X2].x1.w[0] & 0xffff;
+}
+int get_hash_4(int index)
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse&1) {
+		unsigned int idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+		return ((ARCH_WORD_32 *)&(crypt_key[idx]))[index&(MMX_COEF-1)] & 0xfffff;
+	}
+#endif
+#if MD5_X2
+	if (index & 1)
+		return crypt_key_X86[index>>MD5_X2].x2.w2[0] & 0xfffff;
+#endif
+	return crypt_key_X86[index>>MD5_X2].x1.w[0] & 0xfffff;
+}
+
+/*********************************************************************************
+ * 'normal' get salt function. We simply return a pointer past the '$' char
+ *********************************************************************************/
+static void *salt(char *ciphertext)
+{
+	static char Salt[SALT_SIZE+1];
+	memset(Salt, 0, SALT_SIZE+1);
+	if (curdat.md5_gen_FIXED_SALT_SIZE==0 && !curdat.bUserName && !curdat.FldMask)
+		return Salt;
+	if (!strncmp(ciphertext, "md5_gen(", 8)) {
+		if (ciphertext[curdat.md5_gen_SALT_OFFSET] == '$')
+			strnzcpy(Salt, &ciphertext[curdat.md5_gen_SALT_OFFSET-1], SALT_SIZE);
+		else
+			strnzcpy(Salt, &ciphertext[curdat.md5_gen_SALT_OFFSET], SALT_SIZE);
+	}
+	else {
+		if (ciphertext[curdat.md5_gen_SALT_OFFSET-strlen(curdat.md5_gen_WHICH_TYPE_SIG)] == '$')
+			strnzcpy(Salt, &ciphertext[curdat.md5_gen_SALT_OFFSET-strlen(curdat.md5_gen_WHICH_TYPE_SIG)-1], SALT_SIZE);
+		else
+			strnzcpy(Salt, &ciphertext[curdat.md5_gen_SALT_OFFSET-strlen(curdat.md5_gen_WHICH_TYPE_SIG)], SALT_SIZE);
+	}
+	if (curdat.md5_gen_salt_as_hex)
+	{
+		// Do not 'worry' about SSE/MMX,  Only do 'generic' md5.  This is ONLY done
+		// at the start of the run.  We will NEVER see this run, once john starts.
+		MD5_CTX ctx;
+		unsigned char Buf[16];
+		unsigned char *cpo, *cpi, i;
+		unsigned slen=strlen(Salt);
+		MD5_Init(&ctx);
+		if (curdat.md5_gen_salt_as_hex & 0x100)
+		{
+			char *s2 = mem_alloc(slen*2+1);
+			for (i = 0; i < slen; ++i)
+			{
+				s2[i<<1] = Salt[i];
+				s2[(i<<1)+1] = 0;
+			}
+			MD5_Update(&ctx, s2, slen*2);
+			MEM_FREE(s2);
+		}
+		else
+			MD5_Update(&ctx, Salt, slen);
+		MD5_Final(Buf, &ctx);
+		if ( (curdat.md5_gen_salt_as_hex&3) == 2) {
+			strcat(Salt, "$$2");
+			cpo = (unsigned char *)&Salt[slen+3];
+		}
+		else {
+			cpo = (unsigned char*)Salt;
+			memset(Salt, 0, SALT_SIZE+1);
+		}
+		cpi = Buf;
+		for (i = 0; i < 16; ++i)
+		{
+			*cpo++ = md5gen_itoa16[(*cpi)>>4];
+			*cpo++ = md5gen_itoa16[(*cpi)&0xF];
+			++cpi;
+		}
+		*cpo = 0;
+	}
+	if (curdat.md5_gen_hdaa_salt) {
+		//=md5_gen(1060)679066476e67b5c7c4e88f04be567f8b$8c12bd8f728afe56d45a0ce846b70e5a$$Uuser$$F2myrealm$$F3GET$/$$F400000001$4b61913cec32e2c9$auth:nocode
+		//digest authentication scheme :
+		//H1 = md5(user:realm:password)
+		//H2 = md5(method:digestURI)
+		//response = H3 = md5(h1:nonce:nonceCount:ClientNonce:qop:h2)
+
+		// salt is:
+		//8c12bd8f728afe56d45a0ce846b70e5a$$Uuser$$F2myrealm$$F3GET$/$$F400000001$4b61913cec32e2c9$auth
+		//change this to:  (abcd is base-64 number)
+		//abcd                            :8c12bd8f728afe56d45a0ce846b70e5a:00000001:4b61913cec32e2c9:auth:H1$$Uuser$$F2myrealm
+
+		unsigned char *cp2, *cp3, *cp4, *cpTmp = mem_alloc(strlen(Salt) + 200);  // larger than needed, 100% assured.
+		unsigned char *cpU2 = mem_alloc(strlen(Salt));
+		static unsigned cnt = 1;
+		unsigned i, j;
+		MD5_CTX ctx;
+		unsigned char Buf[16], h1_input[64];
+
+		memset(cpTmp, ' ', 33);
+
+		j = cnt++;
+		cp2 = cpTmp;
+		for (i = 0; i < 4; ++i) {
+			*cp2++ = itoa64[j%64];
+			j /= 64;
+		}
+		cp3 = (unsigned char*)strstr(Salt, "$$U");
+		*cp3++ = 0;
+		cp2 = cpU2;
+		*cp2++ = '$';
+		while (strncmp((char*)cp3, "$$F3", 4))
+			*cp2++ = *cp3++;
+		*cp2 = 0;
+		cp2 = &cpTmp[32];
+		*cp2++ = ':';
+		strcpy((char*)cp2, Salt);
+		cp2 += strlen((char*)cp2);
+		*cp2++ = ':';
+		cp4 = h1_input;
+		cp3 += 4;
+		while (strncmp((char*)cp3, "$$F4", 4)) {
+			if (*cp3 == '$') { *cp4++ = ':'; ++cp3; continue; }
+			*cp4++ = *cp3++;
+		}
+		*cp4 = 0;
+		MD5_Init(&ctx);
+		MD5_Update(&ctx, h1_input, strlen((char*)h1_input));
+		MD5_Final(Buf, &ctx);
+
+		cp3 += 4;
+		while (*cp3) {
+			if (*cp3 == '$') { *cp2++ = ':'; ++cp3; continue; }
+			*cp2++ = *cp3++;
+		}
+		*cp2++ = ':';
+		cp3 = Buf;
+		for (i = 0; i < 16; ++i)
+		{
+			*cp2++ = md5gen_itoa16[(*cp3)>>4];
+			*cp2++ = md5gen_itoa16[(*cp3)&0xF];
+			++cp3;
+		}
+		*cp2 = 0;
+		strcat((char*)cpTmp, (char*)cpU2);
+		strcpy(Salt, (char*)cpTmp);
+		MEM_FREE(cpU2);
+		MEM_FREE(cpTmp);
+	}
+	return Salt;
+}
+/*********************************************************************************
+ * 'special' get salt function for phpass. We return the 8 bytes salt, followed by
+ * the 1 byte loop count.  'normally' in phpass format, that order is reversed.
+ * we do it this way, since our 'primitive' functions would not know to treat the
+ * salt any differently for phpass.  Thus the primitives are told about the first
+ * 8 bytes (and not the full 9).  But the phpass crypt function uses that 9th byte.
+ *********************************************************************************/
+static void *salt_phpass(char *ciphertext)
+{
+	static unsigned char salt[64];
+	// store off the 'real' 8 bytes of salt
+	char *cp = strchr(ciphertext, ')');
+	memcpy(salt, &cp[25], 8);
+	// append the 1 byte of loop count information.
+	salt[8] = cp[24];
+	salt[9]=0;
+
+	saltlen=8;
+
+
+	return salt;
+}
+
+/*********************************************************************************
+ * This returns a 'decent' hash for salted hashes (where they are unk arbritray
+ * text.  Many of the salts are from ' ' to 0x7E.  This function works well for
+ * them. NOTE we have to KNOW that a format is not salted, and ALWAYS return 0
+ * for them.  If not, even though they are listed as not salted, JOHN will have
+ * problems, and will treat them 'like' salted (i.e. slows john down A LOT).
+ *********************************************************************************/
+static int salt_hash(void *salt)
+{
+	int x,y;
+	if (!salt || *((char*)salt) == 0)
+		return 0;
+	x = ((ARCH_WORD_32)(ARCH_INDEX(((unsigned char *)salt)[0])-' '));
+	y = (((ARCH_WORD_32)(ARCH_INDEX(((unsigned char *)salt)[1])-' ')<<4));
+	return (x+y) & 0x3FF;
+}
+
+/*********************************************************************************
+ * Gets the binary value from a base-16 hash.
+ *********************************************************************************/
+static void *binary(char *_ciphertext)
+{
+	static char *realcipher;
+	int i;
+	char *ciphertext = _ciphertext;
+
+	if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE_SHA, MEM_ALIGN_WORD);
+
+	if (!strncmp(_ciphertext, "md5_gen(", 8)) {
+		while (*ciphertext++ != ')')
+			;
+	}
+
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		realcipher[i] =
+			atoi16[ARCH_INDEX(ciphertext[i*2])]*16 +
+			atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+	}
+	return (void *)realcipher;
+}
+/*********************************************************************************
+ * Gets the binary value from a base-64 hash (such as phpass)
+ *********************************************************************************/
+static void * binary_b64(char *ciphertext)
+{
+	int i;
+	unsigned sixbits;
+	static unsigned char b[16];
+	int bidx=0;
+	char *pos;
+
+	// ugly code, but only called one time (at program load,
+	// once for each candidate pass hash).
+
+	pos = ciphertext;
+	if (!strncmp(ciphertext, "md5_gen(", 8)) {
+		while (*pos++ != ')')
+			;
+	}
+	for (i = 0; i < 5; ++i)
+	{
+ 		sixbits = atoi64[ARCH_INDEX(*pos++)];
+		b[bidx] = sixbits;
+		sixbits = atoi64[ARCH_INDEX(*pos++)];
+		b[bidx++] |= (sixbits<<6);
+		sixbits >>= 2;
+		b[bidx] = sixbits;
+		sixbits = atoi64[ARCH_INDEX(*pos++)];
+		b[bidx++] |= (sixbits<<4);
+		sixbits >>= 4;
+		b[bidx] = sixbits;
+		sixbits = atoi64[ARCH_INDEX(*pos++)];
+		b[bidx++] |= (sixbits<<2);
+	}
+	sixbits = atoi64[ARCH_INDEX(*pos++)];
+	b[bidx] = sixbits;
+	sixbits = atoi64[ARCH_INDEX(*pos++)];
+	b[bidx] |= (sixbits<<6);
+	return b;
+}
+
+#define TO_BINARY(b1, b2, b3) \
+	value = \
+		(MD5_word)atoi64[ARCH_INDEX(pos[0])] | \
+		((MD5_word)atoi64[ARCH_INDEX(pos[1])] << 6) | \
+		((MD5_word)atoi64[ARCH_INDEX(pos[2])] << 12) | \
+		((MD5_word)atoi64[ARCH_INDEX(pos[3])] << 18); \
+	pos += 4; \
+	b[b1] = value >> 16; \
+	b[b2] = value >> 8; \
+	b[b3] = value;
+static void * binary_b64a(char *ciphertext)
+{
+	static unsigned char b[16];
+	char *pos;
+	MD5_word value;
+
+	pos = ciphertext;
+	if (!strncmp(ciphertext, "md5_gen(", 8)) {
+		while (*pos++ != ')')
+			;
+	}
+	TO_BINARY(0, 6, 12);
+	TO_BINARY(1, 7, 13);
+	TO_BINARY(2, 8, 14);
+	TO_BINARY(3, 9, 15);
+	TO_BINARY(4, 10, 5);
+	b[11] =
+		(MD5_word)atoi64[ARCH_INDEX(pos[0])] |
+		((MD5_word)atoi64[ARCH_INDEX(pos[1])] << 6);
+
+	MD5_swap((MD5_word*)b,(MD5_word*)b, 4);
+	return b;
+}
+
+/*********************************************************************************
+ * Gets the binary value from a base-64 hash (such as cisco PIX)
+ *********************************************************************************/
+static void * binary_b64_4x6(char *ciphertext)
+{
+	static ARCH_WORD_32 b[4];
+	int i;
+	char *pos;
+
+	pos = ciphertext;
+	if (!strncmp(ciphertext, "md5_gen(", 8)) {
+		while (*pos++ != ')')
+			;
+	}
+	for(i = 0; i < 4; i++) {
+		b[i] =
+			atoi64[ARCH_INDEX(pos[i*4 + 0])] +
+			(atoi64[ARCH_INDEX(pos[i*4 + 1])] << 6) +
+			(atoi64[ARCH_INDEX(pos[i*4 + 2])] << 12) +
+			(atoi64[ARCH_INDEX(pos[i*4 + 3])] << 18);
+	}
+	MD5_swap(b,b, 4);
+	return (void *)b;
+}
+
+/*********************************************************************************
+ * Here is the main mdg_generic fmt_main. NOTE in it's default settings, it is
+ * ready to handle base-16 hashes.  The phpass stuff will be linked in later, IF
+ * needed.
+ *********************************************************************************/
+struct fmt_main fmt_MD5gen =
+{
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+#ifdef MMX_COEF
+		ALGORITHM_NAME,
+#else
+		ALGORITHM_NAME_X86,
+#endif
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+#ifdef MMX_COEF
+		PLAINTEXT_LENGTH,
+#else
+		PLAINTEXT_LENGTH_X86,
+#endif
+		BINARY_SIZE,
+		SALT_SIZE,
+#ifdef MMX_COEF
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+#else
+		MIN_KEYS_PER_CRYPT_X86,
+		MAX_KEYS_PER_CRYPT_X86,
+#endif
+		FMT_CASE | FMT_8_BIT,
+		md5_gen_tests
+	}, {
+		init,
+		prepare,
+		valid,
+		fmt_default_split,
+		binary,
+		salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
+
+/**************************************************************
+ **************************************************************
+ **************************************************************
+ **************************************************************
+ *  These are the md5 'primitive' functions that are used by
+ *  the build-in expressions, and by the expression generator
+ *  They load passwords, salts, user ids, do crypts, convert
+ *  crypts into base-16, etc.  They are pretty encompassing,
+ *  and have been found to be able to do most anything with
+ *  a standard 'base-16' md5 hash, salted or unsalted that
+ *  fits a 'simple' php style expression.
+ **************************************************************
+ **************************************************************
+ **************************************************************
+ *************************************************************/
+
+#ifdef MMX_COEF
+
+
+/**************************************************************
+ **************************************************************
+ *  Here are some 'helpers' to our helpers, when it comes to
+ *  loading data into the mmx/sse buffers.  We have several
+ *  of these common helper functions, and use them in 'most'
+ *  of the helper primatives, instead of having the same
+ *  code being inlined in each of them.
+ **************************************************************
+ *************************************************************/
+
+static void __SSE_Load_itoa16_w2()
+{
+	char buf[3];
+	int i;
+	for (i = 0; i < 256; ++i)
+	{
+		sprintf(buf, "%X%X", i>>4, i&0xF);
+		memcpy(&(itoa16_w2_u[i]), buf, 2);
+		sprintf(buf, "%x%x", i>>4, i&0xF);
+		memcpy(&(itoa16_w2_l[i]), buf, 2);
+	}
+}
+
+//**************************************************************************************
+// output -> base16 -> input.
+//
+//  IPB points to input buffer (&input1[idx] or &input2[idx]).  idx is count/MMX_COEF.
+//      Caller computes right buffer
+//  CRY is pointer to the crypt buffer (&crypt1[idx] or crypt2[idx])
+//  idx_mod is count%MMX_COEF
+//**************************************************************************************
+#if (LOW_BASE16_INPUT_TYPE==1) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_1(ARCH_WORD_32 *IPBdw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #1
+    // 6040K  (core2, md5_gen(2))
+    // 1576K  (core2, md5_gen(1006))
+	// 3392K  (ath64, md5_gen(2))
+	// 827.3K (ath64, md5_gen(1006))
+#if (MMX_COEF==4)
+#  define inc 4
+#  define incCRY 12
+#else
+#  define inc 2
+#  define incCRY 4
+#endif
+	// start our pointers out at the right 32 bit offset into the first MMX/SSE buffer
+	IPBdw += idx_mod;
+	CRY += (idx_mod<<2);
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+
+	// Add the 0x80 at the proper location (offset 0x21)
+	IPBdw += inc;
+	*IPBdw = 0x80;
+#undef inc
+#undef incCRY
+}
+#endif
+
+#if (LOW_BASE16_INPUT_TYPE==2) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_2(ARCH_WORD_32 *IPBdw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #2
+    // 6083k  (core2, md5_gen(2))
+    // 1590K  (core2, md5_gen(1006))
+	// 3537K  (ath64, md5_gen(2))
+	// 890.3K (ath64, md5_gen(1006))
+#undef inc
+#if (MMX_COEF==4)
+#define inc 4
+#  define incCRY 14
+#else
+#define inc 2
+#  define incCRY 6
+#endif
+
+	// start our pointers out at the right 32 bit offset into the first MMX/SSE buffer
+	IPBdw += idx_mod;
+	CRY += (idx_mod<<2);
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+
+	// Add the 0x80 at the proper location (offset 0x21)
+	IPBdw += inc;
+	*IPBdw = 0x80;
+#undef inc
+#undef incCRY
+}
+#endif
+
+#if (LOW_BASE16_INPUT_TYPE==3) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_3(unsigned short *IPBw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #3
+    // 5955K  (core2, md5_gen(2))
+    // 1565K  (core2, md5_gen(1006))
+	// 3381K  (ath64, md5_gen(2))
+	// 824.7k (ath64, md5_gen(1006))
+#undef inc
+#if (MMX_COEF==4)
+#define inc 6
+#else
+#define inc 2
+#endif
+	IPBw += (idx_mod<<1);
+	CRY += (idx_mod<<2);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+
+	*IPBw = 0x80;
+#undef inc
+}
+#endif
+
+static void __SSE_overwrite_output_base16_to_input(unsigned short *IPBw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #3
+    // 5955K  (core2, md5_gen(2))
+    // 1565K  (core2, md5_gen(1006))
+	// 3381K  (ath64, md5_gen(2))
+	// 824.7k (ath64, md5_gen(1006))
+#undef inc
+#if (MMX_COEF==4)
+#define inc 6
+#else
+#define inc 2
+#endif
+	IPBw += (idx_mod<<1);
+	CRY += (idx_mod<<2);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+#undef inc
+}
+
+#if (LOW_BASE16_INPUT_SEMI0_TYPE==1) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_semi_aligned0_1(unsigned ip, ARCH_WORD_32* IPBdw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #1
+    // 6083k  (core2, md5_gen(9))
+    // 1590K  (core2, md5_gen(10))
+	// 3537K  (ath64, md5_gen(9))
+	// 890.3K (ath64, md5_gen(10))
+#if (MMX_COEF==4)
+# define inc 4
+# define incCRY 12
+#else
+# define inc 2
+# define incCRY 4
+#endif
+	IPBdw += idx_mod;
+	IPBdw += (ip>>2)*MMX_COEF;
+
+	CRY += (idx_mod<<2);
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	CRY += incCRY;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+
+	// Add the 0x80 at the proper location (offset 0x21)
+	IPBdw += inc;
+	*IPBdw = 0x80;
+#undef inc
+#undef incCRY
+}
+#endif
+
+#if (LOW_BASE16_INPUT_SEMI2_TYPE==1) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_semi_aligned2_1(unsigned ip, ARCH_WORD_32 *IPBdw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #1
+    // 9586k/4740k  (core2, md5_gen(9))
+    // 5113k/4382k  (core2, md5_gen(10))
+	//  (ath64, md5_gen(9))
+	//  (ath64, md5_gen(10))
+#if (MMX_COEF==4)
+# define inc 4
+# define incCRY 12
+#else
+# define inc 2
+# define incCRY 4
+#endif
+	// Ok, here we are 1/2 off. We are starting in the 'middle' of a DWORD (and end
+	// in the middle of the last one).
+
+	// start our pointers out at the right 32 bit offset into the first MMX/SSE buffer
+	IPBdw += idx_mod;
+	IPBdw += (ip>>2)*MMX_COEF;
+
+	CRY += (idx_mod<<2);
+
+	// first byte handled here.
+	*IPBdw &= 0xFFFF;
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	CRY += incCRY;
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	CRY += incCRY;
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+	CRY += incCRY;
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+
+	*IPBdw = (itoa16_w2[*CRY++]);
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY++]))<<16);
+	IPBdw += inc;
+	*IPBdw = (itoa16_w2[*CRY++]);
+
+	// Add the 0x80 at the proper location (offset 0x21)
+	*IPBdw |= 0x800000;
+
+#undef inc
+#undef incCRY
+}
+#endif
+
+#if (LOW_BASE16_INPUT_SEMI0_TYPE==2) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_semi_aligned0_2(unsigned ip, ARCH_WORD_32 *IPBdw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #2
+    // 6083k  (core2, md5_gen(2))
+    // 1590K  (core2, md5_gen(1006))
+	// 3537K  (ath64, md5_gen(2))
+	// 890.3K (ath64, md5_gen(1006))
+#undef inc
+#if (MMX_COEF==4)
+#define inc 4
+//# define incCRY 12
+# define incCRY 14
+#else
+#define inc 2
+# define incCRY 6
+#endif
+
+
+	// start our pointers out at the right 32 bit offset into the first MMX/SSE buffer
+	IPBdw += idx_mod;
+	IPBdw += (ip>>2)*MMX_COEF;
+	CRY += (idx_mod<<2);
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+//	CRY += (inc*3)+2;
+	CRY += incCRY;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+//	CRY += (inc*3)+2;
+	CRY += incCRY;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+//	CRY += (inc*3)+2;
+	CRY += incCRY;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+	IPBdw += inc;
+	CRY += 2;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+1)]))<<16)|(itoa16_w2[*CRY]);
+
+	// Add the 0x80 at the proper location (offset 0x21)
+	IPBdw += inc;
+	*IPBdw = 0x80;
+#undef inc
+#undef incCRY
+}
+#endif
+
+#if (LOW_BASE16_INPUT_SEMI2_TYPE==2) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_semi_aligned2_2(unsigned ip, ARCH_WORD_32 *IPBdw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #2
+    // 10375k/4902k (core2, md5_gen(9))
+    // 5263k/4502k  (core2, md5_gen(10))
+	//  (ath64, md5_gen(9))
+	//  (ath64, md5_gen(10))
+#undef inc
+#if (MMX_COEF==4)
+#define inc 4
+#define incCRY 16
+#else
+#define inc 2
+#define incCRY 8
+#endif
+	// Ok, here we are 1/2 off. We are starting in the 'middle' of a DWORD (and end
+	// in the middle of the last one).
+
+	// start our pointers out at the right 32 bit offset into the first MMX/SSE buffer
+	IPBdw += idx_mod;
+	IPBdw += (ip>>2)*MMX_COEF;
+
+	CRY += (idx_mod<<2);
+
+	// first byte handled here.
+	*IPBdw &= 0xFFFF;
+	*IPBdw |= (((ARCH_WORD_32)(itoa16_w2[*CRY]))<<16);
+	IPBdw += inc;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+2)]))<<16)|(itoa16_w2[*(CRY+1)]);
+	IPBdw += inc;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+incCRY)]))<<16)|(itoa16_w2[*(CRY+3)]);
+	CRY += incCRY;
+	IPBdw += inc;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+2)]))<<16)|(itoa16_w2[*(CRY+1)]);
+	IPBdw += inc;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+incCRY)]))<<16)|(itoa16_w2[*(CRY+3)]);
+	CRY += incCRY;
+	IPBdw += inc;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+2)]))<<16)|(itoa16_w2[*(CRY+1)]);
+	IPBdw += inc;
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+incCRY)]))<<16)|(itoa16_w2[*(CRY+3)]);
+	CRY += incCRY;
+	IPBdw += inc;
+
+	*IPBdw = (((ARCH_WORD_32)(itoa16_w2[*(CRY+2)]))<<16)|(itoa16_w2[*(CRY+1)]);
+	IPBdw += inc;
+	*IPBdw = (0x80<<16)|(itoa16_w2[*(CRY+3)]);
+
+#undef inc
+#undef incCRY
+}
+#endif
+
+#if (LOW_BASE16_INPUT_SEMI0_TYPE==3) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_semi_aligned0_3(unsigned ip, unsigned short *IPBw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #3
+    // 5955K  (core2, md5_gen(2))
+    // 1565K  (core2, md5_gen(1006))
+	// 3381K  (ath64, md5_gen(2))
+	// 824.7k (ath64, md5_gen(1006))
+#undef inc
+#if (MMX_COEF==4)
+#define inc 6
+#else
+#define inc 2
+#endif
+	IPBw += (idx_mod<<1);
+	IPBw += (ip>>1)*MMX_COEF;
+	CRY += (idx_mod<<2);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+
+	*IPBw = 0x80;
+#undef inc
+}
+#endif
+
+#if (LOW_BASE16_INPUT_SEMI2_TYPE==3) || defined (DEEP_TIME_TEST)
+static void __SSE_append_output_base16_to_input_semi_aligned2_3(unsigned ip, unsigned short *IPBw, unsigned char *CRY, unsigned idx_mod)
+{
+	// #3
+    // 9398k/4588k  (core2, md5_gen(2))
+    // 4825k/4186k  (core2, md5_gen(1006))
+	//  (ath64, md5_gen(2))
+	//  (ath64, md5_gen(1006))
+#undef inc
+#if (MMX_COEF==4)
+#define inc 6
+#else
+#define inc 2
+#endif
+	IPBw += (idx_mod<<1);
+	IPBw += ((ip>>2)*MMX_COEF)<<1;
+	CRY += (idx_mod<<2);
+
+	++IPBw;
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	CRY += (inc<<1);
+
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+	*IPBw++ = itoa16_w2[*CRY++];
+	IPBw += inc;
+	*IPBw++ = itoa16_w2[*CRY++];
+
+	*IPBw = 0x80;
+#undef inc
+}
+#endif
+
+static void __SSE_append_string_to_input_unicode(unsigned char *IPB, unsigned idx_mod, char *cp, unsigned len, unsigned bf_ptr, unsigned bUpdate0x80)
+{
+	unsigned char *cpO;
+#if ARCH_LITTLE_ENDIAN
+	// if big-endian, we gain nothing from this function (since we would have to byte swap)
+    if (len>1&&!(bf_ptr&1))
+    {
+        unsigned w32_cnt;
+		if(bf_ptr&2) {
+			cpO = &IPB[GETPOS(bf_ptr, idx_mod)];
+			bf_ptr += 2;
+			*cpO = *cp++;
+			cpO[1] = 0;
+			--len;
+		}
+		w32_cnt = len>>1;
+        if (w32_cnt)
+        {
+            ARCH_WORD_32 *wpO;
+            wpO = (ARCH_WORD_32*)&IPB[GETPOS(bf_ptr, idx_mod)];
+            len -= (w32_cnt<<1);
+            bf_ptr += (w32_cnt<<2);
+            do
+            {
+				ARCH_WORD_32 x = 0;
+                x = cp[1];
+				x <<= 16;
+				x += cp[0];
+				*wpO = x;
+                cp += 2;
+                wpO += MMX_COEF;
+            }
+            while (--w32_cnt);
+        }
+    }
+#endif
+	cpO = &IPB[GETPOS(bf_ptr, idx_mod)];
+	while (len--)
+	{
+		*cpO++ = *cp++;
+		if ( ((++bf_ptr)&3) == 0)
+			cpO += ((MMX_COEF-1)*4);
+		*cpO++ = 0;
+		if ( ((++bf_ptr)&3) == 0)
+			cpO += ((MMX_COEF-1)*4);
+	}
+	if (bUpdate0x80)
+		*cpO = 0x80;
+
+}
+
+static void __SSE_append_string_to_input(unsigned char *IPB, unsigned idx_mod, char *cp, unsigned len, unsigned bf_ptr, unsigned bUpdate0x80)
+{
+	unsigned char *cpO;
+	// if our insertion point is on an 'even' DWORD, then we use DWORD * copying, as long as we can
+	// This provides quite a nice speedup.
+#if ARCH_LITTLE_ENDIAN
+	// if big-endian, we gain nothing from this function (since we would have to byte swap)
+	if (len>3&&(bf_ptr&3)) {
+		cpO = &IPB[GETPOS(bf_ptr, idx_mod)];
+		while (len--)
+		{
+			*cpO++ = *cp++;
+			if ( ((++bf_ptr)&3) == 0) {
+				if (!len) {
+					if (bUpdate0x80)
+						*cpO = 0x80;
+					return;
+				}
+				break;
+			}
+		}
+	}
+    if (len>3&&!(bf_ptr&3))
+    {
+        unsigned w32_cnt = len>>2;
+        if (w32_cnt)
+        {
+            ARCH_WORD_32 *wpO;
+            wpO = (ARCH_WORD_32*)&IPB[GETPOS(bf_ptr, idx_mod)];
+            len -= (w32_cnt<<2);
+            bf_ptr += (w32_cnt<<2);
+            do
+            {
+                *wpO = *((ARCH_WORD_32*)cp);
+                cp += 4;
+                wpO += MMX_COEF;
+            }
+            while (--w32_cnt);
+        }
+		if (!len) {
+			if (bUpdate0x80)
+				IPB[GETPOS(bf_ptr, idx_mod)] = 0x80;
+			return;
+		}
+    }
+#endif
+	cpO = &IPB[GETPOS(bf_ptr, idx_mod)];
+	while (len--)
+	{
+		*cpO++ = *cp++;
+		if ( ((++bf_ptr)&3) == 0)
+			cpO += ((MMX_COEF-1)*4);
+	}
+	if (bUpdate0x80)
+		*cpO = 0x80;
+}
+
+#ifdef DEEP_TIME_TEST
+#include "timer.h"
+
+static int __SSE_gen_BenchLowLevMD5(unsigned secs, unsigned which)
+{
+#ifndef CLK_TCK
+	return 0;
+#else
+	int i;
+	unsigned cnt=0;
+	clock_t til;
+	sTimer Timer;
+	double d;
+
+	til = clock();
+	til += secs*CLK_TCK;
+	m_count = 100;
+
+	store_keys_in_input = 1;
+
+	for (i = 0; i < BLOCK_LOOPS-2; ++i)
+	{
+		char Pass[40];
+		sprintf(Pass, "Sample Password %d - %d", cnt, i);
+		fmt_MD5gen.methods.set_key(Pass, i);
+	}
+	MD5GenBaseFunc__clean_input();
+	MD5GenBaseFunc__clean_input2();
+	MD5GenBaseFunc__append_keys();
+	MD5GenBaseFunc__crypt();
+	MD5GenBaseFunc__append_keys2();
+	MD5GenBaseFunc__crypt2();
+
+	sTimer_sTimer(&Timer);
+	sTimer_Start(&Timer, 1);
+
+	while (clock() < til)
+	{
+		++cnt;
+		switch(which)
+		{
+			case 1:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_1((void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_1((void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 2:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_2((void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_2((void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 3:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_3((void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_3((void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 4:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_semi_aligned0_1(8, (void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_semi_aligned0_1(8, (void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 5:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_semi_aligned0_2(8, (void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_semi_aligned0_2(8, (void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 6:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_semi_aligned0_3(8, (void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_semi_aligned0_3(8, (void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 7:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_semi_aligned2_1(10, (void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_semi_aligned2_1(10, (void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 8:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_semi_aligned2_2(10, (void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_semi_aligned2_2(10, (void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+			case 9:
+				for (i = 0; i<100; i++)
+				{
+					__SSE_append_output_base16_to_input_semi_aligned2_3(10, (void*)(&input_buf[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+					__SSE_append_output_base16_to_input_semi_aligned2_3(10, (void*)(&input_buf2[i>>(MMX_COEF>>1)]), (unsigned char*)(&crypt_key2[i>>(MMX_COEF>>1)]), i&(MMX_COEF-1));
+				}
+				break;
+		}
+	}
+	d = cnt;
+	d *= 100;
+	d /= sTimer_GetSecs(&Timer);
+
+
+	MD5GenBaseFunc__clean_input();
+	MD5GenBaseFunc__clean_input2();
+	fmt_MD5gen.methods.set_key("", 0);
+
+	return (int)d;
+#endif
+}
+
+static void __SSE_gen_BenchLowLevelFunctions()
+{
+#ifdef CLK_TCK
+	unsigned cnt;
+	extern unsigned int benchmark_time;
+
+	printf ("\n\nBenchmarking Low Level generic-md5 conversion functions (smaller is faster)\n");
+	if (benchmark_time > 3600)
+		benchmark_time = 3600;
+	// I am simply going to use the 'emu' time, using clock() function.  If
+	// a compiler does not have CLK_TCK defined (they define CLK_TCK CLOCKS_PER_SEC)
+	// then this function will never be run.  Sorry, it works for me.
+
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 1);
+	printf ("%u runs of __SSE_append_output_base16_to_input_1\n", cnt);
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 2);
+	printf ("%u runs of __SSE_append_output_base16_to_input_2\n", cnt);
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 3);
+	printf ("%u runs of __SSE_append_output_base16_to_input_3\n\n", cnt);
+
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 4);
+	printf ("%u runs of __SSE_append_output_base16_to_input_semi_aligned0_1\n", cnt);
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 5);
+	printf ("%u runs of __SSE_append_output_base16_to_input_semi_aligned0_2\n", cnt);
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 6);
+	printf ("%u runs of __SSE_append_output_base16_to_input_semi_aligned0_3\n\n", cnt);
+
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 7);
+	printf ("%u runs of __SSE_append_output_base16_to_input_semi_aligned2_1\n", cnt);
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 8);
+	printf ("%u runs of __SSE_append_output_base16_to_input_semi_aligned2_2\n", cnt);
+	cnt = __SSE_gen_BenchLowLevMD5(benchmark_time, 9);
+	printf ("%u runs of __SSE_append_output_base16_to_input_semi_aligned2_3\n\n", cnt);
+
+#endif
+}
+#endif
+
+#endif  // #ifdef MMX_COEF from way above.
+
+
+static inline void __append_string(char *Str, unsigned len)
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		if (!md5_unicode_convert) {
+			for (j = 0; j < m_count; ++j) {
+				unsigned idx = (j>>(MMX_COEF>>1));
+				unsigned idx_mod = j&(MMX_COEF-1);
+				unsigned bf_ptr = (total_len[idx] >> ((32/MMX_COEF)*idx_mod)) & 0xFF;
+				total_len[idx] += (len << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input((unsigned char*)(&input_buf[idx]),idx_mod,Str,len,bf_ptr,1);
+			}
+		} else {
+			for (j = 0; j < m_count; ++j) {
+				unsigned idx = (j>>(MMX_COEF>>1));
+				unsigned idx_mod = j&(MMX_COEF-1);
+				unsigned bf_ptr = (total_len[idx] >> ((32/MMX_COEF)*idx_mod)) & 0xFF;
+				total_len[idx] += ( (len<<1) << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input_unicode((unsigned char*)(&input_buf[idx]),idx_mod,Str,len,bf_ptr,1);
+			}
+		}
+		return;
+	}
+#endif
+	if (md5_unicode_convert) {
+		for (j = 0; j < m_count; ++j) {
+			int z;
+			char *cp;
+			char *cpi = Str;
+#if MD5_X2
+			if (j&1)
+				cp = &(input_buf_X86[j>>MD5_X2].x2.b2[total_len_X86[j]]);
+			else
+#endif
+			cp = &(input_buf_X86[j>>MD5_X2].x1.b[total_len_X86[j]]);
+			for (z = 0; z < len; ++z) {
+				*cp++ = *cpi++;
+				*cp++ = 0;
+			}
+			total_len_X86[j] += (len<<1);
+		}
+	} else {
+		for (j = 0; j < m_count; ++j) {
+#if MD5_X2
+			if (j&1)
+				memcpy(&(input_buf_X86[j>>MD5_X2].x2.b2[total_len_X86[j]]), Str, len);
+			else
+#endif
+			memcpy(&(input_buf_X86[j>>MD5_X2].x1.b[total_len_X86[j]]), Str, len);
+			total_len_X86[j] += len;
+		}
+	}
+}
+
+static inline void __append2_string(char *Str, unsigned len)
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		if (!md5_unicode_convert) {
+			for (j = 0; j < m_count; ++j) {
+				unsigned idx = (j>>(MMX_COEF>>1));
+				unsigned idx_mod = j&(MMX_COEF-1);
+				unsigned bf_ptr = (total_len2[idx] >> ((32/MMX_COEF)*idx_mod)) & 0xFF;
+				total_len2[idx] += ( len << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input((unsigned char*)(&input_buf2[idx]),idx_mod,Str,len,bf_ptr,1);
+			}
+		} else {
+			for (j = 0; j < m_count; ++j) {
+				unsigned idx = (j>>(MMX_COEF>>1));
+				unsigned idx_mod = j&(MMX_COEF-1);
+				unsigned bf_ptr = (total_len2[idx] >> ((32/MMX_COEF)*idx_mod)) & 0xFF;
+				total_len2[idx] += ( (len<<1) << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input_unicode((unsigned char*)(&input_buf2[idx]),idx_mod,Str,len,bf_ptr,1);
+			}
+		}
+		return;
+	}
+#endif
+	if (md5_unicode_convert) {
+		for (j = 0; j < m_count; ++j) {
+			int z;
+			char *cp;
+			char *cpi = Str;
+#if MD5_X2
+			if (j&1)
+				cp = (char*)&(input_buf2_X86[j>>MD5_X2].x2.b2[total_len2_X86[j]]);
+			else
+#endif
+			cp = (char*)&(input_buf2_X86[j>>MD5_X2].x1.b[total_len2_X86[j]]);
+			for (z = 0; z < len; ++z) {
+				*cp++ = *cpi++;
+				*cp++ = 0;
+			}
+			total_len2_X86[j] += (len<<1);
+		}
+	} else {
+		for (j = 0; j < m_count; ++j) {
+#if MD5_X2
+			if (j&1)
+				memcpy(&(input_buf2_X86[j>>MD5_X2].x2.b2[total_len2_X86[j]]), Str, len);
+			else
+#endif
+			memcpy(&(input_buf2_X86[j>>MD5_X2].x1.b[total_len2_X86[j]]), Str, len);
+			total_len2_X86[j] += len;
+		}
+	}
+}
+
+void MD5GenBaseFunc__setmode_unicode()
+{
+	md5_unicode_convert = 1;
+}
+void MD5GenBaseFunc__setmode_normal ()
+{
+	md5_unicode_convert = 0;
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Clears the input variable, and input 'lengths'
+ *************************************************************/
+void MD5GenBaseFunc__clean_input()
+{
+	unsigned i=0;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		memset(input_buf, 0, sizeof(input_buf));
+		memset(total_len, 0, sizeof(total_len));
+		return;
+	}
+#endif
+	for (; i < MAX_KEYS_PER_CRYPT_X86; ++i) {
+		//if (total_len_X86[i]) {
+#if MD5_X2
+			if (i&1)
+				memset(input_buf_X86[i>>MD5_X2].x2.b2, 0, total_len_X86[i]+5);
+			else
+#endif
+			memset(input_buf_X86[i>>MD5_X2].x1.b, 0, total_len_X86[i]+5);
+			total_len_X86[i] = 0;
+		//}
+	}
+	return;
+}
+void MD5GenBaseFunc__clean_input2()
+{
+	unsigned i=0;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		memset(input_buf2, 0, sizeof(input_buf2));
+		memset(total_len2, 0, sizeof(total_len2));
+		return;
+	}
+#endif
+	for (; i < MAX_KEYS_PER_CRYPT_X86; ++i) {
+		//if (total_len2_X86[i]) {
+#if MD5_X2
+			if (i&1)
+				memset(input_buf2_X86[i>>MD5_X2].x2.b2, 0, total_len2_X86[i]+5);
+			else
+#endif
+			memset(input_buf2_X86[i>>MD5_X2].x1.b, 0, total_len2_X86[i]+5);
+			total_len2_X86[i] = 0;
+		//}
+	}
+	return;
+}
+void MD5GenBaseFunc__clean_input_full()
+{
+#ifdef MMX_COEF
+	memset(input_buf, 0, sizeof(input_buf));
+	memset(total_len, 0, sizeof(total_len));
+#endif
+	memset(input_buf_X86, 0, sizeof(input_buf_X86));
+	memset(total_len_X86, 0, sizeof(total_len_X86));
+}
+void MD5GenBaseFunc__clean_input2_full()
+{
+#ifdef MMX_COEF
+	memset(input_buf2, 0, sizeof(input_buf));
+	memset(total_len2, 0, sizeof(total_len));
+#endif
+	memset(input_buf2_X86, 0, sizeof(input_buf2_X86));
+	memset(total_len2_X86, 0, sizeof(total_len2_X86));
+}
+void MD5GenBaseFunc__clean_input_kwik()
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		memset(total_len, 0, sizeof(total_len));
+		return;
+	}
+#endif
+	memset(total_len_X86, 0, sizeof(total_len_X86));
+#if !ARCH_LITTLE_ENDIAN
+	memset(input_buf_X86, 0, sizeof(input_buf_X86));
+#endif
+}
+void MD5GenBaseFunc__clean_input2_kwik()
+{
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		memset(total_len2, 0, sizeof(total_len2));
+		return;
+	}
+#endif
+	memset(total_len2_X86, 0, sizeof(total_len2_X86));
+#if !ARCH_LITTLE_ENDIAN
+	memset(input_buf2_X86, 0, sizeof(input_buf2_X86));
+#endif
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Appends all keys to the end of the input variables, and
+ * updates lengths
+ *************************************************************/
+void MD5GenBaseFunc__append_keys()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		for (j = 0; j < m_count; ++j) {
+			unsigned idx = (j>>(MMX_COEF>>1));
+			unsigned idx_mod = j&(MMX_COEF-1);
+			unsigned bf_ptr = (total_len[idx] >> ((32/MMX_COEF)*idx_mod)) & 0xFF;
+			if (md5_unicode_convert) {
+				total_len[idx] += ( ((saved_key_len[j])<<1) << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input_unicode((unsigned char*)(&input_buf[idx]),idx_mod,saved_key[j],saved_key_len[j],bf_ptr,1);
+			} else {
+				total_len[idx] += (saved_key_len[j] << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input((unsigned char*)(&input_buf[idx]),idx_mod,saved_key[j],saved_key_len[j],bf_ptr,1);
+			}
+		}
+		return;
+	}
+#endif
+	if (md5_unicode_convert) {
+		for (j = 0; j < m_count; ++j) {
+			int z;
+			char *cp, *cpi = saved_key[j];
+#if MD5_X2
+			if (j&1)
+				cp = (char*)&(input_buf_X86[j>>MD5_X2].x2.b2[total_len_X86[j]]);
+			else
+#endif
+			cp = (char*)&(input_buf_X86[j>>MD5_X2].x1.b[total_len_X86[j]]);
+			for (z = 0; z < saved_key_len[j]; ++z) {
+				*cp++ = *cpi++;
+				*cp++ = 0;
+			}
+			total_len_X86[j] += (saved_key_len[j]<<1);
+		}
+	} else {
+		for (j = 0; j < m_count; ++j) {
+#if MD5_X2
+			if (j&1)
+				memcpy(&(input_buf_X86[j>>MD5_X2].x2.b2[total_len_X86[j]]), saved_key[j], saved_key_len[j]);
+			else
+#endif
+			memcpy(&(input_buf_X86[j>>MD5_X2].x1.b[total_len_X86[j]]), saved_key[j], saved_key_len[j]);
+			total_len_X86[j] += saved_key_len[j];
+		}
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Appends all keys to the end of the 2nd input variables, and
+ * updates lengths
+ *************************************************************/
+void MD5GenBaseFunc__append_keys2()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		for (j = 0; j < m_count; ++j) {
+			unsigned idx = (j>>(MMX_COEF>>1));
+			unsigned idx_mod = j&(MMX_COEF-1);
+			unsigned bf_ptr = (total_len2[idx] >> ((32/MMX_COEF)*idx_mod)) & 0xFF;
+			if (md5_unicode_convert) {
+				total_len2[idx] += ( (saved_key_len[j]<<1) << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input_unicode((unsigned char*)(&input_buf2[idx]),idx_mod,saved_key[j],saved_key_len[j],bf_ptr,1);
+			} else {
+				total_len2[idx] += (saved_key_len[j] << ((32/MMX_COEF)*idx_mod));
+				__SSE_append_string_to_input((unsigned char*)(&input_buf2[idx]),idx_mod,saved_key[j],saved_key_len[j],bf_ptr,1);
+			}
+		}
+		return;
+	}
+#endif
+	if (md5_unicode_convert) {
+		for (j = 0; j < m_count; ++j) {
+			int z;
+			unsigned char *cp, *cpi = (unsigned char*)saved_key[j];
+#if MD5_X2
+			if (j&1)
+				cp = &(input_buf2_X86[j>>MD5_X2].x2.B2[total_len2_X86[j]]);
+			else
+#endif
+				cp = &(input_buf2_X86[j>>MD5_X2].x1.B[total_len2_X86[j]]);
+			for (z = 0; z < saved_key_len[j]; ++z) {
+				*cp++ = *cpi++;
+				*cp++ = 0;
+			}
+			total_len2_X86[j] += (saved_key_len[j]<<1);
+		}
+	} else {
+		for (j = 0; j < m_count; ++j) {
+#if MD5_X2
+			if (j&1)
+				memcpy(&(input_buf2_X86[j>>MD5_X2].x2.b2[total_len2_X86[j]]), saved_key[j], saved_key_len[j]);
+			else
+#endif
+			memcpy(&(input_buf2_X86[j>>MD5_X2].x1.b[total_len2_X86[j]]), saved_key[j], saved_key_len[j]);
+			total_len2_X86[j] += saved_key_len[j];
+		}
+	}
+}
+
+void MD5GenBaseFunc__set_input_len_16()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned cnt, k;
+		cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (j = 0; j < cnt; ++j)
+		{
+			// If length is < 16, then remove existing end of buffer marker, and then set
+			// one at offset 16
+			unsigned cur_block_len = total_len[j];
+			for (k = 0; k < MMX_COEF; ++k) {
+				unsigned this_item_len = cur_block_len & 0xFF;
+#if (MMX_COEF==4)
+				cur_block_len >>= 8;
+#else
+				cur_block_len >>= 16;
+#endif
+				if (this_item_len < 16)
+					input_buf[j][GETPOS(this_item_len, k&(MMX_COEF-1))] = 0x00;
+				input_buf[j][GETPOS(16, k&(MMX_COEF-1))] = 0x80;
+			}
+#if (MMX_COEF==4)
+			total_len[j] = 0x10101010;
+#else
+			total_len[j] = 0x100010;
+#endif
+		}
+		return;
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+#if MD5_X2
+		if (j&1) {
+			while (total_len_X86[j] < 16)
+				input_buf_X86[j>>MD5_X2].x2.b2[total_len_X86[j]++] = 0;
+		}
+		else
+#endif
+		{while (total_len_X86[j] < 16)
+			input_buf_X86[j>>MD5_X2].x1.b[total_len_X86[j]++] = 0;}
+		total_len_X86[j] = 16;
+	}
+}
+
+void MD5GenBaseFunc__set_input2_len_16()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned cnt, k;
+		cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (j = 0; j < cnt; ++j)
+		{
+			// If length is < 16, then remove existing end of buffer marker, and then set
+			// one at offset 16
+			unsigned cur_block_len = total_len2[j];
+			for (k = 0; k < MMX_COEF; ++k) {
+				unsigned this_item_len = cur_block_len & 0xFF;
+#if (MMX_COEF==4)
+				cur_block_len >>= 8;
+#else
+				cur_block_len >>= 16;
+#endif
+				if (this_item_len < 16)
+					input_buf2[j][GETPOS(this_item_len, k&(MMX_COEF-1))] = 0x00;
+				input_buf2[j][GETPOS(16, k&(MMX_COEF-1))] = 0x80;
+			}
+#if (MMX_COEF==4)
+			total_len2[j] = 0x10101010;
+#else
+			total_len2[j] = 0x100010;
+#endif
+		}
+		return;
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+#if MD5_X2
+		if (j&1) {
+			while (total_len2_X86[j] < 16)
+				input_buf2_X86[j>>MD5_X2].x2.b2[total_len2_X86[j]++] = 0;
+		}
+		else
+#endif
+		{while (total_len2_X86[j] < 16)
+			input_buf2_X86[j>>MD5_X2].x1.b[total_len2_X86[j]++] = 0;}
+		total_len2_X86[j] = 16;
+	}
+}
+
+void MD5GenBaseFunc__set_input_len_32()
+{
+	unsigned i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned cnt;
+		cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+		{
+#if (MMX_COEF==4)
+			total_len[i] = 0x20202020;
+#else
+			total_len[i] = 0x200020;
+#endif
+		}
+		return;
+	}
+#endif
+	for (i = 0; i < m_count; ++i)
+	{
+		total_len_X86[i] = 32;
+#if !ARCH_LITTLE_ENDIAN
+#if MD5_X2
+		if (i&1) {
+			//MD5_swap(input_buf_X86[i>>MD5_X2].x2.w2, input_buf_X86[i>>MD5_X2].x2.w2, 8);
+			memset(&(input_buf_X86[i>>MD5_X2].x2.B2[32]), 0, 24);
+		}
+		else
+#endif
+		{
+			//MD5_swap(input_buf_X86[i>>MD5_X2].x1.w, input_buf_X86[i>>MD5_X2].x1.w, 8);
+			memset(&(input_buf_X86[i>>MD5_X2].x1.B[32]), 0, 24);
+		}
+#endif
+	}
+}
+
+void MD5GenBaseFunc__set_input2_len_32()
+{
+	unsigned i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned cnt;
+		cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+		{
+#if (MMX_COEF==4)
+			total_len2[i] = 0x20202020;
+#else
+			total_len2[i] = 0x200020;
+#endif
+		}
+		return;
+	}
+#endif
+	for (i = 0; i < m_count; ++i)
+	{
+		total_len2_X86[i] = 32;
+#if !ARCH_LITTLE_ENDIAN
+#if MD5_X2
+		if (i&1) {
+			//MD5_swap(input_buf2_X86[i>>MD5_X2].x2.w2, input_buf2_X86[i>>MD5_X2].x2.w2, 8);
+			memset(&(input_buf2_X86[i>>MD5_X2].x2.B2[32]), 0, 24);
+		}
+		else
+#endif
+		{
+			//MD5_swap(input_buf2_X86[i>>MD5_X2].x1.w, input_buf2_X86[i>>MD5_X2].x1.w, 8);
+			memset(&(input_buf2_X86[i>>MD5_X2].x1.B[32]), 0, 24);
+		}
+#endif
+	}
+}
+
+void MD5GenBaseFunc__set_input_len_64()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		exit(!!fprintf(stderr, "Error, in you MD5-GEN script.\nIt is NOT valid to call MD5GenBaseFunc__set_input_len_64 in SSE2/MMX mode\n"));
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+		total_len_X86[j] = 64;
+	}
+}
+void MD5GenBaseFunc__set_input2_len_64()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		exit(!!fprintf(stderr, "Error, in you MD5-GEN script.\nIt is NOT valid to call MD5GenBaseFunc__set_input2_len_64 in SSE2/MMX mode\n"));
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+		total_len2_X86[j] = 64;
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Appends the salt to the end of the input variables, and
+ * updates lengths
+ *************************************************************/
+void MD5GenBaseFunc__append_salt()
+{
+	__append_string(cursalt, saltlen);
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Appends the salt to the end of the 2nd input variables, and
+ * updates lengths
+ *************************************************************/
+void MD5GenBaseFunc__append_salt2()
+{
+	__append2_string(cursalt, saltlen);
+}
+
+void MD5GenBaseFunc__append_input_from_input2()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned i, k, cnt;
+		cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+		{
+			for (j = 0; j < MMX_COEF; ++j)
+			{
+				unsigned start_len = (total_len[i] >> ((32/MMX_COEF)*j)) & 0xFF;
+				unsigned len1 = (total_len2[i] >> ((32/MMX_COEF)*j)) & 0xFF;
+				for (k = 0; k < len1; ++k)
+					input_buf[i][GETPOS((k+start_len), j)] = input_buf2[i][GETPOS(k,j)];
+				input_buf[i][GETPOS((len1+start_len), j)] = 0x80;
+				total_len[i] += ( len1 << ( ( (32/MMX_COEF) * j ) ));
+			}
+		}
+		return;
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+#if MD5_X2
+		if (j&1)
+			memcpy(&(input_buf_X86[j>>MD5_X2].x2.b2[total_len_X86[j]]), input_buf2_X86[j>>MD5_X2].x2.b2, total_len2_X86[j]);
+		else
+#endif
+		memcpy(&(input_buf_X86[j>>MD5_X2].x1.b[total_len_X86[j]]), input_buf2_X86[j>>MD5_X2].x1.b, total_len2_X86[j]);
+		total_len_X86[j] += total_len2_X86[j];
+	}
+}
+
+void MD5GenBaseFunc__append_input2_from_input()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned i, k, cnt;
+		cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+		{
+			for (j = 0; j < MMX_COEF; ++j)
+			{
+				unsigned start_len = (total_len2[i] >> ((32/MMX_COEF)*j)) & 0xFF;
+				unsigned len1 = (total_len[i] >> ((32/MMX_COEF)*j)) & 0xFF;
+				for (k = 0; k < len1; ++k)
+					input_buf2[i][GETPOS((k+start_len), j)] = input_buf[i][GETPOS(k,j)];
+				input_buf2[i][GETPOS((len1+start_len), j)] = 0x80;
+				total_len2[i] += ( len1 << ( ( (32/MMX_COEF) * j ) ));
+			}
+		}
+		return;
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+#if MD5_X2
+		if (j&1)
+			memcpy(&(input_buf2_X86[j>>MD5_X2].x2.b2[total_len2_X86[j]]), input_buf_X86[j>>MD5_X2].x2.b2, total_len_X86[j]);
+		else
+#endif
+		memcpy(&(input_buf2_X86[j>>MD5_X2].x1.b[total_len2_X86[j]]), input_buf_X86[j>>MD5_X2].x1.b, total_len_X86[j]);
+		total_len2_X86[j] += total_len_X86[j];
+	}
+}
+
+#ifdef MD5_SSE_PARA
+void SSE_Intrinsics_LoadLens(int side, int i)
+{
+	ARCH_WORD_32 *p;
+	ARCH_WORD_32 TL;
+	int j;
+	if (side == 0)
+	{
+		for (j = 0; j < MD5_SSE_PARA; j++)
+		{
+			p = (ARCH_WORD_32 *)(&input_buf[i+j]);
+			TL = (ARCH_WORD_32)total_len[i+j];
+			p[14*MMX_COEF+0] = ((TL>>0)&0xFF)<<3;
+			p[14*MMX_COEF+1] = ((TL>>8)&0xFF)<<3;
+			p[14*MMX_COEF+2] = ((TL>>16)&0xFF)<<3;
+			p[14*MMX_COEF+3] = ((TL>>24)&0xFF)<<3;
+		}
+	}
+	else
+	{
+		for (j = 0; j < MD5_SSE_PARA; j++)
+		{
+			p = (ARCH_WORD_32 *)(&input_buf2[i+j]);
+			TL = (ARCH_WORD_32)total_len2[i+j];
+			p[14*MMX_COEF+0] = ((TL>>0)&0xFF)<<3;
+			p[14*MMX_COEF+1] = ((TL>>8)&0xFF)<<3;
+			p[14*MMX_COEF+2] = ((TL>>16)&0xFF)<<3;
+			p[14*MMX_COEF+3] = ((TL>>24)&0xFF)<<3;
+		}
+	}
+}
+#endif
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Encrypts the data in the first input field. The data is
+ * still in the binary encrypted format, in the crypt_key.
+ * we do not yet convert to base-16.  This is so we can output
+ * as base-16, or later, if we add base-64, we can output to
+ * that format instead.  Some functions do NOT change from
+ * the binary format (such as phpass). Thus if we are doing
+ * something like phpass, we would NOT want the conversion
+ * to happen at all
+ *************************************************************/
+void MD5GenBaseFunc__crypt()
+{
+	unsigned i;
+#ifdef MMX_COEF
+#ifdef MD5_SSE_PARA
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; i += MD5_SSE_PARA)
+		{
+			SSE_Intrinsics_LoadLens(0, i);
+			SSEmd5body((unsigned char*)(&input_buf[i]), (unsigned int*)(&crypt_key[i]), 1);
+		}
+		return;
+	}
+#else
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+			mdfivemmx((unsigned char*)&(crypt_key[i]), (unsigned char*)&(input_buf[i]), total_len[i]);
+		return;
+	}
+#endif
+#endif
+	for (i = 0; i < m_count; ++i) {
+#if MD5_X2
+		unsigned len[2];
+		len[0] = total_len_X86[i++];
+		len[1] = total_len_X86[i];
+#else
+		unsigned len = total_len_X86[i];
+#endif
+		DoMD5(input_buf_X86[i>>MD5_X2], len, crypt_key_X86[i>>MD5_X2]);
+	}
+}
+
+#ifndef MMX_COEF
+typedef struct {
+	union {
+		double dummy;
+		MD5_word w[64/4];
+		char b[64];
+		unsigned char B[64];
+	}x1;
+#if MD5_X2
+	union {
+		double dummy2;
+		MD5_word w2[64/4];
+		char b2[64];
+		unsigned char B2[64];
+	}x2;
+#endif
+} MD5_A;
+
+static MD5_A md5_cspp, md5_pspc, md5_cpp, md5_ppc, md5_csp, md5_psc, md5_cp, md5_pc;
+//static unsigned md5_lens[2][8];
+struct md5_item {
+	MD5_A *in1, *in2, *out2;
+#if ARCH_LITTLE_ENDIAN
+#if MD5_X2
+	unsigned char *off[2];
+#else
+	unsigned char *off;
+#endif
+#else
+	unsigned off[2];
+#endif
+	unsigned len1, len2;
+};
+static struct md5_item md5_items[21] = {
+  {&md5_cp,   &md5_pspc, &md5_cspp },
+  {&md5_cspp, &md5_ppc,  &md5_cspp },
+  {&md5_cspp, &md5_pspc, &md5_cpp },
+  {&md5_cpp,  &md5_psc,  &md5_cspp },
+  {&md5_cspp, &md5_ppc,  &md5_cspp },
+  {&md5_cspp, &md5_pspc, &md5_cpp },
+  {&md5_cpp,  &md5_pspc, &md5_csp },
+  {&md5_csp,  &md5_ppc,  &md5_cspp },
+  {&md5_cspp, &md5_pspc, &md5_cpp },
+  {&md5_cpp,  &md5_pspc, &md5_cspp },
+  {&md5_cspp, &md5_pc,   &md5_cspp },
+  {&md5_cspp, &md5_pspc, &md5_cpp },
+  {&md5_cpp,  &md5_pspc, &md5_cspp },
+  {&md5_cspp, &md5_ppc,  &md5_csp },
+  {&md5_csp,  &md5_pspc, &md5_cpp },
+  {&md5_cpp,  &md5_pspc, &md5_cspp },
+  {&md5_cspp, &md5_ppc,  &md5_cspp },
+  {&md5_cspp, &md5_psc,  &md5_cpp },
+  {&md5_cpp,  &md5_pspc, &md5_cspp },
+  {&md5_cspp, &md5_ppc,  &md5_cspp },
+  {&md5_cspp, &md5_pspc, &md5_cp }
+};
+
+/*
+	if (len<md5_lens[i][b]) memset(&cp[len],0,(md5_lens[i][b]-len)+5); \
+	md5_lens[i][b] = len; \
+*/
+#define SETLEN_MD5_INPUT(a,b,c) do{\
+	len=cp-a+c; \
+	a[len]=0x80; ((MD5_word *)a)[14]=(len<<3); \
+}while(0)
+
+static void FreeBSDMD5Crypt_setup_nonMMX() {
+	unsigned char *cp, *cp1;
+	MD5_word *w;
+	unsigned len, i;
+	char *pass;
+	unsigned plen;
+
+	memset(&md5_cspp,0,sizeof(md5_cspp));
+	memset(&md5_pspc,0,sizeof(md5_pspc));
+	memset(&md5_cpp,0,sizeof(md5_cpp));
+	memset(&md5_ppc,0,sizeof(md5_ppc));
+	memset(&md5_csp,0,sizeof(md5_csp));
+	memset(&md5_psc,0,sizeof(md5_psc));
+	memset(&md5_cp,0,sizeof(md5_cp));
+	memset(&md5_pc,0,sizeof(md5_pc));
+
+	i = 0;
+#if MD5_X2
+	for (; i < 2; ++i)  {
+#endif
+		pass = saved_key[i];
+		plen = saved_key_len[i];
+
+	cp1 = md5_cspp.x1.B; w=md5_cspp.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_cspp.x2.B2; w=md5_cspp.x2.w2; }
+#endif
+	cp = &cp1[16];
+	memcpy(cp, cursalt, saltlen); cp += saltlen; memcpy(cp, pass, plen); cp += plen; memcpy(cp, pass, plen); cp += plen;
+	SETLEN_MD5_INPUT(cp1, 0, 0);
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[1].len1 = md5_items[2].len1 = md5_items[4].len1 = md5_items[5].len1 =
+	md5_items[8].len1 = md5_items[10].len1 = md5_items[11].len1 = md5_items[13].len1 =
+	md5_items[16].len1 = md5_items[17].len1 = md5_items[19].len1 = md5_items[20].len1 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+	cp1 = md5_pspc.x1.B; w=md5_pspc.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_pspc.x2.B2; w=md5_pspc.x2.w2; }
+#endif
+	cp = cp1;
+	memcpy(cp, pass, plen); cp += plen; memcpy(cp, cursalt, saltlen); cp += saltlen; memcpy(cp, pass, plen); cp += plen;
+	SETLEN_MD5_INPUT(cp1, 1, 16);
+#if ARCH_LITTLE_ENDIAN
+#if MD5_X2
+	md5_items[0].off[i] = md5_items[2].off[i] = md5_items[5].off[i] = md5_items[6].off[i] =
+	md5_items[8].off[i] = md5_items[9].off[i] = md5_items[11].off[i] = md5_items[12].off[i] =
+	md5_items[14].off[i] = md5_items[15].off[i] = md5_items[18].off[i] = md5_items[20].off[i] = &cp1[cp-cp1];
+#else
+	md5_items[0].off = md5_items[2].off = md5_items[5].off = md5_items[6].off =
+	md5_items[8].off = md5_items[9].off = md5_items[11].off = md5_items[12].off =
+	md5_items[14].off = md5_items[15].off = md5_items[18].off = md5_items[20].off = &cp1[cp-cp1];
+#endif
+#else
+	md5_items[0].off[i] = md5_items[2].off[i] = md5_items[5].off[i] = md5_items[6].off[i] =
+	md5_items[8].off[i] = md5_items[9].off[i] = md5_items[11].off[i] = md5_items[12].off[i] =
+	md5_items[14].off[i] = md5_items[15].off[i] = md5_items[18].off[i] = md5_items[20].off[i] = cp-cp1;
+#endif
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[0].len2 = md5_items[2].len2 = md5_items[5].len2 = md5_items[6].len2 =
+	md5_items[8].len2 = md5_items[9].len2 = md5_items[11].len2 = md5_items[12].len2 =
+	md5_items[14].len2 = md5_items[15].len2 = md5_items[18].len2 = md5_items[20].len2 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+	cp1 = md5_cpp.x1.B; w=md5_cpp.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_cpp.x2.B2; w=md5_cpp.x2.w2; }
+#endif
+	cp = &cp1[16];
+	memcpy(cp, pass, plen); cp += plen; memcpy(cp, pass, plen); cp += plen;
+	SETLEN_MD5_INPUT(cp1, 2, 0);
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[3].len1 = md5_items[6].len1 = md5_items[9].len1 = md5_items[12].len1 =
+	md5_items[15].len1 = md5_items[18].len1 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+	cp1 = md5_ppc.x1.B; w=md5_ppc.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_ppc.x2.B2; w=md5_ppc.x2.w2; }
+#endif
+	cp = cp1;
+	memcpy(cp, pass, plen); cp += plen; memcpy(cp, pass, plen); cp += plen;
+	SETLEN_MD5_INPUT(cp1, 3, 16);
+#if ARCH_LITTLE_ENDIAN
+#if MD5_X2
+	md5_items[1].off[i] = md5_items[4].off[i] = md5_items[7].off[i] = md5_items[13].off[i] =
+	md5_items[16].off[i] = md5_items[19].off[i] = &cp1[cp-cp1];
+#else
+	md5_items[1].off = md5_items[4].off = md5_items[7].off = md5_items[13].off =
+	md5_items[16].off = md5_items[19].off = &cp1[cp-cp1];
+#endif
+#else
+	md5_items[1].off[i] = md5_items[4].off[i] = md5_items[7].off[i] = md5_items[13].off[i] =
+	md5_items[16].off[i] = md5_items[19].off[i] = cp-cp1;
+#endif
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[1].len2 = md5_items[4].len2 = md5_items[7].len2 = md5_items[13].len2 =
+	md5_items[16].len2 = md5_items[19].len2 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+	cp1 = md5_csp.x1.B; w=md5_csp.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_csp.x2.B2; w=md5_csp.x2.w2; }
+#endif
+	cp = &cp1[16];
+	memcpy(cp, cursalt, saltlen); cp += saltlen; memcpy(cp, pass, plen); cp += plen;
+	SETLEN_MD5_INPUT(cp1, 4, 0);
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[7].len1 = md5_items[14].len1 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+	cp1 = md5_psc.x1.B; w=md5_psc.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_psc.x2.B2; w=md5_psc.x2.w2; }
+#endif
+	cp = cp1;
+	memcpy(cp, pass, plen); cp += plen; memcpy(cp, cursalt, saltlen); cp += saltlen;
+	SETLEN_MD5_INPUT(cp1, 5, 16);
+#if ARCH_LITTLE_ENDIAN
+#if MD5_X2
+	md5_items[3].off[i] = md5_items[17].off[i] = &cp1[cp-cp1];
+#else
+	md5_items[3].off = md5_items[17].off = &cp1[cp-cp1];
+#endif
+#else
+	md5_items[3].off[i] = md5_items[17].off[i] = cp-cp1;
+#endif
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[3].len2 = md5_items[17].len2 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+	cp1 = md5_cp.x1.B; w=md5_cp.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_cp.x2.B2; w=md5_cp.x2.w2; }
+#endif
+	cp = &cp1[16];
+	memcpy(cp, pass, plen); cp += plen;
+	SETLEN_MD5_INPUT(cp1, 6, 0);
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[0].len1 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+	cp1 = md5_pc.x1.B; w=md5_pc.x1.w;
+#if MD5_X2
+	if (i == 1) { cp1 = md5_pc.x2.B2; w=md5_pc.x2.w2; }
+#endif
+	cp = cp1;
+	memcpy(cp, pass, plen); cp += plen;
+	SETLEN_MD5_INPUT(cp1, 7, 16);
+#if ARCH_LITTLE_ENDIAN
+#if MD5_X2
+	md5_items[10].off[i] = &cp1[cp-cp1];
+#else
+	md5_items[10].off = &cp1[cp-cp1];
+#endif
+#else
+	md5_items[10].off[i] = cp-cp1;
+#endif
+#if !defined (USE_MD5_Go) || (MD5_ASM != 1)
+	md5_items[10].len2 = len;
+#endif
+	MD5_swap(w,w,(len+5)>>2);
+
+#if MD5_X2
+	}
+#endif
+}
+
+static void MD5GenBaseFunc__FreeBSDMD5Crypt_ANY()
+{
+	unsigned char *cp, *cp1;
+	int i, I, len[2];
+	unsigned jj;
+	char *pass = saved_key[0];
+	unsigned plen = saved_key_len[0];
+
+#if MD5_X2
+	char *pass2 = saved_key[1];
+	unsigned plen2 = saved_key_len[1];
+#endif
+
+	FreeBSDMD5Crypt_setup_nonMMX(); //	dumpMD5(1, 0);
+
+	memset(&input_buf_X86[0], 0, sizeof(input_buf_X86[0]));
+
+	// Build B
+	memcpy(input_buf_X86[0].x1.b, pass, plen);
+	memcpy(&input_buf_X86[0].x1.b[plen], cursalt, saltlen);
+	memcpy(&input_buf_X86[0].x1.b[plen+saltlen], pass, plen);
+#if MD5_X2
+	memcpy(input_buf_X86[0].x2.b2, pass2, plen2);
+	memcpy(&input_buf_X86[0].x2.b2[plen2], cursalt, saltlen);
+	memcpy(&input_buf_X86[0].x2.b2[plen2+saltlen], pass2, plen2);
+	len[0] = (plen<<1)+saltlen;
+	len[1] = (plen2<<1)+saltlen;
+	DoMD5(input_buf_X86[0], len, crypt_key_X86[0]);
+#else
+	DoMD5(input_buf_X86[0],((plen<<1)+saltlen),crypt_key_X86[0]);
+#endif
+
+	i = 0;
+#if MD5_X2
+	for (; i < 2; ++i) {
+#endif
+		// Build A
+		pass = saved_key[i];
+		plen = saved_key_len[i];
+		cp1 = input_buf_X86[0].x1.B;
+#if MD5_X2
+		if (i == 1)
+			cp1 = input_buf_X86[0].x2.B2;
+#endif
+
+		cp = cp1;
+		memcpy(cp, pass, plen);
+		cp += plen;
+		memcpy(cp, curdat.Consts[0], curdat.ConstsLen[0]);
+		cp += curdat.ConstsLen[0];
+
+		memcpy(cp, cursalt, saltlen);
+		cp += saltlen;
+		// since pass len ls limted to 15 bytes (so all will fit in one MD5 block),
+		// we can ignore the loop, and just use plen
+		//for (i = plen; i > 0; i -= 16) {
+		//	memcpy(cp, b, i>16?16:i);
+		//	cp += i>16?16:i;
+		//}
+		if (!i)
+			memcpy(cp, crypt_key_X86[0].x1.b, plen);
+#if MD5_X2
+		else
+			memcpy(cp, crypt_key_X86[0].x2.b2, plen);
+#endif
+		cp += plen;
+
+		for (I = plen; I ; I >>= 1)
+			if (I & 1)
+				*cp++ = 0;
+			else
+				*cp++ = pass[0];
+		len[i] = cp-cp1;
+#if MD5_X2
+	}
+#endif
+
+#if MD5_X2
+	DoMD5(input_buf_X86[0], len, md5_cp);
+	MD5_swap2(md5_cp.x1.w, md5_cp.x2.w2, md5_cp.x1.w, md5_cp.x2.w2, 4);
+#else
+	DoMD5(input_buf_X86[0], len[0], md5_cp);
+	MD5_swap(md5_cp.x1.w, md5_cp.x1.w, 4);
+#endif
+
+	for (jj = 0; jj < 500; ++jj) {
+//		int j = jj%21;
+//		DoMD5a2(md5_items[j].in1, md5_items[j].len1, md5_items[j].in2, md5_items[j].off);
+//		DoMD5a(md5_items[j].in2, md5_items[j].len2, md5_items[j].out2);
+
+		DoMD5a2(md5_items[0].in1, md5_items[0].len1, md5_items[0].in2, md5_items[0].off);
+
+		DoMD5a(md5_items[0].in2, md5_items[0].len2, md5_items[0].out2);
+		DoMD5a2(md5_items[1].in1, md5_items[1].len1, md5_items[1].in2, md5_items[1].off);
+		DoMD5a(md5_items[1].in2, md5_items[1].len2, md5_items[1].out2);
+		DoMD5a2(md5_items[2].in1, md5_items[2].len1, md5_items[2].in2, md5_items[2].off);
+		DoMD5a(md5_items[2].in2, md5_items[2].len2, md5_items[2].out2);
+		DoMD5a2(md5_items[3].in1, md5_items[3].len1, md5_items[3].in2, md5_items[3].off);
+		DoMD5a(md5_items[3].in2, md5_items[3].len2, md5_items[3].out2);
+		DoMD5a2(md5_items[4].in1, md5_items[4].len1, md5_items[4].in2, md5_items[4].off);
+		DoMD5a(md5_items[4].in2, md5_items[4].len2, md5_items[4].out2);
+		DoMD5a2(md5_items[5].in1, md5_items[5].len1, md5_items[5].in2, md5_items[5].off);
+		DoMD5a(md5_items[5].in2, md5_items[5].len2, md5_items[5].out2);
+		DoMD5a2(md5_items[6].in1, md5_items[6].len1, md5_items[6].in2, md5_items[6].off);
+		DoMD5a(md5_items[6].in2, md5_items[6].len2, md5_items[6].out2);
+		DoMD5a2(md5_items[7].in1, md5_items[7].len1, md5_items[7].in2, md5_items[7].off);
+		DoMD5a(md5_items[7].in2, md5_items[7].len2, md5_items[7].out2);
+		DoMD5a2(md5_items[8].in1, md5_items[8].len1, md5_items[8].in2, md5_items[8].off);
+		DoMD5a(md5_items[8].in2, md5_items[8].len2, md5_items[8].out2);
+		DoMD5a2(md5_items[9].in1, md5_items[9].len1, md5_items[9].in2, md5_items[9].off);
+		DoMD5a(md5_items[9].in2, md5_items[9].len2, md5_items[9].out2);
+		DoMD5a2(md5_items[10].in1, md5_items[10].len1, md5_items[10].in2, md5_items[10].off);
+		DoMD5a(md5_items[10].in2, md5_items[10].len2, md5_items[10].out2);
+		DoMD5a2(md5_items[11].in1, md5_items[11].len1, md5_items[11].in2, md5_items[11].off);
+		DoMD5a(md5_items[11].in2, md5_items[11].len2, md5_items[11].out2);
+		DoMD5a2(md5_items[12].in1, md5_items[12].len1, md5_items[12].in2, md5_items[12].off);
+		DoMD5a(md5_items[12].in2, md5_items[12].len2, md5_items[12].out2);
+		DoMD5a2(md5_items[13].in1, md5_items[13].len1, md5_items[13].in2, md5_items[13].off);
+		DoMD5a(md5_items[13].in2, md5_items[13].len2, md5_items[13].out2);
+		DoMD5a2(md5_items[14].in1, md5_items[14].len1, md5_items[14].in2, md5_items[14].off);
+		DoMD5a(md5_items[14].in2, md5_items[14].len2, md5_items[14].out2);
+		DoMD5a2(md5_items[15].in1, md5_items[15].len1, md5_items[15].in2, md5_items[15].off);
+		DoMD5a(md5_items[15].in2, md5_items[15].len2, md5_items[15].out2);
+		DoMD5a2(md5_items[16].in1, md5_items[16].len1, md5_items[16].in2, md5_items[16].off);
+		DoMD5a(md5_items[16].in2, md5_items[16].len2, md5_items[16].out2);
+		if (jj > 480) break;
+		DoMD5a2(md5_items[17].in1, md5_items[17].len1, md5_items[17].in2, md5_items[17].off);
+		DoMD5a(md5_items[17].in2, md5_items[17].len2, md5_items[17].out2);
+		DoMD5a2(md5_items[18].in1, md5_items[18].len1, md5_items[18].in2, md5_items[18].off);
+		DoMD5a(md5_items[18].in2, md5_items[18].len2, md5_items[18].out2);
+		DoMD5a2(md5_items[19].in1, md5_items[19].len1, md5_items[19].in2, md5_items[19].off);
+		DoMD5a(md5_items[19].in2, md5_items[19].len2, md5_items[19].out2);
+		DoMD5a2(md5_items[20].in1, md5_items[20].len1, md5_items[20].in2, md5_items[20].off);
+		DoMD5a(md5_items[20].in2, md5_items[20].len2, md5_items[20].out2);
+		jj += 20;
+	}
+	//memcpy(crypt_key_X86[0], md5_items[j].out2, 16);
+	memcpy(crypt_key_X86[0].x1.b, md5_cspp.x1.b, 16);  // [j]out2 is [16].out2 which is md5_cspp
+#if MD5_X2
+	memcpy(crypt_key_X86[0].x2.b2, md5_cspp.x2.b2, 16);
+#endif
+}
+#else  // if !defined MMX_COEF
+
+#ifdef _MSC_VER
+__declspec(align(16)) unsigned char md5_cspp[BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_pspc[BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_cpp [BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_ppc [BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_csp [BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_psc [BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_cp  [BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_pc  [BSD_BLKS][64*MMX_COEF];
+__declspec(align(16)) unsigned char md5_tmp_out [BSD_BLKS][16*MMX_COEF];
+__declspec(align(16)) unsigned char md5_tmp_in [BSD_BLKS][64*MMX_COEF];
+#else
+unsigned char md5_cspp[BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_pspc[BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_cpp [BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_ppc [BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_csp [BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_psc [BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_cp  [BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_pc  [BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_tmp_out [BSD_BLKS][16*MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char md5_tmp_in [BSD_BLKS][64*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+
+struct md5_item {
+	void *in1, *in2, *out2;	// what we used to call out1 is actually in2, so we simply 'ignore' the extra variable.
+	unsigned lens[BSD_BLKS][MMX_COEF];
+};
+static struct md5_item md5_items[21] =  {
+  {md5_cp,   md5_pspc, md5_cspp },
+  {md5_cspp, md5_ppc,  md5_cspp },
+  {md5_cspp, md5_pspc, md5_cpp },
+  {md5_cpp,  md5_psc,  md5_cspp },
+  {md5_cspp, md5_ppc,  md5_cspp },
+  {md5_cspp, md5_pspc, md5_cpp },
+  {md5_cpp,  md5_pspc, md5_csp },
+  {md5_csp,  md5_ppc,  md5_cspp },
+  {md5_cspp, md5_pspc, md5_cpp },
+  {md5_cpp,  md5_pspc, md5_cspp },
+  {md5_cspp, md5_pc,   md5_cspp },
+  {md5_cspp, md5_pspc, md5_cpp },
+  {md5_cpp,  md5_pspc, md5_cspp },
+  {md5_cspp, md5_ppc,  md5_csp },
+  {md5_csp,  md5_pspc, md5_cpp },
+  {md5_cpp,  md5_pspc, md5_cspp },
+  {md5_cspp, md5_ppc,  md5_cspp },
+  {md5_cspp, md5_psc,  md5_cpp },
+  {md5_cpp,  md5_pspc, md5_cspp },
+  {md5_cspp, md5_ppc,  md5_cspp },
+  {md5_cspp, md5_pspc, md5_cp }
+};
+
+#define SETLEN_MD5_INPUT(a,b,c) do{\
+	len=cp-a+b; \
+	a[len]=0x80; a[64-8]=len<<3; a[64-7]=len>>5; \
+	__SSE_append_string_to_input(c[idx],idx_mod,(char*)a,64,0,0); \
+}while(0)
+
+
+static void FreeBSDMD5Crypt_setup_MMX() {
+	unsigned char *cp;
+	unsigned len=0, plen, i, idx_mod, idx;
+	char *pass;
+	unsigned char Tmp[64];
+
+	memset(Tmp, 0, sizeof(Tmp));
+
+	// Not needed, things get properly cleaned up in SETLEN_MD5_INPUT,
+	// by copying the WHOLE 64 byte line.  Thus these memsets are not needed.
+
+	//memset(md5_cspp,0,sizeof(md5_cspp));
+	//memset(md5_pspc,0,sizeof(md5_pspc));
+	//memset(md5_cpp,0,sizeof(md5_cpp));
+	//memset(md5_ppc,0,sizeof(md5_ppc));
+	//memset(md5_csp,0,sizeof(md5_csp));
+	//memset(md5_psc,0,sizeof(md5_psc));
+	//memset(md5_cp,0,sizeof(md5_cp));
+	//memset(md5_pc,0,sizeof(md5_pc));
+	//for (i = 0; i < 21; ++i)
+	//	memset(md5_items[i].lens, 0, sizeof(md5_items[i].lens));
+
+	idx = 0;
+#ifdef MD5_SSE_PARA
+	for (; idx < MD5_SSE_PARA; ++idx)
+#endif
+	{
+		for (i = 0; i < MMX_COEF; ++i) {
+			idx_mod = i%MMX_COEF;
+
+			pass = saved_key[idx*MMX_COEF+i];
+			plen = saved_key_len[idx*MMX_COEF+i];
+			cp = &Tmp[16];
+			memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(Tmp, 0, md5_cp);
+
+			cp = Tmp;
+			memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(Tmp, 16, md5_pc);
+			md5_items[10].lens[idx][i] = cp-Tmp;
+
+			cp = &Tmp[16];
+			memcpy(cp, cursalt, saltlen); cp += saltlen; memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(Tmp, 0, md5_csp);
+
+			cp = Tmp;
+			memcpy(cp, pass, plen); cp += plen; memcpy(cp, cursalt, saltlen); cp += saltlen;
+			SETLEN_MD5_INPUT(Tmp, 16, md5_psc);
+			md5_items[3].lens[idx][i] = md5_items[17].lens[idx][i] = cp-Tmp;
+
+			cp = &Tmp[16]; memset(Tmp, 0, len+1);
+			memcpy(cp, pass, plen); cp += plen; memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(Tmp, 0, md5_cpp);
+
+			cp = Tmp;
+			memcpy(cp, pass, plen); cp += plen; memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(Tmp, 16, md5_ppc);
+			md5_items[1].lens[idx][i] = md5_items[4].lens[idx][i] = md5_items[7].lens[idx][i] = md5_items[13].lens[idx][i] =
+			md5_items[16].lens[idx][i] = md5_items[19].lens[idx][i] = cp-Tmp;
+
+			cp = &Tmp[16];
+			memcpy(cp, cursalt, saltlen); cp += saltlen; memcpy(cp, pass, plen); cp += plen; memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(Tmp, 0, md5_cspp);
+
+			cp = Tmp;
+			memcpy(cp, pass, plen); cp += plen; memcpy(cp, cursalt, saltlen); cp += saltlen; memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(Tmp, 16, md5_pspc);
+			md5_items[0].lens[idx][i] = md5_items[2].lens[idx][i] = md5_items[5].lens[idx][i] = md5_items[6].lens[idx][i] =
+			md5_items[8].lens[idx][i] = md5_items[9].lens[idx][i] = md5_items[11].lens[idx][i] = md5_items[12].lens[idx][i] =
+			md5_items[14].lens[idx][i] = md5_items[15].lens[idx][i] = md5_items[18].lens[idx][i] = md5_items[20].lens[idx][i] = cp-Tmp;
+
+			memset(Tmp, 0, len+1);
+		}
+	}
+}
+
+static void CopyCryptToOut1Location(unsigned char *o, int j, int k) {
+	int x, idx=0;
+	unsigned char *out;
+	ARCH_WORD_32 Buf[4];
+
+	out = md5_items[j].in2;
+
+#ifdef MD5_SSE_PARA
+	for (; idx < MD5_SSE_PARA; ++idx)
+#endif
+	{
+		for (x = 0; x < MMX_COEF; ++x) {
+			unsigned idx_mod = x%MMX_COEF;
+			ARCH_WORD_32 *pi = (ARCH_WORD_32*)o;
+			pi += idx_mod;
+			Buf[0] = *pi; pi += MMX_COEF;
+			Buf[1] = *pi; pi += MMX_COEF;
+			Buf[2] = *pi; pi += MMX_COEF;
+			Buf[3] = *pi;
+			__SSE_append_string_to_input(out,idx_mod,(char*)Buf,16,md5_items[j].lens[idx][x],0);
+		}
+#ifdef MD5_SSE_PARA
+		out += 64*MMX_COEF;
+		o += 16*MMX_COEF;
+#endif
+	}
+}
+
+void CopyCryptToFlat(unsigned char *cp, int plen, int idx, int idx_mod) {
+	// this function is ONLY called during key setup (once), so trying to optimize
+	// to do full DWORD copying (vs byte/byte copying), will not gain us anything.
+	unsigned char *in = md5_tmp_out[idx];
+	int n = 0;
+	in += 4*idx_mod;
+	while (plen--) {
+		*cp++ = *in++;
+		if (!((++n)&3))
+			// we have processed one DWORD.  Now we need to skip ahead
+			// MMX_COEF-1 dwords (to get to the next DWORD for 'this' crypt)
+			in += 4*(MMX_COEF-1);
+	}
+}
+
+void MD5GenBaseFunc__FreeBSDMD5Crypt_MMX()
+{
+	unsigned char tmp[64], *cp;
+	int i, x, len;
+	unsigned j, jj, plen, idx, idx_mod;
+	char *pass;
+
+	FreeBSDMD5Crypt_setup_MMX();
+
+	memset(md5_tmp_in, 0, sizeof(md5_tmp_in));
+	// Build B
+	memset(tmp, 0, sizeof(tmp));
+	idx = 0;
+#ifdef MD5_SSE_PARA
+	for ( ; idx < MD5_SSE_PARA; ++ idx)
+#endif
+	{
+		for (x = 0; x < MMX_COEF; ++x) {
+			idx_mod = x%MMX_COEF;
+			pass = saved_key[idx*MMX_COEF+x];
+			plen = saved_key_len[idx*MMX_COEF+x];
+
+			cp = tmp;
+			memcpy(cp, pass, plen); cp += plen;
+			memcpy(cp, cursalt, saltlen); cp += saltlen;
+			memcpy(cp, pass, plen); cp += plen;
+			SETLEN_MD5_INPUT(tmp, 0, md5_tmp_in);
+			memset(tmp, 0, cp-tmp+1);
+		}
+	}
+
+#ifdef MD5_SSE_PARA
+	SSEmd5body(md5_tmp_in, (unsigned int *)md5_tmp_out, 1);
+#else
+	mdfivemmx_nosizeupdate(md5_tmp_out[0], md5_tmp_in[0], 1);
+#endif
+
+	// Build A  A should ALWAYS be larger then B, so no memset needed.
+	//memset(md5_tmp_in, 0, sizeof(md5_tmp_in));
+	idx = 0;
+#ifdef MD5_SSE_PARA
+	for ( ; idx < MD5_SSE_PARA; ++ idx)
+#endif
+	{
+		for (x = 0; x < MMX_COEF; ++x) {
+			idx_mod = x%MMX_COEF;
+			pass = saved_key[idx*MMX_COEF+x];
+			plen = saved_key_len[idx*MMX_COEF+x];
+
+			cp = tmp;
+			memcpy(cp, pass, plen);
+			cp += plen;
+			memcpy(cp, curdat.Consts[0], curdat.ConstsLen[0]);
+			cp += curdat.ConstsLen[0];
+
+			memcpy(cp, cursalt, saltlen);
+			cp += saltlen;
+
+			// since pass len ls limted to 15 bytes (so all will fit in one MD5 block),
+			// we can ignore the loop, and just use plen
+			//for (i = plen; i > 0; i -= 16) {
+			//	CopyCryptToFlat(md5_tmp_out, cp, idx, idx_out);
+			//	memcpy(cp, b, i>16?16:i);
+			//	cp += i>16?16:i;
+			//}
+			CopyCryptToFlat(cp, plen, idx, idx_mod);
+			cp += plen;
+
+			i = plen;
+			for (i = plen; i ; i >>= 1)
+				if (i & 1)
+					*cp++ = 0;
+				else
+					*cp++ = pass[0];
+			SETLEN_MD5_INPUT(tmp, 0, md5_tmp_in);
+			memset(tmp, 0, cp-tmp+1);
+		}
+	}
+
+	// Ok, now place this 16 bytes into the 'proper' location.
+	// This is A but we simply shove it to the start of md5_cp which is where we start from.
+
+#ifdef MD5_SSE_PARA
+	SSEmd5body(md5_tmp_in, (unsigned int *)md5_tmp_out, 1);
+	for (j = 0; j < MD5_SSE_PARA; ++j)
+		memcpy(md5_cp[j], md5_tmp_out[j], 16*MMX_COEF);
+#else
+	mdfivemmx_nosizeupdate(md5_cp[0], md5_tmp_in[0], 1);
+#endif
+
+	for (jj = j = 0; jj < 500; ++jj) {
+		j=jj%21;
+#ifdef MD5_SSE_PARA
+		SSEmd5body(md5_items[j].in1, (unsigned int *)md5_tmp_out, 1);
+		CopyCryptToOut1Location(md5_tmp_out[0], j, 0);
+		SSEmd5body(md5_items[j].in2, (unsigned int *)md5_tmp_out, 1);
+		cp = md5_items[j].out2;
+		for (i = 0; i < MD5_SSE_PARA; ++i) {
+			memcpy(cp, md5_tmp_out[i], 16*MMX_COEF);
+			cp += 64*MMX_COEF;
+		}
+#else
+		mdfivemmx_nosizeupdate(md5_tmp_out[0], md5_items[j].in1, 64);
+		CopyCryptToOut1Location(md5_tmp_out[0], j, 0);
+		mdfivemmx_nosizeupdate(md5_items[j].out2, md5_items[j].in2, 64);
+#endif
+		// unrolling seems to be slower.
+	}
+#ifdef MD5_SSE_PARA
+	cp = md5_items[j].out2;
+	for (i = 0; i < MD5_SSE_PARA; ++i) {
+		memcpy(crypt_key[i], cp, BINARY_SIZE*MMX_COEF);
+		cp += 64*MMX_COEF;
+	}
+#else
+	memcpy(crypt_key[0], md5_items[j].out2, BINARY_SIZE*MMX_COEF);
+#endif
+
+
+	md5_gen_use_sse = 1;
+}
+
+#endif
+void MD5GenBaseFunc__FreeBSDMD5Crypt()
+{
+#ifdef MMX_COEF
+	MD5GenBaseFunc__FreeBSDMD5Crypt_MMX();
+#else
+	MD5GenBaseFunc__FreeBSDMD5Crypt_ANY();
+#endif
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Special crypt to handle the 'looping' needed for phpass
+ *************************************************************/
+void MD5GenBaseFunc__PHPassCrypt()
+{
+	unsigned Lcount;
+
+	Lcount = atoi64[ARCH_INDEX(cursalt[8])];
+	if (Lcount < 7 || Lcount > 31)
+		exit(fprintf(stderr, "Error, invalid loop byte in a php salt %s\n",cursalt));
+	Lcount = (1<<Lcount);
+
+	MD5GenBaseFunc__clean_input();
+
+	// First 'round' is md5 of ($s.$p)
+	MD5GenBaseFunc__append_salt();
+	MD5GenBaseFunc__append_keys();
+
+	// The later rounds (variable number, based upon the salt's first byte)
+	//   are ALL done as 16 byte md5 result of prior hash, with the password appeneded
+
+	// crypt, and put the 'raw' 16 byte raw crypt data , into the
+	// input buffer.  We will then append the keys to that, and never
+	// have to append the keys again (we just make sure we do NOT adjust
+	// the amount of bytes to md5 from this point no
+	MD5GenBaseFunc__crypt_to_input_raw();
+
+	// Now append the pass
+	MD5GenBaseFunc__append_keys();
+
+	// NOTE last we do 1 less than the required number of crypts in our loop
+	MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen_but_setlen_in_SSE();
+
+#if !ARCH_LITTLE_ENDIAN
+	// from this point on, we want to have the binary blobs in 'native' big endian
+	// format. Thus, we need to 'unswap' them.  Then the call to the
+	// MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen will leave the 16 bytes
+	// output, in big endian (thus needing no swapping).
+	// we only have to 'fix up' the final crypt results.
+#if MD5_X2
+		MD5_swap(input_buf_X86[0].x2.w2, input_buf_X86[0].x2.w2, 4);
+#endif
+		MD5_swap(input_buf_X86[0].x1.w, input_buf_X86[0].x1.w, 4);
+#endif
+
+	--Lcount;
+	while(--Lcount)
+		MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen();
+
+	// final crypt is to the normal 'output' buffer, since john uses that to find 'hits'.
+#if !ARCH_LITTLE_ENDIAN
+	// we have to use this funtion, since we do not want to 'fixup' the
+	// end of the buffer again (it has been put into BE format already.
+	// Thus, simply use the raw_overwrite again, then swap the output that
+	// is found in the input buf to the output buf.
+	MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen();
+#if MD5_X2
+	MD5_swap(input_buf_X86[0].x2.w2, crypt_key_X86[0].x2.w2, 4);
+#endif
+	MD5_swap(input_buf_X86[0].x1.w, crypt_key_X86[0].x1.w, 4);
+#else
+	// little endian can use 'original' crypt function.
+	MD5GenBaseFunc__crypt();
+#endif
+}
+void MD5GenBaseFunc__POCrypt()
+{
+	//MD5GenBaseFunc__clean_input_kwik();
+	//MD5GenBaseFunc__append_salt,
+	//MD5GenBaseFunc__append_input1_from_CONST1,
+	//MD5GenBaseFunc__append_keys,
+	//MD5GenBaseFunc__append_input1_from_CONST2,
+	//MD5GenBaseFunc__append_salt,
+	//MD5GenBaseFunc__crypt,
+
+	unsigned i, len;
+	unsigned char *pBuf = input_buf_X86[0].x1.B;
+#if MD5_X2
+	unsigned lens[2];
+	unsigned char *pBuf2 = input_buf_X86[0].x2.B2;
+	memset(pBuf2, 0, sizeof(input_buf_X86[0].x2.B2));
+	memcpy(pBuf2, cursalt, 32);
+	pBuf2[32] = 'Y';
+#endif
+	memset(pBuf, 0, sizeof(input_buf_X86[0].x1.b));
+	memcpy(pBuf, cursalt, 32);
+	pBuf[32] = 'Y';
+	for (i = 0; i < m_count; ++i) {
+		len = saved_key_len[i];
+		memcpy(&pBuf[33], saved_key[i], len);
+		pBuf[33+len] = 0xf7;
+		memcpy(&pBuf[34+len], cursalt, 32);
+
+#if MD5_X2
+		lens[0] = len+66;  // len from the 'first'
+		++i;
+		len = saved_key_len[i];
+		memcpy(&pBuf2[33], saved_key[i], len);
+		pBuf2[33+len] = 0xf7;
+		memcpy(&pBuf2[34+len], cursalt, 32);
+		lens[1] = len+66;
+		DoMD5(input_buf_X86[0], lens, crypt_key_X86[i>>MD5_X2]);
+#else
+		DoMD5(input_buf_X86[0], (len+66), crypt_key_X86[i]);
+#endif
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Encrypts the data in the 2nd input field into crypt_keys2.
+ *************************************************************/
+void MD5GenBaseFunc__crypt2()
+{
+	unsigned i;
+#ifdef MMX_COEF
+#ifdef MD5_SSE_PARA
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; i += MD5_SSE_PARA)
+		{
+			SSE_Intrinsics_LoadLens(1, i);
+			SSEmd5body((unsigned char*)(&input_buf2[i]), (unsigned int*)(&crypt_key2[i]), 1);
+		}
+		return;
+	}
+#else
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+			mdfivemmx((unsigned char*)&(crypt_key2[i]), (unsigned char*)&(input_buf2[i]), total_len2[i]);
+		return;
+	}
+#endif
+#endif
+	for (i = 0; i < m_count; ++i) {
+#if MD5_X2
+		unsigned len[2];
+		len[0] = total_len2_X86[i++];
+		len[1] = total_len2_X86[i];
+#else
+		unsigned len = total_len2_X86[i];
+#endif
+		DoMD5(input_buf2_X86[i>>MD5_X2], len, crypt_key2_X86[i>>MD5_X2]);
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Encrypts the data in the 1st input field      crypt_keys2.
+ *************************************************************/
+void MD5GenBaseFunc__crypt_in1_to_out2()
+{
+	unsigned i;
+#ifdef MMX_COEF
+#ifdef MD5_SSE_PARA
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; i += MD5_SSE_PARA)
+		{
+			SSE_Intrinsics_LoadLens(0, i);
+			SSEmd5body((unsigned char*)(&input_buf[i]), (unsigned int*)(&crypt_key2[i]), 1);
+		}
+		return;
+	}
+#else
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+			mdfivemmx((unsigned char*)&(crypt_key2[i]), (unsigned char*)&(input_buf[i]), total_len[i]);
+		return;
+	}
+#endif
+#endif
+	for (i = 0; i < m_count; ++i) {
+#if MD5_X2
+		unsigned len[2];
+		len[0] = total_len_X86[i++];
+		len[1] = total_len_X86[i];
+#else
+		unsigned len = total_len_X86[i];
+#endif
+		DoMD5(input_buf_X86[i>>MD5_X2], len, crypt_key2_X86[i>>MD5_X2]);
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Encrypts the data in the 2nd input field into crypt_keys.
+ *************************************************************/
+void MD5GenBaseFunc__crypt_in2_to_out1()
+{
+	unsigned i;
+#ifdef MMX_COEF
+#ifdef MD5_SSE_PARA
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));;
+		for (i = 0; i < cnt; i += MD5_SSE_PARA)
+		{
+			SSE_Intrinsics_LoadLens(1, i);
+			SSEmd5body((unsigned char*)(&input_buf2[i]), (unsigned int*)(&crypt_key[i]), 1);
+		}
+		return;
+	}
+#else
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));;
+		for (i = 0; i < cnt; ++i)
+			mdfivemmx((unsigned char*)&(crypt_key[i]), (unsigned char*)&(input_buf2[i]), total_len2[i]);
+		return;
+	}
+#endif
+#endif
+	for (i = 0; i < m_count; ++i) {
+#if MD5_X2
+		unsigned len[2];
+		len[0] = total_len2_X86[i++];
+		len[1] = total_len2_X86[i];
+#else
+		unsigned len = total_len2_X86[i];
+#endif
+		DoMD5(input_buf2_X86[i>>MD5_X2], len, crypt_key_X86[i>>MD5_X2]);
+	}
+}
+
+void MD5GenBaseFunc__crypt_to_input_raw()
+{
+	unsigned i;
+#ifdef MMX_COEF
+#ifdef MD5_SSE_PARA
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; i += MD5_SSE_PARA)
+		{
+			unsigned j;
+			SSE_Intrinsics_LoadLens(0, i);
+			// NOTE, since crypt_key array is 16 bytes each, and input_buf is 64 bytes
+			// each, and we are doing 3 at a time, we can NOT directly write to the
+			// input buff, but have to use the crypt_key buffer, and then memcpy when done.
+			SSEmd5body((char*)(&input_buf[i]), (unsigned int*)(&crypt_key[i]), 1);
+			for (j = 0; j < MD5_SSE_PARA; ++j)
+			{
+				memset((&input_buf[i+j]), 0, sizeof(input_buf[0]));
+				memcpy((char*)(&input_buf[i+j]), (char*)(&crypt_key[i+j]), 16*4);
+				total_len[i+j] = 0x10101010;
+			}
+		}
+		return;
+	}
+#else
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+		{
+			mdfivemmx((unsigned char*)&(crypt_key[i]), (unsigned char*)&(input_buf[i]), total_len[i]);
+			memset((&input_buf[i]), 0, sizeof(input_buf[0]));
+			memcpy((char*)(&input_buf[i]), (char*)(&crypt_key[i]), sizeof(crypt_key[0]));
+#if (MMX_COEF==4)
+			total_len[i] = 0x10101010;
+#else
+			total_len[i] = 0x100010;
+#endif
+		}
+		return;
+	}
+#endif
+#endif
+	for (i = 0; i < m_count; ++i) {
+#if MD5_X2
+		unsigned len[2];
+		len[0] = total_len_X86[i];
+		total_len_X86[i++] = 0x10;
+		len[1] = total_len_X86[i];
+#else
+		unsigned len = total_len_X86[i];
+#endif
+		DoMD5(input_buf_X86[i>>MD5_X2], len, input_buf_X86[i>>MD5_X2]);
+		total_len_X86[i] = 0x10;
+	}
+}
+void MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen_but_setlen_in_SSE()
+{
+	unsigned i;
+#ifdef MMX_COEF
+#ifdef MD5_SSE_PARA
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; i += MD5_SSE_PARA)
+		{
+			unsigned j;
+			SSE_Intrinsics_LoadLens(0, i);
+			// NOTE, since crypt_key array is 16 bytes each, and input_buf is 64 bytes
+			// each, and we are doing 3 at a time, we can NOT directly write to the
+			// input buff, but have to use the crypt_key buffer, and then memcpy when done.
+			SSEmd5body((char*)(&input_buf[i]), (unsigned int*)(&crypt_key[i]), 1);
+			for (j = 0; j < MD5_SSE_PARA; ++j)
+				memcpy((char*)(&input_buf[i+j]), (char*)(&crypt_key[i+j]), 16*4);
+		}
+		return;
+	}
+#else
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+			mdfivemmx((unsigned char*)&(input_buf[i]), (unsigned char*)&(input_buf[i]), total_len[i]);
+		return;
+	}
+#endif
+#endif
+	for (i = 0; i < m_count; ++i) {
+#if MD5_X2
+		unsigned len[2];
+		len[0] = total_len_X86[i++];
+		len[1] = total_len_X86[i];
+#else
+		unsigned len = total_len_X86[i];
+#endif
+		DoMD5(input_buf_X86[i>>MD5_X2], len, input_buf_X86[i>>MD5_X2]);
+	}
+}
+
+void MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen()
+{
+	unsigned i;
+#ifdef MMX_COEF
+#ifdef MD5_SSE_PARA
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; i += MD5_SSE_PARA)
+		{
+			unsigned j;
+			// NOTE, since crypt_key array is 16 bytes each, and input_buf is 64 bytes
+			// each, and we are doing 3 at a time, we can NOT directly write to the
+			// input buff, but have to use the crypt_key buffer, and then memcpy when done.
+			SSEmd5body((char*)(&input_buf[i]), (unsigned int*)(&crypt_key[i]), 1);
+			for (j = 0; j < MD5_SSE_PARA; ++j)
+				memcpy((char*)(&input_buf[i+j]), (char*)(&crypt_key[i+j]), 16*4);
+		}
+		return;
+	}
+#else
+	if (md5_gen_use_sse==1) {
+		unsigned cnt = ( ((unsigned)m_count+MMX_COEF-1)>>(MMX_COEF>>1));
+		for (i = 0; i < cnt; ++i)
+			mdfivemmx_nosizeupdate((unsigned char*)&(input_buf[i]), (unsigned char*)&(input_buf[i]), 0);
+		return;
+	}
+#endif
+#endif
+	for (i = 0; i < m_count; ++i) {
+#if MD5_X2
+		unsigned len[2];
+		len[0] = total_len_X86[i++];
+		len[1] = total_len_X86[i];
+#else
+		unsigned len = total_len_X86[i];
+#endif
+		// we call DoMD5o so as to 'not' change then length (it was already set)
+		DoMD5o(input_buf_X86[i>>MD5_X2], len, input_buf_X86[i>>MD5_X2]);
+	}
+}
+
+void MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		if (md5_unicode_convert) {
+			for (j = 0; j < m_count; ++j)
+				__SSE_append_string_to_input_unicode((unsigned char*)(&input_buf[j>>(MMX_COEF>>1)]),j&(MMX_COEF-1),cursalt,saltlen,0,0);
+			return;
+		}
+		for (j = 0; j < m_count; ++j)
+			__SSE_append_string_to_input((unsigned char*)(&input_buf[j>>(MMX_COEF>>1)]),j&(MMX_COEF-1),cursalt,saltlen,0,0);
+		return;
+	}
+#endif
+	if (md5_unicode_convert) {
+		for (j = 0; j < m_count; ++j) {
+			int z;
+			char *cp, *cpi = cursalt;
+#if MD5_X2
+			if (j&1)
+				cp = input_buf_X86[j>>MD5_X2].x2.b2;
+			else
+#endif
+			cp = input_buf_X86[j>>MD5_X2].x1.b;
+			for (z = 0; z < saltlen; ++z) {
+				*cp++ = *cpi++;
+				*cp++ = 0;
+			}
+		}
+		return;
+	}
+	for (j = 0; j < m_count; ++j) {
+#if MD5_X2
+		if (j&1)
+			memcpy(input_buf_X86[j>>MD5_X2].x2.b2, cursalt, saltlen);
+		else
+#endif
+		memcpy(input_buf_X86[j>>MD5_X2].x1.b, cursalt, saltlen);
+	}
+}
+void MD5GenBaseFunc__overwrite_salt_to_input2_no_size_fix()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		if (md5_unicode_convert) {
+			for (j = 0; j < m_count; ++j)
+				__SSE_append_string_to_input_unicode((unsigned char*)(&input_buf2[j>>(MMX_COEF>>1)]),j&(MMX_COEF-1),cursalt,saltlen,0,0);
+			return;
+		}
+		for (j = 0; j < m_count; ++j)
+			__SSE_append_string_to_input((unsigned char*)(&input_buf2[j>>(MMX_COEF>>1)]),j&(MMX_COEF-1),cursalt,saltlen,0,0);
+		return;
+	}
+#endif
+	if (md5_unicode_convert) {
+		for (j = 0; j < m_count; ++j) {
+			int z;
+			char *cp, *cpi = cursalt;
+#if MD5_X2
+			if (j&1)
+				cp = input_buf2_X86[j>>MD5_X2].x2.b2;
+			else
+#endif
+			cp = input_buf2_X86[j>>MD5_X2].x1.b;
+
+			for (z = 0; z < saltlen; ++z) {
+				*cp++ = *cpi++;
+				*cp++ = 0;
+			}
+		}
+		return;
+	}
+	for (j = 0; j < m_count; ++j) {
+#if MD5_X2
+		if (j&1)
+			memcpy(input_buf2_X86[j>>MD5_X2].x2.b2, cursalt, saltlen);
+		else
+#endif
+		memcpy(input_buf2_X86[j>>MD5_X2].x1.b, cursalt, saltlen);
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * overwrites start of input1 from the output1 data using base-16
+ *************************************************************/
+void MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix()
+{
+	unsigned i, j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned idx;
+		for (i = 0; i < m_count; ++i)
+		{
+			idx = ( ((unsigned)i)>>(MMX_COEF>>1));
+			__SSE_overwrite_output_base16_to_input((void*)(&input_buf[idx]), (unsigned char*)(&crypt_key[idx]), i&(MMX_COEF-1));
+		}
+		return;
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+		unsigned char *cpo, *cpi;
+		MD5_word *w;
+#if MD5_X2
+		if (j&1)
+			{cpo = input_buf_X86[j>>MD5_X2].x2.B2; cpi = crypt_key_X86[j>>MD5_X2].x2.B2; w=input_buf_X86[j>>MD5_X2].x2.w2;}
+		else
+#endif
+		{cpo = input_buf_X86[j>>MD5_X2].x1.B; cpi = crypt_key_X86[j>>MD5_X2].x1.B; w=input_buf_X86[j>>MD5_X2].x1.w;}
+		for (i = 0; i < 16; ++i, ++cpi)
+		{
+			*cpo++ = md5gen_itoa16[*cpi>>4];
+			*cpo++ = md5gen_itoa16[*cpi&0xF];
+		}
+		//MD5_swap(w,w,4);
+		// if swapped, then HDAA fails on big endian systems.
+	}
+}
+
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * This will take the data stored in the crypt_keys (the encrypted
+ * 'first' key variable), and use a base-16 text formatting, and
+ * append this to the first input buffer (adjusting the lengths)
+ *************************************************************/
+void MD5GenBaseFunc__append_from_last_output_as_base16()
+{
+	unsigned j;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned index, idx;
+		for (index = 0; index < m_count; ++index)
+		{
+			unsigned ip;
+			idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+			// This is the 'actual' work.
+			ip = (total_len[idx] >> ((32/MMX_COEF)*(index&(MMX_COEF-1)))) & 0xFF;
+			total_len[idx] += (32<<((32/MMX_COEF)*(index&(MMX_COEF-1))));
+			if (!ip)
+				__SSE_append_output_base16_to_input((void*)(&input_buf[idx]), (unsigned char*)(&crypt_key[idx]), index&(MMX_COEF-1));
+			else if (ip&1)
+			{
+				// Note we are 100% unaligned, and it seems fastest to handle byte/byte (at this time).
+				for (j = 0; j < 16; ++j)
+				{
+					unsigned char v = crypt_key[idx][GETPOS(j, index&(MMX_COEF-1))];
+					input_buf[idx][GETPOS(ip+(j<<1), index&(MMX_COEF-1))] = md5gen_itoa16[v>>4];
+					input_buf[idx][GETPOS(ip+(j<<1)+1, index&(MMX_COEF-1))] = md5gen_itoa16[v&0xF];
+				}
+				input_buf[idx][GETPOS(ip+32, index&(MMX_COEF-1))] = 0x80;
+			}
+			else if ((ip&3)==0)
+				__SSE_append_output_base16_to_input_semi_aligned_0(ip, (void*)(&input_buf[idx]), (unsigned char*)(&crypt_key[idx]), index&(MMX_COEF-1));
+			else
+				__SSE_append_output_base16_to_input_semi_aligned_2(ip, (void*)(&input_buf[idx]), (unsigned char*)(&crypt_key[idx]), index&(MMX_COEF-1));
+
+		}
+		return;
+	}
+#endif
+	for (j = 0; j < m_count; ++j)
+	{
+		unsigned char *cp, *cpi;
+		unsigned i;
+#if MD5_X2
+		if (j&1)
+		{cp = &(input_buf_X86[j>>MD5_X2].x2.B2[total_len_X86[j]]); cpi =  crypt_key_X86[j>>MD5_X2].x2.B2; }
+		else
+#endif
+		{cp = &(input_buf_X86[j>>MD5_X2].x1.B[total_len_X86[j]]);  cpi = crypt_key_X86[j>>MD5_X2].x1.B; }
+		for (i = 0; i < 16; ++i)
+		{
+			unsigned char b = *cpi++;
+			*cp++ = md5gen_itoa16[b>>4];
+			*cp++ = md5gen_itoa16[b&0xF];
+		}
+		*cp = 0;
+		total_len_X86[j] += 32;
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * This will take the data stored in the crypt_keys2 (the encrypted
+ * 'second' key variable), and base-16 appends to the 2nd input
+ *************************************************************/
+void MD5GenBaseFunc__append_from_last_output2_as_base16()
+{
+	unsigned i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned index, idx;
+		for (index = 0; index < m_count; ++index)
+		{
+			unsigned ip;
+			idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+			// This is the 'actual' work.
+			ip = (total_len2[idx] >> ((32/MMX_COEF)*(index&(MMX_COEF-1)))) & 0xFF;
+			total_len2[idx] += (32<<((32/MMX_COEF)*(index&(MMX_COEF-1))));
+			if (!ip)
+				__SSE_append_output_base16_to_input((void*)(&input_buf2[idx]), (unsigned char*)(&crypt_key2[idx]), index&(MMX_COEF-1));
+			else if (ip&1)
+			{
+				// Note we are 100% unaligned, and it seems fastest to handle byte/byte (at this time).
+				for (i = 0; i < 16; ++i)
+				{
+					unsigned char v = crypt_key2[idx][GETPOS(i, index&(MMX_COEF-1))];
+					input_buf2[idx][GETPOS(ip+(i<<1), index&(MMX_COEF-1))] = md5gen_itoa16[v>>4];
+					input_buf2[idx][GETPOS(ip+(i<<1)+1, index&(MMX_COEF-1))] = md5gen_itoa16[v&0xF];
+				}
+				input_buf2[idx][GETPOS(ip+32, index&(MMX_COEF-1))] = 0x80;
+			}
+			else if ((ip&3)==0)
+				__SSE_append_output_base16_to_input_semi_aligned_0(ip, (void*)(&input_buf2[idx]), (unsigned char*)(&crypt_key2[idx]), index&(MMX_COEF-1));
+			else
+				__SSE_append_output_base16_to_input_semi_aligned_2(ip, (void*)(&input_buf2[idx]), (unsigned char*)(&crypt_key2[idx]), index&(MMX_COEF-1));
+		}
+		return;
+	}
+#endif
+	for (i = 0; i < m_count; ++i)
+	{
+		unsigned j;
+		unsigned char *cp, *cpi;
+#if MD5_X2
+		if (i&1)
+		{cp = &(input_buf2_X86[i>>MD5_X2].x2.B2[total_len2_X86[i]]); cpi = crypt_key2_X86[i>>MD5_X2].x2.B2; }
+		else
+#endif
+		{cp = &(input_buf2_X86[i>>MD5_X2].x1.B[total_len2_X86[i]]); cpi = crypt_key2_X86[i>>MD5_X2].x1.B; }
+		for (j = 0; j < 16; ++j)
+		{
+			unsigned char b = *cpi++;
+			*cp++ = md5gen_itoa16[b>>4];
+			*cp++ = md5gen_itoa16[b&0xF];
+		}
+		*cp = 0;
+		total_len2_X86[i] += 32;
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * This will take the data stored in the crypt_keys1 (the encrypted
+ * 'first' key variable), and base-16 appends to the 2nd input
+ *************************************************************/
+void MD5GenBaseFunc__append_from_last_output_to_input2_as_base16()
+{
+	unsigned i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned index, idx;
+		for (index = 0; index < m_count; ++index)
+		{
+			unsigned ip;
+			idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+			// This is the 'actual' work.
+			ip = (total_len2[idx] >> ((32/MMX_COEF)*(index&(MMX_COEF-1)))) & 0xFF;
+			total_len2[idx] += (32<<((32/MMX_COEF)*(index&(MMX_COEF-1))));
+			if (!ip)
+				__SSE_append_output_base16_to_input((void*)(&input_buf2[idx]), (unsigned char*)(&crypt_key[idx]), index&(MMX_COEF-1));
+			else if (ip&1)
+			{
+				// Note we are 100% unaligned, and it seems fastest to handle byte/byte (at this time).
+				for (i = 0; i < 16; ++i)
+				{
+					unsigned char v = crypt_key[idx][GETPOS(i, index&(MMX_COEF-1))];
+					input_buf2[idx][GETPOS(ip+(i<<1), index&(MMX_COEF-1))] = md5gen_itoa16[v>>4];
+					input_buf2[idx][GETPOS(ip+(i<<1)+1, index&(MMX_COEF-1))] = md5gen_itoa16[v&0xF];
+				}
+				input_buf2[idx][GETPOS(ip+32, index&(MMX_COEF-1))] = 0x80;
+			}
+			else if ((ip&3)==0)
+				__SSE_append_output_base16_to_input_semi_aligned_0(ip, (void*)(&input_buf2[idx]), (unsigned char*)(&crypt_key[idx]), index&(MMX_COEF-1));
+			else
+				__SSE_append_output_base16_to_input_semi_aligned_2(ip, (void*)(&input_buf2[idx]), (unsigned char*)(&crypt_key[idx]), index&(MMX_COEF-1));
+		}
+		return;
+	}
+#endif
+	for (i = 0; i < m_count; ++i)
+	{
+		unsigned j;
+		unsigned char *cp, *cpi;
+#if MD5_X2
+		if (i&1)
+		{cpi = crypt_key_X86[i>>MD5_X2].x2.B2; cp = &(input_buf2_X86[i>>MD5_X2].x2.B2[total_len2_X86[i]]); }
+		else
+#endif
+		{cpi = crypt_key_X86[i>>MD5_X2].x1.B; cp = &(input_buf2_X86[i>>MD5_X2].x1.B[total_len2_X86[i]]);}
+		for (j = 0; j < 16; ++j)
+		{
+			unsigned char b = *cpi++;
+			*cp++ = md5gen_itoa16[b>>4];
+			*cp++ = md5gen_itoa16[b&0xF];
+		}
+		*cp = 0;
+		total_len2_X86[i] += 32;
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * This will take the data stored in the crypt_keys2 (the encrypted
+ * 'second' key variable), and base-16 appends to the 1st input
+ *************************************************************/
+void MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16()
+{
+	unsigned i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned index, idx;
+		for (index = 0; index < m_count; ++index)
+		{
+			unsigned ip;
+			idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+			// This is the 'actual' work.
+			ip = (total_len[idx] >> ((32/MMX_COEF)*(index&(MMX_COEF-1)))) & 0xFF;
+			total_len[idx] += (32<<((32/MMX_COEF)*(index&(MMX_COEF-1))));
+			if (!ip)
+				__SSE_append_output_base16_to_input((void*)(&input_buf[idx]), (unsigned char*)(&crypt_key2[idx]), index&(MMX_COEF-1));
+			else if (ip&1)
+			{
+				// Note we are 100% unaligned, and it seems fastest to handle byte/byte (at this time).
+				for (i = 0; i < 16; ++i)
+				{
+					unsigned char v = crypt_key2[idx][GETPOS(i, index&(MMX_COEF-1))];
+					input_buf[idx][GETPOS(ip+(i<<1), index&(MMX_COEF-1))] = md5gen_itoa16[v>>4];
+					input_buf[idx][GETPOS(ip+(i<<1)+1, index&(MMX_COEF-1))] = md5gen_itoa16[v&0xF];
+				}
+				input_buf[idx][GETPOS(ip+32, index&(MMX_COEF-1))] = 0x80;
+			}
+			else if ((ip&3)==0)
+				__SSE_append_output_base16_to_input_semi_aligned_0(ip, (void*)(&input_buf[idx]), (unsigned char*)(&crypt_key2[idx]), index&(MMX_COEF-1));
+			else
+				__SSE_append_output_base16_to_input_semi_aligned_2(ip, (void*)(&input_buf[idx]), (unsigned char*)(&crypt_key2[idx]), index&(MMX_COEF-1));
+		}
+		return;
+	}
+#endif
+	for (i = 0; i < m_count; ++i)
+	{
+		unsigned j;
+		unsigned char *cp, *cpi;
+#if MD5_X2
+		if (i&1)
+		{cp = &(input_buf_X86[i>>MD5_X2].x2.B2[total_len_X86[i]]); cpi = crypt_key2_X86[i>>MD5_X2].x2.B2; }
+		else
+#endif
+		{cp = &(input_buf_X86[i>>MD5_X2].x1.B[total_len_X86[i]]); cpi = crypt_key2_X86[i>>MD5_X2].x1.B; }
+		for (j = 0; j < 16; ++j)
+		{
+			unsigned char b = *cpi++;
+			*cp++ = md5gen_itoa16[b>>4];
+			*cp++ = md5gen_itoa16[b&0xF];
+		}
+		*cp = 0;
+		total_len_X86[i] += 32;
+	}
+}
+
+void MD5GenBaseFunc__append_from_last_output2_as_raw()
+{
+	unsigned i;
+#ifdef MMX_COEF
+	if (md5_gen_use_sse==1) {
+		unsigned index, idx;
+		for (index = 0; index < m_count; ++index)
+		{
+			unsigned ip;
+			idx = ( ((unsigned)index)>>(MMX_COEF>>1));
+			// This is the 'actual' work.
+			ip = (total_len[idx] >> ((32/MMX_COEF)*(index&(MMX_COEF-1)))) & 0xFF;
+			if (!ip)
+			{
+				ARCH_WORD_32 *po = (ARCH_WORD_32*)(&(input_buf[idx]));
+				ARCH_WORD_32 *pi = (ARCH_WORD_32*)(&(crypt_key2[idx]));
+				for (i = 0; i < 4; i++)
+				{
+					*po = *pi;
+					po += MMX_COEF;
+					pi += MMX_COEF;
+				}
+				input_buf[idx][GETPOS(16, index&(MMX_COEF-1))] = 0x80;
+			}
+			else
+			{
+				for (i = 0; i < 16; ++i)
+					input_buf[idx][GETPOS(ip+i, index&(MMX_COEF-1))] = crypt_key2[idx][GETPOS(i, index&(MMX_COEF-1))];
+				input_buf[idx][GETPOS(ip+16, index&(MMX_COEF-1))] = 0x80;
+			}
+			total_len[idx] += (16<<((32/MMX_COEF)*(index&(MMX_COEF-1))));
+		}
+		return;
+	}
+#endif
+	for (i = 0; i < m_count; ++i)
+	{
+		unsigned j;
+		unsigned char *cp, *cpi;
+
+#if MD5_X2
+		if (i&1)
+		{cp = &(input_buf_X86[i>>MD5_X2].x2.B2[total_len_X86[i]]); cpi = crypt_key2_X86[i>>MD5_X2].x2.B2; }
+		else
+#endif
+		{cp = &(input_buf_X86[i>>MD5_X2].x1.B[total_len_X86[i]]); cpi = crypt_key2_X86[i>>MD5_X2].x1.B; }
+
+		for (j = 0; j < 16; ++j)
+			*cp++ = *cpi++;
+		*cp = 0;
+		total_len_X86[i] += 16;
+	}
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Append salt #2 into input 1
+ *************************************************************/
+void MD5GenBaseFunc__append_2nd_salt()
+{
+	__append_string(cursalt2, saltlen2);
+}
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Append salt #2 into input 2
+ *************************************************************/
+void MD5GenBaseFunc__append_2nd_salt2()
+{
+	__append2_string(cursalt2, saltlen2);
+}
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Append UserID into input 1
+ *************************************************************/
+void MD5GenBaseFunc__append_userid()
+{
+	__append_string(username, usernamelen);
+}
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * Append UserID into input 2
+ *************************************************************/
+void MD5GenBaseFunc__append_userid2()
+{
+	__append2_string(username, usernamelen);
+}
+
+void MD5GenBaseFunc__append_input1_from_CONST1()
+{
+	__append_string(curdat.Consts[0], curdat.ConstsLen[0]);
+}
+void MD5GenBaseFunc__append_input1_from_CONST2()
+{
+	__append_string(curdat.Consts[1], curdat.ConstsLen[1]);
+}
+void MD5GenBaseFunc__append_input1_from_CONST3()
+{
+	__append_string(curdat.Consts[2], curdat.ConstsLen[2]);
+}
+void MD5GenBaseFunc__append_input1_from_CONST4()
+{
+	__append_string(curdat.Consts[3], curdat.ConstsLen[3]);
+}
+void MD5GenBaseFunc__append_input1_from_CONST5()
+{
+	__append_string(curdat.Consts[4], curdat.ConstsLen[4]);
+}
+void MD5GenBaseFunc__append_input1_from_CONST6()
+{
+	__append_string(curdat.Consts[5], curdat.ConstsLen[5]);
+}
+void MD5GenBaseFunc__append_input1_from_CONST7()
+{
+	__append_string(curdat.Consts[6], curdat.ConstsLen[6]);
+}
+void MD5GenBaseFunc__append_input1_from_CONST8()
+{
+	__append_string(curdat.Consts[7], curdat.ConstsLen[7]);
+}
+
+void MD5GenBaseFunc__append_input2_from_CONST1()
+{
+	__append2_string(curdat.Consts[0], curdat.ConstsLen[0]);
+}
+void MD5GenBaseFunc__append_input2_from_CONST2()
+{
+	__append2_string(curdat.Consts[1], curdat.ConstsLen[1]);
+}
+void MD5GenBaseFunc__append_input2_from_CONST3()
+{
+	__append2_string(curdat.Consts[2], curdat.ConstsLen[2]);
+}
+void MD5GenBaseFunc__append_input2_from_CONST4()
+{
+	__append2_string(curdat.Consts[3], curdat.ConstsLen[3]);
+}
+void MD5GenBaseFunc__append_input2_from_CONST5()
+{
+	__append2_string(curdat.Consts[4], curdat.ConstsLen[4]);
+}
+void MD5GenBaseFunc__append_input2_from_CONST6()
+{
+	__append2_string(curdat.Consts[5], curdat.ConstsLen[5]);
+}
+void MD5GenBaseFunc__append_input2_from_CONST7()
+{
+	__append2_string(curdat.Consts[6], curdat.ConstsLen[6]);
+}
+void MD5GenBaseFunc__append_input2_from_CONST8()
+{
+	__append2_string(curdat.Consts[7], curdat.ConstsLen[7]);
+}
+
+void MD5GenBaseFunc__append_fld0()
+{
+	__append_string(flds[0], fld_lens[0]);
+}
+void MD5GenBaseFunc__append_fld1()
+{
+	__append_string(flds[1], fld_lens[1]);
+}
+void MD5GenBaseFunc__append_fld2()
+{
+	__append_string(flds[2], fld_lens[2]);
+}
+void MD5GenBaseFunc__append_fld3()
+{
+	__append_string(flds[3], fld_lens[3]);
+}
+void MD5GenBaseFunc__append_fld4()
+{
+	__append_string(flds[4], fld_lens[4]);
+}
+void MD5GenBaseFunc__append_fld5()
+{
+	__append_string(flds[5], fld_lens[5]);
+}
+void MD5GenBaseFunc__append_fld6()
+{
+	__append_string(flds[6], fld_lens[6]);
+}
+void MD5GenBaseFunc__append_fld7()
+{
+	__append_string(flds[7], fld_lens[7]);
+}
+void MD5GenBaseFunc__append_fld8()
+{
+	__append_string(flds[8], fld_lens[8]);
+}
+void MD5GenBaseFunc__append_fld9()
+{
+	__append_string(flds[9], fld_lens[9]);
+}
+
+void MD5GenBaseFunc__append2_fld0()
+{
+	__append2_string(flds[0], fld_lens[0]);
+}
+void MD5GenBaseFunc__append2_fld1()
+{
+	__append2_string(flds[1], fld_lens[1]);
+}
+void MD5GenBaseFunc__append2_fld2()
+{
+	__append2_string(flds[2], fld_lens[2]);
+}
+void MD5GenBaseFunc__append2_fld3()
+{
+	__append2_string(flds[3], fld_lens[3]);
+}
+void MD5GenBaseFunc__append2_fld4()
+{
+	__append2_string(flds[4], fld_lens[4]);
+}
+void MD5GenBaseFunc__append2_fld5()
+{
+	__append2_string(flds[5], fld_lens[5]);
+}
+void MD5GenBaseFunc__append2_fld6()
+{
+	__append2_string(flds[6], fld_lens[6]);
+}
+void MD5GenBaseFunc__append2_fld7()
+{
+	__append2_string(flds[7], fld_lens[7]);
+}
+void MD5GenBaseFunc__append2_fld8()
+{
+	__append2_string(flds[8], fld_lens[8]);
+}
+void MD5GenBaseFunc__append2_fld9()
+{
+	__append2_string(flds[9], fld_lens[9]);
+}
+
+
+void MD5GenBaseFunc__SSEtoX86_switch_input1() {
+#ifdef MMX_COEF
+	int j, k, idx, max;
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 2;
+
+	for (j = 0; j < m_count; j += MMX_COEF)
+	{
+		ARCH_WORD_32 *cpi;
+		ARCH_WORD_32 *cpo = input_buf_X86[j].x1.w;
+		ARCH_WORD_32 *cpo2 = input_buf_X86[j+1].x1.w;
+#if (MMX_COEF==4)
+		ARCH_WORD_32 *cpo3 = input_buf_X86[j+2].x1.w;
+		ARCH_WORD_32 *cpo4 = input_buf_X86[j+3].x1.w;
+#endif
+		idx = ( ((unsigned)j)>>(MMX_COEF>>1));
+		cpi = (void*)(&input_buf[idx]);
+
+		max = total_len_X86[j] = (total_len[idx]&0xFF);
+#if (MMX_COEF==2)
+		if (max < (total_len_X86[j+1]=((total_len[idx]>> 16)&0xFF)))
+			max = total_len_X86[j+1];
+#else
+		if (max < (total_len_X86[j+1]=((total_len[idx]>> 8)&0xFF)))
+			max = total_len_X86[j+1];
+		if (max < (total_len_X86[j+2]=((total_len[idx]>>16)&0xFF)))
+			max = total_len_X86[j+2];
+		if (max < (total_len_X86[j+3]=((total_len[idx]>>24)&0xFF)))
+			max = total_len_X86[j+3];
+#endif
+		max = (max+3)>>2;
+		for (k = 0; k < max; ++k) {
+			*cpo++ = *cpi++;
+			*cpo2++ = *cpi++;
+#if (MMX_COEF==4)
+			*cpo3++ = *cpi++;
+			*cpo4++ = *cpi++;
+#endif
+		}
+		input_buf_X86[j].x1.b[total_len_X86[j]] = 0;
+		input_buf_X86[j+1].x1.b[total_len_X86[j+1]] = 0;
+#if (MMX_COEF==4)
+		input_buf_X86[j+2].x1.b[total_len_X86[j+2]] = 0;
+		input_buf_X86[j+3].x1.b[total_len_X86[j+3]] = 0;
+#endif
+	}
+#endif
+}
+void MD5GenBaseFunc__SSEtoX86_switch_input2() {
+#ifdef MMX_COEF
+	int j, k, idx, max;
+
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 2;
+
+	for (j = 0; j < m_count; j += MMX_COEF)
+	{
+		ARCH_WORD_32 *cpi;
+		ARCH_WORD_32 *cpo = input_buf2_X86[j].x1.w;
+		ARCH_WORD_32 *cpo2 = input_buf2_X86[j+1].x1.w;
+#if (MMX_COEF==4)
+		ARCH_WORD_32 *cpo3 = input_buf2_X86[j+2].x1.w;
+		ARCH_WORD_32 *cpo4 = input_buf2_X86[j+3].x1.w;
+#endif
+		idx = ( ((unsigned)j)>>(MMX_COEF>>1));
+		cpi = (void*)(&input_buf2[idx]);
+
+		max = total_len2_X86[j] = (total_len2[idx]&0xFF);
+#if (MMX_COEF==2)
+		if (max < (total_len2_X86[j+1]=((total_len2[idx]>>16)&0xFF)))
+			max = total_len2_X86[j+1];
+#else
+		if (max < (total_len2_X86[j+1]=((total_len2[idx]>> 8)&0xFF)))
+			max = total_len2_X86[j+1];
+		if (max < (total_len2_X86[j+2]=((total_len2[idx]>>16)&0xFF)))
+			max = total_len2_X86[j+2];
+		if (max < (total_len2_X86[j+3]=((total_len2[idx]>>24)&0xFF)))
+			max = total_len2_X86[j+3];
+#endif
+		max = (max+3)>>2;
+		for (k = 0; k < max; ++k) {
+			*cpo++ = *cpi++;
+			*cpo2++ = *cpi++;
+#if (MMX_COEF==4)
+			*cpo3++ = *cpi++;
+			*cpo4++ = *cpi++;
+#endif
+		}
+		// get rid of the 0x80
+		input_buf2_X86[j].x1.b[total_len2_X86[j]] = 0;
+		input_buf2_X86[j+1].x1.b[total_len2_X86[j+1]] = 0;
+#if (MMX_COEF==4)
+		input_buf2_X86[j+2].x1.b[total_len2_X86[j+2]] = 0;
+		input_buf2_X86[j+3].x1.b[total_len2_X86[j+3]] = 0;
+#endif
+	}
+#endif
+}
+void MD5GenBaseFunc__SSEtoX86_switch_output1() {
+#ifdef MMX_COEF
+	int j, k, idx;
+
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 2;
+
+	for (j = 0; j < m_count; j += MMX_COEF)
+	{
+		ARCH_WORD_32 *cpi;
+		ARCH_WORD_32 *cpo = crypt_key_X86[j].x1.w;
+		ARCH_WORD_32 *cpo2 = crypt_key_X86[j+1].x1.w;
+#if (MMX_COEF==4)
+		ARCH_WORD_32 *cpo3 = crypt_key_X86[j+2].x1.w;
+		ARCH_WORD_32 *cpo4 = crypt_key_X86[j+3].x1.w;
+#endif
+		idx = ( ((unsigned)j)>>(MMX_COEF>>1));
+		cpi = (void*)(&crypt_key[idx]);
+		for (k = 0; k < 4; ++k) {
+			*cpo++ = *cpi++;
+			*cpo2++ = *cpi++;
+#if (MMX_COEF==4)
+			*cpo3++ = *cpi++;
+			*cpo4++ = *cpi++;
+#endif
+		}
+	}
+#endif
+}
+void MD5GenBaseFunc__SSEtoX86_switch_output2() {
+#ifdef MMX_COEF
+	int j, k, idx;
+
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 2;
+
+	for (j = 0; j < m_count; j += MMX_COEF)
+	{
+		ARCH_WORD_32 *cpi;
+		ARCH_WORD_32 *cpo = crypt_key2_X86[j].x1.w;
+		ARCH_WORD_32 *cpo2 = crypt_key2_X86[j+1].x1.w;
+#if (MMX_COEF==4)
+		ARCH_WORD_32 *cpo3 = crypt_key2_X86[j+2].x1.w;
+		ARCH_WORD_32 *cpo4 = crypt_key2_X86[j+3].x1.w;
+#endif
+		idx = ( ((unsigned)j)>>(MMX_COEF>>1));
+		cpi = (void*)(&crypt_key2[idx]);
+		for (k = 0; k < 4; ++k) {
+			*cpo++ = *cpi++;
+			*cpo2++ = *cpi++;
+#if (MMX_COEF==4)
+			*cpo3++ = *cpi++;
+			*cpo4++ = *cpi++;
+#endif
+		}
+	}
+#endif
+}
+void MD5GenBaseFunc__X86toSSE_switch_input1() {
+#ifdef MMX_COEF
+	unsigned j, idx, idx_mod;
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 1;
+	MD5GenBaseFunc__clean_input();
+	for (j = 0; j < m_count; ++j) {
+		idx = (j>>(MMX_COEF>>1));
+		idx_mod = j&(MMX_COEF-1);
+		total_len[idx] += (total_len_X86[j] << ((32/MMX_COEF)*idx_mod));
+		__SSE_append_string_to_input((unsigned char*)(&input_buf[idx]),idx_mod,input_buf_X86[j].x1.b,total_len_X86[j],0,1);
+	}
+#endif
+}
+void MD5GenBaseFunc__X86toSSE_switch_input2() {
+#ifdef MMX_COEF
+	unsigned j, idx, idx_mod;
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 1;
+	MD5GenBaseFunc__clean_input2();
+	for (j = 0; j < m_count; ++j) {
+		idx = (j>>(MMX_COEF>>1));
+		idx_mod = j&(MMX_COEF-1);
+		total_len2[idx] += (total_len2_X86[j] << ((32/MMX_COEF)*idx_mod));
+		__SSE_append_string_to_input((unsigned char*)(&input_buf2[idx]),idx_mod,input_buf2_X86[j].x1.b,total_len2_X86[j],0,1);
+	}
+#endif
+}
+void MD5GenBaseFunc__X86toSSE_switch_output1() {
+#ifdef MMX_COEF
+	int j, k, idx;
+
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 1;
+
+	for (j = 0; j < m_count; j += MMX_COEF)
+	{
+		ARCH_WORD_32 *cpi;
+		ARCH_WORD_32 *cpo = crypt_key_X86[j].x1.w;
+		ARCH_WORD_32 *cpo2 = crypt_key_X86[j+1].x1.w;
+#if (MMX_COEF==4)
+		ARCH_WORD_32 *cpo3 = crypt_key_X86[j+2].x1.w;
+		ARCH_WORD_32 *cpo4 = crypt_key_X86[j+3].x1.w;
+#endif
+		idx = ( ((unsigned)j)>>(MMX_COEF>>1));
+		cpi = (void*)(&crypt_key[idx]);
+		for (k = 0; k < 4; ++k) {
+			*cpi++ = *cpo++;
+			*cpi++ = *cpo2++;
+#if (MMX_COEF==4)
+			*cpi++ = *cpo3++;
+			*cpi++ = *cpo4++;
+#endif
+		}
+	}
+#endif
+}
+void MD5GenBaseFunc__X86toSSE_switch_output2() {
+#ifdef MMX_COEF
+	int j, k, idx;
+
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 1;
+
+	for (j = 0; j < m_count; j += MMX_COEF)
+	{
+		ARCH_WORD_32 *cpi;
+		ARCH_WORD_32 *cpo = crypt_key2_X86[j].x1.w;
+		ARCH_WORD_32 *cpo2 = crypt_key2_X86[j+1].x1.w;
+#if (MMX_COEF==4)
+		ARCH_WORD_32 *cpo3 = crypt_key2_X86[j+2].x1.w;
+		ARCH_WORD_32 *cpo4 = crypt_key2_X86[j+3].x1.w;
+#endif
+		idx = ( ((unsigned)j)>>(MMX_COEF>>1));
+		cpi = (void*)(&crypt_key2[idx]);
+		for (k = 0; k < 4; ++k) {
+			*cpi++ = *cpo++;
+			*cpi++ = *cpo2++;
+#if (MMX_COEF==4)
+			*cpi++ = *cpo3++;
+			*cpi++ = *cpo4++;
+#endif
+		}
+	}
+#endif
+}
+// This function, simply 'switches' back to SSE  It does NOT copy any data from X86 to SSE
+void MD5GenBaseFunc__ToSSE() {
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 1;
+}
+// This function, simply 'switches' to X86  It does NOT copy any data from SSE to X86
+void MD5GenBaseFunc__ToX86() {
+	if (md5_gen_use_sse == 0)
+		return;
+	md5_gen_use_sse = 2;
+}
+
+void MD5GenBaseFunc__base16_convert_locase() {
+	md5gen_itoa16 = itoa16;
+	itoa16_w2=itoa16_w2_l;
+}
+void MD5GenBaseFunc__base16_convert_upcase() {
+	md5gen_itoa16 = itoa16_up;
+	itoa16_w2=itoa16_w2_u;
+}
+
+
+
+/**************************************************************
+ **************************************************************
+  SHA1 functions. Intermix.   not as 'powerful' due to limitations
+  But this allows building in 'some' interplay bewteen the formats.
+ **************************************************************
+ **************************************************************/
+
+#ifdef MMX_COEF
+void SHA1_SSE_Crypt(MD5_IN input[MAX_KEYS_PER_CRYPT_X86], unsigned int ilen[MAX_KEYS_PER_CRYPT_X86],
+					MD5_IN out[MAX_KEYS_PER_CRYPT_X86]  , unsigned int olen[MAX_KEYS_PER_CRYPT_X86], int append)
+{
+	unsigned i, j, tot=0, tot2=0, z, k;
+
+	for (k = 0; k*MMX_COEF*SHA_BLOCKS < m_count; ++k)
+	{
+		z=0;
+#ifdef SHA1_SSE_PARA
+		for (; z < SHA1_SSE_PARA; ++z)
+#endif
+		{
+			memset(sinput_buf[z], 0, 56*MMX_COEF); // we only have to blank out the 'first' part of the buffer.
+			for (j = 0; j < MMX_COEF && tot < m_count; ++j, ++tot)
+			{
+				unsigned char *si = input[k*MMX_COEF*SHA_BLOCKS+z*MMX_COEF+j].x1.B;
+				unsigned int li = ilen[k*MMX_COEF*SHA_BLOCKS+z*MMX_COEF+j];
+				for (i = 0; i < li; ++i)
+					sinput_buf[z][SHAGETPOS(i, j)] = si[i];
+				sinput_buf[z][SHAGETPOS(i, j)] = 0x80;
+				((unsigned int *)sinput_buf[z])[15*MMX_COEF+j] = li<<3;
+			}
+		}
+#ifdef SHA1_SSE_PARA
+		SSESHA1body(sinput_buf, (unsigned int*)scrypt_key, 1);
+#else
+		shammx_nosizeupdate_nofinalbyteswap(((unsigned char*)(scrypt_key[0])), sinput_buf[0], 1);
+#endif
+		// Ok, convert to base-16
+		z = 0;
+#ifdef SHA1_SSE_PARA
+		for (; z < SHA1_SSE_PARA; ++z)
+#endif
+		{
+			for (j = 0; j < MMX_COEF && tot2 < m_count; ++j, ++tot2)
+			{
+				unsigned char *oo = out[k*MMX_COEF*SHA_BLOCKS+z*MMX_COEF+j].x1.B;
+				unsigned short *wo;
+				if (!append)
+					olen[k*MMX_COEF*SHA_BLOCKS+z*MMX_COEF+j] = 0;
+				oo += olen[k*MMX_COEF*SHA_BLOCKS+z*MMX_COEF+j];
+				wo = (unsigned short*)oo;
+				olen[k*MMX_COEF*SHA_BLOCKS+z*MMX_COEF+j] += 40;
+
+				for (i = 0; i < 20; i+=4) {
+					*wo++ = itoa16_w2[scrypt_key[z][GETPOS(i+3, j)]];
+					*wo++ = itoa16_w2[scrypt_key[z][GETPOS(i+2, j)]];
+					*wo++ = itoa16_w2[scrypt_key[z][GETPOS(i+1, j)]];
+					*wo++ = itoa16_w2[scrypt_key[z][GETPOS(i+0, j)]];
+				}
+				oo[40] = 0;
+			}
+		}
+	}
+}
+
+#if 0
+void SHA1_SSE_Crypt_final(MD5_IN input[MAX_KEYS_PER_CRYPT_X86], unsigned int ilen[MAX_KEYS_PER_CRYPT_X86])
+{
+	if (md5_gen_use_sse==3)
+	{
+		shammx(crypt_key[0], sinput_buf[0], total_len[0]);
+	}
+	else
+	{
+		unsigned i, j, k, tot=0, totstart;
+		unsigned char *so = sinput_buf[0];
+		unsigned char *sc = crypt_key[0];
+		for (k = 0; tot < m_count; ++k)
+		{
+			unsigned total_len=0;
+			totstart = tot;
+			memset(so, 0, 64*MMX_COEF); // we only have to blank out the 'first' part of the buffer.
+			for (j = 0; j < MMX_COEF && tot < m_count; ++j, ++tot)
+			{
+				unsigned char *si = input[k*MMX_COEF+j].x1.B;
+				unsigned int li = ilen[k*MMX_COEF+j];
+
+				total_len += li << ((32/MMX_COEF)*j);
+				for (i = 0; i < li; ++i)
+					so[SHAGETPOS(i, j)] = si[i];
+				so[SHAGETPOS(i, j)] = 0x80;
+			}
+			shammx(sc, so, total_len);
+			sc += 16*MMX_COEF;
+		}
+	}
+}
+#endif
+
+void SHA1_SSE_Crypt_final(MD5_IN input[MAX_KEYS_PER_CRYPT_X86], unsigned int ilen[MAX_KEYS_PER_CRYPT_X86])
+{
+#if !SHA1_SSE_PARA
+	if (md5_gen_use_sse==3)
+	{
+		shammx(crypt_key[0], sinput_buf[0], total_len[0]);
+	}
+	else
+#endif
+	{
+		unsigned i, j, tot=0, /*tot2=0,*/ z, k;
+		unsigned MMXCOEF=MMX_COEF, SHABLOCKS=SHA_BLOCKS;
+
+		for (k = 0; k*MMXCOEF*SHABLOCKS < m_count; ++k)
+		{
+			z=0;
+#ifdef SHA1_SSE_PARA
+			for (; z < SHA1_SSE_PARA; ++z)
+#endif
+			{
+				memset(sinput_buf[z], 0, 56*MMXCOEF); // we only have to blank out the 'first' part of the buffer.
+				for (j = 0; j < MMXCOEF && tot < m_count; ++j, ++tot)
+				{
+					unsigned char *si = input[k*MMXCOEF*SHABLOCKS+z*MMXCOEF+j].x1.B;
+					unsigned int li = ilen[k*MMXCOEF*SHABLOCKS+z*MMXCOEF+j];
+					for (i = 0; i < li; ++i)
+						sinput_buf[z][SHAGETPOS(i, j)] = si[i];
+					sinput_buf[z][SHAGETPOS(i, j)] = 0x80;
+					((unsigned int *)sinput_buf[z])[15*MMXCOEF+j] = li<<3;
+				}
+			}
+#ifdef SHA1_SSE_PARA
+			SSESHA1body(sinput_buf, (unsigned int*)scrypt_key, 1);
+			SHA1_swap(((MD5_word*)scrypt_key), ((MD5_word*)scrypt_key), 5*MMX_COEF*SHA1_SSE_PARA);
+			for (z = 0; z < SHA1_SSE_PARA; ++z)
+				memcpy(crypt_key[k*SHA1_SSE_PARA+z], scrypt_key[z], BINARY_SIZE*MMXCOEF);
+#else
+			shammx_nosizeupdate(((unsigned char*)(crypt_key[k])), sinput_buf[0], 1);
+#endif
+		}
+	}
+}
+#endif
+
+void MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20], *cpi, *cpo;
+	int i, j;
+
+	if (md5_gen_use_sse == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input1();
+		MD5GenBaseFunc__SSEtoX86_switch_input2();
+	}
+#ifdef MMX_COEF
+	if (switchback)
+		SHA1_SSE_Crypt(input_buf_X86, total_len_X86, input_buf2_X86, total_len2_X86, 1);
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1) {
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i]);
+			cpo = (unsigned char *)&(input_buf2_X86[i>>MD5_X2].x2.b2[total_len2_X86[i]]);
+		}
+		else
+#endif
+		{
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i]);
+			cpo = (unsigned char *)&(input_buf2_X86[i>>MD5_X2].x1.b[total_len2_X86[i]]);
+		}
+		SHA1_Final(crypt_out, &sha_ctx);
+		cpi = crypt_out;
+		for (j = 0; j < 20; ++j) {
+			*cpo++ = md5gen_itoa16[*cpi>>4];
+			*cpo++ = md5gen_itoa16[*cpi&0xF];
+			++cpi;
+		}
+		*cpo = 0;
+		total_len2_X86[i] += 40;
+	}
+	if (switchback==1) {
+		MD5GenBaseFunc__X86toSSE_switch_input2();
+	}
+}
+void MD5GenBaseFunc__SHA1_crypt_input2_append_input1_base16()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20], *cpi, *cpo;
+	int i, j;
+
+	if (md5_gen_use_sse == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input1();
+		MD5GenBaseFunc__SSEtoX86_switch_input2();
+	}
+#ifdef MMX_COEF
+	if (switchback)
+		SHA1_SSE_Crypt(input_buf2_X86, total_len2_X86, input_buf_X86, total_len_X86, 1);
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1) {
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i]);
+			cpo = (unsigned char *)&(input_buf_X86[i>>MD5_X2].x2.b2[total_len_X86[i]]);
+		}
+		else
+#endif
+		{
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i]);
+			cpo = (unsigned char *)&(input_buf_X86[i>>MD5_X2].x1.b[total_len_X86[i]]);
+		}
+		SHA1_Final(crypt_out, &sha_ctx);
+		cpi = crypt_out;
+		for (j = 0; j < 20; ++j) {
+			*cpo++ = md5gen_itoa16[*cpi>>4];
+			*cpo++ = md5gen_itoa16[*cpi&0xF];
+			++cpi;
+		}
+		*cpo = 0;
+		total_len_X86[i] += 40;
+	}
+	if (switchback==1) {
+		MD5GenBaseFunc__X86toSSE_switch_input1();
+	}
+}
+void MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input1_base16()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20], *cpi, *cpo;
+	int i, j;
+
+	if (md5_gen_use_sse == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input1();
+	}
+#ifdef MMX_COEF
+	if (switchback)
+		SHA1_SSE_Crypt(input_buf_X86, total_len_X86, input_buf_X86, total_len_X86, 0);
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1) {
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i]);
+			cpo = (unsigned char *)input_buf_X86[i>>MD5_X2].x2.b2;
+		}
+		else
+#endif
+		{
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i]);
+			cpo = (unsigned char *)input_buf_X86[i>>MD5_X2].x1.b;
+		}
+		SHA1_Final(crypt_out, &sha_ctx);
+		cpi = crypt_out;
+		for (j = 0; j < 20; ++j) {
+			*cpo++ = md5gen_itoa16[*cpi>>4];
+			*cpo++ = md5gen_itoa16[*cpi&0xF];
+			++cpi;
+		}
+		memset(cpo, 0, 16);
+		total_len_X86[i] = 40;
+	}
+	if (switchback==1) {
+		MD5GenBaseFunc__X86toSSE_switch_input1();
+	}
+}
+void MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input2_base16()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20], *cpi, *cpo;
+	int i, j;
+
+	if (md5_gen_use_sse == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input1();
+	}
+#ifdef MMX_COEF
+	if (switchback)
+		SHA1_SSE_Crypt(input_buf_X86, total_len_X86, input_buf2_X86, total_len2_X86, 0);
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1) {
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i]);
+			cpo = (unsigned char *)input_buf2_X86[i>>MD5_X2].x2.b2;
+		}
+		else
+#endif
+		{
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i]);
+			cpo = (unsigned char *)input_buf2_X86[i>>MD5_X2].x1.b;
+		}
+		SHA1_Final(crypt_out, &sha_ctx);
+		cpi = crypt_out;
+		for (j = 0; j < 20; ++j) {
+			*cpo++ = md5gen_itoa16[*cpi>>4];
+			*cpo++ = md5gen_itoa16[*cpi&0xF];
+			++cpi;
+		}
+		memset(cpo, 0, 16);
+		total_len2_X86[i] = 40;
+	}
+	if (switchback==1) {
+		MD5GenBaseFunc__X86toSSE_switch_input2();
+	}
+}
+void MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input1_base16()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20], *cpi, *cpo;
+	int i, j;
+
+	if (md5_gen_use_sse == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input2();
+	}
+#ifdef MMX_COEF
+	if (switchback)
+		SHA1_SSE_Crypt(input_buf2_X86, total_len2_X86, input_buf_X86, total_len_X86, 0);
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1) {
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i]);
+			cpo = (unsigned char *)input_buf_X86[i>>MD5_X2].x2.b2;
+		}
+		else
+#endif
+		{
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i]);
+			cpo = (unsigned char *)input_buf_X86[i>>MD5_X2].x1.b;
+		}
+		SHA1_Final(crypt_out, &sha_ctx);
+		cpi = crypt_out;
+		for (j = 0; j < 20; ++j) {
+			*cpo++ = md5gen_itoa16[*cpi>>4];
+			*cpo++ = md5gen_itoa16[*cpi&0xF];
+			++cpi;
+		}
+		memset(cpo, 0, 16);
+		total_len_X86[i] = 40;
+	}
+	if (switchback==1) {
+		MD5GenBaseFunc__X86toSSE_switch_input1();
+	}
+}
+
+void MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20], *cpi, *cpo;
+	int i, j;
+
+	if (md5_gen_use_sse == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input2();
+	}
+#ifdef MMX_COEF
+	if (switchback)
+		SHA1_SSE_Crypt(input_buf2_X86, total_len2_X86, input_buf2_X86, total_len2_X86, 0);
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1) {
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i]);
+			cpo = (unsigned char *)input_buf2_X86[i>>MD5_X2].x2.b2;
+		}
+		else
+#endif
+		{
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i]);
+			cpo = (unsigned char *)input_buf2_X86[i>>MD5_X2].x1.b;
+		}
+		SHA1_Final(crypt_out, &sha_ctx);
+		cpi = crypt_out;
+		for (j = 0; j < 20; ++j) {
+			*cpo++ = md5gen_itoa16[*cpi>>4];
+			*cpo++ = md5gen_itoa16[*cpi&0xF];
+			++cpi;
+		}
+		*cpo = 0;
+		total_len2_X86[i] = 40;
+	}
+	if (switchback==1) {
+		MD5GenBaseFunc__X86toSSE_switch_input2();
+	}
+}
+
+void MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20];
+	int i;
+
+	if (switchback == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input1();
+	}
+#ifdef MMX_COEF
+	if (switchback) {
+		SHA1_SSE_Crypt_final(input_buf_X86, total_len_X86);
+		md5_gen_use_sse=switchback;
+		if (md5_gen_use_sse==2)
+			md5_gen_use_sse=1;
+	}
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1)
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x2.b2, total_len_X86[i]);
+		else
+#endif
+			SHA1_Update(&sha_ctx, input_buf_X86[i>>MD5_X2].x1.b, total_len_X86[i]);
+		SHA1_Final(crypt_out, &sha_ctx);
+
+		// Only copies the first 16 out of 20 bytes.  Thus we do not have
+		// the entire SHA1. It would NOT be valid to continue from here. However
+		// it is valid (and 128 bit safe), to simply check the first 128 bits
+		// of SHA1 hash (vs the whole 160 bits), with cmp_all/cmp_one, and if it
+		// matches, then we can 'assume' we have a hit.
+		// That is why the name of the function is *_FINAL()  it is meant to be
+		// something like sha1(md5($p))  and then we simply compare 16 bytes
+		// of hash (instead of the full 20).
+#if (MD5_X2)
+		if (i & 1)
+			memcpy(crypt_key_X86[i>>MD5_X2].x2.b2, crypt_out, 16);
+		else
+#endif
+			memcpy(crypt_key_X86[i>>MD5_X2].x1.b, crypt_out, 16);
+	}
+}
+void MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL()
+{
+	int switchback=md5_gen_use_sse;
+	unsigned char crypt_out[20];
+	int i;
+
+	if (switchback == 1) {
+		MD5GenBaseFunc__SSEtoX86_switch_input2();
+	}
+#ifdef MMX_COEF
+	if (switchback) {
+		SHA1_SSE_Crypt_final(input_buf2_X86, total_len2_X86);
+		md5_gen_use_sse = switchback;
+		if (md5_gen_use_sse==2)
+			md5_gen_use_sse=1;
+	}
+	else
+#endif
+	for (i = 0; i < m_count; ++i) {
+		SHA1_Init(&sha_ctx);
+#if (MD5_X2)
+		if (i & 1)
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x2.b2, total_len2_X86[i]);
+		else
+#endif
+			SHA1_Update(&sha_ctx, input_buf2_X86[i>>MD5_X2].x1.b, total_len2_X86[i]);
+		SHA1_Final(crypt_out, &sha_ctx);
+
+		// Only copies the first 16 out of 20 bytes.  Thus we do not have
+		// the entire SHA1. It would NOT be valid to continue from here. However
+		// it is valid (and 128 bit safe), to simply check the first 128 bits
+		// of SHA1 hash (vs the whole 160 bits), with cmp_all/cmp_one, and if it
+		// matches, then we can 'assume' we have a hit.
+		// That is why the name of the function is *_FINAL()  it is meant to be
+		// something like sha1(md5($p))  and then we simply compare 16 bytes
+		// of hash (instead of the full 20).
+#if (MD5_X2)
+		if (i & 1)
+			memcpy(crypt_key_X86[i>>MD5_X2].x2.b2, crypt_out, 16);
+		else
+#endif
+			memcpy(crypt_key_X86[i>>MD5_X2].x1.b, crypt_out, 16);
+	}
+}
+
+/**************************************************************
+ **************************************************************
+ * MD5_GEN primitive helper function
+ * These are not done yet. Usage of them will exit john with
+ * an error message. Some of these are for optimzations (like
+ * speeding up phpass, some use 2nd salt and user id, which we
+ * have not yet implemented
+ **************************************************************
+ *************************************************************/
+
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * overwrites start of input2 from the output1 data using base-16
+ * an optimization, if the same thing is done over and over
+ * again, such as md5(md5(md5(md5($p))))  There, we would only
+ * call the copy and set length once, then simply call copy.
+ *************************************************************/
+void MD5GenBaseFunc__overwrite_from_last_output_to_input2_as_base16_no_size_fix()
+{
+	exit(fprintf(stderr, "Error, MD5GenBaseFunc__overwrite_from_last_output_to_input2_as_base16_no_size_fix() primitive has not been implemented\n"));
+}
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * overwrites start of input2 from the output2 data using base-16
+ *************************************************************/
+void MD5GenBaseFunc__overwrite_from_last_output2_as_base16_no_size_fix()
+{
+	exit(fprintf(stderr, "Error, MD5GenBaseFunc__overwrite_from_last_output2_as_base16_no_size_fix() primitive has not been implemented\n"));
+}
+/**************************************************************
+ * MD5_GEN primitive helper function
+ * overwrites start of input1 from the output2 data using base-16
+ *************************************************************/
+void MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix()
+{
+	exit(fprintf(stderr, "Error, MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix() primitive has not been implemented\n"));
+}
+void MD5GenBaseFunc__append2_from_last_output2_as_raw()
+{
+	exit(fprintf(stderr, "Error, MD5GenBaseFunc__append2_from_last_output2_as_raw() primitive has not been implemented\n"));
+}
+void MD5GenBaseFunc__append_from_last_output1_as_raw()
+{
+	exit(fprintf(stderr, "Error, MD5GenBaseFunc__append_from_last_output1_as_raw() primitive has not been implemented\n"));
+}
+void MD5GenBaseFunc__append2_from_last_output1_as_raw()
+{
+	exit(fprintf(stderr, "Error, MD5GenBaseFunc__append2_from_last_output1_as_raw() primitive has not been implemented\n"));
+}
+
+/**************************************************************
+ * DEPRICATED functions. These are the older pseudo functions
+ * which we now have flags for.  We keep them, so that we can
+ * add the proper flags, even if the user is running an older
+ * script.
+ *************************************************************/
+void MD5GenBaseFunc__PHPassSetup() {}
+void MD5GenBaseFunc__InitialLoadKeysToInput() {}
+void MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2() {}
+void MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1() {}
+void MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1_offset32() {}
+
+
+/**************************************************************
+ **************************************************************
+ **************************************************************
+ **************************************************************
+ * MD5_GEN primitive helper function
+ * This is the END of the primitives.
+ **************************************************************
+ **************************************************************
+ **************************************************************
+ *************************************************************/
+
+static MD5_GEN_primitive_funcp *ConvertFuncs(MD5_GEN_primitive_funcp p, int *count)
+{
+	static MD5_GEN_primitive_funcp fncs[20];
+	*count = 0;
+	if (p==MD5GenBaseFunc__PHPassSetup  ||
+		p==MD5GenBaseFunc__InitialLoadKeysToInput ||
+		p==MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2 ||
+		p==MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1 ||
+		p==MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1_offset32)
+		return fncs; // ignore these
+
+#ifndef MMX_COEF
+	if (p==MD5GenBaseFunc__SSEtoX86_switch_input1  || p==MD5GenBaseFunc__SSEtoX86_switch_input2 ||
+		p==MD5GenBaseFunc__SSEtoX86_switch_output1 || p==MD5GenBaseFunc__SSEtoX86_switch_output2 ||
+		p==MD5GenBaseFunc__X86toSSE_switch_input1  || p==MD5GenBaseFunc__X86toSSE_switch_input2 ||
+		p==MD5GenBaseFunc__X86toSSE_switch_output1 || p==MD5GenBaseFunc__X86toSSE_switch_output2 ||
+		p==MD5GenBaseFunc__ToSSE                   || p==MD5GenBaseFunc__ToX86)
+		return fncs; // we ignore these functions 100% in x86 mode.
+#endif
+//	if (p==MD5GenBaseFunc__append_input2_from_CONST1) {
+//		fncs[0] = MD5GenBaseFunc__set_input2;
+//		fncs[1] = MD5GenBaseFunc__set_CONST1;
+//		fncs[2] = MD5GenBaseFunc__append_CONST;
+//		*count = 3;
+//	}
+
+#if !ARCH_LITTLE_ENDIAN
+	if (p==MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16    ||
+		p==MD5GenBaseFunc__SHA1_crypt_input2_append_input1_base16    ||
+		p==MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input1_base16 ||
+		p==MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16 ||
+		p==MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input2_base16 ||
+		p==MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input1_base16 ||
+		p==MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL        ||
+		p==MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL)
+		curdat.force_md5_ctx = 0;
+#endif
+
+
+	*count = 1;
+	fncs[0] = p;
+	return fncs;
+}
+
+int md5_gen_SETUP(MD5_GEN_Setup *Setup, struct fmt_main *pFmt)
+{
+	int i, j, cnt, cnt2, x;
+	MD5_GEN_primitive_funcp *pFuncs;
+
+	if (Setup->flags & MGF_ColonNOTValid)
+	{
+		extern struct options_main options;
+		if (options.field_sep_char == ':')
+		{
+			return 0;
+		}
+	}
+
+	// Deal with depricated 1st functions.  Convert them to proper 'flags'
+	if (Setup->pFuncs[0] == MD5GenBaseFunc__PHPassSetup)
+		Setup->startFlags |= MGF_PHPassSetup;
+	if (Setup->pFuncs[0] == MD5GenBaseFunc__InitialLoadKeysToInput)
+		Setup->startFlags |= MGF_KEYS_INPUT;
+	if (Setup->pFuncs[0] == MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2)
+		Setup->startFlags |= MGF_KEYS_CRYPT_IN2;
+	if (Setup->pFuncs[0] == MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1)
+		Setup->startFlags |= MGF_KEYS_BASE16_IN1;
+	if (Setup->pFuncs[0] == MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1_offset32)
+		Setup->startFlags |= MGF_KEYS_BASE16_IN1_Offset32;
+
+	curdat.md5_gen_hdaa_salt     = ((Setup->flags&MGF_HDAA_SALT)==MGF_HDAA_SALT) ? 1 : 0;
+	curdat.md5_gen_40_byte_sha1  = ((Setup->flags&MGF_SHA1_40_BYTE_FINISH)==MGF_SHA1_40_BYTE_FINISH) ? 1 : 0;
+	curdat.b2Salts               = ((Setup->flags&MGF_SALTED2)==MGF_SALTED2) ? 1 : 0;
+	curdat.md5_gen_base16_upcase = ((Setup->flags&MGF_BASE_16_OUTPUT_UPCASE)==MGF_BASE_16_OUTPUT_UPCASE) ? 1 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD0)==MGF_FLD0) ? MGF_FLD0 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD1)==MGF_FLD1) ? MGF_FLD1 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD2)==MGF_FLD2) ? MGF_FLD2 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD3)==MGF_FLD3) ? MGF_FLD3 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD4)==MGF_FLD4) ? MGF_FLD4 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD5)==MGF_FLD5) ? MGF_FLD5 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD6)==MGF_FLD6) ? MGF_FLD6 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD7)==MGF_FLD7) ? MGF_FLD7 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD8)==MGF_FLD8) ? MGF_FLD8 : 0;
+	curdat.FldMask              |= ((Setup->flags&MGF_FLD9)==MGF_FLD9) ? MGF_FLD9 : 0;
+
+	curdat.md5_gen_base64_inout = 0;
+	curdat.md5_gen_salt_as_hex = 0;
+	curdat.FldMask = 0;
+	curdat.force_md5_ctx = 0;
+	curdat.bUserName = 0;
+	curdat.md5_startup_in_x86 = curdat.md5_gen_use_sse = 0;  // if 0, then never use SSE2
+	pFmt->methods.binary = binary;
+	pFmt->methods.cmp_all=cmp_all;
+	pFmt->methods.cmp_one=cmp_one;
+	pFmt->methods.salt = salt;
+	pFmt->methods.set_salt = set_salt;
+	pFmt->methods.salt_hash = salt_hash;
+	pFmt->params.format_name = str_alloc_copy(Setup->szFORMAT_NAME);
+	pFmt->params.benchmark_length = 0;		// NOTE 0 'assumes' salted. If unsalted, we set back to -1
+	pFmt->params.salt_size = 0;
+	pFmt->params.min_keys_per_crypt = 1;
+#ifdef MMX_COEF
+	curdat.md5_gen_use_sse = 1;  // if 1, then we are in SSE2 mode (but can switch out)
+	if ((Setup->flags & MGF_NOTSSE2Safe) == MGF_NOTSSE2Safe)
+		curdat.md5_gen_use_sse = 0;  // Do not use SSE code at all.
+	else if ((Setup->flags & MGF_StartInX86Mode) == MGF_StartInX86Mode) {
+		curdat.md5_gen_use_sse = 2;  // if 2, then we are in SSE2 mode, but currently using X86 (and can switch back to SSE2).
+		curdat.md5_startup_in_x86 = 1;
+	}
+	if (curdat.md5_gen_use_sse) {
+		pFmt->params.max_keys_per_crypt = MAX_KEYS_PER_CRYPT;
+		pFmt->params.algorithm_name = ALGORITHM_NAME;
+	} else {
+		pFmt->params.max_keys_per_crypt = MAX_KEYS_PER_CRYPT_X86;
+		pFmt->params.algorithm_name = ALGORITHM_NAME_X86;
+	}
+#else
+	pFmt->params.max_keys_per_crypt = MAX_KEYS_PER_CRYPT_X86;
+	pFmt->params.algorithm_name = ALGORITHM_NAME_X86;
+#endif
+	Setup->flags ^= MGF_NOTSSE2Safe;
+	md5_gen_use_sse = curdat.md5_gen_use_sse;
+
+	// Ok, set the new 'constants' data
+	memset(curdat.Consts, 0, sizeof(curdat.Consts));
+	memset(curdat.ConstsLen, 0, sizeof(curdat.ConstsLen));
+	for (curdat.nConsts = 0; curdat.nConsts < 8; ++curdat.nConsts)
+	{
+		if (Setup->pConstants[curdat.nConsts].Const == NULL)
+			break;
+		curdat.Consts[curdat.nConsts] = str_alloc_copy(Setup->pConstants[curdat.nConsts].Const);
+		curdat.ConstsLen[curdat.nConsts] = strlen(Setup->pConstants[curdat.nConsts].Const);
+	}
+
+	if (Setup->flags & MGF_INPBASE64)
+	{
+		curdat.md5_gen_base64_inout = 1;
+		pFmt->methods.binary = binary_b64;
+	}
+	if (Setup->flags & MGF_INPBASE64_4x6)
+	{
+		curdat.md5_gen_base64_inout = 2;
+		pFmt->methods.binary = binary_b64_4x6;
+		pFmt->methods.cmp_all = cmp_all_64_4x6;
+		pFmt->methods.cmp_one = cmp_one_64_4x6;
+
+#if !ARCH_LITTLE_ENDIAN
+		pFmt->methods.binary_hash[0] = binary_hash_0_64x4;
+		pFmt->methods.binary_hash[1] = binary_hash_1_64x4;
+		pFmt->methods.binary_hash[2] = binary_hash_2_64x4;
+		pFmt->methods.binary_hash[3] = binary_hash_3_64x4;
+		pFmt->methods.binary_hash[4] = binary_hash_4_64x4;
+		pFmt->methods.get_hash[0] = get_hash_0_64x4;
+		pFmt->methods.get_hash[1] = get_hash_1_64x4;
+		pFmt->methods.get_hash[2] = get_hash_2_64x4;
+		pFmt->methods.get_hash[3] = get_hash_3_64x4;
+		pFmt->methods.get_hash[4] = get_hash_4_64x4;
+#endif
+	}
+	if (Setup->flags & MGF_INPBASE64a)
+	{
+		curdat.md5_gen_base64_inout = 1;
+		pFmt->methods.binary = binary_b64a;
+	}
+
+	if ( (Setup->flags & MGF_USERNAME) == MGF_USERNAME)
+		curdat.bUserName = 1;
+	if ( (Setup->flags & MGF_USERNAME_UPCASE) == MGF_USERNAME_UPCASE)
+		curdat.bUserName = 2;
+	if ( (Setup->flags & MGF_USERNAME_LOCASE) == MGF_USERNAME_LOCASE)
+		curdat.bUserName = 3;
+
+	if ( (Setup->flags & MGF_SALT_AS_HEX) == MGF_SALT_AS_HEX)
+		curdat.md5_gen_salt_as_hex = 1;
+	if ( (Setup->flags & MGF_SALT_AS_HEX_TO_SALT2) == MGF_SALT_AS_HEX_TO_SALT2) {
+		curdat.md5_gen_salt_as_hex = 2;
+		if (curdat.b2Salts)
+			exit(fprintf(stderr, "Error, MGF_SALT_AS_HEX_TO_SALT2 and MGF_SALTED2 are not valid to use in same format\n"));
+		curdat.b2Salts = 2;
+	}
+	if ( (Setup->flags & MGF_SALT_UNICODE_B4_CRYPT) == MGF_SALT_UNICODE_B4_CRYPT && curdat.md5_gen_salt_as_hex)
+		curdat.md5_gen_salt_as_hex |= 0x100;
+
+	if ( (Setup->flags & MGF_SALTED) == 0)
+	{
+		curdat.md5_gen_FIXED_SALT_SIZE = 0;
+		pFmt->params.benchmark_length = -1;
+		pFmt->params.salt_size = 0;
+	}
+	else
+	{
+		if (Setup->SaltLen > 0)
+		{
+			pFmt->params.salt_size = SALT_SIZE;
+			curdat.md5_gen_FIXED_SALT_SIZE = Setup->SaltLen;
+		}
+		else
+		{
+			pFmt->params.salt_size = SALT_SIZE;
+			curdat.md5_gen_FIXED_SALT_SIZE = -1;		// says we have a salt, but NOT a fixed sized one that we 'know' about.
+		}
+	}
+
+#ifdef MMX_COEF
+		pFmt->params.plaintext_length = PLAINTEXT_LENGTH;
+#else
+		pFmt->params.plaintext_length = PLAINTEXT_LENGTH_X86;
+#endif
+
+	if (Setup->MaxInputLen)
+		pFmt->params.plaintext_length = Setup->MaxInputLen;
+
+	curdat.store_keys_in_input = !!(Setup->startFlags&MGF_KEYS_INPUT );
+
+	if (!curdat.store_keys_in_input && Setup->startFlags&MGF_KEYS_INPUT_BE_SAFE)
+		curdat.store_keys_in_input = 3;
+
+	curdat.store_keys_in_input_unicode_convert = !!(Setup->startFlags&MGF_KEYS_UNICODE_B4_CRYPT);
+	if (curdat.store_keys_in_input_unicode_convert && curdat.store_keys_in_input)
+		return !!fprintf(stderr, "Invalid format.  Using MGF_KEYS_INPUT and MGF_KEYS_UNICODE_B4_CRYPT in same format is NOT valid\n");
+
+	curdat.store_keys_normal_but_precompute_md5_to_output2 = !!(Setup->startFlags&MGF_KEYS_CRYPT_IN2);
+
+	curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1 = !!(Setup->startFlags&MGF_KEYS_BASE16_IN1);
+	if (!!(Setup->startFlags&MGF_KEYS_BASE16_X86_IN1)) {
+		curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1=2;
+	}
+	if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1)
+		curdat.store_keys_normal_but_precompute_md5_to_output2 = 1;
+
+	curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32 = !!(Setup->startFlags&MGF_KEYS_BASE16_IN1_Offset32);
+	if (!!(Setup->startFlags&MGF_KEYS_BASE16_X86_IN1_Offset32))
+		curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32=2;
+	if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32)
+	{
+		curdat.store_keys_normal_but_precompute_md5_to_output2 = 1;
+	}
+
+	if (Setup->startFlags&MGF_RAW_SHA1_INPUT)
+	{
+		curdat.store_keys_in_input = 2;
+#ifdef MMX_COEF
+		pFmt->params.max_keys_per_crypt = MMX_COEF*SHA_BLOCKS;
+#if (SHA_BLOCKS < 2)
+		pFmt->params.algorithm_name = "4x1";
+#elif (SHA_BLOCKS == 2)
+		pFmt->params.algorithm_name = "4x2";
+#elif (SHA_BLOCKS == 3)
+		pFmt->params.algorithm_name = "4x3";
+#elif (SHA_BLOCKS == 4)
+		pFmt->params.algorithm_name = "4x4";
+#endif
+#endif
+	}
+
+	if (Setup->startFlags&MGF_FreeBSDMD5Setup)
+	{
+#ifdef MMX_COEF
+#if (MMX_COEF==2)
+		pFmt->params.algorithm_name = "MMX 2x1 (.S)";
+		pFmt->params.max_keys_per_crypt = 2;
+#elif (MD5_SSE_PARA==1)
+		pFmt->params.algorithm_name = "SSE2 4x1 (intr)";
+		pFmt->params.max_keys_per_crypt = 4;
+#elif (MD5_SSE_PARA==2)
+		pFmt->params.algorithm_name = "SSE2 4x2 (intr)";
+		pFmt->params.max_keys_per_crypt = 8;
+#elif (MD5_SSE_PARA==3)
+		pFmt->params.algorithm_name = "SSE2 4x3 (intr)";
+		pFmt->params.max_keys_per_crypt = 12;
+#elif (MD5_SSE_PARA==4)
+		pFmt->params.algorithm_name = "SSE2 4x4 (intr)";
+		pFmt->params.max_keys_per_crypt = 16;
+#elif (MD5_SSE_PARA==5)
+		pFmt->params.algorithm_name = "SSE2 4x5 (intr)";
+		pFmt->params.max_keys_per_crypt = 20;
+#elif (MD5_SSE_PARA==6)
+		pFmt->params.algorithm_name = "SSE2 4x6 (intr)";
+		pFmt->params.max_keys_per_crypt = 24;
+#else
+		pFmt->params.algorithm_name = "SSE2 4x1 (.S)";
+		pFmt->params.max_keys_per_crypt = 4;
+#endif
+#else
+		// In non-sse mode, 1 test runs as fast as 128. But validity checking is MUCH faster if
+		// we leave it at only 1.
+		pFmt->params.max_keys_per_crypt = 1;
+#if MD5_X2
+		pFmt->params.max_keys_per_crypt = 2;
+		pFmt->params.algorithm_name = "2x1 (MD5_body)";
+#else
+		pFmt->params.algorithm_name = "1x1 (MD5_body)";
+#endif
+#endif
+		pFmt->params.min_keys_per_crypt = 1;
+		saltlen = 8;
+		// no reason to run double tests. The 1 salt vs MANY salts is the
+		// same speed, so why double the benchmark time for no reason.
+		pFmt->params.benchmark_length = -1;
+	}
+	if (Setup->startFlags&MGF_PHPassSetup)
+	{
+		pFmt->methods.salt = salt_phpass;
+		pFmt->methods.set_salt = set_salt_phpass;
+#ifdef MMX_COEF
+		// no reason to do 128 crypts, causes slow validity checking.  But we do get some gains
+		// by doing more than simple 1 set of MMX_COEF
+		pFmt->params.max_keys_per_crypt = 16;
+#if (MMX_COEF==2)
+		pFmt->params.algorithm_name = "MMX 8x2 (.S)";
+#elif (MD5_SSE_PARA==1)
+		pFmt->params.algorithm_name = "SSE2 4x4x1 (intr)";
+#elif (MD5_SSE_PARA==2)
+		pFmt->params.algorithm_name = "SSE2 2x4x2 (intr)";
+#elif (MD5_SSE_PARA==3)
+		pFmt->params.algorithm_name = "SSE2 2x4x3 (intr)";
+		pFmt->params.max_keys_per_crypt = 24;
+#elif (MD5_SSE_PARA==4)
+		pFmt->params.algorithm_name = "SSE2 1x4x4 (intr)";
+#elif (MD5_SSE_PARA==5)
+		pFmt->params.algorithm_name = "SSE2 1x4x5 (intr)";
+		pFmt->params.max_keys_per_crypt = 20;
+#elif (MD5_SSE_PARA==6)
+		pFmt->params.algorithm_name = "SSE2 1x4x6 (intr)";
+		pFmt->params.max_keys_per_crypt = 24;
+#else
+		pFmt->params.algorithm_name = "SSE2 4x4 (.S)";
+#endif
+#else
+		// In non-sse mode, 1 test runs as fast as 128. But validity checking is MUCH faster if
+		// we leave it at only 1.
+		pFmt->params.max_keys_per_crypt = 1;
+#if MD5_X2
+		pFmt->params.max_keys_per_crypt = 2;
+		pFmt->params.algorithm_name = "2x1 (MD5_body)";
+#else
+		pFmt->params.algorithm_name = "1x1 (MD5_body)";
+#endif
+#endif
+		pFmt->params.min_keys_per_crypt = 1;
+		saltlen = 8;
+		// no reason to run double tests. The 1 salt vs MANY salts is the
+		// same speed, so why double the benchmark time for no reason.
+		pFmt->params.benchmark_length = -1;
+	}
+
+	if ((Setup->startFlags) == 0)
+	{
+		// Ok, if we do not have some 'special' loader function, we MUST first clean some
+		// input.  If that is not done, there is NO WAY this is a valid format.  This is
+		// NOT an intelligent check, but more like the dummy lights on newer automobiles.
+		// You know it will not work, but do not know 'why', nor should you care.
+		if (Setup->pFuncs[0] != MD5GenBaseFunc__clean_input &&
+			Setup->pFuncs[0] != MD5GenBaseFunc__clean_input2 &&
+			Setup->pFuncs[0] != MD5GenBaseFunc__clean_input_kwik &&
+			Setup->pFuncs[0] != MD5GenBaseFunc__clean_input2_kwik &&
+			Setup->pFuncs[0] != MD5GenBaseFunc__clean_input_full)
+			return !!fprintf(stderr, "Invalid format.  The first command MUST be a clean of input 1 or input 2\nOR a special key 2 input loader function\n");
+	}
+	if ( (Setup->flags&MGF_SALTED2)==MGF_SALTED2 && (Setup->flags&MGF_SALT_AS_HEX) == MGF_SALT_AS_HEX)
+	{
+		// if the user wants salt_as_hex, then here can NOT be 2 salts.
+			return !!fprintf(stderr, "Invalid format.  If using MGF_SALT_AS_HEX flag, then you can NOT have a 2nd salt.\n");
+	}
+
+	if (Setup->pFuncs && Setup->pFuncs[0])
+	{
+		int z;
+		for (z = 0; Setup->pFuncs[z]; ++z)
+			;
+		z += 50;
+		curdat.md5_gen_FUNCTIONS = mem_alloc_tiny(z*sizeof(MD5_GEN_primitive_funcp), MEM_ALIGN_WORD);
+
+		j = 0;
+#if !ARCH_LITTLE_ENDIAN
+		// for bigendian, we do NOT store into keys, since we byte swap them.
+
+		if (curdat.store_keys_in_input==1) {
+			// this is only a minor speed hit, so simply fix by doing this.  There is an
+			// extra memcpy, that is it.
+			curdat.store_keys_in_input = 0;
+			curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__clean_input;
+			curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__append_keys;
+		}
+
+		// NOTE NOTE NOTE, FIXME.  These are 'hacks' which slow stuff way down.  We should look at
+		// building preloads that CAN do this. Store key input to input 1, but then do not use
+		// input 1.  Put a copy to input 2, then append, etc.   In that way, we cut the number of
+		// MD5's down by at least 1.
+		//
+		// But for now, just get it working.  Get it working faster later.
+
+		// note, with Setup->pFuncs[0]==MD5GenBaseFunc__set_input_len_32, we only will handle type 6 and 7
+		// for now we have this 'turned' off.  It is fixed for type 6, 7 and 14.  It is left on for the
+		// john.ini stuff.  Thus, if someone builds the intel version type 6, it will work (but slower).
+		if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1==1 && Setup->pFuncs[0]==MD5GenBaseFunc__set_input_len_32) {
+			curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1 = 0;
+			curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__clean_input;
+			curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__append_keys;
+			curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__crypt;
+			curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__clean_input;
+			Setup->pFuncs[0] = MD5GenBaseFunc__append_from_last_output_as_base16;
+		}
+
+//			if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1)
+//			{
+//				if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1==2)
+//					MD5GenBaseFunc__SSEtoX86_switch_output2();
+//				MD5GenBaseFunc__clean_input();
+//				MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16();
+//			}
+//			if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32)
+//			{
+//#ifndef MMX_COEF
+//				if (curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1_offset32==2)
+//#endif
+//					MD5GenBaseFunc__SSEtoX86_switch_output2();
+//				MD5GenBaseFunc__clean_input();
+//				MD5GenBaseFunc__set_input_len_32();
+//				MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16();
+//			}
+#endif
+#ifdef SHA1_SSE_PARA
+	if (Setup->startFlags&MGF_RAW_SHA1_INPUT)
+	{
+		if(curdat.md5_gen_use_sse != 0) {
+			curdat.md5_gen_use_sse = 3;  // if 2, then we are in SSE2 mode, but currently using X86 (and can switch back to SSE2).
+			curdat.md5_startup_in_x86 = 1;
+			curdat.store_keys_in_input = 0;
+			if (Setup->pFuncs[0]==MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL) {
+				curdat.store_keys_normal_but_precompute_md5_to_output2_base16_to_input1 = 0;
+				curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__clean_input;
+				curdat.md5_gen_FUNCTIONS[j++] = MD5GenBaseFunc__append_keys;
+			}
+		}
+	}
+#endif
+
+		for (i=0; Setup->pFuncs[i]; ++i)
+		{
+			if (j > z-10)
+			{
+				int k;
+				z += 100;
+				curdat.md5_gen_FUNCTIONS = mem_alloc_tiny(z*sizeof(MD5_GEN_primitive_funcp), MEM_ALIGN_WORD);
+				for (k = 0; k <= j; ++k)
+					curdat.md5_gen_FUNCTIONS[k] = curdat.md5_gen_FUNCTIONS[k];
+			}
+			if (curdat.store_keys_in_input)
+			{
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__append_keys)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but append_keys called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__append_keys2)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but append_keys2 called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__clean_input)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but clean_input called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__append_salt)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but append_salt called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but append_from_last_output2_to_input1_as_base16 called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but overwrite_from_last_output2_to_input1_as_base16_no_size_fix called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__append_from_last_output_as_base16)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but append_from_last_output_as_base16s called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but overwrite_from_last_output_as_base16_no_size_fix called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__append_2nd_salt)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but append_2nd_salt called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__set_input_len_32)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but MD5GenBaseFunc__set_input_len_32 called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__set_input_len_64)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but MD5GenBaseFunc__set_input_len_32 called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but MD5GenBaseFunc__set_input_len_32 called and that is invalid\n");
+				if (Setup->pFuncs[i] == MD5GenBaseFunc__append_input_from_input2)
+					return !!fprintf(stderr, "MGF_KEYS_INPUT used, but MD5GenBaseFunc__set_input_len_32 called and that is invalid\n");
+			}
+			// Ok if copy constants are set, make SURE we have that many constants.
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST1 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST1) && curdat.nConsts == 0)
+				return !!fprintf(stderr, "Append Constant function called, but NO constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST2 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST2) && curdat.nConsts < 2)
+				return !!fprintf(stderr, "Append Constant #2 function called, but NO constants, or less than 2 constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST3 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST3) && curdat.nConsts < 3)
+				return !!fprintf(stderr, "Append Constant #3 function called, but NO constants, or less than 3 constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST4 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST4) && curdat.nConsts < 4)
+				return !!fprintf(stderr, "Append Constant #4 function called, but NO constants, or less than 4 constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST5 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST5) && curdat.nConsts < 5)
+				return !!fprintf(stderr, "Append Constant #5 function called, but NO constants, or less than 5 constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST6 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST6) && curdat.nConsts < 6)
+				return !!fprintf(stderr, "Append Constant #6 function called, but NO constants, or less than 6 constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST7 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST7) && curdat.nConsts < 7)
+				return !!fprintf(stderr, "Append Constant #7 function called, but NO constants, or less than 7 constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_input1_from_CONST8 || Setup->pFuncs[i] == MD5GenBaseFunc__append_input2_from_CONST8) && curdat.nConsts < 8)
+				return !!fprintf(stderr, "Append Constant #8 function called, but NO constants, or less than 8 constants in the format\n");
+			if ( (Setup->pFuncs[i] == MD5GenBaseFunc__append_2nd_salt || Setup->pFuncs[i] == MD5GenBaseFunc__append_2nd_salt2) && curdat.b2Salts == 0)
+				return !!fprintf(stderr, "A call to one of the 'salt-2' functions, but this format does not have MFG_SALT2 flag set\n");
+
+			// Ok, if we have made it here, the function is 'currently' still valid.  Load this pointer into our array of pointers.
+			pFuncs = ConvertFuncs(Setup->pFuncs[i], &cnt2);
+			for (x = 0; x < cnt2; ++x)
+				curdat.md5_gen_FUNCTIONS[j++] = pFuncs[x];
+
+			if (curdat.md5_gen_FUNCTIONS[j-1] == MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL ||
+				curdat.md5_gen_FUNCTIONS[j-1] == MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL)
+			{
+				if (Setup->pFuncs[i+1])
+					return !!fprintf(stderr, "MD5GenBaseFunc__SHA1_crypt_inputX_to_output1_FINAL, can ONLY be used as the last function in a script\n");
+			}
+		}
+		curdat.md5_gen_FUNCTIONS[j] = NULL;
+	}
+	if (!Setup->pPreloads || Setup->pPreloads[0].ciphertext == NULL)
+	{
+		return !!fprintf(stderr, "Error, no validation hash(s) for this format\n");
+	}
+	cnt = 0;
+
+	{
+		struct fmt_tests *pfx = mem_alloc_tiny(ARRAY_COUNT(md5_gen_tests) * sizeof (struct fmt_tests), MEM_ALIGN_WORD);
+		memset(pfx, 0, ARRAY_COUNT(md5_gen_tests) * sizeof (struct fmt_tests));
+
+		for (i = 0; cnt < ARRAY_COUNT(md5_gen_tests) -1; ++i, ++cnt)
+		{
+			if (Setup->pPreloads[i].ciphertext == NULL) {
+				if (Setup->startFlags&MGF_PHPassSetup || Setup->startFlags&MGF_FreeBSDMD5Setup)
+					// for phpass, do not load ANY more than the 9 that are in the preload.
+					// loading more will simply slow down the validation code loop at startup.
+					break;
+				i = 0;
+			}
+			pfx[cnt].ciphertext = str_alloc_copy(Setup->pPreloads[i].ciphertext);
+			pfx[cnt].plaintext = str_alloc_copy(Setup->pPreloads[i].plaintext);
+			for (j = 0; j < 10; ++j)
+				pfx[cnt].flds[j] = Setup->pPreloads[i].flds[j]  ? str_alloc_copy(Setup->pPreloads[i].flds[j]) : "";
+		}
+		pfx[cnt].ciphertext = NULL;
+		pfx[cnt].plaintext = NULL;
+
+		pFmt->params.tests = pfx;
+	}
+
+	if (curdat.md5_gen_base16_upcase)
+		md5gen_itoa16 = itoa16_up;
+	else
+		md5gen_itoa16 = itoa16;
+
+	return 1;
+}
+
+static int LoadOneFormat(int idx, struct fmt_main *pFmt)
+{
+	extern struct options_main options;
+	char label[40];
+	memcpy(pFmt, &fmt_MD5gen, sizeof(struct fmt_main));
+	md5_gen_RESET(pFmt);
+	sprintf(label, "md5_gen(%d)", idx);
+
+	if (!options.format || strncmp(options.format, "md5_gen(", 8))
+		pFmt->params.label = str_alloc_copy("md5-gen");
+	else
+		pFmt->params.label = str_alloc_copy(label);
+
+	if (idx < 1000) {
+		if (md5_gen_RESERVED_PRELOAD_SETUP(idx, pFmt) != 1)
+			return 0;
+	}
+	else {
+		if (md5_gen_LOAD_PARSER_FUNCTIONS(idx, pFmt) != 1)
+			return 0;
+	}
+
+	strcpy(curdat.md5_gen_WHICH_TYPE_SIG, label);
+
+	curdat.md5_gen_HASH_OFFSET = strlen(label);
+
+	if (curdat.md5_gen_base64_inout == 1)
+		curdat.md5_gen_SALT_OFFSET = curdat.md5_gen_HASH_OFFSET + 22 + 1;
+	else if (curdat.md5_gen_base64_inout == 2)
+		curdat.md5_gen_SALT_OFFSET = curdat.md5_gen_HASH_OFFSET + 16 + 1;
+	else if (curdat.md5_gen_40_byte_sha1)
+		curdat.md5_gen_SALT_OFFSET = curdat.md5_gen_HASH_OFFSET + 40 + 1;
+	else
+		curdat.md5_gen_SALT_OFFSET = curdat.md5_gen_HASH_OFFSET + 32 + 1;
+
+	pFmt->private.data = mem_alloc_tiny(sizeof(private_subformat_data), MEM_ALIGN_WORD);
+	memcpy(pFmt->private.data, &curdat, sizeof(private_subformat_data));
+
+	return 1;
+}
+
+int md5_gen_Register_formats(struct fmt_main **ptr)
+{
+	int count, i, idx, single=-1;
+	extern struct options_main options;
+
+#ifdef MMX_COEF
+		__SSE_Load_itoa16_w2();
+#endif
+	if (options.format && !strncmp(options.format, "md5_gen(", 8))
+		sscanf(options.format, "md5_gen(%d)", &single);
+	if (options.format && options.subformat  && !strcmp(options.format, "md5-gen") && !strncmp(options.subformat, "md5_gen(", 8))
+		sscanf(options.subformat, "md5_gen(%d)", &single);
+
+	if (single != -1) {
+		// user wanted only a 'specific' format.  Simply load that one.
+		m_allow_rawhash_fixup = 1;
+		if (md5_gen_IS_VALID(single) == 0)
+			return 0;
+		pFmts = mem_alloc_tiny(sizeof(pFmts[0]), MEM_ALIGN_WORD);
+		if (!LoadOneFormat(single, pFmts))
+			return 0;
+		*ptr = pFmts;
+		return (nFmts = 1);
+	}
+
+	for (count = i = 0; i < 5000; ++i) {
+		if (md5_gen_IS_VALID(i) == 1)
+			++count;
+	}
+	// Ok, now we know how many formats we have.  Load them
+	pFmts = mem_alloc_tiny(sizeof(pFmts[0])*count, MEM_ALIGN_WORD);
+	for (idx = i = 0; i < 5000; ++i) {
+		if (md5_gen_IS_VALID(i) == 1) {
+			if (LoadOneFormat(i, &pFmts[idx]) == 0)
+				--count;
+			else
+				++idx;
+		}
+	}
+	*ptr = pFmts;
+	return (nFmts = count);
+}
+
+/*
+ * finds the 'proper' sub format from the allocated formats, IFF that format 'exists'
+ */
+static struct fmt_main *md5_gen_Get_fmt_main(int which)
+{
+	char label[40];
+	int i;
+
+	sprintf(label, "md5_gen(%d)", which);
+	for (i = 0; i < nFmts; ++i) {
+		private_subformat_data *pPriv = pFmts[i].private.data;
+		if (!strcmp(pPriv->md5_gen_WHICH_TYPE_SIG, label))
+			return &pFmts[i];
+	}
+	return NULL;
+}
+
+/*
+ * This function will 'forget' which md5-gen subtype we are working with. It will allow
+ * a different type to be used.  Very useful for things like -test (benchmarking).
+ */
+void md5_gen_RESET(struct fmt_main *fmt)
+{
+	memset(&curdat, 0, sizeof(curdat));
+	m_count = 0;
+	keys_dirty = 0;
+	memset(cursalt, 0, sizeof(cursalt));
+	saltlen = 0;
+	memset(cursalt2, 0, sizeof(cursalt2));
+	saltlen2 = 0;
+	memset(username, 0, sizeof(username));
+	usernamelen = 0;
+	// make 'sure' we startout with blank inputs.
+	m_count = 0;
+	MD5GenBaseFunc__clean_input_full();
+	MD5GenBaseFunc__clean_input2_full();
+}
+
+/*
+ * This will LINK our functions into some other fmt_main struction. That way
+ * that struction can use our code.  The other *_fmt.c file will need to
+ * 'override' the valid, the binary and the salt functions, and make changes
+ * to the hash, BEFORE calling into the md5_gen valid/binary/salt functions.
+ * Other than those functions (and calling into this linkage function at init time)
+ * that is about all that needs to be in that 'other' *_fmt.c file, as long as the
+ * format is part of the md5-generic 'class' of functions.
+ */
+
+struct fmt_main *md5_gen_THIN_FORMAT_LINK(struct fmt_main *pFmt, char *ciphertext, char *orig_sig)
+{
+	int i, valid, nFmtNum;
+	struct fmt_main *pFmtLocal;
+	static char subformat[17], *cp;
+	strncpy(subformat, ciphertext, 16);
+	subformat[16] = 0;
+	cp = strchr(subformat, ')');
+	if (cp)
+		cp[1] = 0;
+
+	nFmtNum = -1;
+	sscanf(subformat, "md5_gen(%d)", &nFmtNum);
+	if (nFmtNum==-1)
+		exit(fprintf(stderr, "Error, Invalid signature line trying to link to md5-gen.\nOriginal format=%s\nSignature line=%s\n", orig_sig, ciphertext));
+
+	pFmtLocal = md5_gen_Get_fmt_main(nFmtNum);
+	if (pFmtLocal == NULL) {
+		exit(fprintf(stderr, "Error, Invalid signature line trying to link to md5-gen.\nOriginal format=%s\nSignature line=%s\n", orig_sig, ciphertext));
+	}
+
+	valid = pFmtLocal->methods.valid(ciphertext, pFmtLocal);
+	if (!valid)
+		exit(fprintf(stderr, "Error, trying to link to %s using ciphertext=%s FAILED\n", subformat, ciphertext));
+
+	printf ("Using %s mode, by linking to %s functions", orig_sig, subformat);
+	// If benchmarking, simply add a space.  If not, then add a newline.
+	if (options.flags & FLG_TEST_CHK)
+		printf (" ");
+	else
+		printf ("\n");
+
+	pFmt->params.max_keys_per_crypt = pFmtLocal->params.max_keys_per_crypt;
+	pFmt->params.min_keys_per_crypt = pFmtLocal->params.min_keys_per_crypt;
+	pFmt->methods.cmp_all    = pFmtLocal->methods.cmp_all;
+	pFmt->methods.cmp_one    = pFmtLocal->methods.cmp_one;
+	pFmt->methods.cmp_exact  = pFmtLocal->methods.cmp_exact;
+	pFmt->methods.set_salt   = pFmtLocal->methods.set_salt;
+	pFmt->methods.salt       = pFmtLocal->methods.salt;
+	pFmt->methods.salt_hash  = pFmtLocal->methods.salt_hash;
+	pFmt->methods.split      = pFmtLocal->methods.split;
+	pFmt->methods.set_key    = pFmtLocal->methods.set_key;
+	pFmt->methods.get_key    = pFmtLocal->methods.get_key;
+	pFmt->methods.clear_keys = pFmtLocal->methods.clear_keys;
+	pFmt->methods.crypt_all  = pFmtLocal->methods.crypt_all;
+	for (i = 0; i < 5; ++i)
+	{
+		pFmt->methods.binary_hash[i] = pFmtLocal->methods.binary_hash[i];
+		pFmt->methods.get_hash[i]    = pFmtLocal->methods.get_hash[i];
+	}
+
+	init(pFmtLocal);
+
+	return pFmtLocal;
+}
+
+static char *FixupIfNeeded(char *ciphertext, private_subformat_data *pPriv)
+{
+	if (!ciphertext || *ciphertext == 0 || *ciphertext == '*')
+		return ciphertext;
+	if (m_allow_rawhash_fixup && strncmp(ciphertext, "md5_gen(", 8))
+	{
+		static char __ciphertext[512+24];
+		strcpy(__ciphertext, pPriv->md5_gen_WHICH_TYPE_SIG);
+		strnzcpy(&__ciphertext[strlen(__ciphertext)], ciphertext, 512);
+		return __ciphertext;
+	}
+	return ciphertext;
+}
+
+// if caseType == 1, return cp
+// if caseType == 2, return upcase(cp)
+// if caseType == 3, return locase(cp)
+// if caseType == 4, return upcaseFirstChar(locase(cp))
+static char *HandleCase(char *cp, int caseType)
+{
+	char *tmp;
+	int offset;
+	if (caseType==1)
+		return cp;
+	tmp = str_alloc_copy(cp);
+	cp = tmp;
+	offset = 'a'-'A';
+	if (caseType == 2)
+		offset = -offset;
+	while (*cp)
+	{
+		if (*cp >= 'a' && *cp <= 'z')
+			*cp += offset;
+		++cp;
+	}
+	if (caseType==4 && *tmp >= 'a' && *tmp <= 'z')
+		*tmp -= offset;
+	return tmp;
+}
diff -rupN john-1.7.8/src/md5_gen_parser.c john-1.7.8-jumbo-2/src/md5_gen_parser.c
--- john-1.7.8/src/md5_gen_parser.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_gen_parser.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,499 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Generic MD5 hashes cracker
+ *
+ * This file implements code that allows 'dynamic' building of
+ * generic MD5 functions.  john.conf is used to store the 'script'
+ * and supporting data (like the expression, or 'flags' needed to
+ * make the format work).
+ *
+ * To make this work, you simply add a "section" to the john.conf
+ * file of this format:
+ *
+ *  [List.Generic:md5_gen(NUM)]
+ *
+ * Num has to be replaced with a number, greater than 1000, since
+ * md5_gen(0) to md5_gen(1000) are reserved for 'built-in' and any
+ * user defined md5_gen(#) functions need to start at 1001 or more.
+ *
+ * Then under the new section, add the script.  There are 2 required
+ * data types, and 2 optional.  The required are a list of Func=
+ * and a list of Test=    Then there is an optional Expression=
+ * and an optional list of Flag= items.
+ *
+ * Here is an example, showing processing for md5(md5(md5(md5($p))))
+ *
+ * [List.Generic:md5_gen(1001)]
+ * Expression=md5(md5(md5(md5($p))))
+ * Flag=MGF_KEYS_INPUT
+ * Func=MD5GenBaseFunc__crypt
+ * Func=MD5GenBaseFunc__clean_input2
+ * Func=MD5GenBaseFunc__append_from_last_output_to_input2_as_base16
+ * Func=MD5GenBaseFunc__crypt2
+ * Func=MD5GenBaseFunc__clean_input2_kwik
+ * Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+ * Func=MD5GenBaseFunc__crypt2
+ * Func=MD5GenBaseFunc__clean_input2_kwik
+ * Func=MD5GenBaseFunc__append_from_last_output2_as_base16
+ * Func=MD5GenBaseFunc__crypt_in2_to_out1
+ * Test=md5_gen(1001)57200e13b490d4ae47d5e19be026b057:test1
+ * Test=md5_gen(1001)c6cc44f9e7fb7efcde62ba2e627a49c6:thatsworking
+ * Test=md5_gen(1001)0ae9549604e539a249c1fa9f5e5fb73b:test3
+ *
+ */
+
+#include <string.h>
+#include <ctype.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "config.h"
+#include "md5.h"
+#include "loader.h"
+#include "options.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
+
+#define DEFINE_MD5_PREDICATE_POINTERS
+#include "md5_gen.h"
+
+typedef struct MD5Gen_Predicate_t
+{
+	char *name;
+	void(*func)();
+} MD5Gen_Predicate_t;
+
+typedef struct MD5Gen_Str_Flag_t
+{
+	char *name;
+	unsigned flag_bit;
+} MD5Gen_Str_Flag_t;
+
+
+static MD5Gen_Predicate_t MD5Gen_Predicate[] =  {
+	{ "MD5GenBaseFunc__clean_input",  MD5GenBaseFunc__clean_input },
+	{ "MD5GenBaseFunc__clean_input_kwik", MD5GenBaseFunc__clean_input_kwik },
+	{ "MD5GenBaseFunc__clean_input_full", MD5GenBaseFunc__clean_input_full },
+	{ "MD5GenBaseFunc__append_keys", MD5GenBaseFunc__append_keys },
+	{ "MD5GenBaseFunc__crypt", MD5GenBaseFunc__crypt },
+	{ "MD5GenBaseFunc__append_from_last_output_as_base16", MD5GenBaseFunc__append_from_last_output_as_base16 },
+	{ "MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix", MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix },
+	{ "MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen_but_setlen_in_SSE", MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen_but_setlen_in_SSE },
+	{ "MD5GenBaseFunc__append_salt", MD5GenBaseFunc__append_salt },
+	{ "MD5GenBaseFunc__set_input_len_32", MD5GenBaseFunc__set_input_len_32 },
+	{ "MD5GenBaseFunc__clean_input2", MD5GenBaseFunc__clean_input2 },
+	{ "MD5GenBaseFunc__clean_input2_kwik", MD5GenBaseFunc__clean_input2_kwik },
+	{ "MD5GenBaseFunc__clean_input2_full", MD5GenBaseFunc__clean_input2_full },
+	{ "MD5GenBaseFunc__append_keys2", MD5GenBaseFunc__append_keys2 },
+	{ "MD5GenBaseFunc__crypt2", MD5GenBaseFunc__crypt2 },
+	{ "MD5GenBaseFunc__append_from_last_output2_as_base16", MD5GenBaseFunc__append_from_last_output2_as_base16 },
+	{ "MD5GenBaseFunc__overwrite_from_last_output2_as_base16_no_size_fix", MD5GenBaseFunc__overwrite_from_last_output2_as_base16_no_size_fix },
+	{ "MD5GenBaseFunc__append_from_last_output_to_input2_as_base16", MD5GenBaseFunc__append_from_last_output_to_input2_as_base16 },
+	{ "MD5GenBaseFunc__overwrite_from_last_output_to_input2_as_base16_no_size_fix", MD5GenBaseFunc__overwrite_from_last_output_to_input2_as_base16_no_size_fix },
+	{ "MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16", MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16 },
+	{ "MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix", MD5GenBaseFunc__overwrite_from_last_output2_to_input1_as_base16_no_size_fix },
+	{ "MD5GenBaseFunc__append_salt2", MD5GenBaseFunc__append_salt2 },
+	{ "MD5GenBaseFunc__set_input2_len_32", MD5GenBaseFunc__set_input2_len_32 },
+	{ "MD5GenBaseFunc__append_input_from_input2", MD5GenBaseFunc__append_input_from_input2 },
+	{ "MD5GenBaseFunc__append_input2_from_input", MD5GenBaseFunc__append_input2_from_input },
+	{ "MD5GenBaseFunc__append_2nd_salt", MD5GenBaseFunc__append_2nd_salt },
+	{ "MD5GenBaseFunc__append_2nd_salt2", MD5GenBaseFunc__append_2nd_salt2 },
+	{ "MD5GenBaseFunc__append_userid", MD5GenBaseFunc__append_userid },
+	{ "MD5GenBaseFunc__append_userid2", MD5GenBaseFunc__append_userid2 },
+	{ "MD5GenBaseFunc__crypt_in1_to_out2", MD5GenBaseFunc__crypt_in1_to_out2 },
+	{ "MD5GenBaseFunc__crypt_in2_to_out1", MD5GenBaseFunc__crypt_in2_to_out1 },
+	{ "MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen", MD5GenBaseFunc__crypt_to_input_raw_Overwrite_NoLen },
+	{ "MD5GenBaseFunc__crypt_to_input_raw", MD5GenBaseFunc__crypt_to_input_raw },
+	{ "MD5GenBaseFunc__PHPassCrypt", MD5GenBaseFunc__PHPassCrypt },
+	{ "MD5GenBaseFunc__FreeBSDMD5Crypt", MD5GenBaseFunc__FreeBSDMD5Crypt },
+	{ "MD5GenBaseFunc__POCrypt", MD5GenBaseFunc__POCrypt },
+	{ "MD5GenBaseFunc__set_input_len_16", MD5GenBaseFunc__set_input_len_16},
+	{ "MD5GenBaseFunc__set_input2_len_16", MD5GenBaseFunc__set_input2_len_16},
+	{ "MD5GenBaseFunc__set_input_len_64", MD5GenBaseFunc__set_input_len_64 },
+	{ "MD5GenBaseFunc__set_input2_len_64", MD5GenBaseFunc__set_input2_len_64 },
+	{ "MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix", MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix },
+	{ "MD5GenBaseFunc__overwrite_salt_to_input2_no_size_fix", MD5GenBaseFunc__overwrite_salt_to_input2_no_size_fix },
+	{ "MD5GenBaseFunc__append_input1_from_CONST1", MD5GenBaseFunc__append_input1_from_CONST1 },
+	{ "MD5GenBaseFunc__append_input1_from_CONST2", MD5GenBaseFunc__append_input1_from_CONST2 },
+	{ "MD5GenBaseFunc__append_input1_from_CONST3", MD5GenBaseFunc__append_input1_from_CONST3 },
+	{ "MD5GenBaseFunc__append_input1_from_CONST4", MD5GenBaseFunc__append_input1_from_CONST4 },
+	{ "MD5GenBaseFunc__append_input1_from_CONST5", MD5GenBaseFunc__append_input1_from_CONST5 },
+	{ "MD5GenBaseFunc__append_input1_from_CONST6", MD5GenBaseFunc__append_input1_from_CONST6 },
+	{ "MD5GenBaseFunc__append_input1_from_CONST7", MD5GenBaseFunc__append_input1_from_CONST7 },
+	{ "MD5GenBaseFunc__append_input1_from_CONST8", MD5GenBaseFunc__append_input1_from_CONST8 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST1", MD5GenBaseFunc__append_input2_from_CONST1 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST2", MD5GenBaseFunc__append_input2_from_CONST2 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST3", MD5GenBaseFunc__append_input2_from_CONST3 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST4", MD5GenBaseFunc__append_input2_from_CONST4 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST5", MD5GenBaseFunc__append_input2_from_CONST5 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST6", MD5GenBaseFunc__append_input2_from_CONST6 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST7", MD5GenBaseFunc__append_input2_from_CONST7 },
+	{ "MD5GenBaseFunc__append_input2_from_CONST8", MD5GenBaseFunc__append_input2_from_CONST8 },
+	{ "MD5GenBaseFunc__SSEtoX86_switch_input1", MD5GenBaseFunc__SSEtoX86_switch_input1 },
+	{ "MD5GenBaseFunc__SSEtoX86_switch_input2", MD5GenBaseFunc__SSEtoX86_switch_input2 },
+	{ "MD5GenBaseFunc__SSEtoX86_switch_output1", MD5GenBaseFunc__SSEtoX86_switch_output1 },
+	{ "MD5GenBaseFunc__SSEtoX86_switch_output2", MD5GenBaseFunc__SSEtoX86_switch_output2 },
+	{ "MD5GenBaseFunc__X86toSSE_switch_input1", MD5GenBaseFunc__X86toSSE_switch_input1 },
+	{ "MD5GenBaseFunc__X86toSSE_switch_input2", MD5GenBaseFunc__X86toSSE_switch_input2 },
+	{ "MD5GenBaseFunc__X86toSSE_switch_output1", MD5GenBaseFunc__X86toSSE_switch_output1 },
+	{ "MD5GenBaseFunc__X86toSSE_switch_output2", MD5GenBaseFunc__X86toSSE_switch_output2 },
+	{ "MD5GenBaseFunc__ToSSE", MD5GenBaseFunc__ToSSE },
+	{ "MD5GenBaseFunc__ToX86", MD5GenBaseFunc__ToX86 },
+	{ "MD5GenBaseFunc__setmode_unicode", MD5GenBaseFunc__setmode_unicode },
+	{ "MD5GenBaseFunc__setmode_normal", MD5GenBaseFunc__setmode_normal },
+	{ "MD5GenBaseFunc__base16_convert_locase", MD5GenBaseFunc__base16_convert_locase },
+	{ "MD5GenBaseFunc__base16_convert_upcase", MD5GenBaseFunc__base16_convert_upcase },
+	{ "MD5GenBaseFunc__append_fld0", MD5GenBaseFunc__append_fld0 },
+	{ "MD5GenBaseFunc__append_fld1", MD5GenBaseFunc__append_fld1 },
+	{ "MD5GenBaseFunc__append_fld2", MD5GenBaseFunc__append_fld2 },
+	{ "MD5GenBaseFunc__append_fld3", MD5GenBaseFunc__append_fld3 },
+	{ "MD5GenBaseFunc__append_fld4", MD5GenBaseFunc__append_fld4 },
+	{ "MD5GenBaseFunc__append_fld5", MD5GenBaseFunc__append_fld5 },
+	{ "MD5GenBaseFunc__append_fld6", MD5GenBaseFunc__append_fld6 },
+	{ "MD5GenBaseFunc__append_fld7", MD5GenBaseFunc__append_fld7 },
+	{ "MD5GenBaseFunc__append_fld8", MD5GenBaseFunc__append_fld8 },
+	{ "MD5GenBaseFunc__append_fld9", MD5GenBaseFunc__append_fld9 },
+	{ "MD5GenBaseFunc__append2_fld0", MD5GenBaseFunc__append2_fld0 },
+	{ "MD5GenBaseFunc__append2_fld1", MD5GenBaseFunc__append2_fld1 },
+	{ "MD5GenBaseFunc__append2_fld2", MD5GenBaseFunc__append2_fld2 },
+	{ "MD5GenBaseFunc__append2_fld3", MD5GenBaseFunc__append2_fld3 },
+	{ "MD5GenBaseFunc__append2_fld4", MD5GenBaseFunc__append2_fld4 },
+	{ "MD5GenBaseFunc__append2_fld5", MD5GenBaseFunc__append2_fld5 },
+	{ "MD5GenBaseFunc__append2_fld6", MD5GenBaseFunc__append2_fld6 },
+	{ "MD5GenBaseFunc__append2_fld7", MD5GenBaseFunc__append2_fld7 },
+	{ "MD5GenBaseFunc__append2_fld8", MD5GenBaseFunc__append2_fld8 },
+	{ "MD5GenBaseFunc__append2_fld9", MD5GenBaseFunc__append2_fld9 },
+	{ "MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16", MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16 },
+	{ "MD5GenBaseFunc__SHA1_crypt_input2_append_input1_base16", MD5GenBaseFunc__SHA1_crypt_input2_append_input1_base16 },
+	{ "MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input1_base16", MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input1_base16 },
+	{ "MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16", MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input2_base16 },
+	{ "MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input2_base16", MD5GenBaseFunc__SHA1_crypt_input1_overwrite_input2_base16 },
+	{ "MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input1_base16", MD5GenBaseFunc__SHA1_crypt_input2_overwrite_input1_base16 },
+	{ "MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL", MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL },
+	{ "MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL", MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL },
+
+	// Depricated.  They are still 'here', but in md5_gen_fmt.c md5_gen_SETUP() they get converted properly into
+	// flags.  Also, they do not get loaded into the 'script'.  NOTE, these were magic functions before. They
+	// had to be the first function of the script.  That is still the same way.  If they are first, they do not
+	// get loaded, and they get properly converted to flag bits.
+	{ "MD5GenBaseFunc__PHPassSetup", MD5GenBaseFunc__PHPassSetup },
+	{ "MD5GenBaseFunc__InitialLoadKeysToInput", MD5GenBaseFunc__InitialLoadKeysToInput },
+	{ "MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2", MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2 },
+	{ "MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1", MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1 },
+	{ "MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1_offset32", MD5GenBaseFunc__InitialLoadKeys_md5crypt_ToOutput2_Base16_to_Input1_offset32 },
+
+	{ NULL, NULL }};
+
+static MD5Gen_Str_Flag_t MD5Gen_Str_Flag[] =  {
+	{ "MGF_NOTSSE2Safe",                  MGF_NOTSSE2Safe },
+	{ "MGF_StartInX86Mode",               MGF_StartInX86Mode },
+	{ "MGF_ColonNOTValid",                MGF_ColonNOTValid },
+	{ "MGF_SALTED",                       MGF_SALTED },
+	{ "MGF_SALTED2",                      MGF_SALTED2 },
+	{ "MGF_USERNAME",                     MGF_USERNAME },
+	{ "MGF_USERNAME_UPCASE",              MGF_USERNAME_UPCASE },
+	{ "MGF_USERNAME_LOCASE",              MGF_USERNAME_LOCASE },
+	{ "MGF_INPBASE64",                    MGF_INPBASE64 },
+	{ "MGF_INPBASE64a",                   MGF_INPBASE64a },
+	{ "MGF_SALT_AS_HEX",                  MGF_SALT_AS_HEX },
+	{ "MFG_SALT_AS_HEX",                  MGF_SALT_AS_HEX },  // Deprecated misspelling
+	{ "MGF_SALT_AS_HEX_TO_SALT2",         MGF_SALT_AS_HEX_TO_SALT2 },
+	{ "MGF_INPBASE64_4x6",				  MGF_INPBASE64_4x6 },
+	{ "MGF_SALT_UNICODE_B4_CRYPT",        MGF_SALT_UNICODE_B4_CRYPT },
+	{ "MGF_BASE_16_OUTPUT_UPCASE",        MGF_BASE_16_OUTPUT_UPCASE },
+	{ "MGF_HDAA_SALT",                    MGF_HDAA_SALT },
+	{ "MGF_FLD0",                         MGF_FLD0 },
+	{ "MGF_FLD1",                         MGF_FLD1 },
+	{ "MGF_FLD2",                         MGF_FLD2 },
+	{ "MGF_FLD3",                         MGF_FLD3 },
+	{ "MGF_FLD4",                         MGF_FLD4 },
+	{ "MGF_FLD5",                         MGF_FLD5 },
+	{ "MGF_FLD6",                         MGF_FLD6 },
+	{ "MGF_FLD7",                         MGF_FLD7 },
+	{ "MGF_FLD8",                         MGF_FLD8 },
+	{ "MGF_FLD9",                         MGF_FLD9 },
+	{ "MGF_SHA1_40_BYTE_FINISH",          MGF_SHA1_40_BYTE_FINISH },
+	{ NULL, 0 }};
+
+static MD5Gen_Str_Flag_t MD5Gen_Str_sFlag[] =  {
+	{ "MGF_KEYS_INPUT",                   MGF_KEYS_INPUT },
+	{ "MGF_KEYS_CRYPT_IN2",               MGF_KEYS_CRYPT_IN2 },
+	{ "MGF_KEYS_BASE16_IN1",              MGF_KEYS_BASE16_IN1 },
+	{ "MGF_KEYS_BASE16_X86_IN1",          MGF_KEYS_BASE16_X86_IN1 },
+	{ "MGF_KEYS_BASE16_IN1_Offset32",     MGF_KEYS_BASE16_IN1_Offset32 },
+	{ "MGF_KEYS_BASE16_X86_IN1_Offset32", MGF_KEYS_BASE16_X86_IN1_Offset32 },
+	{ "MGF_KEYS_UNICODE_B4_CRYPT",        MGF_KEYS_UNICODE_B4_CRYPT },
+	{ "MGF_PHPassSetup",                  MGF_PHPassSetup },
+	{ "MGF_POSetup",                      MGF_POSetup },
+	{ "MGF_FreeBSDMD5Setup",              MGF_FreeBSDMD5Setup },
+	{ "MGF_RAW_SHA1_INPUT",               MGF_RAW_SHA1_INPUT },
+	{ "MGF_KEYS_INPUT_BE_SAFE",           MGF_KEYS_INPUT_BE_SAFE },  // big endian safe, i.e. the input will NEVER get swapped.  Only SHA1 is 'safe'.
+	{ NULL, 0 }};
+
+static MD5_GEN_Setup Setup;
+static int nPreloadCnt;
+static int nFuncCnt;
+static char SetupName[128];
+static struct cfg_list *gen_source;
+
+extern struct options_main options;
+
+static int load_config(int which) {
+	char SubSection[32];
+	sprintf(SubSection, ":md5_gen(%d)", which);
+
+	gen_source = cfg_get_list("list.generic", SubSection);
+	return !!gen_source;
+}
+
+char *GetFld(char **out, char *in)
+{
+	char *cp;
+	if (!in || !*in) return "";
+	cp = strchr(in, options.loader.field_sep_char);
+	if (cp)
+		*cp++ = 0;
+	*out = in;
+	return cp;
+}
+
+int md5_gen_LOAD_PARSER_FUNCTIONS_LoadLINE(char *Line)
+{
+	int nConst, j;
+	char c = tolower(*Line);
+	if (c == 't' && !strncasecmp(Line, "Test=", 5))
+	{
+		char *cp;
+		cp = str_alloc_copy(&Line[5]);
+		cp = GetFld(&(Setup.pPreloads[nPreloadCnt].ciphertext), cp);
+		if (!Setup.pPreloads[nPreloadCnt].ciphertext ||
+			strncmp(Setup.pPreloads[nPreloadCnt].ciphertext, SetupName, strlen(SetupName)))
+			return !!fprintf(stderr, "Error, invalid test line (wrong generic type):  %s\n", Line);
+		cp = GetFld(&(Setup.pPreloads[nPreloadCnt].plaintext), cp);
+		Setup.pPreloads[nPreloadCnt].flds[1] = str_alloc_copy(Setup.pPreloads[nPreloadCnt].ciphertext);
+		for (j = 0; j < 10; ++j) {
+			if (j==1) continue;
+			cp = GetFld(&(Setup.pPreloads[nPreloadCnt].flds[j]), cp);
+		}
+		++nPreloadCnt;
+		return 1;
+	}
+	if (c == 'c' && !strncasecmp(Line, "ColonChar=", 10))
+	{
+		char *tmp = md5_gen_Demangle(&Line[10]);
+		if (!tmp)
+			return !!fprintf(stderr, "Error, invalid test line: %s\n", Line);
+		options.loader.field_sep_char = *tmp;
+		return 1;
+	}
+	if (c == 'f' && !strncasecmp(Line, "Func=", 5))
+	{
+		int i;
+		for (i = 0; MD5Gen_Predicate[i].name; ++i)
+		{
+			if (!strcmp(MD5Gen_Predicate[i].name, &Line[5]))
+			{
+				Setup.pFuncs[nFuncCnt++] = MD5Gen_Predicate[i].func;
+				return 1;
+			}
+		}
+		return !!fprintf(stderr, "Error, unknown function:  %s\n", Line);
+	}
+	if (c == 'f' && !strncasecmp(Line, "Flag=", 5))
+	{
+		int i;
+		for (i = 0; MD5Gen_Str_Flag[i].name; ++i)
+		{
+			if (!strcmp(MD5Gen_Str_Flag[i].name, &Line[5]))
+			{
+				Setup.flags |= MD5Gen_Str_Flag[i].flag_bit;
+				return 1;
+			}
+		}
+		for (i = 0; MD5Gen_Str_sFlag[i].name; ++i)
+		{
+			if (!strcmp(MD5Gen_Str_sFlag[i].name, &Line[5]))
+			{
+				Setup.startFlags |= MD5Gen_Str_sFlag[i].flag_bit;
+				return 1;
+			}
+		}
+		return !!fprintf(stderr, "Error, unknown flag:  %s\n", Line);
+	}
+	if (c == 's' && !strncasecmp(Line, "SaltLen=", 8))
+	{
+		if (sscanf(&Line[7], "=%d", &Setup.SaltLen) == 1)
+			return 1;
+		return !!fprintf(stderr, "Error, Invalid SaltLen= line:  %s  \n", Line);
+	}
+	if (c == 'm' && !strncasecmp(Line, "MaxInputLen=", 12))
+	{
+		if (sscanf(&Line[11], "=%d", &Setup.MaxInputLen) == 1)
+			return 1;
+		return !!fprintf(stderr, "Error, Invalid MaxInputLen= line:  %s  \n", Line);
+	}
+	if (c == 'e' && !strncasecmp(Line, "Expression=", 11))
+	{
+		char tmp[256];
+		sprintf(tmp, "%s %s", SetupName, &Line[11]);
+		Setup.szFORMAT_NAME = str_alloc_copy(tmp);
+		return 1;
+	}
+	if (c == 'c' && !strncasecmp(Line, "const", 5))
+	{
+		if (sscanf(&Line[5], "%d=", &nConst)!=1)
+			return !!fprintf(stderr, "Error, invalid const line.   Line: %s\n", Line);
+		if (nConst < 1 || nConst > 8)
+			return !!fprintf(stderr, "Error, only constants from 1 to 8 are valid.   Line: %s\n", Line);
+		if (strlen(Line) == 7)
+			return !!fprintf(stderr, "Error, a 'blank' constant is not valid.   Line: %s\n", Line);
+		if (Setup.pConstants[nConst-1].Const)
+			return !!fprintf(stderr, "Error, this constant has already entered.   Line: %s\n", Line);
+		Setup.pConstants[nConst-1].Const = md5_gen_Demangle(&Line[7]);
+		return 1;
+	}
+	return !!fprintf(stderr, "Error, unknown line:   %s\n", Line);
+}
+
+char *md5_gen_LOAD_PARSER_SIGNATURE(int which)
+{
+	struct cfg_line *gen_line;
+	static char Sig[256];
+	if (which < 1000)
+		return NULL;
+
+	if (!load_config(which))
+		return NULL;
+
+	// Setup the 'default' format name
+	sprintf(Sig, "md5_gen(%d) ", which);
+
+	gen_line = gen_source->head;
+	while (gen_line)
+	{
+		if (!strncasecmp(gen_line->data, "Expression=", 11))
+		{
+			char SigApp[241];
+			strncpy(SigApp, &gen_line->data[11], 240);
+			SigApp[240] = 0;
+			strcat(Sig, SigApp);
+			break;
+		}
+		gen_line = gen_line->next;
+	}
+	return Sig;
+}
+
+int md5_gen_IS_PARSER_VALID(int which)
+{
+	struct cfg_line *gen_line;
+	if (!md5_gen_LOAD_PARSER_SIGNATURE(which))
+		return 0;
+
+	gen_line = gen_source->head;
+	while (gen_line)
+	{
+		if (!strncasecmp(gen_line->data, "ColonChar", 9))
+		{
+			// not sse2, but we do not handle this in the long bench.
+			// we can still bench if we specify JUST this one.
+			return 0;
+		}
+		if (strstr(gen_line->data, "MGF_ColonNOTValid"))
+			return 0;  // same as above, ColonChar.
+		gen_line = gen_line->next;
+	}
+	return 1;
+}
+
+static int Count_Items(char *Key)
+{
+	struct cfg_line *gen_line;
+	int Cnt=0, len=strlen(Key);
+
+	gen_line = gen_source->head;
+	while (gen_line)
+	{
+		if (!strncasecmp(gen_line->data, Key, len))
+			++Cnt;
+		gen_line = gen_line->next;
+	}
+	return Cnt;
+}
+
+int md5_gen_LOAD_PARSER_FUNCTIONS(int which, struct fmt_main *pFmt)
+{
+	int ret, cnt;
+	struct cfg_line *gen_line;
+
+	nPreloadCnt = 0;
+	nFuncCnt = 0;
+
+	if (!md5_gen_LOAD_PARSER_SIGNATURE(which))
+	{
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
+		fprintf(stderr, "Could not find section [List.Generic:md5_gen(%d)] in the john.ini/conf file\n", which);
+		error();
+	}
+
+	// Setup the 'default' format name
+	sprintf(SetupName, "md5_gen(%d)", which);
+	Setup.szFORMAT_NAME = str_alloc_copy(SetupName);
+
+	// allocate (and set null) enough file pointers
+	cnt = Count_Items("Func=");
+	Setup.pFuncs = mem_alloc_tiny((cnt+1)*sizeof(MD5_GEN_primitive_funcp), MEM_ALIGN_WORD);
+	memset(Setup.pFuncs, 0, (cnt+1)*sizeof(MD5_GEN_primitive_funcp));
+
+	// allocate (and set null) enough Preloads
+	cnt = Count_Items("Test=");
+	Setup.pPreloads = mem_alloc_tiny((cnt+1)*sizeof(struct fmt_tests), MEM_ALIGN_WORD);
+	memset(Setup.pPreloads, 0, (cnt+1)*sizeof(struct fmt_tests));
+
+	// allocate (and set null) enough constants (if we have 8, we still need a null to specify the end of the list)
+	cnt = Count_Items("CONST");
+	Setup.pConstants = mem_alloc_tiny((cnt+1)*sizeof(MD5_GEN_Constants), MEM_ALIGN_WORD);
+	memset(Setup.pConstants, 0, (cnt+1)*sizeof(MD5_GEN_Constants));
+
+	Setup.flags = 0;
+	Setup.startFlags = 0;
+	Setup.SaltLen = 0;
+	Setup.MaxInputLen = 0;
+
+	// Ok, now 'grind' through the data  I do know know how to use
+	// the config stuff too much, so will grind for now, and later
+	// go back over this, and do it 'right', if there is a right way
+	gen_line = gen_source->head;
+
+	while (gen_line)
+	{
+		if (!md5_gen_LOAD_PARSER_FUNCTIONS_LoadLINE(gen_line->data))
+		{
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "Error parsing section [List.Generic:md5_gen(%d)] in the john.ini/conf file\n", which);
+			error();
+		}
+		gen_line = gen_line->next;
+	}
+
+	ret = md5_gen_SETUP(&Setup, pFmt);
+
+	return ret;
+}
diff -rupN john-1.7.8/src/md5_gen_preloads.c john-1.7.8-jumbo-2/src/md5_gen_preloads.c
--- john-1.7.8/src/md5_gen_preloads.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_gen_preloads.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,796 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Generic MD5 hashes cracker
+ *
+ * Preloaded types md5gen(0) to md5gen(100) are 'reserved' types.
+ * They are loaded from this file. If someone tryes to build a 'custom'
+ * type in their john.ini file using one of those, john will abort
+ * the run.
+ *
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5.h"
+#include "md5_gen.h"
+
+#ifdef MD5_SSE_PARA
+#undef MMX_COEF
+#define MMX_COEF 4
+#endif
+
+//
+// HERE is the 'official' list of md5_gen(#) builtin's to John.
+//
+//md5_gen(0) --> md5($p)
+//md5_gen(1) --> md5($p.$s)  (joomla)
+//md5_gen(2) --> md5(md5($p))
+//md5_gen(3) --> md5(md5(md5($p)))
+//md5_gen(4) --> md5($s.$p)  (osCommerce MD5 2 byte salt)
+//md5_gen(5) --> md5($s.$p.$s)
+//md5_gen(6) --> md5(md5($p).$s)
+//md5_gen(7) --> md5(md5($p).$s) vBulletin  (fixed 3 byte salt, colon not valid as field sep, since all chars from 0x20 to 0x7E are in the salt)
+//md5_gen(8) --> md5(md5($s).$p)
+//md5_gen(9) --> md5($s.md5($p))
+//md5_gen(10) --> md5($s.md5($s.$p))
+//md5_gen(11) --> md5($s.md5($p.$s))
+//md5_gen(12) --> md5(md5($s).md5($p)) (IPB)
+//md5_gen(13) --> md5(md5($p).md5($s))
+//md5_gen(14) --> md5($s.md5($p).$s)
+//md5_gen(15) --> md5($u.md5($p).$s)
+//md5_gen(16) --> md5(md5(md5($p).$s).$s2)
+//md5_gen(17) --> phpass ($P$ or $H$)		// phpass OR phpbb (or WordPress, etc).  Should handle all conforming formats
+//md5_gen(18) --> md5($s.Y.$p.\xF7.$s)		//(Post.Office MD5) Does not workin SSE2, uses ONLY x86 md5 calls.
+//md5_gen(19) --> Cisco PIX (MD5)
+//md5_gen(20) --> Cisco PIX (MD5 salted)
+//md5_gen(21) --> HTTP Digest Access Auth
+//md5_gen(22) --> md5(sha1($p))
+//md5_gen(23) --> sha1(md5($p))             // requires a 40 byte hex hash
+//md5_gen(24) --> sha1($p.$s)               // requires a 40 byte hex hash
+//md5_gen(25) --> sha1($s.$p)               // requires a 40 byte hex hash
+//md5_gen(26) --> sha1($p)                  // MGF_RAW_SHA1_INPUT
+//md5_gen(27) --> FreeBSD MD5
+//md5_gen(28) --> Apache MD5
+
+// gen_md5(0)  raw-md5
+static MD5_GEN_primitive_funcp _Funcs_0[] =
+{
+	//MGF_KEYS_INPUT
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_0[] =
+{
+	{"md5_gen(0)5a105e8b9d40e1329780d62ea2265d8a","test1"},
+	{"md5_gen(0)378e2c4a07968da2eca692320136433d","thatsworking"},
+	{"md5_gen(0)8ad8757baa8564dc136c1e07507f4a98","test3"},
+	{NULL}
+};
+
+// gen_md5(1)  Joomla md5($p.$s)
+static MD5_GEN_primitive_funcp _Funcs_1[] =
+{
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_1[] =
+{
+	{"md5_gen(1)ed52af63d8ecf0c682442dfef5f36391$1aDNNojYGSc7pSzcdxKxhbqvLtEe4deG","test1"},
+	{"md5_gen(1)4fa1e9d54d89bfbe48b4c0f0ca0a3756$laxcaXPjgcdKdKEbkX1SIjHKm0gfYt1c","thatsworking"},
+	{"md5_gen(1)82568eeaa1fcf299662ccd59d8a12f54$BdWwFsbGtXPGc0H1TBxCrn0GasyAlJBJ","test3"},
+	{NULL}
+};
+
+
+// gen_md5(2)  md5(md5($p))
+static MD5_GEN_primitive_funcp _Funcs_2[] =
+{
+	//MGF_KEYS_INPUT
+	MD5GenBaseFunc__crypt,
+	MD5GenBaseFunc__clean_input2_kwik,
+	MD5GenBaseFunc__append_from_last_output_to_input2_as_base16,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+};
+static struct fmt_tests _Preloads_2[] =
+{
+	{"md5_gen(2)418d89a45edadb8ce4da17e07f72536c","test1"},
+	{"md5_gen(2)ccd3c4231a072b5e13856a2059d04fad","thatsworking"},
+	{"md5_gen(2)9992295627e7e7162bdf77f14734acf8","test3"},
+	{NULL}
+};
+// gen_md5(3)  md5(md5(md5($p)))
+static MD5_GEN_primitive_funcp _Funcs_3[] =
+{
+	//MGF_KEYS_INPUT
+	MD5GenBaseFunc__crypt,
+	MD5GenBaseFunc__clean_input2_kwik,
+	MD5GenBaseFunc__append_from_last_output_to_input2_as_base16,
+	MD5GenBaseFunc__crypt2,
+	MD5GenBaseFunc__clean_input2_kwik,
+	MD5GenBaseFunc__append_from_last_output2_as_base16,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+};
+static struct fmt_tests _Preloads_3[] =
+{
+	{"md5_gen(3)964c02612b2a1013ed26d46ba9a73e74","test1"},
+	{"md5_gen(3)5d7e6330f69548797c07d97c915690fe","thatsworking"},
+	{"md5_gen(3)2e54db8c72b312007f3f228d9d4dd34d","test3"},
+	{NULL}
+};
+
+//md5_gen(4) --> md5($s.$p)
+static MD5_GEN_primitive_funcp _Funcs_4[] =
+{
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_4[] =
+{
+	{"md5_gen(4)c02e8eef3eaa1a813c2ff87c1780f9ed$123456","test1"},
+	{"md5_gen(4)4a2a1b013da3cda7f7e0625cf3dc3f4c$1234","thatsworking"},
+	{"md5_gen(4)3a032e36a9609df6411b8004070431d3$aaaaa","test3"},
+	{NULL}
+};
+
+//md5_gen(5) --> md5($s.$p.$s)
+static MD5_GEN_primitive_funcp _Funcs_5[] =
+{
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_5[] =
+{
+	{"md5_gen(5)c1003cd39cb5523dd0923a94ab15a3c7$123456","test1"},
+	{"md5_gen(5)c1c8618abfc7bdbc4a3c49c2c2c48f82$1234","thatsworking"},
+	{"md5_gen(5)e7222e806a8ce5efa6d48acb3aa56dc2$aaaaa","test3"},
+	{NULL}
+};
+
+//md5_gen(6) --> md5(md5($p).$s)
+static MD5_GEN_primitive_funcp _Funcs_6[] =
+{
+	//MGF_KEYS_BASE16_IN1
+#if ARCH_LITTLE_ENDIAN
+	MD5GenBaseFunc__set_input_len_32,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	NULL
+#else
+	MD5GenBaseFunc__clean_input2,
+	MD5GenBaseFunc__append_input2_from_input,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+#endif
+};
+static struct fmt_tests _Preloads_6[] =
+{
+	{"md5_gen(6)3a9ae23758f05da1fe539e55a096b03b$S111XB","test1"},
+	{"md5_gen(6)9694d706d1992abf04344c1e7da1c5d3$T &222","thatsworking"},
+	{"md5_gen(6)b7a7f0c374d73fac422bb01f07f5a9d4$lxxxl","test3"},
+	{NULL}
+};
+
+//md5_gen(7) --> md5(md5($p).$s) vBulletin  (forced 3 byte salt, valid chars from 0x20 to 0x7E)
+static MD5_GEN_primitive_funcp _Funcs_7[] =
+{
+	//MGF_KEYS_BASE16_IN1
+#if ARCH_LITTLE_ENDIAN
+	MD5GenBaseFunc__set_input_len_32,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	NULL
+#else
+	MD5GenBaseFunc__clean_input2,
+	MD5GenBaseFunc__append_input2_from_input,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+#endif
+};
+static struct fmt_tests _Preloads_7[] =
+{
+	{"md5_gen(7)daa61d77e218e42060c2fa198ac1feaf$SXB","test1"},
+	{"md5_gen(7)de56b00bb15d6db79204bd44383469bc$T &","thatsworking"},
+	{"md5_gen(7)fb685c6f469f6e549c85e4c1fb5a65a6$\\H:","test3"},
+	{NULL}
+};
+
+//md5_gen(8) --> md5(md5($s).$p)
+static MD5_GEN_primitive_funcp _Funcs_8[] =
+{
+	//MGF_SALT_AS_HEX
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_8[] =
+{
+	{"md5_gen(8)534c2fb38e757d9448315abb9822db00$aaaSXB","test1"},
+	{"md5_gen(8)02547864bed278658e8f54dd6dfd69b7$123456","thatsworking"},
+	{"md5_gen(8)2f6f3881972653ebcf86e5ad3071a4ca$5555hh","test3"},
+	{NULL}
+};
+
+//md5_gen(9) --> md5($s.md5($p))
+static MD5_GEN_primitive_funcp _Funcs_9[] =
+{
+#if defined (MMX_COEF)
+	//MGF_KEYS_CRYPT_IN2
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16,
+	MD5GenBaseFunc__crypt,
+	NULL
+#else
+	//MGF_KEYS_BASE16_IN1
+	MD5GenBaseFunc__clean_input2,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__append_input2_from_input,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+#endif
+};
+static struct fmt_tests _Preloads_9[] =
+{
+	{"md5_gen(9)b38c18b5e5b676e211442bd41000b2ec$aaaSXB","test1"},
+	{"md5_gen(9)4dde7cd4cbf0dc4c59b255ae77352914$123456","thatsworking"},
+	{"md5_gen(9)899af20e3ebdd77aaecb0d9bc5fbbb66$5555hh","test3"},
+	{NULL}
+};
+
+//md5_gen(10) --> md5($s.md5($s.$p))
+static MD5_GEN_primitive_funcp _Funcs_10[] =
+{
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__crypt,
+	MD5GenBaseFunc__clean_input2_kwik,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__append_from_last_output_to_input2_as_base16,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+};
+static struct fmt_tests _Preloads_10[] =
+{
+	{"md5_gen(10)781f83a676f45169dcfc7f36dfcdc3d5$aaaSXB","test1"},
+	{"md5_gen(10)f385748e67a2dc1f6379b9124fabc0df$123456","thatsworking"},
+	{"md5_gen(10)9e3702bb13386270cd4b0bd4dbdd489e$5555hh","test3"},
+	{NULL}
+};
+
+//md5_gen(11) --> md5($s.md5($p.$s))
+static MD5_GEN_primitive_funcp _Funcs_11[] =
+{
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	MD5GenBaseFunc__clean_input2_kwik,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__append_from_last_output_to_input2_as_base16,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+};
+static struct fmt_tests _Preloads_11[] =
+{
+	{"md5_gen(11)f809a64cbd0d23e099cd5b544c8501ac$aaaSXB","test1"},
+	{"md5_gen(11)979e6671535cda6db95357d8a0afd9ac$123456","thatsworking"},
+	{"md5_gen(11)78a61ea73806ebf27bef2ab6a9bf5412$5555hh","test3"},
+	{NULL}
+};
+
+//md5_gen(12) --> md5(md5($s).md5($p))
+static MD5_GEN_primitive_funcp _Funcs_12[] =
+{
+	//MGF_KEYS_BASE16_X86_IN1_Offset32
+	//MGF_SALT_AS_HEX
+	MD5GenBaseFunc__ToX86,
+	MD5GenBaseFunc__overwrite_salt_to_input1_no_size_fix,
+	MD5GenBaseFunc__set_input_len_64,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_12[] =
+{
+	{"md5_gen(12)fbbd9532460f2d03fa8af9e75c41eefc$aaaSXB","test1"},
+	{"md5_gen(12)b80eef24d1d01b61b3beff38559f9d26$123456","thatsworking"},
+	{"md5_gen(12)1e5489bdca008aeed6e390ee87ce9b92$5555hh","test3"},
+	{NULL}
+};
+
+//md5_gen(13) --> md5(md5($p).md5($s))
+static MD5_GEN_primitive_funcp _Funcs_13[] =
+{
+	//MGF_KEYS_BASE16_X86_IN1
+	//MGF_SALT_AS_HEX
+	MD5GenBaseFunc__ToX86,
+	MD5GenBaseFunc__set_input_len_32,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	NULL
+
+};
+static struct fmt_tests _Preloads_13[] =
+{
+	{"md5_gen(13)c6b69bec81d9ff5d0560d8f469a8efd5$aaaSXB","test1"},
+	{"md5_gen(13)7abf788b3abbfc8719d900af96a3763a$123456","thatsworking"},
+	{"md5_gen(13)1c55e15102ed17eabe5bf11271c7fcae$5555hh","test3"},
+	{NULL}
+};
+
+//md5_gen(14) --> md5($s.md5($p).$s)
+static MD5_GEN_primitive_funcp _Funcs_14[] =
+{
+#if defined (MMX_COEF)
+	//MGF_KEYS_CRYPT_IN2
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	NULL
+#else
+	//MGF_KEYS_BASE16_IN1
+	MD5GenBaseFunc__clean_input2,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__append_input2_from_input,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+#endif
+};
+static struct fmt_tests _Preloads_14[] =
+{
+	{"md5_gen(14)778e40e10d82a08f5377992330008cbe$aaaSXB","test1"},
+	{"md5_gen(14)d6321956964b2d27768df71d139eabd2$123456","thatsworking"},
+	{"md5_gen(14)1b3c72e16427a2f4f0819243877f7967$5555hh","test3"},
+	{NULL}
+};
+
+//md5_gen(15) --> md5($u.md5($p).$s)
+static MD5_GEN_primitive_funcp _Funcs_15[] =
+{
+	// MGF_KEYS_CRYPT_IN2
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_userid,
+	MD5GenBaseFunc__append_from_last_output2_to_input1_as_base16,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_15[] =
+{
+	{"md5_gen(15)6093d5cb3e2f99d9110eb9c4bbca5f8c$aaaSXB$$Ujoeblow","test1"},
+	{"md5_gen(15)6a2dc4a6637bc5c2488f27faeead8720$123456$$Uadmin","thatsworking"},
+	{"md5_gen(15)63aea4b8fe491df8545cc0099ac668d4$5555hh$$Uralph","test3"},
+
+	// to test 'like' we would see from an 'input file' where user name would be first field
+	{"md5_gen(15)6093d5cb3e2f99d9110eb9c4bbca5f8c$aaaSXB","test1",        {"joeblow"} },
+	{"md5_gen(15)6a2dc4a6637bc5c2488f27faeead8720$123456","thatsworking", {"admin"} },
+	{"md5_gen(15)63aea4b8fe491df8545cc0099ac668d4$5555hh","test3",        {"ralph"} },
+
+	{NULL}
+};
+
+//md5_gen(16) --> md5(md5(md5($p).$s).$s2)
+static MD5_GEN_primitive_funcp _Funcs_16[] =
+{
+	//MGF_KEYS_BASE16_IN1
+	MD5GenBaseFunc__clean_input2,
+	MD5GenBaseFunc__append_input2_from_input,
+	MD5GenBaseFunc__append_salt2,
+	MD5GenBaseFunc__crypt2,
+	MD5GenBaseFunc__clean_input2,
+	MD5GenBaseFunc__append_from_last_output2_as_base16,
+	MD5GenBaseFunc__append_2nd_salt2,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+};
+static struct fmt_tests _Preloads_16[] =
+{
+	// NOTE the $ is the byte starting the salt block, and the $$2 is the
+	// pattern showing where to 'split off' the
+	{"md5_gen(16)5ce496c635f96ac1ccd87518d4274b49$aaaSXB$$2salt2","test1"},
+	{"md5_gen(16)2f49a8804a3aee4da3c219539fc93c6d$123456$$2ssss2","thatsworking"},
+	{"md5_gen(16)d8deb4f271694c7a9a6c54f5068e3825$5555hh$$2sxxx3","test3"},
+	{NULL}
+};
+
+//md5_gen(17) --> $P$9 phpass (or $H$7, $P$A, ... )
+static MD5_GEN_primitive_funcp _Funcs_17[] =
+{
+	//MGF_PHPassSetup
+	MD5GenBaseFunc__PHPassCrypt,
+	NULL
+};
+static struct fmt_tests _Preloads_17[] =
+{
+	// format:  md5_gen(17)hash$Xssssssss
+	// Xssssssss is the 9 bytes immediately following the standard
+	// signature of $P$  So $P$912345678jgypwqm.JsMssPLiS8YQ00 the
+	// 912345678 will be inserted into $Xssssssss
+	// ssssssss is the salt, and X is a byte used to count how many
+	// times we do the inner md5 crypt packing.
+	{"md5_gen(17)jgypwqm.JsMssPLiS8YQ00$9aaaaaSXB","test1"},
+	{"md5_gen(17)5R3ueot5zwV.7MyzAItyg/$912345678","thatsworking"},
+	{"md5_gen(17)JSe8S8ufpLrsNE7utOpWc/$BaaaaaSXB","test1"},
+	{"md5_gen(17)mwulIMWPGe6RPXG1/R8l50$712345678","thatsworking"},
+
+	// Place last, so this is the 'timing' test for 'single salt'
+	{"md5_gen(17)Y5RwgMij0xFsUIrr33lM1/$9555555hh","test3"},
+
+	{NULL}
+};
+
+//md5_gen(18) --> PO  md5($s.$C1.$p.$C2.$s)
+static MD5_GEN_primitive_funcp _Funcs_18[] =
+{
+	//MD5GenBaseFunc__clean_input_kwik,
+	//MD5GenBaseFunc__append_salt,
+	//MD5GenBaseFunc__append_input1_from_CONST1,
+	//MD5GenBaseFunc__append_keys,
+	//MD5GenBaseFunc__append_input1_from_CONST2,
+	//MD5GenBaseFunc__append_salt,
+	//MD5GenBaseFunc__crypt,
+
+	//MGF_POSetup
+	// made a 'special' function to speed this up about 20%
+	MD5GenBaseFunc__POCrypt,
+	NULL
+};
+static struct fmt_tests _Preloads_18[] =
+{
+	{"md5_gen(18)0c78bdef7d5448105cfbbc9aaa490a44$550c41c11bab48f9dbd8203ed313eef0", "abc123"},
+	{"md5_gen(18)550c41c11bab48f9dbd8203ed313eef0$aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "abc123"},
+	{"md5_gen(18)9be296cf73d2f548dae3cccafaff1dd9$82916963c701200625cba2acd40d6569", "FRED"},
+	{"md5_gen(18)a0e2078f0354846ec5bc4c7d7be08a46$82916963c701200625cba2acd40d6569", ""},
+	{NULL}
+};
+static MD5_GEN_Constants _Const_18[] =
+{
+	// constants not needed in the MD5GenBaseFunc__POCrypt call, but left here for documentation reasons.
+	{"Y"},
+	{"\xF7"},
+	{NULL}
+};
+
+//md5_gen(19) --> Cisco PIX hash (same as pixMD5_fmt.c)
+static MD5_GEN_primitive_funcp _Funcs_19[] =
+{
+	//MGF_INPBASE64_4x6
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__set_input_len_16,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_19[] =
+{
+	{"md5_gen(19)2KFQnbNIdI.2KYOU","cisco"},
+	{"md5_gen(19)TRPEas6f/aa6JSPL","test1"},
+	{"md5_gen(19)OMT6mXmAvGyzrCtp","test2"},
+	{"md5_gen(19)gTC7RIy1XJzagmLm","test3"},
+	{"md5_gen(19).7nfVBEIEu4KbF/1","0123456789abcdef"},
+	{"md5_gen(19)NuLKvvWGg.x9HEKO","password"},
+	{"md5_gen(19)oWC1WRwqlBlbpf/O","test4"},
+	{NULL}
+};
+
+
+//md5_gen(20) --> Salted Cisco PIX hash
+static MD5_GEN_primitive_funcp _Funcs_20[] =
+{
+	//MGF_INPBASE64_4x6
+	//MGF_SALTED
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__set_input_len_16,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_20[] =
+{
+	{"md5_gen(20)h3mJrcH0901pqX/m$alex","ripper"},
+	{"md5_gen(20)3USUcOPFUiMCO4Jk$cisc","cisco"},
+	{"md5_gen(20)lZt7HSIXw3.QP7.R$admc","CscFw-ITC!"},
+	{"md5_gen(20)hN7LzeyYjw12FSIU$john","cisco"},
+	{"md5_gen(20)7DrfeZ7cyOj/PslD$jack","cisco"},
+	{NULL}
+};
+
+//md5_gen(21) --> HDAA HTTP Digest access authentication
+static MD5_GEN_primitive_funcp _Funcs_21[] =
+{
+	//MGF_HDAA_SALT
+	//MGF_FLD2
+	//MGF_FLD3
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_userid,
+	MD5GenBaseFunc__append_input1_from_CONST1,
+	MD5GenBaseFunc__append_fld2,
+	MD5GenBaseFunc__append_input1_from_CONST1,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__crypt,
+	MD5GenBaseFunc__SSEtoX86_switch_output1,
+	MD5GenBaseFunc__clean_input_kwik,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__overwrite_from_last_output_as_base16_no_size_fix,
+	MD5GenBaseFunc__crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_21[] =
+{
+	{"md5_gen(21)679066476e67b5c7c4e88f04be567f8b$8c12bd8f728afe56d45a0ce846b70e5a$$Uuser$$F2myrealm$$F3GET$/$$F400000001$4b61913cec32e2c9$auth","nocode"},
+	{"md5_gen(21)faa6cb7d676e5b7c17fcbf966436aa0c$af32592775d27b1cd06356b3a0db9ddf$$Umoi$$F2myrealm$$F3GET$/$$F400000001$8e1d49754a25aea7$auth","kikou"},
+	{NULL}
+};
+static MD5_GEN_Constants _Const_21[] =
+{
+	// constants not needed in the MD5GenBaseFunc__POCrypt call, but left here for documentation reasons.
+	{":"},
+	{NULL}
+};
+
+//md5_gen(22) --> md5(sha1($p))
+static MD5_GEN_primitive_funcp _Funcs_22[] =
+{
+	//MGF_StartInX86Mode
+	//MGF_KEYS_INPUT_BE_SAFE
+	MD5GenBaseFunc__clean_input2_kwik,
+	MD5GenBaseFunc__SHA1_crypt_input1_append_input2_base16,
+	MD5GenBaseFunc__X86toSSE_switch_input2,
+	MD5GenBaseFunc__crypt_in2_to_out1,
+	NULL
+};
+static struct fmt_tests _Preloads_22[] =
+{
+	{"md5_gen(22)a7168f0f249e3add33da11a59e228a57","test1"},
+	{"md5_gen(22)067dda3ad565339fffa61ba74fab0ba3","thatsworking"},
+	{"md5_gen(22)71a1083be5c288da7e57b8c2bd7cbc96","test3"},
+	{NULL}
+};
+
+//md5_gen(23) --> sha1(md5($p))
+static MD5_GEN_primitive_funcp _Funcs_23[] =
+{
+	//MGF_SHA1_40_BYTE_FINISH
+	//MGF_KEYS_INPUT
+	MD5GenBaseFunc__crypt,
+	MD5GenBaseFunc__SSEtoX86_switch_output1,
+	MD5GenBaseFunc__clean_input2,
+	MD5GenBaseFunc__append_from_last_output_to_input2_as_base16,
+	MD5GenBaseFunc__SHA1_crypt_input2_to_output1_FINAL,
+	NULL
+};
+static struct fmt_tests _Preloads_23[] =
+{
+	{"md5_gen(23)81d84525eb1499d518cf3cb3efcbe1d11c4ccf25","test1"},
+	{"md5_gen(23)6cd62e1767b65eec58d687de6d9c08a828018254","thatsworking"},
+	{"md5_gen(23)7d653cf00d747a9fbab213b6c2b335cfe8199ff3","test3"},
+	{NULL}
+};
+
+//md5_gen(24) --> sha1($p.$s)
+static MD5_GEN_primitive_funcp _Funcs_24[] =
+{
+	//MGF_SHA1_40_BYTE_FINISH
+	//MGF_SALTED
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL,
+	NULL
+};
+static struct fmt_tests _Preloads_24[] =
+{
+	{"md5_gen(24)5a12479f0a8286a832288e1dc2ea9b2eda4e382d$sG","test1"},
+	{"md5_gen(24)c72b6f1caddb158831cab0b08d29243ea20fc869$xxRW","thatsworking"},
+	{"md5_gen(24)b966eff1aac95e92818a7c59326cce297b935eff$s3xx","test3"},
+	{NULL}
+};
+
+//md5_gen(25) --> sha1($s.$p)
+static MD5_GEN_primitive_funcp _Funcs_25[] =
+{
+	//MGF_SHA1_40_BYTE_FINISH
+	//MGF_SALTED
+	MD5GenBaseFunc__clean_input,
+	MD5GenBaseFunc__append_salt,
+	MD5GenBaseFunc__append_keys,
+	MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL,
+	NULL
+};
+static struct fmt_tests _Preloads_25[] =
+{
+	{"md5_gen(25)f5266f29ff7f1ea6fc30085c8347fcf6a6e36e9c$sG","test1"},
+	{"md5_gen(25)a34af873d9047541b4d76ceae7b391f0664ca99e$xxRW","thatsworking"},
+	{"md5_gen(25)f0058038be0e821caa3031b463aed00fbe7e3beb$s3xx","test3"},
+	{NULL}
+};
+
+// gen_md5(26)  raw-sha1
+static MD5_GEN_primitive_funcp _Funcs_26[] =
+{
+	//MGF_SHA1_40_BYTE_FINISH
+	//MGF_RAW_SHA1_INPUT
+	MD5GenBaseFunc__SHA1_crypt_input1_to_output1_FINAL,
+	NULL
+};
+static struct fmt_tests _Preloads_26[] =
+{
+	{"md5_gen(26)b444ac06613fc8d63795be9ad0beaf55011936ac","test1"},
+	{"md5_gen(26)1068db2941b46d12f790df99d72fe8c2eb6d3aaf","thatsworking"},
+	{"md5_gen(26)3ebfa301dc59196f18593c45e519287a23297589","test3"},
+	{NULL}
+};
+
+//md5_gen(27) --> FreeBSD MD5
+static MD5_GEN_primitive_funcp _Funcs_27[] =
+{
+	//MGF_FreeBSDMD5Setup
+	//MGF_INPBASE64
+	//MGF_SALTED
+	//MGF_StartInX86Mode
+	MD5GenBaseFunc__FreeBSDMD5Crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_27[] =
+{
+	{"md5_gen(27)C02xyp4O8Wi6/LAEkwVoT1$vjfazyg4","test1"},
+	{"md5_gen(27)BdIMOAWFOV2AQlLsrN/Sw.$1234","1234"},
+	{"md5_gen(27)Nv.tUZO7PmHiGOEIkp8.2.$kh4r/VjF","test2"},
+	{"md5_gen(27)KU7So6H/HpTU32hTZgWz80$KOFeLHvp","john ripper"},
+	{"md5_gen(27)TM9iK9z9bFUd8hfd4uEoU1$VD7.Lfhq","LongerPassword"},
+	{NULL}
+};
+static MD5_GEN_Constants _Const_27[] =
+{
+	{"$1$"},
+	{NULL}
+};
+
+//md5_gen(28) --> Apache MD5
+static MD5_GEN_primitive_funcp _Funcs_28[] =
+{
+	//MGF_FreeBSDMD5Setup
+	//MGF_INPBASE64
+	//MGF_SALTED
+	//MGF_StartInX86Mode
+	MD5GenBaseFunc__FreeBSDMD5Crypt,
+	NULL
+};
+static struct fmt_tests _Preloads_28[] =
+{
+	{"md5_gen(28)z63aHLt/0wBGomn09h6cE0$PmeWFwRA","test1"},
+	{"md5_gen(28)E5dH18qiSyTSoU.HqVFvD1$aSEuolRV","test2"},
+	{"md5_gen(28)JW5QhVWf5KPMBMXKK.mu10$VnTS8fM5","john ripper"},
+	{"md5_gen(28)oIetaUvUng.EN8U6Px6f/.$jdJFaVdA","LongerPassword"},
+	{NULL}
+};
+static MD5_GEN_Constants _Const_28[] =
+{
+	{"$apr1$"},
+	{NULL}
+};
+
+// Here is a 'dummy' constant array. This will be 'linked' to any md5-gen format that does not have any constants.
+static MD5_GEN_Constants _ConstDefault[] =
+{
+	{NULL}
+};
+
+// Here are the 'prebuilt' md5-gen objects, ready to be 'loaded'
+static MD5_GEN_Setup Setups[] =
+{
+	{ " md5_gen(0): md5($p)  (raw-md5) ",           _Funcs_0, _Preloads_0, _ConstDefault, MGF_NO_FLAG, MGF_KEYS_INPUT },
+	{ " md5_gen(1): md5($p.$s)  (joomla) ",         _Funcs_1, _Preloads_1, _ConstDefault, MGF_SALTED },
+	{ " md5_gen(2): md5(md5($p))  (e107) ",         _Funcs_2, _Preloads_2, _ConstDefault, MGF_NO_FLAG, MGF_KEYS_INPUT },
+	{ " md5_gen(3): md5(md5(md5($p))) ",            _Funcs_3, _Preloads_3, _ConstDefault, MGF_NO_FLAG, MGF_KEYS_INPUT },
+	{ " md5_gen(4): md5($s.$p)  (OSC) ",            _Funcs_4, _Preloads_4, _ConstDefault, MGF_SALTED },
+	{ " md5_gen(5): md5($s.$p.$s) ",                _Funcs_5, _Preloads_5, _ConstDefault, MGF_SALTED },
+	{ " md5_gen(6): md5(md5($p).$s) ",              _Funcs_6, _Preloads_6, _ConstDefault, MGF_SALTED, MGF_KEYS_BASE16_IN1 },
+	{ " md5_gen(7): md5(md5($p).$s)  (vBulletin) ", _Funcs_7, _Preloads_7, _ConstDefault, MGF_SALTED|MGF_ColonNOTValid, MGF_KEYS_BASE16_IN1, 3 },
+	{ " md5_gen(8): md5(md5($s).$p) ",              _Funcs_8, _Preloads_8, _ConstDefault, MGF_SALTED|MGF_SALT_AS_HEX },
+#if defined (MMX_COEF)
+	{ " md5_gen(9): md5($s.md5($p)) ",              _Funcs_9, _Preloads_9, _ConstDefault, MGF_SALTED, MGF_KEYS_CRYPT_IN2 },
+#else
+	{ " md5_gen(9): md5($s.md5($p)) ",              _Funcs_9, _Preloads_9, _ConstDefault, MGF_SALTED, MGF_KEYS_BASE16_IN1 },
+#endif
+	{ " md5_gen(10): md5($s.md5($s.$p)) ",          _Funcs_10,_Preloads_10,_ConstDefault, MGF_SALTED },
+	{ " md5_gen(11): md5($s.md5($p.$s)) ",          _Funcs_11,_Preloads_11,_ConstDefault, MGF_SALTED },
+	{ " md5_gen(12): md5(md5($s).md5($p))  (IPB) ", _Funcs_12,_Preloads_12,_ConstDefault, MGF_SALTED|MGF_SALT_AS_HEX,MGF_KEYS_BASE16_X86_IN1_Offset32 },
+	{ " md5_gen(13): md5(md5($p).md5($s)) ",        _Funcs_13,_Preloads_13,_ConstDefault, MGF_SALTED|MGF_SALT_AS_HEX,MGF_KEYS_BASE16_X86_IN1 },
+#if defined (MMX_COEF)
+	{ " md5_gen(14): md5($s.md5($p).$s) ",          _Funcs_14,_Preloads_14,_ConstDefault, MGF_SALTED,MGF_KEYS_CRYPT_IN2 },
+#else
+	{ " md5_gen(14): md5($s.md5($p).$s) ",          _Funcs_14,_Preloads_14,_ConstDefault, MGF_SALTED, MGF_KEYS_BASE16_IN1 },
+#endif
+	{ " md5_gen(15): md5($u.md5($p).$s) ",          _Funcs_15,_Preloads_15,_ConstDefault, MGF_SALTED|MGF_USERNAME, MGF_KEYS_CRYPT_IN2 },
+	{ " md5_gen(16): md5(md5(md5($p).$s).$s2) ",    _Funcs_16,_Preloads_16,_ConstDefault, MGF_SALTED|MGF_SALTED2, MGF_KEYS_BASE16_IN1 },
+	{ " md5_gen(17): phpass ($P$ or $H$) ",         _Funcs_17,_Preloads_17,_ConstDefault, MGF_SALTED|MGF_INPBASE64, MGF_PHPassSetup, 9 },
+	{ " md5_gen(18): md5($s.Y.$p.0xF7.$s) (Post.Office MD5) ",  _Funcs_18,_Preloads_18,_Const_18,     MGF_SALTED|MGF_NOTSSE2Safe, MGF_POSetup, 32 },
+	{ " md5_gen(19): Cisco PIX (MD5)",              _Funcs_19,_Preloads_19,_ConstDefault, MGF_INPBASE64_4x6, MGF_NO_FLAG, 0, 16 },
+	{ " md5_gen(20): Cisco PIX (MD5 salted)",       _Funcs_20,_Preloads_20,_ConstDefault, MGF_INPBASE64_4x6|MGF_SALTED, MGF_NO_FLAG, 4, 12 },
+	{ " md5_gen(21): HTTP Digest Access Auth",      _Funcs_21,_Preloads_21,_Const_21,     MGF_HDAA_SALT|MGF_FLD2|MGF_FLD3|MGF_SALTED, MGF_NO_FLAG },
+	{ " md5_gen(22): md5(sha1($p))",                _Funcs_22,_Preloads_22,_ConstDefault, MGF_StartInX86Mode, MGF_KEYS_INPUT_BE_SAFE },
+	{ " md5_gen(23): sha1(md5($p))",                _Funcs_23,_Preloads_23,_ConstDefault, MGF_SHA1_40_BYTE_FINISH, MGF_KEYS_INPUT },
+	{ " md5_gen(24): sha1($p.$s)",                  _Funcs_24,_Preloads_24,_ConstDefault, MGF_SALTED|MGF_SHA1_40_BYTE_FINISH, MGF_NO_FLAG },
+	{ " md5_gen(25): sha1($s.$p)",                  _Funcs_25,_Preloads_25,_ConstDefault, MGF_SALTED|MGF_SHA1_40_BYTE_FINISH, MGF_NO_FLAG },
+	{ " md5_gen(26): sha1($p) raw-sha1",            _Funcs_26,_Preloads_26,_ConstDefault, MGF_SHA1_40_BYTE_FINISH, MGF_RAW_SHA1_INPUT },
+	{ " md5_gen(27): FreeBSD MD5",                  _Funcs_27,_Preloads_27,_Const_27,     MGF_SALTED|MGF_INPBASE64a|MGF_StartInX86Mode, MGF_FreeBSDMD5Setup, 0, 15 },
+	{ " md5_gen(28): Apache MD5",                   _Funcs_28,_Preloads_28,_Const_28,     MGF_SALTED|MGF_INPBASE64a|MGF_StartInX86Mode, MGF_FreeBSDMD5Setup, 0, 15 }
+};
+
+char *md5_gen_PRELOAD_SIGNATURE(int cnt)
+{
+	if (cnt >= 0 && cnt < ARRAY_COUNT(Setups))
+		return Setups[cnt].szFORMAT_NAME;
+	return NULL;
+}
+
+int md5_gen_RESERVED_PRELOAD_SETUP(int cnt, struct fmt_main *pFmt)
+{
+	if (cnt < 0 || cnt > 1000)
+		return 0;
+	if (cnt >= ARRAY_COUNT(Setups))
+		return 0;
+
+	return md5_gen_SETUP(&Setups[cnt], pFmt);
+}
+
+// -1 is NOT valid
+// 0 is valid, but NOT usable by this build (i.e. no SSE2)
+// 1 is valid.
+int md5_gen_IS_VALID(int i)
+{
+	if (i < 0 || (i > 100 && i < 1000) || i > 2000)
+		return -1;
+	if (i < 1000 && i >= ARRAY_COUNT(Setups))
+		return -1;
+	if (i >= 1000) {
+		if (!md5_gen_IS_PARSER_VALID(i))
+			return 0;
+		return 1;
+	}
+
+#ifdef NT_X86_64
+	// right now, these formats FAIL for 64 bit intrisic builds.  For the time being,
+	// I am simply commenting these OUT.  I will fix at some time.
+	if (i == 12 || i == 13 || i == 21 || i == 22 || i == 23 || i == 24 || i == 25 || i == 26)
+		return 0;
+#endif
+
+	return 1;
+}
+
diff -rupN john-1.7.8/src/md5_gen_utils.c john-1.7.8-jumbo-2/src/md5_gen_utils.c
--- john-1.7.8/src/md5_gen_utils.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_gen_utils.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,98 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Generic MD5 hashes cracker
+ *
+ * Preloaded types md5gen(0) to md5gen(100) are 'reserved' types.
+ * They are loaded from this file. If someone tryes to build a 'custom'
+ * type in their john.ini file using one of those, john will abort
+ * the run.
+ *
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "config.h"
+#include "md5.h"
+#include "md5_gen.h"
+
+void md5_gen_DISPLAY_ALL_FORMATS()
+{
+	int i;
+	for (i = 0; i < 1000; ++i)
+	{
+		char *sz = md5_gen_PRELOAD_SIGNATURE(i);
+		if (!sz)
+			break;
+		printf ("Format = md5_gen(%d)%s  type = %s\n", i, i<10?" ":"", sz);
+	}
+
+	// The config has not been loaded, so we have to load it now, if we want to 'check'
+	// and show any user set md5-generic functions.
+#if JOHN_SYSTEMWIDE
+	cfg_init(CFG_PRIVATE_FULL_NAME, 1);
+	cfg_init(CFG_PRIVATE_ALT_NAME, 1);
+#endif
+	cfg_init(CFG_FULL_NAME, 1);
+	cfg_init(CFG_ALT_NAME, 0);
+
+	for (i = 1001; i < 10000; ++i)
+	{
+		char *sz = md5_gen_LOAD_PARSER_SIGNATURE(i);
+		if (sz)
+			printf ("UserFormat = md5_gen(%d)  type = %s\n", i, sz);
+	}
+}
+
+char *md5_gen_Demangle(char *Line)
+{
+	char *tmp, *cp, *cp2, digits[3];
+	if (!Line || !strlen(Line))
+		return str_alloc_copy("");
+	tmp = str_alloc_copy(Line);
+	cp = tmp;
+	cp2 = Line;
+	while (*cp2)
+	{
+		if (*cp2 != '\\')
+			*cp++ = *cp2++;
+		else
+		{
+			++cp2;
+			if (*cp2 == '\\')
+				*cp++ = *cp2++;
+			else
+			{
+				unsigned val;
+				if (*cp2 != 'x')
+					exit(fprintf(stderr, "Error, invalid line:  %s\n", Line));
+				++cp2;
+				if (!cp2)
+					exit(fprintf(stderr, "Error, invalid line:  %s\n", Line));
+				digits[0] = *cp2++;
+				if (!cp2)
+					exit(fprintf(stderr, "Error, invalid line:  %s\n", Line));
+				digits[1] = *cp2++;
+				digits[2] = 0;
+				val = (unsigned)strtol(digits, NULL, 16);
+				sprintf(cp, "%c", val);
+				++cp;
+			}
+		}
+	}
+	*cp = 0;
+	return tmp;
+}
diff -rupN john-1.7.8/src/md5_go.c john-1.7.8-jumbo-2/src/md5_go.c
--- john-1.7.8/src/md5_go.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_go.c	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,275 @@
+/*
+ * This is an OpenSSL-compatible implementation of the RSA Data Security,
+ * Inc. MD5 Message-Digest Algorithm (RFC 1321).
+ *
+ * Written by Solar Designer <solar at openwall.com> in 2001, and placed
+ * in the public domain.  There's absolutely no warranty.
+ *
+ * This differs from Colin Plumb's older public domain implementation in
+ * that no 32-bit integer data type is required, there's no compile-time
+ * endianness configuration, and the function prototypes match OpenSSL's.
+ * The primary goals are portability and ease of use.
+ *
+ * This implementation is meant to be fast, but not as fast as possible.
+ * Some known optimizations are not included to reduce source code size
+ * and avoid compile-time configuration.
+ *
+ * This file has been modified by David Luyer <david at luyer.net> to
+ * introduce some performance improvements, at the cost of its
+ * general-purpose use.
+ * See the caveats documented above the MD5_Go() routine.
+ *
+ * If you reuse the code for another purpose, please download the original from:
+ * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "common.h"
+#include "md5_go.h"
+
+#define MD5_out MD5_out_go
+#define MD5_bitswapped_out MD5_bitswapped_out_go
+
+/* Output words */
+ARCH_WORD_32 MD5_out[4];
+ARCH_WORD_32 *pMD5_out=MD5_out;
+
+#if !ARCH_LITTLE_ENDIAN
+/* Bit-swapped output words */
+ARCH_WORD_32 MD5_bitswapped_out[4];
+#endif
+
+/*
+ * The basic MD5 functions.
+ *
+ * F and G are optimized compared to their RFC 1321 definitions for
+ * architectures that lack an AND-NOT instruction, just like in Colin Plumb's
+ * implementation.
+ */
+#define F(x, y, z)			((z) ^ ((x) & ((y) ^ (z))))
+#define G(x, y, z)			((y) ^ ((z) & ((x) ^ (y))))
+#define H(x, y, z)			((x) ^ (y) ^ (z))
+#define I(x, y, z)			((y) ^ ((x) | ~(z)))
+
+/*
+ * The MD5 transformation for all four rounds.
+ */
+#define STEP(f, a, b, c, d, x, t, s) \
+	(a) += f((b), (c), (d)) + (x) + (t); \
+	(a) = (((a) << (s)) | (((a) & 0xffffffff) >> (32 - (s)))); \
+	(a) += (b);
+
+/*
+ * SET reads 4 input bytes in little-endian byte order and stores them
+ * in a properly aligned word in host byte order.
+ *
+ * The check for little-endian architectures that tolerate unaligned
+ * memory accesses is just an optimization.  Nothing will break if it
+ * doesn't work.
+ */
+#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)
+#define SET(n) \
+	(*(MD5_u32plus *)&ptr[(n) * 4])
+#define GET(n) \
+	SET(n)
+#else
+static MD5_u32plus work[16];
+#define SET(n) \
+	(work[(n)] = \
+	(MD5_u32plus)ptr[(n) * 4] | \
+	((MD5_u32plus)ptr[(n) * 4 + 1] << 8) | \
+	((MD5_u32plus)ptr[(n) * 4 + 2] << 16) | \
+	((MD5_u32plus)ptr[(n) * 4 + 3] << 24))
+#define GET(n) \
+	(work[(n)])
+#endif
+
+/*
+ * This processes one or more 64-byte data blocks, but does NOT update
+ * the bit counters.  There are no alignment requirements.
+ */
+static void body(void *data, unsigned int size)
+{
+	unsigned char *ptr;
+	MD5_u32plus a, b, c, d;
+	MD5_u32plus saved_a, saved_b, saved_c, saved_d;
+
+	ptr = data;
+
+	a = 0x67452301;
+	b = 0xefcdab89;
+	c = 0x98badcfe;
+	d = 0x10325476;
+
+	do {
+		saved_a = a;
+		saved_b = b;
+		saved_c = c;
+		saved_d = d;
+
+/* Round 1 */
+		STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)
+		STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)
+		STEP(F, c, d, a, b, SET(2), 0x242070db, 17)
+		STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)
+		STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)
+		STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)
+		STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)
+		STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)
+		STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)
+		STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)
+		STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)
+		STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)
+		STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)
+		STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)
+		STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)
+		STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)
+
+/* Round 2 */
+		STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)
+		STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)
+		STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)
+		STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)
+		STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)
+		STEP(G, d, a, b, c, GET(10), 0x02441453, 9)
+		STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)
+		STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)
+		STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)
+		STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)
+		STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)
+		STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)
+		STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)
+		STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)
+		STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)
+		STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)
+
+/* Round 3 */
+		STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)
+		STEP(H, d, a, b, c, GET(8), 0x8771f681, 11)
+		STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)
+		STEP(H, b, c, d, a, GET(14), 0xfde5380c, 23)
+		STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)
+		STEP(H, d, a, b, c, GET(4), 0x4bdecfa9, 11)
+		STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)
+		STEP(H, b, c, d, a, GET(10), 0xbebfbc70, 23)
+		STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)
+		STEP(H, d, a, b, c, GET(0), 0xeaa127fa, 11)
+		STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)
+		STEP(H, b, c, d, a, GET(6), 0x04881d05, 23)
+		STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)
+		STEP(H, d, a, b, c, GET(12), 0xe6db99e5, 11)
+		STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)
+		STEP(H, b, c, d, a, GET(2), 0xc4ac5665, 23)
+
+/* Round 4 */
+		STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)
+		STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)
+		STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)
+		STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)
+		STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)
+		STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)
+		STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)
+		STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)
+		STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)
+		STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)
+		STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)
+		STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)
+		STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)
+		STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)
+		STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)
+		STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)
+
+		a += saved_a;
+		b += saved_b;
+		c += saved_c;
+		d += saved_d;
+
+		ptr += 64;
+	} while (size -= 64);
+
+	pMD5_out[0] = a;
+	pMD5_out[1] = b;
+	pMD5_out[2] = c;
+	pMD5_out[3] = d;
+}
+
+/* Single-pass MD5 of a string of up to 2^11 bytes
+ *
+ * Caveats:
+ *   - String length limited to 2^11 bytes (can be easily increased
+ *     by adding data[process-6] = len >> 13 etc).
+ *   - Requires scratch space at the end of the string (up to 73 bytes).
+ *   - String will need re-terminating after calling this rountine.
+ */
+void MD5_Go(unsigned char *data, unsigned int len)
+{
+	unsigned int process = (len + 73) & ~0x3f;
+
+	data[len] = 0x80;
+	memset(&data[len+1], 0, process - len - 1);
+	data[process-8] = len << 3;
+	data[process-7] = len >> 5;
+	body(data, process);
+
+#if !ARCH_LITTLE_ENDIAN
+        MD5_bitswapped_out[0] = (MD5_out[0] << 24) |
+				(MD5_out[0] >> 24) |
+				((MD5_out[0] << 8) & 0x00ff0000) |
+				((MD5_out[0] >> 8) & 0x0000ff00);
+        MD5_bitswapped_out[1] = (MD5_out[1] << 24) |
+				(MD5_out[1] >> 24) |
+				((MD5_out[1] << 8) & 0x00ff0000) |
+				((MD5_out[1] >> 8) & 0x0000ff00);
+        MD5_bitswapped_out[2] = (MD5_out[2] << 24) |
+				(MD5_out[2] >> 24) |
+				((MD5_out[2] << 8) & 0x00ff0000) |
+				((MD5_out[2] >> 8) & 0x0000ff00);
+        MD5_bitswapped_out[3] = (MD5_out[3] << 24) |
+				(MD5_out[3] >> 24) |
+				((MD5_out[3] << 8) & 0x00ff0000) |
+				((MD5_out[3] >> 8) & 0x0000ff00);
+#endif
+}
+
+void MD5_Go2(unsigned char *data, unsigned int len, unsigned char *result)
+{
+	unsigned int process = (len + 73) & ~0x3f;
+
+	// We have a 'specific' destination (not the MD5_out)
+	pMD5_out = (ARCH_WORD_32*)result;
+
+	data[len] = 0x80;
+	memset(&data[len+1], 0, process - len - 1);
+	data[process-8] = len << 3;
+	data[process-7] = len >> 5;
+	body(data, process);
+
+#if !ARCH_LITTLE_ENDIAN
+		ARCH_WORD_32 w;
+		w = (pMD5_out[0] << 24) |
+			(pMD5_out[0] >> 24) |
+			((pMD5_out[0] << 8) & 0x00ff0000) |
+			((pMD5_out[0] >> 8) & 0x0000ff00);
+		pMD5_out[0] = w;
+        w = (pMD5_out[1] << 24) |
+			(pMD5_out[1] >> 24) |
+			((pMD5_out[1] << 8) & 0x00ff0000) |
+			((pMD5_out[1] >> 8) & 0x0000ff00);
+		pMD5_out[1] = w;
+        w = (pMD5_out[2] << 24) |
+			(pMD5_out[2] >> 24) |
+			((pMD5_out[2] << 8) & 0x00ff0000) |
+			((pMD5_out[2] >> 8) & 0x0000ff00);
+		pMD5_out[2] = w;
+        w = (pMD5_out[3] << 24) |
+			(pMD5_out[3] >> 24) |
+			((pMD5_out[3] << 8) & 0x00ff0000) |
+			((pMD5_out[3] >> 8) & 0x0000ff00);
+		pMD5_out[3] = w;
+#endif
+
+	// leaves the 'original' MD5_go() function working exactly the same as before.
+	pMD5_out = MD5_out;
+}
diff -rupN john-1.7.8/src/md5_go.h john-1.7.8-jumbo-2/src/md5_go.h
--- john-1.7.8/src/md5_go.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/md5_go.h	2011-05-17 18:13:02.000000000 +0200
@@ -0,0 +1,20 @@
+/*
+ * This is an OpenSSL-compatible implementation of the RSA Data Security,
+ * Inc. MD5 Message-Digest Algorithm.
+ *
+ * Written by Solar Designer <solar at openwall.com> in 2001, placed in
+ * the public domain, and hacked by others.
+ *
+ * If you reuse the code for another purpose, please download the original from:
+ * http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
+ */
+
+#if !defined(_MD5_GO_H)
+#define _MD5_GO_H
+
+/* Any 32-bit or wider unsigned integer data type will do */
+typedef unsigned int MD5_u32plus;
+extern void MD5_Go(unsigned char *data, unsigned int len);
+extern void MD5_Go2(unsigned char *data, unsigned int len, unsigned char *result);
+
+#endif
diff -rupN john-1.7.8/src/mediawiki_fmt_plug.c john-1.7.8-jumbo-2/src/mediawiki_fmt_plug.c
--- john-1.7.8/src/mediawiki_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mediawiki_fmt_plug.c	2011-06-08 18:24:06.000000000 +0200
@@ -0,0 +1,182 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2011. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2011 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Media-wiki salted-MD5 hashes cracker
+ *
+ * info about this format is found here:
+ *   http://www.mediawiki.org/wiki/Manual:User_table
+ *
+ *  there are 2 formats. Format 1 is simple raw md5.  It is easier
+ *  to do a 1 time edit of the format string, removing the :A: from
+ *  the md5 hash string, and then simply using raw-md5.  This format
+ *  will NOT do that for you.
+ *
+ *  This format is for the :B: type.
+ *
+ *  Here is a SQL statement for MySQL which will convert the database
+ *  records into proper input lines for this format:
+ *
+ SELECT CONCAT_WS(':',user_name,REPLACE(user_password,':','$'),user_id,'0',user_real_name,user_email)
+   FROM `dw_user` where user_password like ':B:%';
+ *
+ *  This will return data in this format:
+userName1:$B$5ae58e0c$e5fe3ec9a8c4e3e9baa30e462adbfbd6:1551:0:RealName:emailaddress@yahoo.com
+userName2:$B$107$dd494cb03ac1c5b8f8d2dddafca2f7a6:1552:0::emailaddress@gmail.com
+ *
+ * This thin format will change the above line into this, for hooking
+ * into md5_gen(9)  (NOTE the '-' char is appended to the salt)
+ *
+ *  md5_gen(9)dd494cb03ac1c5b8f8d2dddafca2f7a6$107-
+ *
+ */
+
+
+#include <string.h>
+
+#include "common.h"
+#include "formats.h"
+#include "md5_gen.h"
+
+#define FORMAT_LABEL		"mediawiki"
+#define FORMAT_NAME			"MediaWiki MD5s"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME		"MD5($s.'-'.md5($p)) MMX"
+#else
+#define ALGORITHM_NAME		"MD5($s.'-'.md5($p)) SSE2"
+#endif
+#else
+#define ALGORITHM_NAME		"MD5($s.'-'.md5($p)) MD5"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH	0
+
+#define MD5_BINARY_SIZE		16
+#define MD5_HEX_SIZE		(MD5_BINARY_SIZE * 2)
+
+#define BINARY_SIZE			MD5_BINARY_SIZE
+
+#define SALT_SIZE			9
+#define PROCESSED_SALT_SIZE	SALT_SIZE
+
+#define PLAINTEXT_LENGTH	32
+
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+static struct fmt_tests mediawiki_tests[] = {
+	{"$B$113$de2874e33da25313d808d2a8cbf31485",      "qwerty"},
+	{"$B$bca6c557$8d187736f828e4cb032bd6c7a268cd95", "abc123"},
+	{"$B$6$70b3e0907f028877ea47c16496d6df6d",        ""},
+	{"$B$761$3ae7c8e25addfd82544c0c0b1ca8f5e4",      "password"},
+	{"$B$23a0884a$99b4afc91cba24529a9c16ff20e56621", "artist"},
+	{NULL}
+};
+
+static char Conv_Buf[80];
+static struct fmt_main *pFmt_MD5_gen_9;
+static void mediawiki_init(struct fmt_main *pFmt);
+
+/* this function converts a 'native' mediawiki signature string into a md5_gen(9) syntax string */
+static char *Convert(char *Buf, char *ciphertext)
+{
+	int i;
+	char *cp;
+	cp = strchr(&ciphertext[3], '$');
+	if (!cp)
+		return "*";
+	i = sprintf(Buf, "md5_gen(9)%s$", &cp[1]);
+	ciphertext += 3;
+	// now append salt, and the '-' char
+	while (*ciphertext != '$')
+		Buf[i++] = *ciphertext++;
+	Buf[i++] = '-';
+	Buf[i] = 0;
+	return Buf;
+}
+
+static int mediawiki_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+	char *cp;
+
+	if (!ciphertext)
+		return 0;
+
+	if (strncmp(ciphertext, "$B$", 3) != 0)
+		return 0;
+
+	cp = strchr(&ciphertext[3], '$');
+	if (!cp)
+		return 0;
+
+	++cp;
+	for (i = 0;i < MD5_HEX_SIZE; ++i)
+		if (atoi16[ARCH_INDEX(cp[i])] == 0x7F)
+			return 0;
+
+	if (!pFmt_MD5_gen_9)
+		mediawiki_init(pFmt);
+	return pFmt_MD5_gen_9->methods.valid(Convert(Conv_Buf, ciphertext), pFmt_MD5_gen_9);
+}
+
+
+static void * our_salt(char *ciphertext)
+{
+	return pFmt_MD5_gen_9->methods.salt(Convert(Conv_Buf, ciphertext));
+}
+static void * our_binary(char *ciphertext)
+{
+	return pFmt_MD5_gen_9->methods.binary(Convert(Conv_Buf, ciphertext));
+}
+
+struct fmt_main fmt_mediawiki =
+{
+	{
+		// setup the labeling and stuff. NOTE the max and min crypts are set to 1
+		// here, but will be reset within our init() function.
+		FORMAT_LABEL, FORMAT_NAME, ALGORITHM_NAME, BENCHMARK_COMMENT, BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH, BINARY_SIZE, SALT_SIZE+1, 1, 1, FMT_CASE | FMT_8_BIT, mediawiki_tests
+	},
+	{
+		/*  All we setup here, is the pointer to valid, and the pointer to init */
+		/*  within the call to init, we will properly set this full object      */
+		mediawiki_init,
+		fmt_default_prepare,
+		mediawiki_valid
+	}
+};
+
+
+static void mediawiki_init(struct fmt_main *pFmt)
+{
+	if (pFmt->private.initialized == 0) {
+		pFmt_MD5_gen_9 = md5_gen_THIN_FORMAT_LINK(&fmt_mediawiki, Convert(Conv_Buf, mediawiki_tests[0].ciphertext), "mediawiki");
+		fmt_mediawiki.methods.salt   = our_salt;
+		fmt_mediawiki.methods.binary = our_binary;
+		pFmt->private.initialized = 1;
+	}
+}
+
+/**
+ * GNU Emacs settings: K&R with 1 tab indent.
+ * Local Variables:
+ * c-file-style: "k&r"
+ * c-basic-offset: 8
+ * indent-tabs-mode: t
+ * End:
+ */
diff -rupN john-1.7.8/src/memory.c john-1.7.8-jumbo-2/src/memory.c
--- john-1.7.8/src/memory.c	2010-01-17 11:54:13.000000000 +0100
+++ john-1.7.8-jumbo-2/src/memory.c	2011-06-02 17:19:49.000000000 +0200
@@ -11,9 +11,39 @@
 #include "arch.h"
 #include "misc.h"
 #include "memory.h"
+#include "common.h"
 
 unsigned int mem_saving_level = 0;
 
+// Add 'cleanup' methods for the mem_tiny_alloc.  VERY little cost, but
+// allows us to check for mem leaks easier.
+struct rm_list
+{
+	void *mem;
+	struct rm_list *next;
+};
+static struct rm_list *mem_alloc_tiny_memory;
+
+static void add_memory_link(void *v) {
+	struct rm_list *p = mem_alloc(sizeof(struct rm_list));
+	p->next = mem_alloc_tiny_memory;
+	p->mem = v;
+	mem_alloc_tiny_memory = p;
+}
+// call at program exit.
+void cleanup_tiny_memory()
+{
+	struct rm_list *p = mem_alloc_tiny_memory, *p2;
+	for (;;) {
+		if (!p)
+			return;
+		free(p->mem);
+		p2 = p->next;
+		free(p);
+		p = p2;
+	}
+}
+
 void *mem_alloc(size_t size)
 {
 	void *res;
@@ -46,11 +76,14 @@ void *mem_alloc_tiny(size_t size, size_t
 	} else
 	if (size + align <= MEM_ALLOC_SIZE && bufree <= MEM_ALLOC_MAX_WASTE) {
 		buffer = (unsigned long)mem_alloc(MEM_ALLOC_SIZE);
+		add_memory_link((void*)buffer);
 		bufree = MEM_ALLOC_SIZE;
 		return mem_alloc_tiny(size, align + 1);
-	} else
-		start = ((unsigned long)
-			mem_alloc(size + align) + align) & ~align;
+	} else {
+		start = ((unsigned long) mem_alloc(size + align) + align);
+		add_memory_link((void*)(start-align));
+		start &= ~align;
+	}
 
 	return (void *)start;
 }
@@ -70,3 +103,58 @@ char *str_alloc_copy(char *src)
 	size = strlen(src) + 1;
 	return (char *)memcpy(mem_alloc_tiny(size, MEM_ALIGN_NONE), src, size);
 }
+
+void dump_stuff(unsigned char * x, unsigned int size)
+{
+        unsigned int i;
+        for(i=0;i<size;i++)
+        {
+                printf("%.2x", x[i]);
+                if( (i%4)==3 )
+                        printf(" ");
+        }
+        printf("\n");
+}
+void dump_stuff_msg(char *msg, unsigned char * x, unsigned int size) {
+	printf("%s : ", msg);
+	dump_stuff(x, size);
+}
+
+#if defined(MMX_COEF) || defined(NT_X86_64) || defined (MD5_SSE_PARA) || defined (MD4_SSE_PARA) || defined (SHA1_SSE_PARA)
+#ifndef MMX_COEF
+#define MMX_COEF	4
+#endif
+
+#define ROTATE_LEFT(i,c) (i) = (((i)<<(c))|((ARCH_WORD_32)(i)>>(32-(c))))
+
+void alter_endianity(unsigned char * _x, unsigned int size)
+{
+	// since we are only using this in MMX code, we KNOW that we are using x86 CPU's which do not have problems
+	// with non aligned 4 byte word access.  Thus, we use a faster swapping function.
+	ARCH_WORD_32 tmp, *x = (ARCH_WORD_32*)_x;
+	size>>=2;
+	while (size--) {
+		tmp = *x;
+		ROTATE_LEFT(tmp, 16);
+		*x++ = ((tmp & 0x00FF00FF) << 8) | ((tmp >> 8) & 0x00FF00FF);
+	}
+}
+
+#define GETPOS(i, index) ( (index&3)*4 + (i& (0xffffffff-3) )*MMX_COEF + ((i)&3) )
+
+void dump_stuff_mmx(unsigned char * buf, unsigned int size, unsigned int index)
+{
+	unsigned int i;
+	for(i=0;i<size;i++)
+	{
+		if(!(i%4))
+			printf(" ");
+		printf("%.2x", buf[GETPOS(i, index)]);
+	}
+	printf("\n");
+}
+void dump_stuff_mmx_msg(char *msg, unsigned char * buf, unsigned int size, unsigned int index) {
+	printf("%s : ", msg);
+	dump_stuff_mmx(buf, size, index);
+}
+#endif
diff -rupN john-1.7.8/src/memory.h john-1.7.8-jumbo-2/src/memory.h
--- john-1.7.8/src/memory.h	2011-02-25 10:31:32.000000000 +0100
+++ john-1.7.8-jumbo-2/src/memory.h	2011-06-02 17:19:49.000000000 +0200
@@ -82,4 +82,21 @@ extern void *mem_alloc_copy(size_t size,
  */
 extern char *str_alloc_copy(char *src);
 
+/*
+ * This will 'cleanup' the memory allocated by mem_alloc_tiny().  All
+ * of that memory was 'blindly' allocated, and not freed up during
+ * the run of john.  Now, it is 'cleaned' up.
+ */
+extern void cleanup_tiny_memory();
+
+
+void dump_stuff(unsigned char * x, unsigned int size);
+void dump_stuff_msg(char *msg, unsigned char * x, unsigned int size);
+#if defined (MMX_COEF) || defined(NT_X86_64) || defined (MD5_SSE_PARA) || defined (MD4_SSE_PARA) || defined (SHA1_SSE_PARA)
+void dump_stuff_mmx(unsigned char * x, unsigned int size, unsigned int index);
+void dump_stuff_mmx_msg(char *msg, unsigned char * buf, unsigned int size, unsigned int index);
+void alter_endianity(unsigned char * x, unsigned int size);
+#endif
+
+
 #endif
diff -rupN john-1.7.8/src/misc.c john-1.7.8-jumbo-2/src/misc.c
--- john-1.7.8/src/misc.c	2011-02-27 14:29:19.000000000 +0100
+++ john-1.7.8-jumbo-2/src/misc.c	2011-05-25 18:37:35.000000000 +0200
@@ -1,10 +1,17 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for MSC, by JimF.
  */
 
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#else
+#include <io.h>
+#pragma warning ( disable : 4996 )
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
@@ -12,11 +19,19 @@
 
 #include "logger.h"
 
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
+
 void error(void)
 {
 #ifndef _JOHN_MISC_NO_LOG
 	log_event("Terminating on error");
 	log_done();
+#if defined(HAVE_MPI) && defined(JOHN_MPI_ABORT)
+	if (mpi_p > 1)
+		MPI_Abort(MPI_COMM_WORLD,1);
+#endif
 #endif
 
 	exit(1);
@@ -26,6 +41,12 @@ void pexit(char *format, ...)
 {
 	va_list args;
 
+#ifndef _JOHN_MISC_NO_LOG
+#ifdef HAVE_MPI
+	if (mpi_p > 1)
+		fprintf(stderr, "Node %u@%s: ", mpi_id, mpi_name);
+#endif
+#endif
 	va_start(args, format);
 	vfprintf(stderr, format, args);
 	va_end(args);
@@ -124,6 +145,7 @@ char *strnzcat(char *dst, char *src, int
 	return dst;
 }
 
+#ifndef _MSC_VER
 char *strlwr(char *s)
 {
 	unsigned char *ptr = (unsigned char *)s;
@@ -136,3 +158,4 @@ char *strlwr(char *s)
 
 	return s;
 }
+#endif
diff -rupN john-1.7.8/src/misc.h john-1.7.8-jumbo-2/src/misc.h
--- john-1.7.8/src/misc.h	2003-09-06 22:30:26.000000000 +0200
+++ john-1.7.8-jumbo-2/src/misc.h	2011-05-17 18:13:02.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for MSC, by JimF.
  */
 
 /*
@@ -61,6 +63,10 @@ extern char *strnzcat(char *dst, char *s
 /*
  * Converts a string to lowercase.
  */
+#ifndef _MSC_VER
 extern char *strlwr(char *s);
+#else
+#define strlwr _strlwr
+#endif
 
 #endif
diff -rupN john-1.7.8/src/mkv.c john-1.7.8-jumbo-2/src/mkv.c
--- john-1.7.8/src/mkv.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mkv.c	2011-06-08 01:57:38.000000000 +0200
@@ -0,0 +1,394 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "params.h"
+#include "path.h"
+#include "memory.h"
+#include "signals.h"
+#include "formats.h"
+#include "loader.h"
+#include "logger.h"
+#include "status.h"
+#include "recovery.h"
+#include "config.h"
+#include "charset.h"
+#include "external.h"
+#include "cracker.h"
+
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
+#include "mkv.h"
+
+#if defined (__MINGW32__) || defined (_MSC_VER)
+// Later versions of MSVC can handle %lld but some older
+// ones can only handle %I64d.  Easiest to simply use
+// %I64d then all versions of MSVC will handle it just fine
+// MinGW is 'same', since it uses msvcrt.dll
+#define LLd "%I64d"
+#else
+#define LLd "%lld"
+#endif
+
+extern struct fmt_main fmt_LM;
+
+static long long tidx;
+
+static void save_state(FILE *file)
+{
+	fprintf(file, LLd"\n", tidx);
+}
+
+static int restore_state(FILE *file)
+{
+	if (fscanf(file, LLd"\n", &gidx) != 1) return 1;
+
+	return 0;
+}
+
+static void fix_state(void)
+{
+	tidx = gidx;
+}
+
+static int show_pwd_rnbs(struct s_pwd * pwd)
+{
+	unsigned long long i;
+	unsigned int k;
+	unsigned long lvl;
+	char pass_filtered[PLAINTEXT_BUFFER_SIZE];
+	char * pass;
+
+	k=0;
+	i = nbparts[pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len];
+	pwd->len++;
+	lvl = pwd->level;
+	pwd->password[pwd->len] = 0;
+	while(i>1)
+	{
+		pwd->password[pwd->len-1] = charsorted[ pwd->password[pwd->len-2]*256 + k ];
+		pwd->level = lvl + proba2[ pwd->password[pwd->len-2]*256 + pwd->password[pwd->len-1] ];
+		i -= nbparts[ pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len ];
+		if(pwd->len<=gmax_len)
+		{
+			if(show_pwd_rnbs(pwd))
+				return 1;
+		}
+		if( (pwd->len >= gmin_len) && (pwd->level >= gmin_level) )
+		{
+			pass = (char*) pwd->password;
+			if (!ext_mode || !f_filter || ext_filter_body((char*) pwd->password, pass = pass_filtered))
+				if(crk_process_key(pass))
+					return 1;
+		}
+		gidx++;
+		k++;
+		if(gidx>gend)
+			return 1;
+	}
+	pwd->len--;
+	pwd->password[pwd->len] = 0;
+	pwd->level = lvl;
+	return 0;
+}
+
+static int show_pwd_r(struct s_pwd * pwd, unsigned int bs)
+{
+	unsigned long long i;
+	unsigned int k;
+	unsigned long lvl;
+	unsigned char curchar;
+	char pass_filtered[PLAINTEXT_BUFFER_SIZE];
+	char * pass;
+
+	k=0;
+	i = nbparts[pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len];
+	pwd->len++;
+	lvl = pwd->level;
+	if(bs)
+	{
+		while( (curchar=charsorted[ pwd->password[pwd->len-2]*256 + k ]) != pwd->password[pwd->len-1] )
+		{
+			i -= nbparts[ curchar + pwd->len*256 + (pwd->level + proba2[ pwd->password[pwd->len-2]*256 + curchar ])*256*gmax_len  ];
+			k++;
+		}
+		pwd->level += proba2[ pwd->password[pwd->len-2]*256 + pwd->password[pwd->len-1] ];
+		if(pwd->password[pwd->len]!=0)
+			if(show_pwd_r(pwd, 1))
+				return 1;
+		i -= nbparts[ pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len ];
+		if( (pwd->len >= gmin_len) && (pwd->level >= gmin_level) )
+		{
+			pass = (char*) pwd->password;
+			if (!ext_mode || !f_filter || ext_filter_body((char*)pwd->password, pass = pass_filtered))
+				if(crk_process_key(pass))
+					return 1;
+		}
+		gidx++;
+		k++;
+	}
+	pwd->password[pwd->len] = 0;
+	while(i>1)
+	{
+		pwd->password[pwd->len-1] = charsorted[ pwd->password[pwd->len-2]*256 + k ];
+		pwd->level = lvl + proba2[ pwd->password[pwd->len-2]*256 + pwd->password[pwd->len-1] ];
+		i -= nbparts[ pwd->password[pwd->len-1] + pwd->len*256 + pwd->level*256*gmax_len ];
+		if(pwd->len<=gmax_len)
+		{
+			if(show_pwd_r(pwd, 0))
+				return 1;
+		}
+		if( (pwd->len >= gmin_len) && (pwd->level >= gmin_level) )
+		{
+			pass = (char*) pwd->password;
+			if (!ext_mode || !f_filter || ext_filter_body((char*)pwd->password, pass = pass_filtered))
+				if(crk_process_key(pass))
+					return 1;
+		}
+		gidx++;
+		k++;
+		if(gidx>gend)
+			return 1;
+	}
+	pwd->len--;
+	pwd->password[pwd->len] = 0;
+	pwd->level = lvl;
+	return 0;
+}
+
+static int show_pwd(unsigned long long start)
+{
+	struct s_pwd pwd;
+	unsigned int i;
+	char pass_filtered[PLAINTEXT_BUFFER_SIZE];
+	char * pass;
+
+	if(gidx==0)
+		gidx = start;
+	i=0;
+
+	if(gidx>0)
+	{
+		print_pwd(gidx, &pwd, gmax_level, gmax_len);
+		while(charsorted[i] != pwd.password[0])
+			i++;
+		pwd.len = 1;
+		pwd.level = proba1[pwd.password[0]];
+		if(show_pwd_r(&pwd, 1))
+			return 1;
+
+		if( (pwd.len >= gmin_len) && (pwd.level >= gmin_level) )
+		{
+			pass = (char*) pwd.password;
+			if (!ext_mode || !f_filter || ext_filter_body((char*)pwd.password, pass = pass_filtered))
+				if(crk_process_key(pass))
+					return 1;
+		}
+		gidx++;
+		i++;
+	}
+	while(proba1[charsorted[i]]<=gmax_level)
+	{
+		if(gidx>gend)
+			return 1;
+		pwd.len = 1;
+		pwd.password[0] = charsorted[i];
+		pwd.level = proba1[pwd.password[0]];
+		pwd.password[1] = 0;
+		if(show_pwd_rnbs(&pwd))
+			return 1;
+		if( (pwd.len >= gmin_len) && (pwd.level >= gmin_level) )
+		{
+			pass = (char*) pwd.password;
+			if (!ext_mode || !f_filter || ext_filter_body((char*)pwd.password, pass = pass_filtered))
+				if(crk_process_key(pass))
+					return 1;
+		}
+		gidx++;
+		i++;
+	}
+	return 0;
+}
+
+static int get_progress(int *hundth_perc)
+{
+	unsigned long long lltmp;
+	unsigned hun;
+	int per;
+
+	if(gend == 0)
+		return 0;
+
+	lltmp = gidx;
+	lltmp -= gstart;
+	lltmp *= 10000;
+	lltmp /= (gend-gstart);
+
+	hun = (unsigned)lltmp;
+	per = (int)(hun/100);
+	*hundth_perc = (int)(hun-(per*100));
+	return per;
+}
+
+
+void do_markov_crack(struct db_main *db, unsigned int mkv_level, unsigned long long mkv_start, unsigned long long mkv_end, unsigned int mkv_maxlen, unsigned int mkv_minlevel, unsigned int mkv_minlen)
+{
+	char * statfile;
+
+#ifdef HAVE_MPI
+	unsigned long long mkv_size;
+#endif
+	if(mkv_level == 0)
+		if( (mkv_level = cfg_get_int("Options", NULL, "MkvLvl")) == -1 )
+		{
+			log_event("no markov level defined!");
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "no markov level defined!\n");
+			error();
+		}
+
+	if(mkv_maxlen == 0)
+		if( (mkv_maxlen = cfg_get_int("Options", NULL, "MkvMaxLen")) == -1 )
+		{
+			log_event("no markov max length defined!");
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "no markov max length defined!\n");
+			error();
+		}
+
+	statfile = cfg_get_param("Options", NULL, "Statsfile");
+	if(statfile == NULL)
+	{
+		log_event("statfile not defined");
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
+		fprintf(stderr, "Statfile not defined\n");
+		error();
+	}
+
+	if (mkv_maxlen > db->format->params.plaintext_length) {
+		log_event("! MaxLen = %d is too large for this hash type",
+			mkv_maxlen);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
+		fprintf(stderr, "Warning: "
+			"MaxLen = %d is too large for the current hash type, "
+			"reduced to %d\n",
+			mkv_maxlen, db->format->params.plaintext_length);
+		mkv_maxlen = db->format->params.plaintext_length;
+	}
+
+	if (mkv_maxlen > MAX_MKV_LEN) {
+		log_event("! MaxLen = %d is too large (max=%d)", mkv_maxlen, MAX_MKV_LEN);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
+		fprintf(stderr, "Warning: Maxlen = %d is too large (max = %d)\n", mkv_maxlen, MAX_MKV_LEN);
+		mkv_maxlen = MAX_MKV_LEN;
+	}
+
+	if (mkv_level > MAX_MKV_LVL) {
+		log_event("! Level = %d is too large (max=%d)", mkv_level, MAX_MKV_LVL);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
+		fprintf(stderr, "Warning: Level = %d is too large (max = %d)\n", mkv_level, MAX_MKV_LVL);
+		mkv_level = MAX_MKV_LVL;
+	}
+
+	gidx = 0;
+	status_init(get_progress, 0);
+	rec_restore_mode(restore_state);
+	rec_init(db, save_state);
+
+	init_probatables(path_expand(statfile));
+
+	crk_init(db, fix_state, NULL);
+
+	gmax_level = mkv_level;
+	gmax_len = mkv_maxlen;
+	gmin_level = mkv_minlevel;
+	gmin_len = mkv_minlen;
+
+	nbparts = mem_alloc(256*(mkv_level+1)*sizeof(long long)*(mkv_maxlen+1));
+	memset(nbparts, 0, 256*(mkv_level+1)*(mkv_maxlen+1)*sizeof(long long));
+
+	nb_parts(0, 0, 0, mkv_level, mkv_maxlen);
+
+	if(mkv_end==0)
+		mkv_end = nbparts[0];
+
+	if(mkv_end>nbparts[0])
+	{
+		log_event("! End = "LLd" is too large (max="LLd")", mkv_end, nbparts[0]);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
+		fprintf(stderr, "Warning: End = "LLd" is too large (max = "LLd")\n", mkv_end, nbparts[0]);
+		mkv_end = nbparts[0];
+	}
+
+	if(mkv_start>mkv_end)
+	{
+		log_event("! MKV start > end ("LLd" > "LLd")", mkv_start, mkv_end);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
+		fprintf(stderr, "Error: MKV start > end ("LLd" > "LLd")\n", mkv_start, mkv_end);
+		error();
+	}
+
+#ifdef HAVE_MPI
+	if (mpi_id == 0) {
+		fprintf(stderr, "MKV start (lvl=");
+		if(mkv_minlevel>0) fprintf(stderr, "%d-", mkv_minlevel);
+		fprintf(stderr, "%d len=", mkv_level);
+		if(mkv_minlen>0) fprintf(stderr, "%d-", mkv_minlen);
+		fprintf(stderr, "%d pwd="LLd"%s)\n", mkv_maxlen, mkv_end-mkv_start,
+		mpi_p > 1 ? " split over MPI nodes" : "");
+	}
+
+	if (mpi_p > 1) {
+		mkv_size = mkv_end - mkv_start + 1;
+		if (mpi_id != (mpi_p - 1))
+			mkv_end = mkv_start + (mkv_size / mpi_p) * (mpi_id + 1) - 1;
+		mkv_start = mkv_start + (mkv_size / mpi_p) * mpi_id;
+	}
+#endif
+	gstart = mkv_start;
+	gend = mkv_end + 10; /* omg !! */
+
+#ifndef HAVE_MPI
+	fprintf(stderr, "MKV start (lvl=");
+	if(mkv_minlevel>0) fprintf(stderr, "%d-", mkv_minlevel);
+	fprintf(stderr, "%d len=", mkv_level);
+	if(mkv_minlen>0) fprintf(stderr, "%d-", mkv_minlen);
+	fprintf(stderr, "%d pwd="LLd")\n", mkv_maxlen, mkv_end-mkv_start);
+#endif
+
+	show_pwd(mkv_start);
+
+	if (!event_abort)
+		gidx = gend; // For reporting DONE properly
+
+	crk_done();
+	rec_done(event_abort);
+
+	MEM_FREE(nbparts);
+	MEM_FREE(proba1);
+	MEM_FREE(proba2);
+	MEM_FREE(first);
+}
diff -rupN john-1.7.8/src/mkv.h john-1.7.8-jumbo-2/src/mkv.h
--- john-1.7.8/src/mkv.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mkv.h	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,17 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#ifndef _JOHN_MKV_H
+#define _JOHN_MKV_H
+
+#include "loader.h"
+#include "mkvlib.h"
+
+/*
+ * Runs the markov mode cracker.
+ */
+extern void do_markov_crack(struct db_main *db, unsigned int mkv_level, unsigned long long mkv_start, unsigned long long mkv_end, unsigned int mkv_maxlen, unsigned int mkv_minlevel, unsigned int mkv_minlen);
+
+#endif
diff -rupN john-1.7.8/src/mkvcalcproba.c john-1.7.8-jumbo-2/src/mkvcalcproba.c
--- john-1.7.8/src/mkvcalcproba.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mkvcalcproba.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,191 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#if !defined (_MSC_VER)
+#include <unistd.h>
+#else
+#pragma warning ( disable : 4244 )
+#endif
+#include <string.h>
+
+#if defined (__MINGW32__) || defined (_MSC_VER)
+// Later versions of MSVC can handle %lld but some older
+// ones can only handle %I64d.  Easiest to simply use
+// %I64d then all versions of MSVC will handle it just fine
+#define LLd "I64d"
+#else
+#define LLd "lld"
+#endif
+
+#define MAX_LVL_LEN 28
+#define MAX_LEN 7
+
+#include "params.h"
+#include "mkvlib.h"
+
+#define C2I(c) ((unsigned int)(unsigned char)(c))
+
+unsigned char * proba1;
+unsigned char * proba2;
+unsigned char * first;
+
+int main(int argc, char * * argv)
+{
+	FILE * fichier;
+	char * ligne;
+	unsigned int i;
+	unsigned int j;
+	unsigned int k;
+	unsigned int l;
+	unsigned long long index;
+	unsigned char position[256];
+	unsigned int charset;
+	unsigned int nb_lignes;
+
+	if(argc!=3)
+	{
+		printf("Usage: %s statfile pwdfile\n", argv[0]);
+		return -1;
+	}
+
+	fichier = fopen(argv[1], "r");
+	if(!fichier)
+	{
+		printf("could not open %s\n", argv[1]);
+		return -1;
+	}
+
+	first = malloc( sizeof(unsigned char) * 256 );
+	if(first == NULL)
+	{
+		perror("malloc first");
+		return 3;
+	}
+
+	ligne = malloc(4096);
+	if(ligne == NULL) { perror("malloc ligne"); return 3; }
+	proba2 = malloc(sizeof(unsigned char) * 256 * 256);
+	if(proba2 == NULL) { perror("malloc proba2"); return 3; }
+	proba1 = malloc(sizeof(unsigned char) * 256 );
+	if(proba1 == NULL) { perror("malloc proba1"); return 3; }
+	for(i=0;i<256*256;i++)
+		proba2[i] = UNK_STR;
+	for(i=0;i<256;i++)
+		proba1[i] = UNK_STR;
+
+	for(i=0;i<256;i++)
+	{
+		first[i] = 255;
+		position[i] = 255;
+	}
+
+	nb_lignes = 0;
+	charset = 0;
+	fprintf(stderr, "reading stats ... [%p]\n", fichier);
+	while(fgets(ligne, 4096, fichier))
+	{
+		if (ligne[0] == 0)
+		{
+			fprintf(stderr, "empty line?\n");
+			continue;
+		}
+		ligne[strlen(ligne)-1] = 0; // chop
+		if( sscanf(ligne, "%d=proba1[%d]", &i, &j) == 2 )
+		{
+			if( j>255 )
+			{
+				fprintf(stderr, "invalid line %s\n", ligne);
+				continue;
+			}
+			proba1[j] = i;
+			if(position[j] == 255)
+			{
+				position[j] = charset;
+				charset++;
+			}
+		}
+		else if( sscanf(ligne, "%d=proba2[%d*256+%d]", &i, &j, &k) == 3 )
+		{
+			if( (j>255) || (k>255) )
+			{
+				fprintf(stderr, "invalid line %s\n", ligne);
+				continue;
+			}
+			if( (first[j]>k) && (i<UNK_STR))
+				first[j] = k;
+			proba2[j*256+k] = i;
+			if(position[k] == 255)
+			{
+				position[k] = charset;
+				charset++;
+			}
+		}
+		else
+			fprintf(stderr, "invalid line %s\n", ligne);
+		nb_lignes++;
+	}
+	fprintf(stderr, "%d lines parsed [%p]\n", nb_lignes, fichier);
+	fclose(fichier);
+
+	fichier = fopen(argv[2], "r");
+	if(!fichier)
+	{
+		printf("could not open %s\n", argv[2]);
+		return -1;
+	}
+
+	fprintf(stderr, "scanning password file ...\n");
+	while(fgets(ligne, 4096, fichier))
+	{
+		if (ligne[0] == 0)
+			continue;
+		ligne[strlen(ligne)-1] = 0; // chop
+		i=1; j=0; k=0;
+		j = C2I(ligne[0]);
+		k = proba1[j];
+		if(ligne[0]==0)
+			k = 0;
+		printf("%s\t%d", ligne, k);
+		l = 0;
+		index = position[j];
+		if(position[j]==255)
+			index = 8.1E18;
+		while(ligne[i])
+		{
+			if(index<8E18)
+				index = (index*charset)+position[C2I(ligne[i])];
+			if(position[C2I(ligne[i])]==255)
+				index = 8.1E18;
+			printf("+%d", proba2[j*256+C2I(ligne[i])]);
+			k+=proba2[j*256+C2I(ligne[i])];
+			if(l)
+				l+=proba2[j*256+C2I(ligne[i])];
+			if(i==2)
+				l=proba1[C2I(ligne[i])];
+			j = C2I(ligne[i]);
+			i++;
+		}
+		if(index<8E18)
+			printf("\t%d\t%d\t%"LLd"\t%d\n",k,i,index,l);
+		else
+			printf("\t%d\t%d\t-\t%d\n",k,i,l);
+	}
+	fprintf(stderr, "freeing stuff ...\n");
+
+	fclose(fichier);
+
+	free(proba1);
+	free(proba2);
+
+	free(first);
+
+	free(ligne);
+
+	fprintf(stderr, "charsetsize = %d\n", charset);
+
+	return 0;
+}
diff -rupN john-1.7.8/src/mkvlib.c john-1.7.8-jumbo-2/src/mkvlib.c
--- john-1.7.8/src/mkvlib.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mkvlib.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,222 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#include <stdio.h>
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "params.h"
+#include "memory.h"
+#include "mkvlib.h"
+
+unsigned char * proba1;
+unsigned char * proba2;
+unsigned long long * nbparts;
+unsigned char * first;
+unsigned char charsorted[256*256];
+
+unsigned int gmax_level;
+unsigned int gmax_len;
+unsigned int gmin_level;
+unsigned int gmin_len;
+unsigned long long gidx;
+unsigned long long gstart;
+unsigned long long gend;
+
+unsigned long long nb_parts(unsigned char lettre, unsigned int len, unsigned int level, unsigned int max_lvl, unsigned int max_len)
+{
+        int i;
+        unsigned long long out=1;
+
+        if(level>max_lvl)
+                return 0;
+
+        if(len==max_len)
+        {
+                nbparts[lettre + len*256 + level*256*max_len] = 1;
+                return 1;
+        }
+
+        if(nbparts[lettre + (len)*256 + level*256*max_len] != 0)
+                return nbparts[lettre + (len)*256 + level*256*max_len];
+
+        for(i=1;i<256;i++)
+                if(len==0)
+                        out += nb_parts(i, len+1, proba1[i], max_lvl, max_len);
+                else
+                        out += nb_parts(i, len+1, level + proba2[lettre*256 + i], max_lvl, max_len);
+
+        nbparts[lettre + (len)*256 + level*256*max_len] = out;
+        return out;
+}
+
+void print_pwd(unsigned long long index, struct s_pwd * pwd, unsigned int max_lvl, unsigned int max_len)
+{
+	unsigned int len = 1;
+	unsigned int level = 0;
+	unsigned int lvl = 0;
+	unsigned int i;
+	unsigned int oldc = 0;
+
+	if(index>nbparts[0])
+		return;
+
+	len = 1;
+	while(index && (len<=max_len))
+	{
+
+		for(i=0;i<256;i++)
+		{
+			if(len==1)
+				level = proba1[charsorted[256*0+i]];
+			else
+			{
+				level = lvl + proba2[oldc*256 + charsorted[oldc*256+i]];
+			}
+
+			if( level > max_lvl )
+			{
+				i=256;
+				break;
+			}
+
+			if(nbparts[charsorted[oldc*256+i] + len*256 + level*256*max_len]==0)
+			{
+				break;
+			}
+
+			if (index <= nbparts[charsorted[oldc*256+i] + len*256 + level*256*max_len])
+				break;
+
+			index -= nbparts[charsorted[oldc*256+i] + len*256 + level*256*max_len];
+		}
+		if(i==256)
+			break;
+		lvl = level;
+		pwd->password[len-1] = charsorted[oldc*256+i];
+		oldc = charsorted[oldc*256+i];
+		len++;
+	}
+	pwd->password[len-1] = 0;
+	pwd->index = index;
+	pwd->level = lvl;
+	pwd->len = len-1;
+}
+
+
+static void stupidsort(unsigned char * result, unsigned char * source, unsigned int size)
+{
+	unsigned char pivot;
+	unsigned char more[256];
+	unsigned char less[256];
+	unsigned char piv[256];
+	unsigned int i,m,l,p;
+
+	if(size<=1)
+		return;
+	i=0;
+	while( (i<size) && (source[result[i]]==UNK_STR))
+		i++;
+	if(i==size)
+		return;
+	pivot = result[i];
+	if(size<=1)
+		return;
+	m=0;
+	l=0;
+	p=0;
+	for(i=0;i<size;i++)
+	{
+		if(source[result[i]]==source[pivot])
+		{
+			piv[p] = result[i];
+			p++;
+		}
+		else if(source[result[i]]<=source[pivot])
+		{
+			less[l] = result[i];
+			l++;
+		}
+		else
+		{
+			more[m] = result[i];
+			m++;
+		}
+	}
+	stupidsort(less, source, l);
+	stupidsort(more, source, m);
+	memcpy(result, less, l);
+	memcpy(result+l, piv, p);
+	memcpy(result+l+p, more, m);
+}
+
+void init_probatables(char * filename)
+{
+	FILE * fichier;
+	char * ligne;
+	unsigned int i;
+	unsigned int j;
+	unsigned int k;
+	unsigned int nb_lignes;
+
+	fichier = fopen(filename, "r");
+	if(!fichier)
+	{
+		fprintf(stderr, "could not open %s\n", filename);
+		error();
+	}
+
+	first = mem_alloc( sizeof(unsigned char) * 256 );
+	ligne = mem_alloc(4096);
+	proba2 = mem_alloc(sizeof(unsigned char) * 256 * 256);
+	proba1 = mem_alloc(sizeof(unsigned char) * 256 );
+
+	for(j=0;j<256*256;j++)
+		proba2[j] = UNK_STR;
+	for(j=0;j<256;j++)
+		proba1[j] = UNK_STR;
+
+	for(i=0;i<256;i++)
+	{
+		first[i] = 255;
+		for(j=0;j<256;j++)
+		{
+			charsorted[i*256+j] = j;
+		}
+	}
+
+	nb_lignes = 0;
+	while(fgets(ligne, 4096, fichier))
+	{
+		if (ligne[0] == 0)
+			continue;
+		ligne[strlen(ligne)-1] = 0; // chop
+		if( sscanf(ligne, "%d=proba1[%d]", &i, &j) == 2 )
+		{
+			if(i>UNK_STR)
+				i = UNK_STR;
+			proba1[j] = i;
+		}
+		if( sscanf(ligne, "%d=proba2[%d*256+%d]", &i, &j, &k) == 3 )
+		{
+			if(i>UNK_STR)
+				i = UNK_STR;
+			if( (first[j]>k) && (i<UNK_STR))
+				first[j] = k;
+			proba2[j*256+k] = i;
+
+		}
+		nb_lignes++;
+	}
+	MEM_FREE(ligne);
+	fclose(fichier);
+
+	stupidsort(charsorted, proba1, 256);
+	for(i=1;i<256;i++)
+		stupidsort(&(charsorted[i*256]), &(proba2[i*256]), 256);
+}
+
+
diff -rupN john-1.7.8/src/mkvlib.h john-1.7.8-jumbo-2/src/mkvlib.h
--- john-1.7.8/src/mkvlib.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mkvlib.h	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,36 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#ifndef _JOHN_MKVLIB_H
+#define _JOHN_MKVLIB_H
+
+#define UNK_STR	255
+
+struct s_pwd
+{
+	unsigned int level;
+	unsigned int len;
+	unsigned int index;
+	unsigned char password[MAX_MKV_LEN+1];
+};
+
+extern unsigned char * proba1;
+extern unsigned char * proba2;
+extern unsigned long long * nbparts;
+extern unsigned char * first;
+extern unsigned char charsorted[256*256];
+
+extern unsigned int gmax_level;
+extern unsigned int gmax_len;
+extern unsigned int gmin_level;
+extern unsigned int gmin_len;
+extern unsigned long long gidx;
+extern unsigned long long gstart;
+extern unsigned long long gend;
+
+void print_pwd(unsigned long long index, struct s_pwd * pwd, unsigned int max_lvl, unsigned int max_len);
+unsigned long long nb_parts(unsigned char lettre, unsigned int len, unsigned int level, unsigned int max_lvl, unsigned int max_len);
+void init_probatables(char * filename);
+#endif
diff -rupN john-1.7.8/src/mscash1_fmt_plug.c john-1.7.8-jumbo-2/src/mscash1_fmt_plug.c
--- john-1.7.8/src/mscash1_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mscash1_fmt_plug.c	2011-07-02 22:22:06.000000000 +0200
@@ -0,0 +1,869 @@
+/* MSCASH patch for john (performance improvement)
+ *
+ * Modified for utf-8 support by magnum in 2011, same terms as below
+ *
+ * Written by Alain Espinosa <alainesp at gmail.com> in 2007.  No copyright
+ * is claimed, and the software is hereby placed in the public domain.
+ * In case this attempt to disclaim copyright and place the software in the
+ * public domain is deemed null and void, then the software is
+ * Copyright (c) 2007 Alain Espinosa and it is hereby released to the
+ * general public under the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * There's ABSOLUTELY NO WARRANTY, express or implied.
+ *
+ * (This is a heavily cut-down "BSD license".)
+ */
+
+#include <string.h>
+#include "arch.h"
+#include "misc.h"
+#include "memory.h"
+#include "common.h"
+#include "formats.h"
+#include "unicode.h"
+#include "options.h"
+
+#define FORMAT_LABEL			"mscash"
+#define FORMAT_NAME			"M$ Cache Hash"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		27
+#define MAX_CIPHERTEXT_LENGTH		(2 + 19*3 + 1 + 32) // x3 because salt may be UTF-8 in input
+
+
+/* Note: some tests will be replaced in init() if running UTF-8 */
+static struct fmt_tests tests[] = {
+	{"M$test1#64cd29e36a8431a2b111378564a10631", "test1" },
+	{"M$\xFC#48f84e6f73d6d5305f6558a33fa2c9bb", "\xFC" },         // German u-umlaut in ISO-8859-1
+	{"M$\xFC\xFC#593246a8335cf0261799bda2a2a9c623", "\xFC\xFC" }, // Two of the above
+	{"176a4c2bd45ac73687676c2f09045353", "", {"root"} }, // nullstring password
+	{"M$test2#ab60bdb4493822b175486810ac2abe63", "test2" },
+	{"M$test3#14dd041848e12fc48c0aa7a416a4a00c", "test3" },
+	{"M$test4#b945d24866af4b01a6d89b9d932a153c", "test4" },
+
+	{"64cd29e36a8431a2b111378564a10631", "test1", {"TEST1"} },    // salt is lowercased before hashing
+	{"290efa10307e36a79b3eebf2a6b29455", "okolada", {"nineteen_characters"} }, // max salt length
+	{"ab60bdb4493822b175486810ac2abe63", "test2", {"test2"} },
+	{"b945d24866af4b01a6d89b9d932a153c", "test4", {"test4"} },
+	{NULL}
+};
+
+#define ALGORITHM_NAME			"Generic 1x"
+
+#define BINARY_SIZE			16
+#define SALT_SIZE			(11*4)
+
+#define OK_NUM_KEYS			64
+#define BEST_NUM_KEYS			512
+#ifdef _OPENMP
+#define MS_NUM_KEYS			(OK_NUM_KEYS * 96)
+#else
+#define MS_NUM_KEYS			BEST_NUM_KEYS
+#endif
+#define MIN_KEYS_PER_CRYPT		OK_NUM_KEYS
+#define MAX_KEYS_PER_CRYPT		MS_NUM_KEYS
+
+
+static unsigned int ms_buffer1x[16*MS_NUM_KEYS];
+static unsigned int output1x[4*MS_NUM_KEYS];
+
+static unsigned int crypt[4*MS_NUM_KEYS];
+static unsigned int last[4*MS_NUM_KEYS];
+
+static unsigned int last_i[MS_NUM_KEYS];
+
+static unsigned int *salt_buffer;
+static unsigned int new_key;
+
+//Init values
+#define INIT_A 0x67452301
+#define INIT_B 0xefcdab89
+#define INIT_C 0x98badcfe
+#define INIT_D 0x10325476
+
+#define SQRT_2 0x5a827999
+#define SQRT_3 0x6ed9eba1
+
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+static void set_key_utf8(char *_key, int index);
+static char *get_key_utf8(int index);
+static void * get_salt_utf8(char *_ciphertext);
+struct fmt_main fmt_mscash;
+
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = omp_get_max_threads(), nmin, nmax;
+	if (n < 1)
+		n = 1;
+	nmin = OK_NUM_KEYS - (OK_NUM_KEYS % n);
+	if (nmin < n)
+		nmin = n;
+	fmt_mscash.params.min_keys_per_crypt = nmin;
+	nmax = n * BEST_NUM_KEYS;
+	if (nmax > MS_NUM_KEYS)
+		nmax = MS_NUM_KEYS;
+	fmt_mscash.params.max_keys_per_crypt = nmax;
+#endif
+	memset(ms_buffer1x,0,64*MS_NUM_KEYS);
+	memset(last_i,0,4*MS_NUM_KEYS);
+	new_key=1;
+
+	if (options.flags & FLG_UTF8) {
+		fmt_mscash.methods.set_key = set_key_utf8;
+		fmt_mscash.methods.get_key = get_key_utf8;
+		fmt_mscash.methods.salt = get_salt_utf8;
+		fmt_mscash.params.plaintext_length = (PLAINTEXT_LENGTH * 3);
+		tests[1].ciphertext = "M$\xC3\xBC#48f84e6f73d6d5305f6558a33fa2c9bb";
+		tests[1].plaintext = "\xC3\xBC";         // German u-umlaut in UTF-8
+		tests[2].ciphertext = "M$user#9121790702dda0fa5d353014c334c2ce";
+		tests[2].plaintext = "\xe2\x82\xac\xe2\x82\xac"; // 2 x Euro signs
+	}
+}
+
+static char * ms_split(char *ciphertext, int index)
+{
+	static char out[MAX_CIPHERTEXT_LENGTH + 1];
+	int i=0;
+
+	for(; ciphertext[i] && i < MAX_CIPHERTEXT_LENGTH; i++)
+		out[i]=ciphertext[i];
+
+	out[i]=0;
+
+	// lowercase salt as well as hash
+	strlwr(&out[2]);
+
+	return out;
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	unsigned int i;
+	unsigned int l;
+	char insalt[3*19+1];
+	UTF16 realsalt[20];
+	int saltlen;
+
+	if (strncmp(ciphertext, "M$", 2))
+		return 0;
+
+	l = strlen(ciphertext);
+	if (l <= 32 || l > MAX_CIPHERTEXT_LENGTH)
+		return 0;
+
+	l -= 32;
+	if(ciphertext[l-1]!='#')
+		return 0;
+
+	for (i = l; i < l + 32; i++)
+		if (atoi16[ARCH_INDEX(ciphertext[i])] == 0x7F)
+			return 0;
+
+	// This is tricky: Max supported salt length is 19 characters of Unicode
+	saltlen = plaintowcs(realsalt, 20, (UTF8*)strnzcpy(insalt, &ciphertext[2], l - 2), l - 3);
+	if (saltlen < 0 || saltlen > 19)
+			return 0;
+
+	return 1;
+}
+
+static char *prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	char *cp;
+	if (!strncmp(split_fields[1], "M$", 2))
+		return split_fields[1];
+	cp = mem_alloc(strlen(split_fields[0]) + strlen(split_fields[1]) + 4);
+	sprintf (cp, "M$%s#%s", split_fields[0], split_fields[1]);
+	if (valid(cp, pFmt))
+	{
+		char *cipher = str_alloc_copy(cp);
+		MEM_FREE(cp);
+		return cipher;
+	}
+	MEM_FREE(cp);
+	return split_fields[1];
+}
+
+static void set_salt(void *salt) {
+	salt_buffer=salt;
+}
+
+static void * get_salt(char *_ciphertext)
+{
+	unsigned char *ciphertext = (unsigned char *)_ciphertext;
+	// length=11 for save memory
+	// position 10 = length
+	// 0-9 = 1-19 Unicode characters + EOS marker (0x80)
+	static unsigned int out[11];
+	unsigned int md4_size=0;
+
+	memset(out,0,44);
+
+	ciphertext+=2;
+
+	for(;;md4_size++)
+		if(ciphertext[md4_size]!='#' && md4_size < 19)
+		{
+			md4_size++;
+
+			out[md4_size>>1] = ciphertext[md4_size-1] | ((ciphertext[md4_size]!='#') ? (ciphertext[md4_size]<<16) : 0x800000);
+
+			if(ciphertext[md4_size]=='#')
+				break;
+		}
+		else
+		{
+			out[md4_size>>1] = 0x80;
+			break;
+		}
+
+	out[10] = (8 + md4_size) << 4;
+
+	return out;
+}
+
+static void * get_salt_utf8(char *_ciphertext)
+{
+	unsigned char *ciphertext = (unsigned char *)_ciphertext;
+	static ARCH_WORD_32 out[11];
+	unsigned int md4_size=0;
+	UTF16 ciphertext_utf16[20];
+	int len;
+
+	memset(out,0,sizeof(out));
+	ciphertext+=2;
+	len = ((unsigned char*)strchr((char*)ciphertext, '#')) - ciphertext;
+	utf8towcs(ciphertext_utf16, 20, ciphertext, strlen((char*)ciphertext));
+
+	for(;;md4_size++) {
+#if !ARCH_LITTLE_ENDIAN
+		ciphertext_utf16[md4_size] = (ciphertext_utf16[md4_size]>>8)|(ciphertext_utf16[md4_size]<<8);
+		ciphertext_utf16[md4_size+1] = (ciphertext_utf16[md4_size+1]>>8)|(ciphertext_utf16[md4_size+1]<<8);
+#endif
+		if(ciphertext_utf16[md4_size]!=(UTF16)'#' && md4_size < 19) {
+			md4_size++;
+			out[md4_size>>1] = ciphertext_utf16[md4_size-1] |
+				((ciphertext_utf16[md4_size]!=(UTF16)'#') ?
+				 (ciphertext_utf16[md4_size]<<16) : 0x800000);
+
+			if(ciphertext_utf16[md4_size]==(UTF16)'#')
+				break;
+		}
+		else {
+			out[md4_size>>1] = 0x80;
+			break;
+		}
+	}
+
+	out[10] = (8 + md4_size) << 4;
+
+	return out;
+}
+
+static void *get_binary(char *ciphertext)
+{
+	static unsigned int out[4];
+	unsigned int i=0;
+	unsigned int temp;
+	unsigned int * salt=fmt_mscash.methods.salt(ciphertext);
+
+	for(;ciphertext[0]!='#';ciphertext++);
+
+	ciphertext++;
+
+	for(; i<4 ;i++)
+	{
+		temp  = (atoi16[ARCH_INDEX(ciphertext[i*8+0])])<<4;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+1])]);
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+2])])<<12;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+3])])<<8;
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+4])])<<20;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+5])])<<16;
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+6])])<<28;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i*8+7])])<<24;
+
+		out[i]=temp;
+	}
+
+	out[0] -= INIT_A;
+	out[1] -= INIT_B;
+	out[2] -= INIT_C;
+	out[3] -= INIT_D;
+
+	// Reversed	b += (c ^ d ^ a) + salt_buffer[11] +  SQRT_3; b = (b << 15) | (b >> 17);
+	out[1]  = (out[1] >> 15) | (out[1] << 17);
+	out[1] -= SQRT_3 + (out[2] ^ out[3] ^ out[0]);
+	// Reversed	c += (d ^ a ^ b) + salt_buffer[3]  +  SQRT_3; c = (c << 11) | (c >> 21);
+	out[2] = (out[2] << 21) | (out[2] >> 11);
+	out[2]-= SQRT_3 + (out[3] ^ out[0] ^ out[1]) + salt[3];
+	// Reversed	d += (a ^ b ^ c) + salt_buffer[7]  +  SQRT_3; d = (d << 9 ) | (d >> 23);
+	out[3]  = (out[3] << 23) | (out[3] >> 9);
+	out[3] -= SQRT_3 + (out[0] ^ out[1] ^ out[2]) + salt[7];
+	//+ SQRT_3; d = (d << 9 ) | (d >> 23);
+	out[3]=(out[3] << 23 ) | (out[3] >> 9);
+	out[3]-=SQRT_3;
+
+	return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0F;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0FFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0FFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0FFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return output1x[4*index+3] & 0x0F;
+}
+
+static int get_hash_1(int index)
+{
+	return output1x[4*index+3] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return output1x[4*index+3] & 0x0FFF;
+}
+
+static int get_hash_3(int index)
+{
+	return output1x[4*index+3] & 0x0FFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return output1x[4*index+3] & 0x0FFFFF;
+}
+
+static void nt_hash(int count)
+{
+	int i;
+
+#if MS_NUM_KEYS > 1 && defined(_OPENMP)
+#pragma omp parallel for default(none) private(i) shared(count, ms_buffer1x, crypt, last)
+#endif
+	for (i = 0; i < count; i++)
+	{
+		unsigned int a;
+		unsigned int b;
+		unsigned int c;
+		unsigned int d;
+
+		/* Round 1 */
+		a = 		0xFFFFFFFF 		  + ms_buffer1x[16*i+0];a = (a << 3 ) | (a >> 29);
+		d = INIT_D + (INIT_C ^ (a & 0x77777777))  + ms_buffer1x[16*i+1];d = (d << 7 ) | (d >> 25);
+		c = INIT_C + (INIT_B ^ (d & (a ^ INIT_B)))+ ms_buffer1x[16*i+2];c = (c << 11) | (c >> 21);
+		b =    INIT_B + (a ^ (c & (d ^ a))) 	  + ms_buffer1x[16*i+3];b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d))) + ms_buffer1x[16*i+4]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c))) + ms_buffer1x[16*i+5]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b))) + ms_buffer1x[16*i+6]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a))) + ms_buffer1x[16*i+7]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d))) + ms_buffer1x[16*i+8]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c))) + ms_buffer1x[16*i+9]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b))) + ms_buffer1x[16*i+10] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a))) + ms_buffer1x[16*i+11] ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d))) + ms_buffer1x[16*i+12] ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c))) + ms_buffer1x[16*i+13] ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b))) + ms_buffer1x[16*i+14] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))/*+ms_buffer1x[16*i+15]*/;b = (b << 19) | (b >> 13);
+
+		/* Round 2 */
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16*i+0]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16*i+4]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16*i+8]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a)) + ms_buffer1x[16*i+12] + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16*i+1]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16*i+5]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16*i+9]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a)) + ms_buffer1x[16*i+13] + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16*i+2]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16*i+6]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16*i+10] + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a)) + ms_buffer1x[16*i+14] + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16*i+3]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16*i+7]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16*i+11] + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))/*+ms_buffer1x[16*i+15]*/+SQRT_2; b = (b << 13) | (b >> 19);
+
+		/* Round 3 */
+		a += (b ^ c ^ d) + ms_buffer1x[16*i+0]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16*i+8]  + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16*i+4]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + ms_buffer1x[16*i+12] + SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + ms_buffer1x[16*i+2]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16*i+10] + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16*i+6]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + ms_buffer1x[16*i+14] + SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + ms_buffer1x[16*i+1]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16*i+9]  + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16*i+5]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + ms_buffer1x[16*i+13] + SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + ms_buffer1x[16*i+3]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16*i+11] + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16*i+7]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) /*+ ms_buffer1x[16*i+15] */+ SQRT_3; b = (b << 15) | (b >> 17);
+
+		crypt[4*i+0] = a + INIT_A;
+		crypt[4*i+1] = b + INIT_B;
+		crypt[4*i+2] = c + INIT_C;
+		crypt[4*i+3] = d + INIT_D;
+
+		//Another MD4_crypt for the salt
+		/* Round 1 */
+		a= 	        0xFFFFFFFF 	            +crypt[4*i+0]; a=(a<<3 )|(a>>29);
+		d=INIT_D + ( INIT_C ^ ( a & 0x77777777))    +crypt[4*i+1]; d=(d<<7 )|(d>>25);
+		c=INIT_C + ( INIT_B ^ ( d & ( a ^ INIT_B))) +crypt[4*i+2]; c=(c<<11)|(c>>21);
+		b=INIT_B + (    a   ^ ( c & ( d ^    a  ))) +crypt[4*i+3]; b=(b<<19)|(b>>13);
+
+		last[4*i+0]=a;
+		last[4*i+1]=b;
+		last[4*i+2]=c;
+		last[4*i+3]=d;
+	}
+}
+
+static void crypt_all(int count)
+{
+	int i;
+
+	if(new_key)
+	{
+		new_key=0;
+		nt_hash(count);
+	}
+
+#if MS_NUM_KEYS > 1 && defined(_OPENMP)
+#pragma omp parallel for default(none) private(i) shared(count, last, crypt, salt_buffer, output1x)
+#endif
+	for(i = 0; i < count; i++)
+	{
+		unsigned int a;
+		unsigned int b;
+		unsigned int c;
+		unsigned int d;
+
+		a = last[4*i+0];
+		b = last[4*i+1];
+		c = last[4*i+2];
+		d = last[4*i+3];
+
+		a += (d ^ (b & (c ^ d)))  + salt_buffer[0]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  + salt_buffer[1]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  + salt_buffer[2]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))  + salt_buffer[3]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d)))  + salt_buffer[4]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  + salt_buffer[5]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  + salt_buffer[6]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))  + salt_buffer[7]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d)))  + salt_buffer[8]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  + salt_buffer[9]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  + salt_buffer[10] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))/*+salt_buffer[11]*/;b = (b << 19) | (b >> 13);
+
+		/* Round 2 */
+		a += ((b & (c | d)) | (c & d))  +  crypt[4*i+0]    + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[0]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[4]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))  +  salt_buffer[8]  + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d))  +  crypt[4*i+1]    + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[1]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[5]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))  +  salt_buffer[9]  + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d))  +  crypt[4*i+2]    + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[2]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[6]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))  +  salt_buffer[10] + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d))  +  crypt[4*i+3]    + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[3]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[7]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))/*+ salt_buffer[11]*/+ SQRT_2; b = (b << 13) | (b >> 19);
+
+		/* Round 3 */
+		a += (b ^ c ^ d) + crypt[4*i+0]    +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + salt_buffer[4]  +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + salt_buffer[0]  +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + salt_buffer[8]  +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + crypt[4*i+2]    +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + salt_buffer[6]  +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + salt_buffer[2]  +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + salt_buffer[10] +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + crypt[4*i+1]    +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + salt_buffer[5];
+
+		output1x[4*i+0]=a;
+		output1x[4*i+1]=b;
+		output1x[4*i+2]=c;
+		output1x[4*i+3]=d;
+	}
+}
+
+static int cmp_all(void *binary, int count)
+{
+	unsigned int i=0;
+	unsigned int d=((unsigned int *)binary)[3];
+
+	for(;i<count;i++)
+		if(d==output1x[i*4+3])
+			return 1;
+
+	return 0;
+}
+
+static int cmp_one(void * binary, int index)
+{
+	unsigned int *t=(unsigned int *)binary;
+	unsigned int a=output1x[4*index+0];
+	unsigned int b=output1x[4*index+1];
+	unsigned int c=output1x[4*index+2];
+	unsigned int d=output1x[4*index+3];
+
+	if(d!=t[3])
+		return 0;
+	d+=SQRT_3;d = (d << 9 ) | (d >> 23);
+
+	c += (d ^ a ^ b) + salt_buffer[1]  +  SQRT_3; c = (c << 11) | (c >> 21);
+	if(c!=t[2])
+		return 0;
+
+	b += (c ^ d ^ a) + salt_buffer[9]  +  SQRT_3; b = (b << 15) | (b >> 17);
+	if(b!=t[1])
+		return 0;
+
+	a += (b ^ c ^ d) + crypt[4*index+3]+  SQRT_3; a = (a << 3 ) | (a >> 29);
+	return (a==t[0]);
+}
+
+static int cmp_exact(char *source, int index)
+{
+	// This check its for the unreal case of collisions.
+	// It verify that the salts its the same.
+	unsigned int *salt=fmt_mscash.methods.salt(source);
+	unsigned int i=0;
+	for(;i<11;i++)
+		if(salt[i]!=salt_buffer[i])
+			return 0;
+	return 1;
+}
+
+// This is common code for the SSE/MMX/generic variants of non-UTF8 set_key
+static inline void set_key_helper(unsigned int * keybuffer,
+                                  unsigned int xBuf,
+                                  const unsigned char * key,
+                                  unsigned int lenStoreOffset,
+                                  unsigned int *last_length)
+{
+	unsigned int i=0;
+	unsigned int md4_size=0;
+	for(; key[md4_size] && md4_size < PLAINTEXT_LENGTH; i += xBuf, md4_size++)
+	{
+		unsigned int temp;
+		if ((temp = key[++md4_size]))
+		{
+			keybuffer[i] = key[md4_size-1] | (temp << 16);
+		}
+		else
+		{
+			keybuffer[i] = key[md4_size-1] | 0x800000;
+			goto key_cleaning;
+		}
+	}
+	keybuffer[i] = 0x80;
+
+key_cleaning:
+	i += xBuf;
+	for(;i <= *last_length; i += xBuf)
+		keybuffer[i] = 0;
+
+	*last_length = (md4_size >> 1)+1;
+
+	keybuffer[lenStoreOffset] = md4_size << 4;
+}
+
+static void set_key(char *_key, int index)
+{
+	set_key_helper(&ms_buffer1x[index << 4], 1, (unsigned char *)_key, 14,
+	               &last_i[index]);
+	//new password_candidate
+	new_key=1;
+//dump_stuff_msg("setkey     ", (unsigned char*)&ms_buffer1x[index << 4], 40);
+//{static int i;if (++i==1)exit(0);}
+}
+
+// We can get our key back from the key buffer instead of storing it
+// This is common code for the SSE/MMX/generic variants
+static inline char *get_key_helper(unsigned int * keybuffer, unsigned int xBuf)
+{
+	static unsigned char key[PLAINTEXT_LENGTH + 1];
+	unsigned int md4_size=0;
+	unsigned int i=0;
+
+	for(; md4_size < PLAINTEXT_LENGTH; i += xBuf, md4_size++)
+	{
+		key[md4_size] = keybuffer[i];
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+		key[++md4_size] = keybuffer[i] >> 16;
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+	}
+	return (char *) key;
+}
+
+static char *get_key(int index)
+{
+	return get_key_helper(&ms_buffer1x[index << 4], 1);
+}
+
+// UTF-8 conversion right into key buffer
+// This is common code for the SSE/MMX/generic variants
+static inline void set_key_helper_utf8(unsigned int * keybuffer, unsigned int xBuf,
+    const UTF8 * source, unsigned int lenStoreOffset, unsigned int *lastlen)
+{
+	unsigned int *target = keybuffer;
+	unsigned int *targetEnd = &keybuffer[xBuf * ((PLAINTEXT_LENGTH + 1) >> 1)];
+	UTF32 chl, chh = 0x80;
+	unsigned int outlen = 0;
+
+	while (*source) {
+		chl = *source;
+		if (chl >= 0xC0) {
+			unsigned int extraBytesToRead = opt_trailingBytesUTF8[chl & 0x3f];
+			switch (extraBytesToRead) {
+			case 2:
+				++source;
+				if (*source) {
+					chl <<= 6;
+					chl += *source;
+				} else {
+					*lastlen = ((27 >> 1) + 1) * xBuf;
+					return;
+				}
+			case 1:
+				++source;
+				if (*source) {
+					chl <<= 6;
+					chl += *source;
+				} else {
+					*lastlen = ((27 >> 1) + 1) * xBuf;
+					return;
+				}
+			case 0:
+				break;
+			default:
+				*lastlen = ((27 >> 1) + 1) * xBuf;
+				return;
+			}
+			chl -= offsetsFromUTF8[extraBytesToRead];
+		}
+		source++;
+		outlen++;
+		if (*source) {
+			chh = *source;
+			if (chh >= 0xC0) {
+				unsigned int extraBytesToRead =
+					opt_trailingBytesUTF8[chh & 0x3f];
+				switch (extraBytesToRead) {
+				case 2:
+					++source;
+					if (*source) {
+						chh <<= 6;
+						chh += *source;
+					} else {
+						*lastlen = ((27 >> 1) + 1) * xBuf;
+						return;
+					}
+				case 1:
+					++source;
+					if (*source) {
+						chh <<= 6;
+						chh += *source;
+					} else {
+						*lastlen = ((27 >> 1) + 1) * xBuf;
+						return;
+					}
+				case 0:
+					break;
+				default:
+					*lastlen = ((27 >> 1) + 1) * xBuf;
+					return;
+				}
+				chh -= offsetsFromUTF8[extraBytesToRead];
+			}
+			source++;
+			outlen++;
+		} else {
+			chh = 0x80;
+		}
+		*target = chh << 16 | chl;
+		target += xBuf;
+		if (*source == 0) {
+			break;
+		}
+		if (target >= targetEnd) {
+			break;
+		}
+	}
+	if (chh != 0x80 || outlen == 0) {
+		*target = 0x80;
+		target += xBuf;
+	}
+
+	while(target < &keybuffer[*lastlen]) {
+		*target = 0;
+		target += xBuf;
+	}
+
+	*lastlen = ((outlen >> 1) + 1) * xBuf;
+	keybuffer[lenStoreOffset] = outlen << 4;
+}
+
+static void set_key_utf8(char *_key, int index)
+{
+	set_key_helper_utf8(&ms_buffer1x[index << 4], 1, (UTF8 *)_key, 14,
+	                &last_i[index]);
+	//new password_candidate
+	new_key=1;
+//dump_stuff_msg("setkey utf8", (unsigned char*)&ms_buffer1x[index << 4], 40);
+//{static int i;if (++i==1)exit(0);}
+}
+
+// Get the key back from the key buffer, from UCS-2
+// This is common code for the SSE/MMX/generic variants
+static inline UTF16 *get_key_helper_utf8(unsigned int * keybuffer, unsigned int xBuf)
+{
+	static UTF16 key[PLAINTEXT_LENGTH + 1];
+	unsigned int md4_size=0;
+	unsigned int i=0;
+
+	for(; md4_size < PLAINTEXT_LENGTH; i += xBuf, md4_size++)
+	{
+		key[md4_size] = keybuffer[i];
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+		key[++md4_size] = keybuffer[i] >> 16;
+		if (key[md4_size] == 0x80) {
+			key[md4_size] = 0;
+			break;
+		}
+	}
+	return key;
+}
+
+static char *get_key_utf8(int index)
+{
+	return utf16toutf8(get_key_helper_utf8(&ms_buffer1x[index << 4], 1));
+}
+
+// Public domain hash function by DJ Bernstein (salt is a username)
+static int salt_hash(void *salt)
+{
+	UTF16 *s = salt;
+	unsigned int hash = 5381;
+
+	while (*s != 0x80)
+		hash = ((hash << 5) + hash) ^ *s++;
+
+	return hash & (SALT_HASH_SIZE - 1);
+}
+
+struct fmt_main fmt_mscash = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP | FMT_UNICODE | FMT_UTF8,
+		tests
+	}, {
+		init,
+		prepare,
+		valid,
+		ms_split,
+		get_binary,
+		get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/mscash2_fmt_plug.c john-1.7.8-jumbo-2/src/mscash2_fmt_plug.c
--- john-1.7.8/src/mscash2_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mscash2_fmt_plug.c	2011-07-03 00:12:05.000000000 +0200
@@ -0,0 +1,1553 @@
+/* MSCASH2 patch for John the Ripper written by S3nf in 2010, 2011
+ * a slow but working version 1.1 ... 1.3
+ *
+ * Cracking Domain Cached Credentials for modern Windows operating systems, supporting:
+ *     - Windows Vista
+ *     - Windows 7
+ *     - Windows Server 2008
+ *
+ * This module is based on:
+ *     - the MSCASH patch for john written by Alain Espinosa <alainesp at gmail.com> in 2007
+ *     - RFC 1320 - The MD4 Message-Digest Algorithm
+ *     - RFC 2104 - HMAC: Keyed-Hashing for Message Authentication
+ *     - RFC 3174 - US Secure Hash Algorithm 1 (SHA1)
+ *     - the HMAC-SHA1 implementation of the PolarSSL open source cryptagraphic library (http://polarssl.org/)
+ *
+ * This software was written by S3nf in 2010, 2011. No copyright is claimed, and the software is hereby placed in
+ * the public domain. In case this attempt to disclaim copyright and place the software in the public domain
+ * is deemed null and void, then the software is Copyright (c) 2010, 2011 S3nf and it is hereby released to the
+ * general public under the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ *
+ * Modified for optional utf-8 support by magnum 2011, same terms as above  (v1.2)
+ *
+ * JimF (June 2011)  (v1.3)
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ *   Fixed bug where this format only worked on user names 8 char or less.
+ *   Created hmac_sha1_init() function (speedup from 85.2/s to 91.4/s)
+ *   xor into dcc2 out using 32 bit (was 8 bit). (speedup from 91.1/s to 92.2/s)
+ *
+ * TODO, It appears this format should work for user names up to 22 characters (possibly only 21).  However
+ * due to implementation within the salt functions, we are only handling upto 19 char user names.  This can
+ * be fixed, by having john store a longer salt (45 bytes, vs 44 bytes), and storing the length as 1 byte past
+ * the 44 bytes of salt.  In this manner, we can have user names up to max allowed.
+ */
+
+// Inlining is very beneficial in the inner loop of PBKDF2
+#ifdef __GNUC__
+#define inline  __attribute__((always_inline))
+#elif defined (_MSC_VER)
+#define inline __forceinline
+#endif
+
+#include <string.h>
+#include "arch.h"
+#include "misc.h"
+#include "memory.h"
+#include "common.h"
+#include "formats.h"
+#include "unicode.h"
+#include "options.h"
+
+#define ITERATIONS					10240
+
+// MD4 and SHA1 init values
+#define INIT_A						0x67452301
+#define INIT_B						0xefcdab89
+#define INIT_C						0x98badcfe
+#define INIT_D						0x10325476
+#define INIT_E						0xC3D2E1F0
+
+#define SQRT_2						0x5a827999
+#define SQRT_3						0x6ed9eba1
+
+#define SHA1_DIGEST_LENGTH			20
+
+#if ARCH_LITTLE_ENDIAN
+#define BESWAP16(n) n
+#else
+#define BESWAP16(n) ( (n >> 8) | ((n << 8) & 0xffff) )
+#endif
+
+#ifndef GET_WORD_32_BE
+#define GET_WORD_32_BE(n,b,i)                           \
+{                                                       \
+    (n) = ( (unsigned long) (b)[(i)    ] << 24 )        \
+        | ( (unsigned long) (b)[(i) + 1] << 16 )        \
+        | ( (unsigned long) (b)[(i) + 2] <<  8 )        \
+        | ( (unsigned long) (b)[(i) + 3]       );       \
+}
+#endif
+
+#ifndef PUT_WORD_32_BE
+#define PUT_WORD_32_BE(n,b,i)                           \
+{                                                       \
+    (b)[(i)    ] = (unsigned char) ( (n) >> 24 );       \
+    (b)[(i) + 1] = (unsigned char) ( (n) >> 16 );       \
+    (b)[(i) + 2] = (unsigned char) ( (n) >>  8 );       \
+    (b)[(i) + 3] = (unsigned char) ( (n)       );       \
+}
+#endif
+
+#define S(x,n) ((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
+
+#define R(t)                                            \
+(                                                       \
+    temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^     \
+           W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],      \
+    ( W[t & 0x0F] = S(temp,1) )                         \
+)
+
+#define P(a,b,c,d,e,x)                                  \
+{                                                       \
+    e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);        \
+}
+
+
+/* Note: some tests will be replaced in init() if running UTF-8 */
+static struct fmt_tests tests[] = {
+	{"M$test1#607bbe89611e37446e736f7856515bf8", "test1" },
+	{"bdb80f2c4656a8b8591bd27d39064a54", "\xfc", {"joe"} },       // German u-umlaut in ISO-8859-1
+	{"0839e4a07c00f18a8c65cf5b985b9e73", "\xfc\xfc", {"admin"} }, // Two of the above
+	{"c0cbe0313a861062e29f92ede58f9b36", "", {"bin"} },           // nullstring password
+	{"87136ae0a18b2dafe4a41d555425b2ed", "w00t", {"nineteen_characters"} }, // max salt length
+	{"fc5df74eca97afd7cd5abb0032496223", "w00t", {"eighteencharacters"} },
+
+	{"M$TEST2#c6758e5be7fc943d00b97972a8a97620", "test2" },    // salt is lowercased before hashing
+	{"M$test3#360e51304a2d383ea33467ab0b639cc4", "test3" },
+	{"M$test4#6f79ee93518306f071c47185998566ae", "test4" },
+
+	{NULL}
+};
+
+#define FORMAT_LABEL				"mscash2"
+#define FORMAT_NAME					"M$ Cache Hash 2"
+
+#define BENCHMARK_COMMENT			""
+#define BENCHMARK_LENGTH			-1
+
+#define PLAINTEXT_LENGTH			27
+#define MAX_CIPHERTEXT_LENGTH		(2 + 19*3 + 1 + 32) // x3 because salt may be UTF-8 in input
+
+#define ALGORITHM_NAME				"Generic 1x"
+
+#define BINARY_SIZE					16
+#define SALT_SIZE					(11*4)
+
+#ifdef _OPENMP
+#define MS_NUM_KEYS				64
+#else
+#define MS_NUM_KEYS				1
+#endif
+#define MIN_KEYS_PER_CRYPT			1
+#define MAX_KEYS_PER_CRYPT			MS_NUM_KEYS
+
+static unsigned int ms_buffer1x[16 * MS_NUM_KEYS];
+static unsigned int output1x[4 * MS_NUM_KEYS];
+static ARCH_WORD_32 output1x_dcc2[4 * MS_NUM_KEYS];
+
+static unsigned int crypt[4 * MS_NUM_KEYS];
+static unsigned int last[4 * MS_NUM_KEYS];
+
+static unsigned int last_i[MS_NUM_KEYS];
+
+// pre-utf8 was 32, we need up to 3 x PLAINTEXT_LENGTH in theory
+#define SAVED_PLAIN_BUF (3 * PLAINTEXT_LENGTH + 1)
+static char saved_plain[SAVED_PLAIN_BUF * MS_NUM_KEYS];
+
+static unsigned int *salt_buffer;
+static unsigned int salt_len;
+static unsigned int new_key;
+
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+static void set_key_utf8(char *_key, int index);
+static void *get_salt_utf8(char *ciphertext);
+struct fmt_main fmt_mscash2;
+
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = omp_get_max_threads();
+	if (n < 1)
+		n = 1;
+	if (n > MS_NUM_KEYS)
+		n = MS_NUM_KEYS;
+	fmt_mscash2.params.min_keys_per_crypt =
+	fmt_mscash2.params.max_keys_per_crypt = n;
+#endif
+	memset(ms_buffer1x, 0, 64 * MS_NUM_KEYS);
+	memset(last_i, 0, 4 * MS_NUM_KEYS);
+	new_key = 1;
+
+	if (options.flags & FLG_UTF8) {
+		fmt_mscash2.methods.set_key = set_key_utf8;
+		fmt_mscash2.methods.salt = get_salt_utf8;
+		// UTF8 may be up to three bytes per character
+		fmt_mscash2.params.plaintext_length = SAVED_PLAIN_BUF - 1;
+		tests[1].plaintext = "\xc3\xbc";         // German u-umlaut in UTF-8
+		tests[2].ciphertext = "M$joe#1e1e20f482ff748038e47d801d0d1bda";
+		tests[2].plaintext = "\xe2\x82\xac\xe2\x82\xac"; // 2 x Euro signs
+	}
+}
+
+
+static char * ms_split(char *ciphertext, int index)
+{
+	static char out[MAX_CIPHERTEXT_LENGTH + 1];
+	int i = 0;
+
+	for(; ciphertext[i] && i < MAX_CIPHERTEXT_LENGTH; i++)
+		out[i] = ciphertext[i];
+
+	out[i] = 0;
+
+	// lowercase salt as well as hash
+	strlwr(&out[2]);
+
+	return out;
+}
+
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	unsigned int i;
+	unsigned int l;
+	char insalt[3*19+1];
+	UTF16 realsalt[20];
+	int saltlen;
+
+	if (strncmp(ciphertext, "M$", 2))
+		return 0;
+
+	l = strlen(ciphertext);
+	if (l <= 32 || l > MAX_CIPHERTEXT_LENGTH)
+		return 0;
+
+	l -= 32;
+	if(ciphertext[l-1]!='#')
+		return 0;
+
+	for (i = l; i < l + 32; i++)
+		if (atoi16[ARCH_INDEX(ciphertext[i])] == 0x7F)
+			return 0;
+
+	// This is tricky: Max supported salt length is 19 characters of Unicode
+	saltlen = plaintowcs(realsalt, 20, (UTF8*)strnzcpy(insalt, &ciphertext[2], l - 2), l - 3);
+	if (saltlen < 0 || saltlen > 19)
+		return 0;
+
+	return 1;
+}
+
+static char *prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	char *cp;
+	if (!strncmp(split_fields[1], "M$", 2))
+		return split_fields[1];
+	cp = mem_alloc(strlen(split_fields[0]) + strlen(split_fields[1]) + 4);
+	sprintf (cp, "M$%s#%s", split_fields[0], split_fields[1]);
+	if (valid(cp, pFmt))
+	{
+		char *cipher = str_alloc_copy(cp);
+		MEM_FREE(cp);
+		return cipher;
+	}
+	MEM_FREE(cp);
+	return split_fields[1];
+}
+
+static void set_salt(void *salt) {
+	salt_buffer = salt;
+#if ARCH_LITTLE_ENDIAN
+	salt_len = ((salt_buffer[10]>>4)-8)<<1;
+#else
+	//for (salt_len = 0; ((unsigned char *)salt)[salt_len] != 0x80 && salt_len < 38; salt_len++);
+	salt_len = (((salt_buffer[10]>>4)-8)<<1)-1;  // I don't get this but it works
+#endif
+}
+
+
+static void *get_salt(char *_ciphertext)
+{
+	unsigned char *ciphertext = (unsigned char *)_ciphertext;
+	// length = 11 for save memory
+	// position 10 = length
+	// 0-9 = 1-19 Unicode characters + EOS marker (0x80)
+	static unsigned int out[11];
+	unsigned int md4_size = 0;
+
+	memset(out, 0, 44);
+
+	ciphertext += 2;
+
+	for (;;md4_size++)
+		if (ciphertext[md4_size] != '#' && md4_size < 19)
+		{
+			md4_size++;
+
+			out[md4_size >> 1] = ciphertext[md4_size - 1] | ((ciphertext[md4_size] != '#') ? (ciphertext[md4_size] << 16) : 0x800000);
+
+			if (ciphertext[md4_size] == '#')
+				break;
+		}
+		else
+		{
+			out[md4_size >> 1] = 0x80;
+			break;
+		}
+
+	out[10] = (8 + md4_size) << 4;
+
+	return out;
+}
+
+
+static void * get_salt_utf8(char *_ciphertext)
+{
+	unsigned char *ciphertext = (unsigned char *)_ciphertext;
+	static ARCH_WORD_32 out[11];
+	unsigned int md4_size=0;
+	UTF16 ciphertext_utf16[21];
+	int len;
+
+	memset(out,0,sizeof(out));
+	ciphertext+=2;
+	len = ((unsigned char*)strchr((char*)ciphertext, '#')) - ciphertext;
+	utf8towcs(ciphertext_utf16, 20, ciphertext, len + 1);
+
+	for(;;md4_size++) {
+#if !ARCH_LITTLE_ENDIAN
+		ciphertext_utf16[md4_size] = BESWAP16(ciphertext_utf16[md4_size]);
+		ciphertext_utf16[md4_size+1] = BESWAP16(ciphertext_utf16[md4_size+1]);
+#endif
+		if(ciphertext_utf16[md4_size]!=(UTF16)'#' && md4_size < 19) {
+			md4_size++;
+			out[md4_size>>1] = ciphertext_utf16[md4_size-1] |
+				((ciphertext_utf16[md4_size]!=(UTF16)'#') ?
+				 (ciphertext_utf16[md4_size]<<16) : 0x800000);
+
+			if(ciphertext_utf16[md4_size]==(UTF16)'#')
+				break;
+		}
+		else {
+			out[md4_size>>1] = 0x80;
+			break;
+		}
+	}
+
+	out[10] = (8 + md4_size) << 4;
+
+	return out;
+}
+
+static void *get_binary(char *ciphertext)
+{
+	static unsigned int out[4];
+	unsigned int i = 0;
+	unsigned int temp;
+
+	for (; ciphertext[0] != '#'; ciphertext++);
+	ciphertext++;
+
+	for (; i < 4 ;i++)
+	{
+		temp  = (atoi16[ARCH_INDEX(ciphertext[i * 8 + 0])]) << 4;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i * 8 + 1])]);
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i * 8 + 2])]) << 12;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i * 8 + 3])]) << 8;
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i * 8 + 4])]) << 20;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i * 8 + 5])]) << 16;
+
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i * 8 + 6])]) << 28;
+		temp |= (atoi16[ARCH_INDEX(ciphertext[i * 8 + 7])]) << 24;
+
+		out[i] = temp;
+	}
+
+	return out;
+}
+
+
+static int binary_hash_0(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0F;
+}
+
+
+static int binary_hash_1(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0xFF;
+}
+
+
+static int binary_hash_2(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0FFF;
+}
+
+
+static int binary_hash_3(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0FFFF;
+}
+
+
+static int binary_hash_4(void *binary)
+{
+	return ((unsigned int*)binary)[3] & 0x0FFFFF;
+}
+
+
+static int get_hash_0(int index)
+{
+	return output1x_dcc2[4 * index + 3] & 0x0F;
+}
+
+
+static int get_hash_1(int index)
+{
+	return output1x_dcc2[4 * index + 3] & 0xFF;
+}
+
+
+static int get_hash_2(int index)
+{
+	return output1x_dcc2[4 * index + 3] & 0x0FFF;
+}
+
+
+static int get_hash_3(int index)
+{
+	return output1x_dcc2[4 * index + 3] & 0x0FFFF;
+}
+
+
+static int get_hash_4(int index)
+{
+	return output1x_dcc2[4 * index + 3] & 0x0FFFFF;
+}
+
+
+static void nt_hash(int count)
+{
+	int i;
+
+#if MS_NUM_KEYS > 1 && defined(_OPENMP)
+#pragma omp parallel for default(none) private(i) shared(count, ms_buffer1x, crypt, last)
+#endif
+	for(i = 0; i < count; i++)
+	{
+		unsigned int a;
+		unsigned int b;
+		unsigned int c;
+		unsigned int d;
+
+		// round 1
+		a =	0xFFFFFFFF + ms_buffer1x[16 * i + 0]; a = (a << 3 ) | (a >> 29);
+		d = INIT_D + (INIT_C ^ (a & 0x77777777)) + ms_buffer1x[16 * i +1]; d = (d << 7 ) | (d >> 25);
+		c = INIT_C + (INIT_B ^ (d & (a ^ INIT_B))) + ms_buffer1x[16 * i +2]; c = (c << 11) | (c >> 21);
+		b = INIT_B + (a ^ (c & (d ^ a))) + ms_buffer1x[16 * i +3]; b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d))) + ms_buffer1x[16 * i + 4]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c))) + ms_buffer1x[16 * i + 5]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b))) + ms_buffer1x[16 * i + 6]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a))) + ms_buffer1x[16 * i + 7]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d))) + ms_buffer1x[16 * i + 8]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c))) + ms_buffer1x[16 * i + 9]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b))) + ms_buffer1x[16 * i + 10] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a))) + ms_buffer1x[16 * i + 11] ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d))) + ms_buffer1x[16 * i + 12] ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c))) + ms_buffer1x[16 * i + 13] ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b))) + ms_buffer1x[16 * i + 14] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))/* + ms_buffer1x[16 * i + 15]*/;b = (b << 19) | (b >> 13);
+
+		// round 2
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16 * i + 0]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16 * i + 4]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16 * i + 8]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a)) + ms_buffer1x[16 * i + 12] + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16 * i + 1]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16 * i + 5]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16 * i + 9]  + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a)) + ms_buffer1x[16 * i + 13] + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16 * i + 2]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16 * i + 6]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16 * i + 10] + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a)) + ms_buffer1x[16 * i + 14] + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d)) + ms_buffer1x[16 * i + 3]  + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c)) + ms_buffer1x[16 * i + 7]  + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b)) + ms_buffer1x[16 * i + 11] + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))/* + ms_buffer1x[ 16 * i + 15]*/+SQRT_2; b = (b << 13) | (b >> 19);
+
+		// round 3
+		a += (b ^ c ^ d) + ms_buffer1x[16 * i + 0]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16 * i + 8]  + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16 * i + 4]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + ms_buffer1x[16 * i + 12] + SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + ms_buffer1x[16 * i + 2]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16 * i + 10] + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16 * i + 6]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + ms_buffer1x[16 * i + 14] + SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + ms_buffer1x[16 * i + 1]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16 * i + 9]  + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16 * i + 5]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + ms_buffer1x[16 * i + 13] + SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + ms_buffer1x[16 * i + 3]  + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + ms_buffer1x[16 * i + 11] + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + ms_buffer1x[16 * i + 7]  + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) /*+ ms_buffer1x[16 * i + 15] */+ SQRT_3; b = (b << 15) | (b >> 17);
+
+		crypt[4 * i + 0] = a + INIT_A;
+		crypt[4 * i + 1] = b + INIT_B;
+		crypt[4 * i + 2] = c + INIT_C;
+		crypt[4 * i + 3] = d + INIT_D;
+
+		// another MD4 crypt for the salt
+		// round 1
+		a =  0xFFFFFFFF + crypt[ 4 * i + 0]; a = ( a << 3 )| ( a >> 29);
+		d = INIT_D + (INIT_C ^ (a & 0x77777777)) + crypt[4 * i + 1]; d =(d << 7 ) | (d >> 25);
+		c = INIT_C + (INIT_B ^ (d & (a ^ INIT_B))) + crypt[4 * i + 2]; c = (c << 11) | (c >> 21);
+		b = INIT_B + (a ^ (c & (d ^ a))) + crypt[4 * i + 3]; b = (b << 19) |(b >> 13);
+
+		last[4 * i + 0] = a;
+		last[4 * i + 1] = b;
+		last[4 * i + 2] = c;
+		last[4 * i + 3] = d;
+	}
+}
+
+
+/*
+ * hmac_sha1
+ * based on RFC 2104, RFC 3174 and the HMAC-SHA1 implementation of the PolarSSL
+ * open source cryptographic library (http://www.polarssl.org)
+ */
+
+/* Creating an hmac_sha1_init function, and ONLY calling it one time, sped up the
+ * runtime on my machine from 85.2/s to 91.4/s  JimF  (June 21, 2011) */
+static inline void hmac_sha1_init(const unsigned char *key, unsigned int keylen, unsigned char *ipad, unsigned char *opad)
+{
+	// step 2: XOR (bitwise exclusive-OR) the B byte string computed in step 1 with ipad
+	// step 5: XOR (bitwise exclusive-OR) the B byte string computed in step 1 with opad
+	unsigned int i;
+	memset(ipad, 0x36, 64);
+	memset(opad, 0x5C, 64);
+	for(i = 0; i < keylen; i++)
+	{
+		ipad[i] = ipad[i] ^ key[i];
+		opad[i] = opad[i] ^ key[i];
+	}
+}
+
+static inline void hmac_sha1(const unsigned char *input, unsigned int inputlen, unsigned char *output, unsigned char *ipad, unsigned char *opad) {
+	unsigned int temp, W[16];
+	unsigned int A, B, C, D, E, state[5];
+	unsigned char buf[64];
+
+	memset(buf, 0, 64);
+
+	// step 1: append zeros to the end of K to create a B Byte string
+	memcpy(buf, input, inputlen);
+	buf[inputlen] = 0x80;
+
+#if ARCH_LITTLE_ENDIAN || !ARCH_ALLOWS_UNALIGNED
+	PUT_WORD_32_BE((64 + inputlen) << 3, buf, 60);
+#else
+	((unsigned int *)buf)[15] = (64 + inputlen) << 3;
+#endif
+
+	// step 3: append the stream of data 'text' to the B byte sting resulting from step 2
+	// first part of stream (64 bytes) is ipad, second part of stream (64 bytes) is buf
+
+	// step 4: apply H to the stream (ipad & buf) generated in step 3
+#if ARCH_LITTLE_ENDIAN
+	GET_WORD_32_BE(W[ 0], ipad,  0);
+	GET_WORD_32_BE(W[ 1], ipad,  4);
+	GET_WORD_32_BE(W[ 2], ipad,  8);
+	GET_WORD_32_BE(W[ 3], ipad, 12);
+	GET_WORD_32_BE(W[ 4], ipad, 16);
+	GET_WORD_32_BE(W[ 5], ipad, 20);
+	GET_WORD_32_BE(W[ 6], ipad, 24);
+	GET_WORD_32_BE(W[ 7], ipad, 28);
+	GET_WORD_32_BE(W[ 8], ipad, 32);
+	GET_WORD_32_BE(W[ 9], ipad, 36);
+	GET_WORD_32_BE(W[10], ipad, 40);
+	GET_WORD_32_BE(W[11], ipad, 44);
+	GET_WORD_32_BE(W[12], ipad, 48);
+	GET_WORD_32_BE(W[13], ipad, 52);
+	GET_WORD_32_BE(W[14], ipad, 56);
+	GET_WORD_32_BE(W[15], ipad, 60);
+#else
+	memcpy(W, ipad, 64);
+#endif
+
+	A = INIT_A;
+	B = INIT_B;
+	C = INIT_C;
+	D = INIT_D;
+	E = INIT_E;
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+	P(A, B, C, D, E, W[0] );
+	P(E, A, B, C, D, W[1] );
+	P(D, E, A, B, C, W[2] );
+	P(C, D, E, A, B, W[3] );
+	P(B, C, D, E, A, W[4] );
+	P(A, B, C, D, E, W[5] );
+	P(E, A, B, C, D, W[6] );
+	P(D, E, A, B, C, W[7] );
+	P(C, D, E, A, B, W[8] );
+	P(B, C, D, E, A, W[9] );
+	P(A, B, C, D, E, W[10]);
+	P(E, A, B, C, D, W[11]);
+	P(D, E, A, B, C, W[12]);
+	P(C, D, E, A, B, W[13]);
+	P(B, C, D, E, A, W[14]);
+	P(A, B, C, D, E, W[15]);
+	P(E, A, B, C, D, R(16));
+	P(D, E, A, B, C, R(17));
+	P(C, D, E, A, B, R(18));
+	P(B, C, D, E, A, R(19));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+	P(A, B, C, D, E, R(20));
+	P(E, A, B, C, D, R(21));
+	P(D, E, A, B, C, R(22));
+	P(C, D, E, A, B, R(23));
+	P(B, C, D, E, A, R(24));
+	P(A, B, C, D, E, R(25));
+	P(E, A, B, C, D, R(26));
+	P(D, E, A, B, C, R(27));
+	P(C, D, E, A, B, R(28));
+	P(B, C, D, E, A, R(29));
+	P(A, B, C, D, E, R(30));
+	P(E, A, B, C, D, R(31));
+	P(D, E, A, B, C, R(32));
+	P(C, D, E, A, B, R(33));
+	P(B, C, D, E, A, R(34));
+	P(A, B, C, D, E, R(35));
+	P(E, A, B, C, D, R(36));
+	P(D, E, A, B, C, R(37));
+	P(C, D, E, A, B, R(38));
+	P(B, C, D, E, A, R(39));
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+	P(A, B, C, D, E, R(40));
+	P(E, A, B, C, D, R(41));
+	P(D, E, A, B, C, R(42));
+	P(C, D, E, A, B, R(43));
+	P(B, C, D, E, A, R(44));
+	P(A, B, C, D, E, R(45));
+	P(E, A, B, C, D, R(46));
+	P(D, E, A, B, C, R(47));
+	P(C, D, E, A, B, R(48));
+	P(B, C, D, E, A, R(49));
+	P(A, B, C, D, E, R(50));
+	P(E, A, B, C, D, R(51));
+	P(D, E, A, B, C, R(52));
+	P(C, D, E, A, B, R(53));
+	P(B, C, D, E, A, R(54));
+	P(A, B, C, D, E, R(55));
+	P(E, A, B, C, D, R(56));
+	P(D, E, A, B, C, R(57));
+	P(C, D, E, A, B, R(58));
+	P(B, C, D, E, A, R(59));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+	P(A, B, C, D, E, R(60));
+	P(E, A, B, C, D, R(61));
+	P(D, E, A, B, C, R(62));
+	P(C, D, E, A, B, R(63));
+	P(B, C, D, E, A, R(64));
+	P(A, B, C, D, E, R(65));
+	P(E, A, B, C, D, R(66));
+	P(D, E, A, B, C, R(67));
+	P(C, D, E, A, B, R(68));
+	P(B, C, D, E, A, R(69));
+	P(A, B, C, D, E, R(70));
+	P(E, A, B, C, D, R(71));
+	P(D, E, A, B, C, R(72));
+	P(C, D, E, A, B, R(73));
+	P(B, C, D, E, A, R(74));
+	P(A, B, C, D, E, R(75));
+	P(E, A, B, C, D, R(76));
+	P(D, E, A, B, C, R(77));
+	P(C, D, E, A, B, R(78));
+	P(B, C, D, E, A, R(79));
+
+#undef K
+#undef F
+
+	A += INIT_A;
+	B += INIT_B;
+	C += INIT_C;
+	D += INIT_D;
+	E += INIT_E;
+
+	state[0] = A;
+	state[1] = B;
+	state[2] = C;
+	state[3] = D;
+	state[4] = E;
+
+	// process buf (2nd part of stream)
+#if ARCH_LITTLE_ENDIAN
+	GET_WORD_32_BE(W[ 0], buf,  0);
+	GET_WORD_32_BE(W[ 1], buf,  4);
+	GET_WORD_32_BE(W[ 2], buf,  8);
+	GET_WORD_32_BE(W[ 3], buf, 12);
+	GET_WORD_32_BE(W[ 4], buf, 16);
+	GET_WORD_32_BE(W[ 5], buf, 20);
+	GET_WORD_32_BE(W[ 6], buf, 24);
+	GET_WORD_32_BE(W[ 7], buf, 28);
+	GET_WORD_32_BE(W[ 8], buf, 32);
+	GET_WORD_32_BE(W[ 9], buf, 36);
+	GET_WORD_32_BE(W[10], buf, 40);
+	GET_WORD_32_BE(W[11], buf, 44);
+	GET_WORD_32_BE(W[12], buf, 48);
+	GET_WORD_32_BE(W[13], buf, 52);
+	GET_WORD_32_BE(W[14], buf, 56);
+	GET_WORD_32_BE(W[15], buf, 60);
+#else
+	memcpy(W, buf, 64);
+#endif
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+	P(A, B, C, D, E, W[0] );
+	P(E, A, B, C, D, W[1] );
+	P(D, E, A, B, C, W[2] );
+	P(C, D, E, A, B, W[3] );
+	P(B, C, D, E, A, W[4] );
+	P(A, B, C, D, E, W[5] );
+	P(E, A, B, C, D, W[6] );
+	P(D, E, A, B, C, W[7] );
+	P(C, D, E, A, B, W[8] );
+	P(B, C, D, E, A, W[9] );
+	P(A, B, C, D, E, W[10]);
+	P(E, A, B, C, D, W[11]);
+	P(D, E, A, B, C, W[12]);
+	P(C, D, E, A, B, W[13]);
+	P(B, C, D, E, A, W[14]);
+	P(A, B, C, D, E, W[15]);
+	P(E, A, B, C, D, R(16));
+	P(D, E, A, B, C, R(17));
+	P(C, D, E, A, B, R(18));
+	P(B, C, D, E, A, R(19));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+	P(A, B, C, D, E, R(20));
+	P(E, A, B, C, D, R(21));
+	P(D, E, A, B, C, R(22));
+	P(C, D, E, A, B, R(23));
+	P(B, C, D, E, A, R(24));
+	P(A, B, C, D, E, R(25));
+	P(E, A, B, C, D, R(26));
+	P(D, E, A, B, C, R(27));
+	P(C, D, E, A, B, R(28));
+	P(B, C, D, E, A, R(29));
+	P(A, B, C, D, E, R(30));
+	P(E, A, B, C, D, R(31));
+	P(D, E, A, B, C, R(32));
+	P(C, D, E, A, B, R(33));
+	P(B, C, D, E, A, R(34));
+	P(A, B, C, D, E, R(35));
+	P(E, A, B, C, D, R(36));
+	P(D, E, A, B, C, R(37));
+	P(C, D, E, A, B, R(38));
+	P(B, C, D, E, A, R(39));
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+	P(A, B, C, D, E, R(40));
+	P(E, A, B, C, D, R(41));
+	P(D, E, A, B, C, R(42));
+	P(C, D, E, A, B, R(43));
+	P(B, C, D, E, A, R(44));
+	P(A, B, C, D, E, R(45));
+	P(E, A, B, C, D, R(46));
+	P(D, E, A, B, C, R(47));
+	P(C, D, E, A, B, R(48));
+	P(B, C, D, E, A, R(49));
+	P(A, B, C, D, E, R(50));
+	P(E, A, B, C, D, R(51));
+	P(D, E, A, B, C, R(52));
+	P(C, D, E, A, B, R(53));
+	P(B, C, D, E, A, R(54));
+	P(A, B, C, D, E, R(55));
+	P(E, A, B, C, D, R(56));
+	P(D, E, A, B, C, R(57));
+	P(C, D, E, A, B, R(58));
+	P(B, C, D, E, A, R(59));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+	P(A, B, C, D, E, R(60));
+	P(E, A, B, C, D, R(61));
+	P(D, E, A, B, C, R(62));
+	P(C, D, E, A, B, R(63));
+	P(B, C, D, E, A, R(64));
+	P(A, B, C, D, E, R(65));
+	P(E, A, B, C, D, R(66));
+	P(D, E, A, B, C, R(67));
+	P(C, D, E, A, B, R(68));
+	P(B, C, D, E, A, R(69));
+	P(A, B, C, D, E, R(70));
+	P(E, A, B, C, D, R(71));
+	P(D, E, A, B, C, R(72));
+	P(C, D, E, A, B, R(73));
+	P(B, C, D, E, A, R(74));
+	P(A, B, C, D, E, R(75));
+	P(E, A, B, C, D, R(76));
+	P(D, E, A, B, C, R(77));
+	P(C, D, E, A, B, R(78));
+	P(B, C, D, E, A, R(79));
+
+#undef K
+#undef F
+
+	A += state[0];
+	B += state[1];
+	C += state[2];
+	D += state[3];
+	E += state[4];
+
+	if (inputlen > 20)
+		memset(&buf[21], 0, inputlen-20);  // will nuke extra input, and the original 0x20
+
+#if ARCH_LITTLE_ENDIAN || !ARCH_ALLOWS_UNALIGNED
+	PUT_WORD_32_BE(A, buf,  0);
+	PUT_WORD_32_BE(B, buf,  4);
+	PUT_WORD_32_BE(C, buf,  8);
+	PUT_WORD_32_BE(D, buf, 12);
+	PUT_WORD_32_BE(E, buf, 16);
+
+	buf[20] = 0x80;
+	PUT_WORD_32_BE(0x2A0, buf, 60);
+#else
+	((unsigned int *)buf)[0] = A;
+	((unsigned int *)buf)[1] = B;
+	((unsigned int *)buf)[2] = C;
+	((unsigned int *)buf)[3] = D;
+	((unsigned int *)buf)[4] = E;
+
+	buf[20] = 0x80;
+	((unsigned int *)buf)[15] = 0x2A0;
+#endif
+
+	// step 6: append the stream of data 'text' to the B byte sting resulting from step 2
+	// first part of stream (64 bytes) is opad, second part of stream (64 bytes) is the H result from step 4
+
+	// step 7: apply H to the stream (opad & buf) generated in step 6 and output the result
+#if ARCH_LITTLE_ENDIAN
+	GET_WORD_32_BE(W[ 0], opad,  0);
+	GET_WORD_32_BE(W[ 1], opad,  4);
+	GET_WORD_32_BE(W[ 2], opad,  8);
+	GET_WORD_32_BE(W[ 3], opad, 12);
+	GET_WORD_32_BE(W[ 4], opad, 16);
+	GET_WORD_32_BE(W[ 5], opad, 20);
+	GET_WORD_32_BE(W[ 6], opad, 24);
+	GET_WORD_32_BE(W[ 7], opad, 28);
+	GET_WORD_32_BE(W[ 8], opad, 32);
+	GET_WORD_32_BE(W[ 9], opad, 36);
+	GET_WORD_32_BE(W[10], opad, 40);
+	GET_WORD_32_BE(W[11], opad, 44);
+	GET_WORD_32_BE(W[12], opad, 48);
+	GET_WORD_32_BE(W[13], opad, 52);
+	GET_WORD_32_BE(W[14], opad, 56);
+	GET_WORD_32_BE(W[15], opad, 60);
+#else
+	memcpy(W, opad, 64);
+#endif
+
+	A = INIT_A;
+	B = INIT_B;
+	C = INIT_C;
+	D = INIT_D;
+	E = INIT_E;
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+	P(A, B, C, D, E, W[0] );
+	P(E, A, B, C, D, W[1] );
+	P(D, E, A, B, C, W[2] );
+	P(C, D, E, A, B, W[3] );
+	P(B, C, D, E, A, W[4] );
+	P(A, B, C, D, E, W[5] );
+	P(E, A, B, C, D, W[6] );
+	P(D, E, A, B, C, W[7] );
+	P(C, D, E, A, B, W[8] );
+	P(B, C, D, E, A, W[9] );
+	P(A, B, C, D, E, W[10]);
+	P(E, A, B, C, D, W[11]);
+	P(D, E, A, B, C, W[12]);
+	P(C, D, E, A, B, W[13]);
+	P(B, C, D, E, A, W[14]);
+	P(A, B, C, D, E, W[15]);
+	P(E, A, B, C, D, R(16));
+	P(D, E, A, B, C, R(17));
+	P(C, D, E, A, B, R(18));
+	P(B, C, D, E, A, R(19));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+	P(A, B, C, D, E, R(20));
+	P(E, A, B, C, D, R(21));
+	P(D, E, A, B, C, R(22));
+	P(C, D, E, A, B, R(23));
+	P(B, C, D, E, A, R(24));
+	P(A, B, C, D, E, R(25));
+	P(E, A, B, C, D, R(26));
+	P(D, E, A, B, C, R(27));
+	P(C, D, E, A, B, R(28));
+	P(B, C, D, E, A, R(29));
+	P(A, B, C, D, E, R(30));
+	P(E, A, B, C, D, R(31));
+	P(D, E, A, B, C, R(32));
+	P(C, D, E, A, B, R(33));
+	P(B, C, D, E, A, R(34));
+	P(A, B, C, D, E, R(35));
+	P(E, A, B, C, D, R(36));
+	P(D, E, A, B, C, R(37));
+	P(C, D, E, A, B, R(38));
+	P(B, C, D, E, A, R(39));
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+	P(A, B, C, D, E, R(40));
+	P(E, A, B, C, D, R(41));
+	P(D, E, A, B, C, R(42));
+	P(C, D, E, A, B, R(43));
+	P(B, C, D, E, A, R(44));
+	P(A, B, C, D, E, R(45));
+	P(E, A, B, C, D, R(46));
+	P(D, E, A, B, C, R(47));
+	P(C, D, E, A, B, R(48));
+	P(B, C, D, E, A, R(49));
+	P(A, B, C, D, E, R(50));
+	P(E, A, B, C, D, R(51));
+	P(D, E, A, B, C, R(52));
+	P(C, D, E, A, B, R(53));
+	P(B, C, D, E, A, R(54));
+	P(A, B, C, D, E, R(55));
+	P(E, A, B, C, D, R(56));
+	P(D, E, A, B, C, R(57));
+	P(C, D, E, A, B, R(58));
+	P(B, C, D, E, A, R(59));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+	P(A, B, C, D, E, R(60));
+	P(E, A, B, C, D, R(61));
+	P(D, E, A, B, C, R(62));
+	P(C, D, E, A, B, R(63));
+	P(B, C, D, E, A, R(64));
+	P(A, B, C, D, E, R(65));
+	P(E, A, B, C, D, R(66));
+	P(D, E, A, B, C, R(67));
+	P(C, D, E, A, B, R(68));
+	P(B, C, D, E, A, R(69));
+	P(A, B, C, D, E, R(70));
+	P(E, A, B, C, D, R(71));
+	P(D, E, A, B, C, R(72));
+	P(C, D, E, A, B, R(73));
+	P(B, C, D, E, A, R(74));
+	P(A, B, C, D, E, R(75));
+	P(E, A, B, C, D, R(76));
+	P(D, E, A, B, C, R(77));
+	P(C, D, E, A, B, R(78));
+	P(B, C, D, E, A, R(79));
+
+#undef K
+#undef F
+
+	A += INIT_A;
+	B += INIT_B;
+	C += INIT_C;
+	D += INIT_D;
+	E += INIT_E;
+
+	// store state for 2nd part
+	state[0] = A;
+	state[1] = B;
+	state[2] = C;
+	state[3] = D;
+	state[4] = E;
+
+#if ARCH_LITTLE_ENDIAN
+	GET_WORD_32_BE(W[ 0], buf,  0);
+	GET_WORD_32_BE(W[ 1], buf,  4);
+	GET_WORD_32_BE(W[ 2], buf,  8);
+	GET_WORD_32_BE(W[ 3], buf, 12);
+	GET_WORD_32_BE(W[ 4], buf, 16);
+	GET_WORD_32_BE(W[ 5], buf, 20);
+	GET_WORD_32_BE(W[ 6], buf, 24);
+	GET_WORD_32_BE(W[ 7], buf, 28);
+	GET_WORD_32_BE(W[ 8], buf, 32);
+	GET_WORD_32_BE(W[ 9], buf, 36);
+	GET_WORD_32_BE(W[10], buf, 40);
+	GET_WORD_32_BE(W[11], buf, 44);
+	GET_WORD_32_BE(W[12], buf, 48);
+	GET_WORD_32_BE(W[13], buf, 52);
+	GET_WORD_32_BE(W[14], buf, 56);
+	GET_WORD_32_BE(W[15], buf, 60);
+#else
+	memcpy(W, buf, 64);
+#endif
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+	P(A, B, C, D, E, W[0] );
+	P(E, A, B, C, D, W[1] );
+	P(D, E, A, B, C, W[2] );
+	P(C, D, E, A, B, W[3] );
+	P(B, C, D, E, A, W[4] );
+	P(A, B, C, D, E, W[5] );
+	P(E, A, B, C, D, W[6] );
+	P(D, E, A, B, C, W[7] );
+	P(C, D, E, A, B, W[8] );
+	P(B, C, D, E, A, W[9] );
+	P(A, B, C, D, E, W[10]);
+	P(E, A, B, C, D, W[11]);
+	P(D, E, A, B, C, W[12]);
+	P(C, D, E, A, B, W[13]);
+	P(B, C, D, E, A, W[14]);
+	P(A, B, C, D, E, W[15]);
+	P(E, A, B, C, D, R(16));
+	P(D, E, A, B, C, R(17));
+	P(C, D, E, A, B, R(18));
+	P(B, C, D, E, A, R(19));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+	P(A, B, C, D, E, R(20));
+	P(E, A, B, C, D, R(21));
+	P(D, E, A, B, C, R(22));
+	P(C, D, E, A, B, R(23));
+	P(B, C, D, E, A, R(24));
+	P(A, B, C, D, E, R(25));
+	P(E, A, B, C, D, R(26));
+	P(D, E, A, B, C, R(27));
+	P(C, D, E, A, B, R(28));
+	P(B, C, D, E, A, R(29));
+	P(A, B, C, D, E, R(30));
+	P(E, A, B, C, D, R(31));
+	P(D, E, A, B, C, R(32));
+	P(C, D, E, A, B, R(33));
+	P(B, C, D, E, A, R(34));
+	P(A, B, C, D, E, R(35));
+	P(E, A, B, C, D, R(36));
+	P(D, E, A, B, C, R(37));
+	P(C, D, E, A, B, R(38));
+	P(B, C, D, E, A, R(39));
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+	P(A, B, C, D, E, R(40));
+	P(E, A, B, C, D, R(41));
+	P(D, E, A, B, C, R(42));
+	P(C, D, E, A, B, R(43));
+	P(B, C, D, E, A, R(44));
+	P(A, B, C, D, E, R(45));
+	P(E, A, B, C, D, R(46));
+	P(D, E, A, B, C, R(47));
+	P(C, D, E, A, B, R(48));
+	P(B, C, D, E, A, R(49));
+	P(A, B, C, D, E, R(50));
+	P(E, A, B, C, D, R(51));
+	P(D, E, A, B, C, R(52));
+	P(C, D, E, A, B, R(53));
+	P(B, C, D, E, A, R(54));
+	P(A, B, C, D, E, R(55));
+	P(E, A, B, C, D, R(56));
+	P(D, E, A, B, C, R(57));
+	P(C, D, E, A, B, R(58));
+	P(B, C, D, E, A, R(59));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+	P(A, B, C, D, E, R(60));
+	P(E, A, B, C, D, R(61));
+	P(D, E, A, B, C, R(62));
+	P(C, D, E, A, B, R(63));
+	P(B, C, D, E, A, R(64));
+	P(A, B, C, D, E, R(65));
+	P(E, A, B, C, D, R(66));
+	P(D, E, A, B, C, R(67));
+	P(C, D, E, A, B, R(68));
+	P(B, C, D, E, A, R(69));
+	P(A, B, C, D, E, R(70));
+	P(E, A, B, C, D, R(71));
+	P(D, E, A, B, C, R(72));
+	P(C, D, E, A, B, R(73));
+	P(B, C, D, E, A, R(74));
+	P(A, B, C, D, E, R(75));
+	P(E, A, B, C, D, R(76));
+	P(D, E, A, B, C, R(77));
+	P(C, D, E, A, B, R(78));
+	P(B, C, D, E, A, R(79));
+
+#undef K
+#undef F
+
+	A += state[0];
+	B += state[1];
+	C += state[2];
+	D += state[3];
+	E += state[4];
+
+#if ARCH_LITTLE_ENDIAN || !ARCH_ALLOWS_UNALIGNED
+	PUT_WORD_32_BE(A, output,  0);
+	PUT_WORD_32_BE(B, output,  4);
+	PUT_WORD_32_BE(C, output,  8);
+	PUT_WORD_32_BE(D, output, 12);
+	PUT_WORD_32_BE(E, output, 16);
+#else
+	((unsigned int *)output)[0] = A;
+	((unsigned int *)output)[1] = B;
+	((unsigned int *)output)[2] = C;
+	((unsigned int *)output)[3] = D;
+	((unsigned int *)output)[4] = E;
+#endif
+}
+
+
+/* PBKDF2
+ * stripped-down implementation
+ * based on the source code written by Dr Stephen N Henson (shenson@bigfoot.com) for the OpenSSL Project 1999
+ */
+static inline void PBKDF2_DCC2(const unsigned char *pass, const unsigned char *salt, int saltlen, ARCH_WORD_32 *out)
+{
+	ARCH_WORD_32 temp[SHA1_DIGEST_LENGTH/4];
+	unsigned char buf[48];
+	unsigned int i;
+	unsigned char ipad[64], opad[64];
+
+	memset(buf, 0, 48);
+#if ARCH_LITTLE_ENDIAN
+	memcpy(buf, salt, saltlen);
+#else
+	// do some big endian byte shifting with the salt
+	unsigned int v;
+
+	saltlen++;
+
+	for (i = 0; i < saltlen / 4; i++)
+	{
+		v = ((unsigned int *)salt)[i];
+		((unsigned int *)buf)[i] = (v >> 24) | ((v << 8) & 0x00FF0000) | ((v >> 8) & 0x0000FF00) | (v << 24);
+	}
+
+	if (saltlen % 4 != 0)
+	{
+		v = ((unsigned int *)salt)[i] & 0x000000FF;
+		((unsigned int *)buf)[i] = (v >> 24) | ((v << 8) & 0x00FF0000) | ((v >> 8) & 0x0000FF00) | (v << 24);
+
+	}
+#endif
+	buf[saltlen + 3] = 0x01;
+
+	hmac_sha1_init(pass, 16, ipad, opad);
+	hmac_sha1(buf, saltlen + 4, (unsigned char*)temp, ipad, opad);
+
+	memcpy(out, temp, 16);
+
+	for (i = 1; i < ITERATIONS; i++)
+	{
+		hmac_sha1((unsigned char*)temp, SHA1_DIGEST_LENGTH, (unsigned char*)temp, ipad, opad);
+		out[0] ^= temp[0];
+		out[1] ^= temp[1];
+		out[2] ^= temp[2];
+		out[3] ^= temp[3];
+	}
+
+#if !ARCH_LITTLE_ENDIAN
+	v = ((unsigned int *)out)[0];
+	((unsigned int *)out)[0] = (v >> 24) | ((v << 8) & 0x00FF0000) | ((v >> 8) & 0x0000FF00) | (v << 24);
+	v = ((unsigned int *)out)[1];
+	((unsigned int *)out)[1] = (v >> 24) | ((v << 8) & 0x00FF0000) | ((v >> 8) & 0x0000FF00) | (v << 24);
+	v = ((unsigned int *)out)[2];
+	((unsigned int *)out)[2] = (v >> 24) | ((v << 8) & 0x00FF0000) | ((v >> 8) & 0x0000FF00) | (v << 24);
+	v = ((unsigned int *)out)[3];
+	((unsigned int *)out)[3] = (v >> 24) | ((v << 8) & 0x00FF0000) | ((v >> 8) & 0x0000FF00) | (v << 24);
+#endif
+}
+
+
+static void crypt_all(int count)
+{
+	int i;
+
+	if (new_key)
+	{
+		new_key = 0;
+		nt_hash(count);
+	}
+
+#if MS_NUM_KEYS > 1 && defined(_OPENMP)
+#pragma omp parallel for default(none) private(i) shared(count, last, salt_buffer, salt_len, crypt, output1x, output1x_dcc2)
+#endif
+	for (i = 0; i < count; i++)
+	{
+		unsigned int a;
+		unsigned int b;
+		unsigned int c;
+		unsigned int d;
+
+		a = last[4 * i + 0];
+		b = last[4 * i + 1];
+		c = last[4 * i + 2];
+		d = last[4 * i + 3];
+
+		a += (d ^ (b & (c ^ d)))  + salt_buffer[0]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  + salt_buffer[1]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  + salt_buffer[2]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))  + salt_buffer[3]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d)))  + salt_buffer[4]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  + salt_buffer[5]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  + salt_buffer[6]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))  + salt_buffer[7]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d)))  + salt_buffer[8]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  + salt_buffer[9]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  + salt_buffer[10] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))/*+salt_buffer[11]*/;b = (b << 19) | (b >> 13);
+
+		// round 2
+		a += ((b & (c | d)) | (c & d))  +  crypt[4 * i + 0] + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[0]   + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[4]   + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))  +  salt_buffer[8]   + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d))  +  crypt[4 * i + 1] + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[1]   + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[5]   + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))  +  salt_buffer[9]   + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d))  +  crypt[4 * i + 2] + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[2]   + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[6]   + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))  +  salt_buffer[10]  + SQRT_2; b = (b << 13) | (b >> 19);
+
+		a += ((b & (c | d)) | (c & d))  +  crypt[4 * i + 3] + SQRT_2; a = (a << 3 ) | (a >> 29);
+		d += ((a & (b | c)) | (b & c))  +  salt_buffer[3]   + SQRT_2; d = (d << 5 ) | (d >> 27);
+		c += ((d & (a | b)) | (a & b))  +  salt_buffer[7]   + SQRT_2; c = (c << 9 ) | (c >> 23);
+		b += ((c & (d | a)) | (d & a))/*+ salt_buffer[11]*/ + SQRT_2; b = (b << 13) | (b >> 19);
+
+		// round 3
+		a += (b ^ c ^ d) + crypt[4 * i + 0] +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + salt_buffer[4]   +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + salt_buffer[0]   +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + salt_buffer[8]   +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + crypt[4 * i + 2] +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + salt_buffer[6]   +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + salt_buffer[2]   +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + salt_buffer[10]  +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + crypt[4 * i + 1] + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + salt_buffer[5]   + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + salt_buffer[1]   + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) + salt_buffer[9]   + SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (b ^ c ^ d) + crypt[4 * i + 3] + SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (a ^ b ^ c) + salt_buffer[7]   + SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (d ^ a ^ b) + salt_buffer[3]   + SQRT_3; c = (c << 11) | (c >> 21);
+		b += (c ^ d ^ a) /*+ salt_buffer[11] */ + SQRT_3; b = (b << 15) | (b >> 17);
+
+#if ARCH_LITTLE_ENDIAN
+		output1x[4 * i + 0] = a + INIT_A;
+		output1x[4 * i + 1] = b + INIT_B;
+		output1x[4 * i + 2] = c + INIT_C;
+		output1x[4 * i + 3] = d + INIT_D;
+#else
+		a = a + INIT_A;
+		b = b + INIT_B;
+		c = c + INIT_C;
+		d = d + INIT_D;
+
+		output1x[4 * i + 0] = (a >> 24) | ((a << 8) & 0x00FF0000) | ((a >> 8) & 0x0000FF00) | (a << 24);
+		output1x[4 * i + 1] = (b >> 24) | ((b << 8) & 0x00FF0000) | ((b >> 8) & 0x0000FF00) | (b << 24);
+		output1x[4 * i + 2] = (c >> 24) | ((c << 8) & 0x00FF0000) | ((c >> 8) & 0x0000FF00) | (c << 24);
+		output1x[4 * i + 3] = (d >> 24) | ((d << 8) & 0x00FF0000) | ((d >> 8) & 0x0000FF00) | (d << 24);
+#endif
+		// PBKDF2 for new Domain Cached Credentials (MS Cash 2)
+		PBKDF2_DCC2((unsigned char *)&output1x[4 * i], (unsigned char *)salt_buffer, salt_len, &output1x_dcc2[4 * i]);
+	}
+}
+
+
+static int cmp_all(void *binary, int count)
+{
+	unsigned int i = 0;
+	unsigned int d = ((unsigned int *)binary)[3];
+
+	for (; i < count; i++)
+		if (d == output1x_dcc2[i * 4 + 3])
+			return 1;
+
+	return 0;
+}
+
+
+static int cmp_one(void * binary, int index)
+{
+	unsigned int *t = (unsigned int *)binary;
+	unsigned int a = output1x_dcc2[4 * index + 0];
+	unsigned int b = output1x_dcc2[4 * index + 1];
+	unsigned int c = output1x_dcc2[4 * index + 2];
+	unsigned int d = output1x_dcc2[4 * index + 3];
+
+	if (d != t[3])
+		return 0;
+
+	if (c != t[2])
+		return 0;
+
+	if (b != t[1])
+		return 0;
+
+	return (a == t[0]);
+}
+
+
+static int cmp_exact(char *source, int index)
+{
+	// This check is for the improbable case of collisions.
+	// It checks if the salts are the same.
+	unsigned int *salt = fmt_mscash2.methods.salt(source);
+	unsigned int i = 0;
+
+	for(; i < 11; i++)
+		if(salt[i] != salt_buffer[i])
+			return 0;
+	return 1;
+}
+
+
+static void set_key(char *_key, int index)
+{
+	unsigned char *key = (unsigned char *) _key;
+	unsigned int md4_size = 0;
+	unsigned int i = 0;
+	unsigned int temp;
+	unsigned int saved_base = index * SAVED_PLAIN_BUF;
+	unsigned int buff_base = index << 4;
+
+	for(; key[md4_size] && md4_size < PLAINTEXT_LENGTH; i++, md4_size++)
+	{
+		saved_plain[saved_base + md4_size] = key[md4_size];
+		temp = key[++md4_size];
+		saved_plain[saved_base + md4_size] = temp;
+
+		if(temp)
+		{
+			ms_buffer1x[buff_base + i] = key[md4_size - 1] | (temp << 16);
+		}
+		else
+		{
+			ms_buffer1x[buff_base + i] = key[md4_size - 1] | 0x800000;
+			goto key_cleaning;
+		}
+	}
+
+	ms_buffer1x[buff_base + i] = 0x80;
+	saved_plain[saved_base + md4_size] = 0;
+
+key_cleaning:
+	i++;
+	for(; i <= last_i[index]; i++)
+		ms_buffer1x[buff_base + i] = 0;
+
+	last_i[index] = md4_size >> 1;
+
+	ms_buffer1x[buff_base + 14] = md4_size << 4;
+
+	// new password candidate
+	new_key = 1;
+}
+
+
+static void set_key_utf8(char *_key, int index)
+{
+	unsigned char *key = (unsigned char *) _key;
+	int utf8len = strlen(_key);
+	unsigned int md4_size = 0;
+	unsigned int i = 0;
+	unsigned int saved_base = index * SAVED_PLAIN_BUF;
+	unsigned int buff_base = index << 4;
+	UTF16 utf16key[PLAINTEXT_LENGTH + 1];
+
+	int utf16len = utf8towcs(utf16key, PLAINTEXT_LENGTH, key, utf8len);
+
+	if (utf16len <= 0) {
+		utf8len = -utf16len;
+		if (utf16len != 0)
+			utf16len = strlen16(utf16key);
+	}
+
+	for(;md4_size+1<utf16len;i++,md4_size+=2)
+		ms_buffer1x[i+buff_base] = BESWAP16(utf16key[md4_size]) | (BESWAP16(utf16key[md4_size+1])<<16);
+
+	if (md4_size<utf16len) {
+		ms_buffer1x[i+buff_base] = 0x800000 | BESWAP16(utf16key[md4_size]);
+		md4_size++;
+	}
+	else
+		ms_buffer1x[i+buff_base]=0x80;
+
+	for(i++;i<=last_i[index];i++)
+		ms_buffer1x[i+buff_base]=0;
+
+	last_i[index]=md4_size>>1;
+
+	ms_buffer1x[14+buff_base] = md4_size << 4;
+
+	memcpy(&saved_plain[saved_base], key, utf8len);
+	saved_plain[saved_base+utf8len] = 0;
+
+	//dump_stuff_msg("setkey utf8", (unsigned char*)&ms_buffer1x, 16*4);
+	//{static int i;if (++i==1)exit(0);}
+
+	// new password candidate
+	new_key = 1;
+}
+
+
+static char *get_key(int index)
+{
+	return saved_plain +( index * SAVED_PLAIN_BUF);
+}
+
+
+// Public domain hash function by DJ Bernstein (salt is a username)
+static int salt_hash(void *salt)
+{
+	UTF16 *s = salt;
+	unsigned int hash = 5381;
+
+	while (*s != 0x80)
+		hash = ((hash << 5) + hash) ^ *s++;
+
+	return hash & (SALT_HASH_SIZE - 1);
+}
+
+
+struct fmt_main fmt_mscash2 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP | FMT_UNICODE | FMT_UTF8,
+		tests
+	}, {
+		init,
+		prepare,
+		valid,
+		ms_split,
+		get_binary,
+		get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/mskrb5_fmt_plug.c john-1.7.8-jumbo-2/src/mskrb5_fmt_plug.c
--- john-1.7.8/src/mskrb5_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mskrb5_fmt_plug.c	2011-06-08 03:10:33.000000000 +0200
@@ -0,0 +1,477 @@
+/*****************************************************************************
+mskrb5_fmt.c
+
+MS Kerberos 5 "PA ENC TIMESTAMP" by magnum 2011, no rights reserved
+
+This attacks a known-plaintext vulnerability in AS_REQ pre-auth packets. The
+known plaintext is a UTC timestamp in the format 20081120171510Z. Only if this
+indicate a match we decrypt the whole timestamp and calculate our own checksum
+to be really sure.
+
+The plaintext attack combined with re-using key setup was said to result in
+more than 60% speedup. This was confirmed using John the Ripper and variants
+of this code.
+
+http://www.ietf.org/rfc/rfc4757.txt
+http://www.securiteam.com/windowsntfocus/5BP0H0A6KM.html
+
+Input format is 'user:$mskrb5$user$realm$checksum$timestamp'
+
+For compatibility with (possible) future attacks, there are fields for username
+and realm but they are not used in this attack so they can be empty. Example:
+
+user:$mskrb5$$$02E837D06B2AC76891F388D9CC36C67A$2A9785BF5036C45D3843490BF9C228E8C18653E10CE58D7F8EF119D2EF4F92B1803B1451
+
+OMP is supported but it doesn't scale well on more than a few cores as-is.
+
+Based on the Kerberos 5 module by Nasko Oskov, in turn based on
+the KRB4 module by Dug Song.
+
+*****************************************************************************/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <ctype.h>
+#ifdef _OPENMP
+#include <omp.h>
+#endif
+
+#include "arch.h"
+#include "misc.h"
+#include "formats.h"
+#include "options.h"
+#include "common.h"
+#include "unicode.h"
+
+#if 0
+#warning INFO: We are using OpenSSL HMAC_MD5
+#include <openssl/hmac.h>
+static void hmac_md5(const unsigned char *key, const unsigned char *data, int datalen, unsigned char *digest)
+{
+	HMAC(EVP_md5(), key, 16, data, datalen, digest, NULL);
+}
+#else
+#include "md5.h"
+#include "hmacmd5.h"
+// Move a hmac_md5_init() from crypt_all to set_key(),
+// and store &ctx in saved_key.
+//
+// Pro: saves another key setup using same key
+// Con: larger saved_key (288 bytes vs 16)
+//
+// This boosted performance with about 8%
+#define SPLIT_HMACMD5
+#endif
+
+#include <openssl/rc4.h>
+#include "md4.h"
+
+#define FORMAT_LABEL       "mskrb5"
+#define FORMAT_NAME        "MS Kerberos 5 AS-REQ Pre-Auth"
+#define ALGORITHM_NAME     "mskrb5"
+#define BENCHMARK_COMMENT  ""
+#define BENCHMARK_LENGTH   0
+#define PLAINTEXT_LENGTH   125
+#define UTF8_PLAINTEXT_LEN 125
+#define CRYPT_BINARY_SIZE  8
+#define BINARY_SIZE        0
+#define MAX_REALMLEN       20
+#define MAX_USERLEN        15
+#define CHECKSUM_SIZE      16
+#define TIMESTAMP_SIZE     36
+#define KEY_SIZE           16
+#define SALT_SIZE          (CHECKSUM_SIZE + TIMESTAMP_SIZE)
+#define TOTAL_LENGTH       (10 + 2 * (CHECKSUM_SIZE + TIMESTAMP_SIZE) + MAX_REALMLEN + MAX_USERLEN)
+#define PLAINTEXT_OFFSET   14
+
+// these may be altered in init() if running OMP
+// and that formula is subject to change
+#define MIN_KEYS_PER_CRYPT	    1
+#define THREAD_RATIO            32
+#ifdef _OPENMP
+#define MAX_KEYS_PER_CRYPT	    0x10000
+#else
+#define MAX_KEYS_PER_CRYPT	    THREAD_RATIO
+#endif
+
+// Second and third plaintext will be replaced in init() under --utf8
+static struct fmt_tests tests[] = {
+	{"$mskrb5$john$JOHN.DOE.MS.COM$02E837D06B2AC76891F388D9CC36C67A$2A9785BF5036C45D3843490BF9C228E8C18653E10CE58D7F8EF119D2EF4F92B1803B1451", "fr2beesgr"},
+	{"$mskrb5$$$958db4ddb514a6cc8be1b1ccf82b0191$090408357a6f41852d17f3b4bb4634adfd388db1be64d3fe1a1d75ee4338d2a4aea387e5", "\xFC"}, // German u-umlaut
+	{"$mskrb5$$$057cd5cb706b3de18e059912b1f057e3$fe2e561bd4e42767e972835ea99f08582ba526e62a6a2b6f61364e30aca7c6631929d427", "\xDC\xDC"}, // two of them in uppercase
+	{"$mskrb5$$$98cd00b6f222d1d34e08fe0823196e0b$5937503ec29e3ce4e94a051632d0fff7b6781f93e3decf7dca707340239300d602932154", ""},
+	{"$mskrb5$$$F4085BA458B733D8092E6B348E3E3990$034ACFC70AFBA542690B8BC912FCD7FED6A848493A3FF0D7AF641A263B71DCC72902995D", "frank"},
+	{"$mskrb5$$$eb03b6fbcfe91f8346f3c0ae7e8abfe5$afcbe07c32c3450b37d0f2516354570fe7d3e78f829e77cdc1718adf612156507181f7da", "John"},
+	{"$mskrb5$$$881c257ce5df7b11715a6a60436e075a$c80f4a5ec18e7c5f765fb9f00eda744a57483db500271369cf4752a67ca0e67f37c68402", "the"},
+	{"$mskrb5$$$ef012e13c8b32448241091f4e1fdc805$354931c919580d4939421075bcd50f2527d092d2abdbc0e739ea72929be087de644cef8a", "Ripper"},
+	{"$mskrb5$$$334ef74dad191b71c43efaa16aa79d88$34ebbad639b2b5a230b7ec1d821594ed6739303ae6798994e72bd13d5e0e32fdafb65413", "VeryveryveryloooooooongPassword"},
+	{NULL}
+};
+
+static ARCH_WORD_32 saved_plain[MAX_KEYS_PER_CRYPT][(UTF8_PLAINTEXT_LEN+4)/sizeof(ARCH_WORD_32)];
+static ARCH_WORD_32 output[MAX_KEYS_PER_CRYPT][CRYPT_BINARY_SIZE/sizeof(ARCH_WORD_32)];
+#ifdef SPLIT_HMACMD5
+static HMACMD5Context saved_key[MAX_KEYS_PER_CRYPT];
+#else
+static unsigned char saved_key[MAX_KEYS_PER_CRYPT][KEY_SIZE];
+#endif
+
+static unsigned char *saltblob = NULL;
+#define CHECKSUM  saltblob
+#define TIMESTAMP &saltblob[CHECKSUM_SIZE]
+
+extern struct fmt_main fmt_mskrb5;
+static void init(struct fmt_main *pFmt)
+{
+#ifdef _OPENMP
+	int n = MIN_KEYS_PER_CRYPT * omp_get_max_threads();
+	if (n < MIN_KEYS_PER_CRYPT)
+		n = MIN_KEYS_PER_CRYPT;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_mskrb5.params.min_keys_per_crypt = n;
+	n = n * n * ((n >> 1) + 1) * THREAD_RATIO;
+	if (n > MAX_KEYS_PER_CRYPT)
+		n = MAX_KEYS_PER_CRYPT;
+	fmt_mskrb5.params.max_keys_per_crypt = n;
+#endif
+	if (options.flags & FLG_UTF8) {
+		// in utf-8, up to four bytes can compose one character
+		fmt_mskrb5.params.plaintext_length = UTF8_PLAINTEXT_LEN;
+		tests[1].plaintext = "\xC3\xBC";         // German u-umlaut in UTF-8
+		tests[2].plaintext = "\xC3\x9C\xC3\x9C"; // 2x uppercase of them
+	}
+}
+
+static char *hex2bin(char *src, unsigned char *dst, int outsize)
+{
+	char *p, *pe;
+	unsigned char *q, *qe, ch, cl;
+
+	pe = src + strlen(src);
+	qe = dst + outsize;
+
+	for (p = src, q = dst;
+	    p < pe && q < qe && isxdigit((int) (unsigned char) *p); p += 2) {
+		ch = tolower((int) (unsigned char) p[0]);
+		cl = tolower((int) (unsigned char) p[1]);
+
+		if ((ch >= '0') && (ch <= '9'))
+			ch -= '0';
+		else if ((ch >= 'a') && (ch <= 'f'))
+			ch -= 'a' - 10;
+		else
+			return p;
+
+		if ((cl >= '0') && (cl <= '9'))
+			cl -= '0';
+		else if ((cl >= 'a') && (cl <= 'f'))
+			cl -= 'a' - 10;
+		else
+			return p + 1;
+
+		*q++ = (ch << 4) | cl;
+	}
+	return p;
+}
+
+static void *get_salt(char *ciphertext)
+{
+	static unsigned char *salt;
+	char *data = ciphertext, *p;
+	int n;
+
+	if (!salt) salt = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);
+
+	// skip the $mskrb5$ string
+	data += 8;
+
+	// skip the user field
+	p = strchr(data, '$');
+	if (!p)
+		return NULL;
+	data = p + 1;
+
+	// skip the realm field
+	p = strchr(data, '$');
+	if (!p)
+		return NULL;
+	data = p + 1;
+
+	// read the checksum
+	p = strchr(data, '$');
+	if (!p)
+		return NULL;
+	n = (p - data);
+	if (n != 2 * CHECKSUM_SIZE)
+		return NULL;
+	p = hex2bin(data, salt, CHECKSUM_SIZE);
+	data = p + 1;
+
+	// read the encrypted timestamp
+	p = hex2bin(data, &salt[CHECKSUM_SIZE], TIMESTAMP_SIZE);
+	if (*p || p - data != TIMESTAMP_SIZE * 2)
+		return NULL;
+
+	return salt;
+}
+
+static void set_salt(void *salt)
+{
+	saltblob = salt;
+}
+
+static char *split(char *ciphertext, int index)
+{
+	static char out[TOTAL_LENGTH + 1];
+	char *data;
+
+	strncpy(out, ciphertext, sizeof(out));
+	out[TOTAL_LENGTH] = 0;
+	data = out;
+
+	// the $mskrb5$ string
+	data += 8;
+
+	// the user field (may be empty for this attack)
+	data = strchr(data, '$') + 1;
+
+	// the realm field (may be empty for this attack)
+	data = strchr(data, '$') + 1;
+
+	strlwr(data);
+
+	return out;
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *data = ciphertext, *p;
+
+	if (strncmp(ciphertext, "$mskrb5$", 8) != 0)
+		return 0;
+	data += 8;
+
+	// user field
+	p = strchr(data, '$');
+	if (!p || p - data > MAX_USERLEN)
+		return 0;
+	data = p + 1;
+
+	// realm field
+	p = strchr(data, '$');
+	if (!p || p - data > MAX_REALMLEN)
+		return 0;
+	data = p + 1;
+
+	// checksum
+	p = strchr(data, '$');
+	if (!p || p - data != 2 * CHECKSUM_SIZE)
+		return 0;
+	data = p + 1;
+
+	// encrypted timestamp
+	p += strlen(data) + 1;
+	if (*p || p - data != TIMESTAMP_SIZE * 2)
+		return 0;
+
+	return 1;
+}
+
+static void set_key(char *key, int index)
+{
+	const unsigned char one[] = { 1, 0, 0, 0 };
+	unsigned char K[KEY_SIZE];
+	int len;
+#ifdef SPLIT_HMACMD5
+	unsigned char K1[KEY_SIZE];
+#endif
+
+	len = strlen(key);
+	memcpy(saved_plain[index], key, len + 1);
+
+	// K = MD4(UTF-16LE(password)), ordinary 16-byte NTLM hash
+	len = E_md4hash((unsigned char *) saved_plain[index], len, K);
+
+	if (len <= 0)
+		((char*)(saved_plain[index]))[-len] = 0;	// match truncation
+
+	// K1 = HMAC-MD5(K, 1)
+	// 1 is encoded as little endian in 4 bytes (0x01000000)
+#ifdef SPLIT_HMACMD5
+	hmac_md5(K, (unsigned char *) &one, 4, K1);
+
+	// We do key setup of the next HMAC_MD5 here. rest in crypt_all()
+	// &saved_key is now &ctx
+	hmac_md5_init_K16(K1, &saved_key[index]);
+#else
+	hmac_md5(K, (unsigned char *) &one, 4, saved_key[index]);
+#endif
+}
+
+static char *get_key(int index)
+{
+	return (char *) saved_plain[index];
+}
+
+static void crypt_all(int count)
+{
+	unsigned char K3[KEY_SIZE], cleartext[PLAINTEXT_OFFSET + CRYPT_BINARY_SIZE];
+	RC4_KEY key;
+	int i;
+
+#ifdef _OPENMP
+#pragma omp parallel for default(none) private(i, K3, cleartext, key) shared(count, output, saved_key, saltblob)
+#endif
+	for (i = 0; i < count; i++) {
+		// K1 is stored in saved_key[index]
+		// CHECKSUM and TIMESTAMP are just defines, they are actually
+		// concatenated to saltblob[]
+
+		// K3 = HMAC-MD5(K1, CHECKSUM)
+#ifdef SPLIT_HMACMD5
+		HMACMD5Context ctx; // can't be moved above the OMP pragma
+		memcpy(&ctx, &saved_key[i], sizeof(ctx));
+		hmac_md5_update(CHECKSUM, CHECKSUM_SIZE, &ctx);
+		hmac_md5_final(K3, &ctx);
+#else
+		hmac_md5(saved_key[i], CHECKSUM, CHECKSUM_SIZE, K3);
+#endif
+
+		// RC4(K3, TIMESTAMP) decrypt part of the timestamp
+		RC4_set_key(&key, KEY_SIZE, K3);
+		RC4(&key, PLAINTEXT_OFFSET + CRYPT_BINARY_SIZE, TIMESTAMP,
+		    cleartext);
+
+		// 15th byte and on is our partial binary
+		memcpy(output[i], &cleartext[PLAINTEXT_OFFSET], CRYPT_BINARY_SIZE);
+	}
+}
+
+static int cmp_all(void *binary, int count)
+{
+	int index;
+	char *tst;
+
+	for (index = 0; index < count; index++) {
+		tst = (char*)(output[index]);
+		if (tst[0] == '2' && tst[1] == '0'
+		    && (tst[2] <= '9' && tst[2] >= '0')
+		    && (tst[3] <= '9' && tst[3] >= '0')
+		    && (tst[4] == '0' || tst[4] == '1')
+		    && (tst[5] <= '9' && tst[5] >= '0')
+		    && (tst[6] <= '3' && tst[6] >= '0')
+		    && (tst[7] <= '9' && tst[7] >= '0')
+		    )
+			return 1;
+	}
+	return 0;
+}
+
+static int cmp_one(void *binary, int index)
+{
+	char *tst = (char*)(output[index]);
+
+	return (tst[0] == '2' && tst[1] == '0'
+		    && (tst[2] <= '9' && tst[2] >= '0')
+		    && (tst[3] <= '9' && tst[3] >= '0')
+		    && (tst[4] == '0' || tst[4] == '1')
+		    && (tst[5] <= '9' && tst[5] >= '0')
+		    && (tst[6] <= '3' && tst[6] >= '0')
+		    && (tst[7] <= '9' && tst[7] >= '0')
+	    );
+}
+
+static int cmp_exact(char *source, int index)
+{
+#ifdef SPLIT_HMACMD5
+	HMACMD5Context ctx;
+#endif
+	unsigned char K2[KEY_SIZE], K3[KEY_SIZE];
+	RC4_KEY key;
+	unsigned char cleartext[TIMESTAMP_SIZE];
+
+	// K1 is stored in saved_key[index]
+	// CHECKSUM and TIMESTAMP are just defines, they are actually
+	// concatenated to saltblob[]
+
+	// K3 = HMAC-MD5(K1, CHECKSUM)
+#ifdef SPLIT_HMACMD5
+	memcpy(&ctx, &saved_key[index], sizeof(ctx));
+	hmac_md5_update(CHECKSUM, CHECKSUM_SIZE, &saved_key[index]);
+	hmac_md5_final(K3, &saved_key[index]);
+#else
+	hmac_md5(saved_key[index], CHECKSUM, CHECKSUM_SIZE, K3);
+#endif
+
+	// Decrypt the timestamp with the derived key K3
+	RC4_set_key(&key, KEY_SIZE, K3);
+	RC4(&key, TIMESTAMP_SIZE, TIMESTAMP, cleartext);
+
+	// create checksum K2 = HMAC-MD5(K1, cleartext)
+#ifdef SPLIT_HMACMD5
+	hmac_md5_update(cleartext, TIMESTAMP_SIZE, &ctx);
+	hmac_md5_final(K2, &ctx);
+#else
+	hmac_md5(saved_key[index], cleartext, TIMESTAMP_SIZE, K2);
+#endif
+
+	// Compare our checksum with the input checksum
+	return (!memcmp(K2, CHECKSUM, CHECKSUM_SIZE));
+}
+
+static int salt_hash(void *salt)
+{
+	return (*(ARCH_WORD_32 *) salt) & (SALT_HASH_SIZE - 1);
+}
+
+struct fmt_main fmt_mskrb5 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_OMP | FMT_UNICODE | FMT_UTF8,
+		tests
+	}, {
+		init,
+		fmt_default_prepare,
+		valid,
+		split,
+		fmt_default_binary,
+		get_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/mssql-old_fmt_plug.c john-1.7.8-jumbo-2/src/mssql-old_fmt_plug.c
--- john-1.7.8/src/mssql-old_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mssql-old_fmt_plug.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,439 @@
+/*
+ * This software is Copyright  2004 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ *
+ * UTF-8 support by magnum 2011, no rights reserved
+ *
+ * microsoft MS SQL cracker
+ *
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+#include "unicode.h"
+#include "sha.h"
+
+#define FORMAT_LABEL			"mssql"
+#define FORMAT_NAME			"MS-SQL"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME			"mssql MMX"
+#else
+#define ALGORITHM_NAME			"mssql SSE2"
+#endif
+#else
+#define ALGORITHM_NAME			"mssql"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		25
+#define CIPHERTEXT_LENGTH		94
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			4
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		MMX_COEF
+#define MAX_KEYS_PER_CRYPT		MMX_COEF
+//#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + ((i)&3) ) //std getpos
+#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) ) //for endianity conversion
+#if (MMX_COEF==2)
+#define SALT_EXTRA_LEN          0x40004
+#else
+#define SALT_EXTRA_LEN          0x4040404
+#endif
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+//microsoft unicode ...
+#if ARCH_LITTLE_ENDIAN
+#define ENDIAN_SHIFT_L
+#define ENDIAN_SHIFT_R
+#else
+#define ENDIAN_SHIFT_L  << 8
+#define ENDIAN_SHIFT_R  >> 8
+#endif
+
+static struct fmt_tests mssql_tests[] = {
+	{"0x0100A607BA7C54A24D17B565C59F1743776A10250F581D482DA8B6D6261460D3F53B279CC6913CE747006A2E3254", "FOO"},
+	{"0x01000508513EADDF6DB7DDD270CCA288BF097F2FF69CC2DB74FBB9644D6901764F999BAB9ECB80DE578D92E3F80D", "BAR"},
+	{"0x01008408C523CF06DCB237835D701C165E68F9460580132E28ED8BC558D22CEDF8801F4503468A80F9C52A12C0A3", "CANARD"},
+	{"0x0100BF088517935FC9183FE39FDEC77539FD5CB52BA5F5761881E5B9638641A79DBF0F1501647EC941F3355440A2", "LAPIN"},
+	{NULL}
+};
+
+static unsigned char cursalt[SALT_SIZE];
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define saved_key mssql_saved_key
+#define crypt_key mssql_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) char saved_key[80*4*MMX_COEF];
+__declspec(align(16)) char crypt_key[BINARY_SIZE*MMX_COEF];
+#else
+char saved_key[80*4*MMX_COEF] __attribute__ ((aligned(16)));
+char crypt_key[BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+static unsigned long total_len;
+static unsigned char saved_plain[MMX_COEF][PLAINTEXT_LENGTH*3+1];
+#else
+
+static unsigned char *saved_key;
+static unsigned char saved_plain[PLAINTEXT_LENGTH*3 + 1];
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static unsigned int key_length;
+#endif
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH) return 0;
+	if(memcmp(ciphertext, "0x0100", 6))
+		return 0;
+	for (i = 6; i < CIPHERTEXT_LENGTH; i++){
+		if (!(  (('0' <= ciphertext[i])&&(ciphertext[i] <= '9')) ||
+					(('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))
+					|| (('A' <= ciphertext[i])&&(ciphertext[i] <= 'F'))))
+			return 0;
+	}
+	return 1;
+}
+
+static void mssql_set_salt(void *salt)
+{
+	memcpy(cursalt, salt, SALT_SIZE);
+}
+
+static void * mssql_get_salt(char * ciphertext)
+{
+	static unsigned char *out2;
+	int l;
+
+	if (!out2) out2 = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);
+
+	for(l=0;l<SALT_SIZE;l++)
+	{
+		out2[l] = atoi16[ARCH_INDEX(ciphertext[l*2+6])]*16
+			+ atoi16[ARCH_INDEX(ciphertext[l*2+7])];
+	}
+
+	return out2;
+}
+
+static inline unsigned char upper(unsigned char c)
+{
+	if( (c>='a') && (c<='z'))
+		return c ^ 0x20;
+	return c;
+}
+
+static void mssql_set_key_utf8(char *_key, int index);
+extern struct fmt_main fmt_mssql;
+
+static void mssql_init(struct fmt_main *pFmt)
+{
+#ifdef MMX_COEF
+	memset(saved_key, 0, sizeof(saved_key));
+#else
+	saved_key = mem_alloc_tiny(PLAINTEXT_LENGTH*2 + 1 + SALT_SIZE, MEM_ALIGN_WORD);
+#endif
+	if (options.flags & FLG_UTF8) {
+		fmt_mssql.methods.set_key = mssql_set_key_utf8;
+		fmt_mssql.params.plaintext_length = PLAINTEXT_LENGTH * 3;
+	}
+}
+
+static void mssql_set_key(char *key, int index) {
+#ifdef MMX_COEF
+	int len;
+	int i;
+
+	if(index==0)
+	{
+		total_len = 0;
+		memset(saved_key, 0, 64*MMX_COEF);
+	}
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+
+	total_len += (len*2) << ( ( (32/MMX_COEF) * index ) );
+	for(i=0;i<len;i++)
+	{
+		saved_key[GETPOS((i*2), index)] = saved_plain[index][i] = upper(key[i]);
+//		saved_key[GETPOS((i*2+1), index)] = 0;
+	}
+	saved_key[GETPOS((i*2+SALT_SIZE) , index)] = 0x80;
+	saved_plain[index][i] = 0;
+#else
+	key_length = 0;
+	while( (((unsigned short *)saved_key)[key_length] = (saved_plain[key_length] = upper(key[key_length])) ENDIAN_SHIFT_L ))
+		key_length++;
+#endif
+}
+
+static void mssql_set_key_utf8(char *_key, int index) {
+	unsigned char *key = (unsigned char*)_key;
+	int utf8len = strlen(_key);
+	int i;
+	UTF16 utf16key[PLAINTEXT_LENGTH+1];
+	int utf16len = utf8towcs(utf16key, PLAINTEXT_LENGTH, key, utf8len);
+	if (utf16len <= 0) {
+		utf8len = -utf16len;
+		if (utf16len != 0)
+			utf16len = strlen16(utf16key);
+	}
+#ifdef MMX_COEF
+	if(index==0)
+	{
+		total_len = 0;
+		memset(saved_key, 0, 64*MMX_COEF);
+	}
+
+	total_len += (utf16len*2) << ( ( (32/MMX_COEF) * index ) );
+	for(i=0;i<utf16len;i++)
+	{
+		// for now, must be fed with uppercase if non-ascii
+		if (utf16key[i]>>8 == 0)
+			utf16key[i] = upper(utf16key[i]);
+		saved_key[GETPOS((i*2), index)] = (char)utf16key[i];
+		saved_key[GETPOS((i*2+1), index)] = (char)(utf16key[i]>>8);
+	}
+	saved_key[GETPOS((i*2+SALT_SIZE) , index)] = 0x80;
+	for(i=0;i<utf8len;i++)
+		saved_plain[index][i] = upper(key[i]);
+	saved_plain[index][i] = 0;
+#else
+	for(i=0;i<utf16len;i++)
+	{
+		// for now, must be fed with uppercase if non-ascii
+#if 0
+#if ARCH_LITTLE_ENDIAN
+		if (utf16key[i]>>8 == 0)
+			utf16key[i] = upper(utf16key[i]);
+		saved_key[i*2] = (char)utf16key[i];
+		saved_key[i*2+1] = (char)(utf16key[i]>>8);
+#else
+		unsigned char uc = (char)(utf16key[i]>>8);
+		if ((utf16key[i]&0xFF) == 0)
+			uc = upper(uc);
+		saved_key[i*2] = uc;
+		saved_key[i*2+1] = (char)utf16key[i];
+#endif
+#else
+		// I have left both 'working' LE vs BE blocks in code.
+		// I prefer this one, it is 'simpler' :)
+		unsigned char *uc = (unsigned char*)&(utf16key[i]);
+		if (uc[1] == 0) saved_key[i*2] = upper(uc[0]);
+		else            saved_key[i*2] = uc[0];
+		saved_key[i*2+1] = uc[1];
+#endif
+	}
+	key_length = i;
+	for(i=0;i<utf8len;i++)
+		saved_plain[i] = upper(key[i]);
+	saved_plain[i] = 0;
+#endif
+}
+
+static char *mssql_get_key(int index) {
+#ifdef MMX_COEF
+	return (char*) saved_plain[index];
+#else
+	return (char*) saved_plain;
+#endif
+}
+
+static int mssql_cmp_all(void *binary, int count) {
+#ifdef MMX_COEF
+	int i=0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#endif
+		)
+			return 0;
+		i++;
+	}
+	return 1;
+#else
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int mssql_cmp_exact(char *source, int count){
+  return (1);
+}
+
+static int mssql_cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+#else
+	return mssql_cmp_all(binary, index);
+#endif
+}
+
+static void mssql_crypt_all(int count) {
+  // get plaintext input in saved_key put it into ciphertext crypt_key
+#ifdef MMX_COEF
+	unsigned i, index;
+	for (index = 0; index < count; ++index)
+	{
+		unsigned len = (total_len >> ((32/MMX_COEF)*index)) & 0xFF;
+		for(i=0;i<SALT_SIZE;i++)
+			saved_key[GETPOS((len+i), index)] = cursalt[i];
+	}
+	shammx( (unsigned char *) crypt_key, (unsigned char *) saved_key, total_len + SALT_EXTRA_LEN);
+#else
+	SHA_CTX ctx;
+	memcpy(saved_key+key_length*2, cursalt, SALT_SIZE);
+	SHA1_Init( &ctx );
+//	dump_stuff_msg("setkey utf8", (unsigned char*)&saved_key[0], 20*4);
+//	exit(0);
+	SHA1_Update( &ctx, saved_key, key_length*2+SALT_SIZE );
+	SHA1_Final( (unsigned char *) crypt_key, &ctx);
+#endif
+
+}
+
+static void * mssql_binary(char *ciphertext)
+{
+	static char *realcipher;
+	int i;
+	if(!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2+54])]*16 + atoi16[ARCH_INDEX(ciphertext[i*2+55])];
+	}
+	return (void *)realcipher;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	// This gave much better distribution on a huge set I analysed
+	return (*((ARCH_WORD_32 *)salt) >> 8) & (SALT_HASH_SIZE - 1);
+}
+
+struct fmt_main fmt_mssql = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_8_BIT | FMT_UNICODE | FMT_UTF8,
+		mssql_tests
+	}, {
+		mssql_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		mssql_binary,
+		mssql_get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		mssql_set_salt,
+		mssql_set_key,
+		mssql_get_key,
+		fmt_default_clear_keys,
+		mssql_crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		mssql_cmp_all,
+		mssql_cmp_one,
+		mssql_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/mssql05_fmt_plug.c john-1.7.8-jumbo-2/src/mssql05_fmt_plug.c
--- john-1.7.8/src/mssql05_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mssql05_fmt_plug.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,439 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ *
+ * Modified by Mathieu Perrin (mathieu at tpfh.org) 09/06
+ * Microsoft MS-SQL05 password cracker
+ *
+ * UTF-8 support by magnum 2011, no rights reserved
+ *
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+#include "unicode.h"
+#include "sha.h"
+
+#define FORMAT_LABEL			"mssql05"
+#define FORMAT_NAME			"MS-SQL05"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME			"ms-sql05 MMX"
+#else
+#define ALGORITHM_NAME			"ms-sql05 SSE2"
+#endif
+#else
+#define ALGORITHM_NAME			"ms-sql05"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		25
+#define CIPHERTEXT_LENGTH		54
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			4
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		MMX_COEF
+#define MAX_KEYS_PER_CRYPT		MMX_COEF
+//#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + ((i)&3) ) //std getpos
+#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) ) //for endianity conversion
+#if (MMX_COEF==2)
+#define SALT_EXTRA_LEN          0x40004
+#else
+#define SALT_EXTRA_LEN          0x4040404
+#endif
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+//microsoft unicode ...
+#if ARCH_LITTLE_ENDIAN
+#define ENDIAN_SHIFT_L
+#define ENDIAN_SHIFT_R
+#else
+#define ENDIAN_SHIFT_L  << 8
+#define ENDIAN_SHIFT_R  >> 8
+#endif
+
+static struct fmt_tests mssql05_tests[] = {
+	{"0x01004086CEB6BF932BC4151A1AF1F13CD17301D70816A8886908", "toto"},
+	{"0x01004086CEB60ED526885801C23B366965586A43D3DEAC6DD3FD", "titi"},
+	{"0x0100A607BA7C54A24D17B565C59F1743776A10250F581D482DA8B6D6261460D3F53B279CC6913CE747006A2E3254", "foo",    {"User1"} },
+	{"0x01000508513EADDF6DB7DDD270CCA288BF097F2FF69CC2DB74FBB9644D6901764F999BAB9ECB80DE578D92E3F80D", "bar",    {"User2"} },
+	{"0x01008408C523CF06DCB237835D701C165E68F9460580132E28ED8BC558D22CEDF8801F4503468A80F9C52A12C0A3", "canard", {"User3"} },
+	{"0x0100BF088517935FC9183FE39FDEC77539FD5CB52BA5F5761881E5B9638641A79DBF0F1501647EC941F3355440A2", "lapin",  {"User4"} },
+	{NULL}
+};
+
+static unsigned char cursalt[SALT_SIZE];
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define saved_key mssql05_saved_key
+#define crypt_key mssql05_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) char saved_key[80*4*MMX_COEF];
+__declspec(align(16)) char crypt_key[BINARY_SIZE*MMX_COEF];
+#else
+char saved_key[80*4*MMX_COEF] __attribute__ ((aligned(16)));
+char crypt_key[BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+static unsigned long total_len;
+static unsigned char saved_plain[MMX_COEF][PLAINTEXT_LENGTH*3+1];
+#else
+
+static unsigned char *saved_key;
+static unsigned char saved_plain[PLAINTEXT_LENGTH*3 + 1];
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static unsigned int key_length;
+#endif
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH) return 0;
+	if(memcmp(ciphertext, "0x0100", 6))
+		return 0;
+	for (i = 6; i < CIPHERTEXT_LENGTH; i++){
+		if (!(  (('0' <= ciphertext[i])&&(ciphertext[i] <= '9')) ||
+					(('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))
+					|| (('A' <= ciphertext[i])&&(ciphertext[i] <= 'F'))))
+			return 0;
+	}
+	return 1;
+}
+
+// Handle full hashes (old and new in one long string) as well. This means the
+// [other] mssql format should be registered before this one. If there are
+// old-style hashes we should crack them first using that format, then run
+// mssql05 with -ru:nt just like LM -> NT format
+static char *prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+	if (strlen(split_fields[1]) == CIPHERTEXT_LENGTH)
+		return split_fields[1];
+
+	if (!memcmp(split_fields[1], "0x0100", 6) && strlen(split_fields[1]) == 94) {
+		char cp[CIPHERTEXT_LENGTH + 1];
+		strnzcpy(cp, split_fields[1], CIPHERTEXT_LENGTH + 1);
+
+		if (valid(cp,pFmt)) {
+			char *cp2 = str_alloc_copy(cp);
+			return cp2;
+		}
+	}
+	return split_fields[1];
+}
+
+static void mssql05_set_salt(void *salt)
+{
+	memcpy(cursalt, salt, SALT_SIZE);
+}
+
+static void * mssql05_get_salt(char * ciphertext)
+{
+	static unsigned char *out2;
+	int l;
+
+	if (!out2) out2 = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);
+
+	for(l=0;l<SALT_SIZE;l++)
+	{
+		out2[l] = atoi16[ARCH_INDEX(ciphertext[l*2+6])]*16
+			+ atoi16[ARCH_INDEX(ciphertext[l*2+7])];
+	}
+
+	return out2;
+}
+
+static void mssql05_set_key_utf8(char *_key, int index);
+extern struct fmt_main fmt_mssql05;
+
+static void mssql05_init(struct fmt_main *pFmt)
+{
+#ifdef MMX_COEF
+	memset(saved_key, 0, sizeof(saved_key));
+#else
+	saved_key = mem_alloc_tiny(PLAINTEXT_LENGTH*2 + 1 + SALT_SIZE, MEM_ALIGN_WORD);
+#endif
+	if (options.flags & FLG_UTF8) {
+		fmt_mssql05.methods.set_key = mssql05_set_key_utf8;
+		fmt_mssql05.params.plaintext_length = PLAINTEXT_LENGTH * 3;
+	}
+}
+
+static void mssql05_set_key(char *key, int index) {
+#ifdef MMX_COEF
+	int len;
+	int i;
+
+	if(index==0)
+	{
+		total_len = 0;
+		memset(saved_key, 0, 64*MMX_COEF);
+	}
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+
+	total_len += (len*2) << ( ( (32/MMX_COEF) * index ) );
+	for(i=0;i<len;i++)
+	{
+		saved_key[GETPOS((i*2), index)] = saved_plain[index][i] = key[i];
+//		saved_key[GETPOS((i*2+1), index)] = 0;
+	}
+	saved_key[GETPOS((i*2+SALT_SIZE) , index)] = 0x80;
+	saved_plain[index][i] = 0;
+#else
+	key_length = 0;
+	while( (((unsigned short *)saved_key)[key_length] = (saved_plain[key_length] = key[key_length]) ENDIAN_SHIFT_L ))
+		key_length++;
+#endif
+}
+
+static void mssql05_set_key_utf8(char *_key, int index) {
+	unsigned char *key = (unsigned char*)_key;
+	int utf8len = strlen(_key);
+	int i;
+	UTF16 utf16key[PLAINTEXT_LENGTH+1];
+	int utf16len = utf8towcs(utf16key, PLAINTEXT_LENGTH, key, utf8len);
+	if (utf16len <= 0) {
+		utf8len = -utf16len;
+		if (utf16len != 0)
+			utf16len = strlen16(utf16key);
+	}
+#ifdef MMX_COEF
+	if(index==0)
+	{
+		total_len = 0;
+		memset(saved_key, 0, 64*MMX_COEF);
+	}
+
+	total_len += (utf16len*2) << ( ( (32/MMX_COEF) * index ) );
+	for(i=0;i<utf16len;i++)
+	{
+		saved_key[GETPOS((i*2), index)] = (char)utf16key[i];
+		saved_key[GETPOS((i*2+1), index)] = (char)(utf16key[i]>>8);
+	}
+	saved_key[GETPOS((i*2+SALT_SIZE) , index)] = 0x80;
+	for(i=0;i<utf8len;i++)
+		saved_plain[index][i] = key[i];
+	saved_plain[index][i] = 0;
+#else
+	for(i=0;i<utf16len;i++)
+	{
+#if ARCH_LITTLE_ENDIAN
+		saved_key[i*2] = (char)utf16key[i];
+		saved_key[i*2+1] = (char)(utf16key[i]>>8);
+#else
+		saved_key[i*2+1] = (char)utf16key[i];
+		saved_key[i*2] = (char)(utf16key[i]>>8);
+#endif
+	}
+	key_length = i;
+	for(i=0;i<utf8len;i++)
+		saved_plain[i] = key[i];
+	saved_plain[i] = 0;
+#endif
+}
+
+static char *mssql05_get_key(int index) {
+#ifdef MMX_COEF
+	return (char*) saved_plain[index];
+#else
+	return (char*) saved_plain;
+#endif
+}
+
+static int mssql05_cmp_all(void *binary, int cound) {
+#ifdef MMX_COEF
+	int i=0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#endif
+		)
+			return 0;
+		i++;
+	}
+	return 1;
+#else
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int mssql05_cmp_exact(char *source, int count){
+  return (1);
+}
+
+static int mssql05_cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+#else
+	return mssql05_cmp_all(binary, index);
+#endif
+}
+
+static void mssql05_crypt_all(int count) {
+  // get plaintext input in saved_key put it into ciphertext crypt_key
+#ifdef MMX_COEF
+	unsigned i, index;
+	for (index = 0; index < count; ++index)
+	{
+		unsigned len = (total_len >> ((32/MMX_COEF)*index)) & 0xFF;
+		for(i=0;i<SALT_SIZE;i++)
+			saved_key[GETPOS((len+i), index)] = cursalt[i];
+	}
+	shammx((unsigned char *) crypt_key, (unsigned char *) saved_key, total_len + SALT_EXTRA_LEN);
+#else
+	SHA_CTX ctx;
+	memcpy(saved_key+key_length*2, cursalt, SALT_SIZE);
+	SHA1_Init( &ctx );
+//	dump_stuff_msg("setkey utf8", (unsigned char*)&saved_key[0], 20*4);
+//	exit(0);
+	SHA1_Update( &ctx, saved_key, key_length*2+SALT_SIZE );
+	SHA1_Final( (unsigned char *) crypt_key, &ctx);
+#endif
+
+}
+
+static void * mssql05_binary(char *ciphertext)
+{
+	static char *realcipher;
+	int i;
+
+	if(!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2+14])]*16 + atoi16[ARCH_INDEX(ciphertext[i*2+15])];
+	}
+	return (void *)realcipher;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	// This gave much better distribution on a huge set I analysed
+	return (*((ARCH_WORD_32 *)salt) >> 8) & (SALT_HASH_SIZE - 1);
+}
+
+struct fmt_main fmt_mssql05 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_8_BIT | FMT_UNICODE | FMT_UTF8,
+		mssql05_tests
+	}, {
+		mssql05_init,
+		prepare,
+		valid,
+		fmt_default_split,
+		mssql05_binary,
+		mssql05_get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		mssql05_set_salt,
+		mssql05_set_key,
+		mssql05_get_key,
+		fmt_default_clear_keys,
+		mssql05_crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		mssql05_cmp_all,
+		mssql05_cmp_one,
+		mssql05_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/mysqlSHA1_fmt_plug.c john-1.7.8-jumbo-2/src/mysqlSHA1_fmt_plug.c
--- john-1.7.8/src/mysqlSHA1_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/mysqlSHA1_fmt_plug.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,389 @@
+// vim: set ts=8 sw=4 et :
+/*
+ * Copyright (c) 2007 Marti Raudsepp <marti AT juffo org>
+ *
+ * Simple MySQL 4.1+ PASSWORD() hash cracker, rev 1.
+ * Adapted from the original rawSHA1_fmt.c cracker.
+ *
+ * Note that many version 4.1 and 5.0 installations still use the old
+ * homebrewn pre-4.1 hash for compatibility with older clients, notably all
+ * Red Hat-based distributions.
+ *
+ * The new PASSWORD() function is unsalted and equivalent to
+ * SHA1(SHA1(password)) where the inner is a binary digest (not hex!) This
+ * means that with the SSE2-boosted SHA-1 implementation, it will be several
+ * times faster than John's cracker for the old hash format. (though the old
+ * hash had significant weaknesses, John's code does not take advantage of
+ * that)
+ *
+ * It's a slight improvement over the old hash, but still not something a
+ * reasonable DBMS would use for password storage.
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "sha.h"
+
+//#define X_DEBUG
+#ifdef X_DEBUG
+# include <assert.h>
+#endif
+
+#define FORMAT_LABEL			"mysql-sha1"
+#define FORMAT_NAME			"MySQL 4.1 double-SHA-1"
+#ifdef MMX_COEF
+# if (MMX_COEF == 2)
+#  define ALGORITHM_NAME		"mysql-sha1 MMX"
+# else
+#  define ALGORITHM_NAME		"mysql-sha1 SSE2"
+# endif
+#else
+# define ALGORITHM_NAME			"mysql-sha1"
+#endif
+
+#ifdef MMX_TYPE
+# define BENCHMARK_COMMENT		MMX_TYPE
+#else
+# define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		41
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			0
+
+#ifdef MMX_COEF
+# define MIN_KEYS_PER_CRYPT		MMX_COEF
+# define MAX_KEYS_PER_CRYPT		MMX_COEF
+//#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + ((i)&3) ) //std getpos
+# define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) ) //for endianity conversion
+# define BYTESWAP(n) ( \
+        (((n)&0x000000ff) << 24) | \
+        (((n)&0x0000ff00) << 8 ) | \
+        (((n)&0x00ff0000) >> 8 ) | \
+        (((n)&0xff000000) >> 24) )
+#else
+# define MIN_KEYS_PER_CRYPT		1
+# define MAX_KEYS_PER_CRYPT		1
+#endif
+
+static struct fmt_tests mysqlsha1_tests[] = {
+    {"*5AD8F88516BD021DD43F171E2C785C69F8E54ADB", "tere"},
+    {"*2C905879F74F28F8570989947D06A8429FB943E6", "verysecretpassword"},
+    {"*A8A397146B1A5F8C8CF26404668EFD762A1B7B82", "________________________________"},
+    {"*F9F1470004E888963FB466A5452C9CBD9DF6239C", "12345678123456781234567812345678"},
+    {"*97CF7A3ACBE0CA58D5391AC8377B5D9AC11D46D9", "' OR 1 /*'"},
+    {"*2470C0C06DEE42FD1618BB99005ADCA2EC9D1E19", "password"},
+    {"*7534F9EAEE5B69A586D1E9C1ACE3E3F9F6FCC446", "5"},
+    {NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define saved_key mysqlSHA1_saved_key
+#define crypt_key mysqlSHA1_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) char saved_key[80*4*MMX_COEF];
+__declspec(align(16)) char crypt_key[BINARY_SIZE*MMX_COEF];
+#define interm_key mysqlSHA1_interm_key
+__declspec(align(16)) char interm_key[80*4*MMX_COEF];
+#else
+char saved_key[80*4*MMX_COEF] __attribute__ ((aligned(16)));
+char crypt_key[BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+/* Intermediate key which stores the hashes between two SHA-1 operations. Don't
+ * ask me why it has to be so long ;) */
+#define interm_key mysqlSHA1_interm_key
+char interm_key[80*4*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+
+static unsigned long total_len;
+
+# if MMX_COEF > 2
+/* argument to shammx(); all intermediary plaintexts are 20 bytes long */
+#  define TMPKEY_LENGTHS 0x14141414
+# else
+#  define TMPKEY_LENGTHS 0x00140014
+# endif
+
+#else
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static SHA_CTX ctx;
+#endif
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+    int i;
+
+    if (strlen(ciphertext) != CIPHERTEXT_LENGTH) return 0;
+    if (ciphertext[0] != '*')
+        return 0;
+    for (i = 1; i < CIPHERTEXT_LENGTH; i++){
+        if (!( (('0' <= ciphertext[i])&&(ciphertext[i] <= '9'))
+           || (('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))
+           || (('A' <= ciphertext[i])&&(ciphertext[i] <= 'F'))))
+        {
+            return 0;
+        }
+    }
+    return 1;
+}
+
+static void mysqlsha1_init(struct fmt_main *pFmt)
+{
+#ifdef MMX_COEF
+	const int offset = (MMX_COEF*BINARY_SIZE)/4;
+
+    memset(saved_key, 0, sizeof saved_key);
+    memset(interm_key, 0, sizeof interm_key);
+    /* input strings have to be terminated by 0x80. The input strings in
+     * interm_key have a static length (20 bytes) so we can set them just once.
+     */
+    ((unsigned*)interm_key)[offset+0] = BYTESWAP(0x80);
+    ((unsigned*)interm_key)[offset+1] = BYTESWAP(0x80);
+# if MMX_COEF > 2
+    ((unsigned*)interm_key)[offset+2] = BYTESWAP(0x80);
+    ((unsigned*)interm_key)[offset+3] = BYTESWAP(0x80);
+# endif
+#endif
+}
+
+static void mysqlsha1_set_key(char *key, int index) {
+#ifdef MMX_COEF
+    int len;
+    int i;
+    /* FIXME: we're wasting 22% time in set_key with SSE2 (rawSHA1 is wasting
+     * nearly 50%!). The huge memset() is probably a culprit, but also the
+     * bytewise byte-order swapping code (see GETPOS macro above). */
+
+    if(index==0)
+    {
+        total_len = 0;
+        //memset(saved_key, 0, sizeof(saved_key));
+		memset(saved_key, 0, 56*MMX_COEF);
+    }
+    len = strlen(key);
+    if(len>PLAINTEXT_LENGTH)
+        len = PLAINTEXT_LENGTH;
+
+    total_len += len << ( ( (32/MMX_COEF) * index ) );
+    for(i=0;i<len;i++)
+        saved_key[GETPOS(i, index)] = key[i];
+
+    saved_key[GETPOS(i, index)] = 0x80;
+#else
+    strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+#endif
+}
+
+static char *mysqlsha1_get_key(int index) {
+#ifdef MMX_COEF
+    static char out[PLAINTEXT_LENGTH+1];
+    unsigned int i,s;
+
+    s = (total_len >> (((32/MMX_COEF)*(index)))) & 0xff;
+    for(i=0;i<s;i++)
+        out[i] = saved_key[ GETPOS(i, index) ];
+    out[i] = 0;
+    return out;
+#else
+    return saved_key;
+#endif
+}
+
+static int mysqlsha1_cmp_all(void *binary, int index) {
+#ifdef MMX_COEF
+    int i=0;
+    while(i< (BINARY_SIZE/4) )
+    {
+        if (
+                ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+                && ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+                && ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+                && ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#endif
+           )
+            return 0;
+        i++;
+    }
+    return 1;
+#else
+    return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int mysqlsha1_cmp_exact(char *source, int count){
+  return (1);
+}
+
+static int mysqlsha1_cmp_one(void *binary, int index)
+{
+#ifdef MMX_COEF
+    int i = 0;
+    for(i=0;i<(BINARY_SIZE/4);i++)
+        if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+            return 0;
+    return 1;
+#else
+    return mysqlsha1_cmp_all(binary, index);
+#endif
+}
+
+static void mysqlsha1_crypt_all(int count) {
+#ifdef MMX_COEF
+    unsigned int i;
+
+//    shammx((unsigned char *) crypt_key, (unsigned char *) saved_key, total_len);
+
+//    for(i = 0; i < MMX_COEF*BINARY_SIZE/sizeof(unsigned); i++)
+//    {
+//        ((unsigned*)interm_key)[i] = BYTESWAP(((unsigned*)crypt_key)[i]);
+//    }
+
+    shammx_nofinalbyteswap((unsigned char *) crypt_key, (unsigned char *) saved_key, total_len);
+    for(i = 0; i < MMX_COEF*BINARY_SIZE/sizeof(unsigned); i++)
+    {
+        ((unsigned*)interm_key)[i] = ((unsigned*)crypt_key)[i];
+    }
+
+
+    /* Verify that the 0x80 padding hasn't been overwritten. */
+# ifdef X_DEBUG
+    assert(((unsigned*)interm_key)[i+0] == BYTESWAP(0x80));
+    assert(((unsigned*)interm_key)[i+1] == BYTESWAP(0x80));
+#  if MMX_COEF > 2
+    assert(((unsigned*)interm_key)[i+2] == BYTESWAP(0x80));
+    assert(((unsigned*)interm_key)[i+3] == BYTESWAP(0x80));
+#  endif
+# endif /* X_DEBUG */
+
+    shammx((unsigned char *) crypt_key, (unsigned char *) interm_key, TMPKEY_LENGTHS);
+
+#else
+    SHA1_Init(&ctx);
+    SHA1_Update(&ctx, (unsigned char *) saved_key, strlen(saved_key));
+    SHA1_Final((unsigned char *) crypt_key, &ctx);
+
+    SHA1_Init(&ctx);
+    SHA1_Update(&ctx, (unsigned char *) crypt_key, BINARY_SIZE);
+    SHA1_Final((unsigned char *) crypt_key, &ctx);
+#endif
+}
+
+static void *mysqlsha1_binary(char *ciphertext)
+{
+    static char realcipher[BINARY_SIZE];
+    int i;
+
+    // ignore first character '*'
+    ciphertext += 1;
+    for(i=0;i<BINARY_SIZE;i++)
+    {
+        realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2])]*16 + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+    }
+    return (void *)realcipher;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xFFFFF;
+}
+
+struct fmt_main fmt_mysqlSHA1 = {
+    {
+        FORMAT_LABEL,
+        FORMAT_NAME,
+        ALGORITHM_NAME,
+        BENCHMARK_COMMENT,
+        BENCHMARK_LENGTH,
+        PLAINTEXT_LENGTH,
+        BINARY_SIZE,
+        SALT_SIZE,
+        MIN_KEYS_PER_CRYPT,
+        MAX_KEYS_PER_CRYPT,
+        FMT_CASE | FMT_8_BIT,
+        mysqlsha1_tests
+    }, {
+        mysqlsha1_init,
+		fmt_default_prepare,
+        valid,
+        fmt_default_split,
+        mysqlsha1_binary,
+        fmt_default_salt,
+        {
+            binary_hash_0,
+            binary_hash_1,
+            binary_hash_2,
+            binary_hash_3,
+            binary_hash_4
+        },
+        fmt_default_salt_hash,
+        fmt_default_set_salt,
+        mysqlsha1_set_key,
+        mysqlsha1_get_key,
+        fmt_default_clear_keys,
+        mysqlsha1_crypt_all,
+        {
+            get_hash_0,
+            get_hash_1,
+            get_hash_2,
+            get_hash_3,
+            get_hash_4
+        },
+        mysqlsha1_cmp_all,
+        mysqlsha1_cmp_one,
+        mysqlsha1_cmp_exact
+    }
+};
diff -rupN john-1.7.8/src/options.c john-1.7.8-jumbo-2/src/options.c
--- john-1.7.8/src/options.c	2011-06-22 15:01:40.000000000 +0200
+++ john-1.7.8-jumbo-2/src/options.c	2011-07-02 21:14:19.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by various authors
  */
 
 #include <stdio.h>
@@ -18,18 +20,42 @@
 #include "recovery.h"
 #include "options.h"
 #include "bench.h"
+#include "md5_gen.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#define _MPI_VERSION " (mpi)"
+#define _PER_NODE "per node "
+#else
+#define _MPI_VERSION ""
+#define _PER_NODE ""
+#endif
 
 struct options_main options;
+static char *field_sep_char_string;
+
+#if defined (__MINGW32__) || defined (_MSC_VER)
+// Later versions of MSVC can handle %lld but some older
+// ones can only handle %I64d.  Easiest to simply use
+// %I64d then all versions of MSVC will handle it just fine
+#define LLd "%I64d"
+#else
+#define LLd "%lld"
+#endif
 
 static struct opt_entry opt_list[] = {
 	{"", FLG_PASSWD, 0, 0, 0, OPT_FMT_ADD_LIST, &options.passwd},
-	{"single", FLG_SINGLE_SET, FLG_CRACKING_CHK},
+	{"single", FLG_SINGLE_SET, FLG_CRACKING_CHK, 0, 0,
+		OPT_FMT_STR_ALLOC, &options.loader.activesinglerules},
 	{"wordlist", FLG_WORDLIST_SET, FLG_CRACKING_CHK,
 		0, OPT_REQ_PARAM, OPT_FMT_STR_ALLOC, &options.wordlist},
+	{"utf8", FLG_UTF8, FLG_UTF8},//, FLG_WORDLIST_CHK | FLG_TEST_CHK},
 	{"stdin", FLG_STDIN_SET, FLG_CRACKING_CHK},
-	{"rules", FLG_RULES, FLG_RULES, FLG_WORDLIST_CHK, FLG_STDIN_CHK},
+	{"rules", FLG_RULES, FLG_RULES, FLG_WORDLIST_CHK, FLG_STDIN_CHK,
+		OPT_FMT_STR_ALLOC, &options.loader.activewordlistrules},
 	{"incremental", FLG_INC_SET, FLG_CRACKING_CHK,
 		0, 0, OPT_FMT_STR_ALLOC, &options.charset},
+	{"markov", FLG_MKV_SET, FLG_CRACKING_CHK,
+		0, 0, OPT_FMT_STR_ALLOC, &options.mkv_param},
 	{"external", FLG_EXTERNAL_SET, FLG_EXTERNAL_CHK,
 		0, OPT_REQ_PARAM, OPT_FMT_STR_ALLOC, &options.external},
 	{"stdout", FLG_STDOUT, FLG_STDOUT,
@@ -48,10 +74,11 @@ static struct opt_entry opt_list[] = {
 		0, FLG_CRACKING_CHK | FLG_SESSION | OPT_REQ_PARAM,
 		OPT_FMT_STR_ALLOC, &options.charset},
 	{"show", FLG_SHOW_SET, FLG_SHOW_CHK,
-		0, FLG_CRACKING_SUP | FLG_MAKECHR_CHK},
+		0, FLG_CRACKING_SUP | FLG_MAKECHR_CHK,
+		OPT_FMT_STR_ALLOC, &options.showuncracked_str},
 	{"test", FLG_TEST_SET, FLG_TEST_CHK,
-		0, ~FLG_TEST_SET & ~FLG_FORMAT & ~FLG_SAVEMEM & ~OPT_REQ_PARAM,
-		"%u", &benchmark_time},
+		0, ~FLG_TEST_SET & ~FLG_FORMAT & ~FLG_SAVEMEM & ~FLG_CONFIG_CLI &
+		~OPT_REQ_PARAM & ~FLG_NOLOG & ~FLG_UTF8, "%u", &benchmark_time},
 	{"users", FLG_NONE, 0, FLG_PASSWD, OPT_REQ_PARAM,
 		OPT_FMT_ADD_LIST_MULTI, &options.loader.users},
 	{"groups", FLG_NONE, 0, FLG_PASSWD, OPT_REQ_PARAM,
@@ -59,59 +86,124 @@ static struct opt_entry opt_list[] = {
 	{"shells", FLG_NONE, 0, FLG_PASSWD, OPT_REQ_PARAM,
 		OPT_FMT_ADD_LIST_MULTI, &options.loader.shells},
 	{"salts", FLG_SALTS, FLG_SALTS, FLG_PASSWD, OPT_REQ_PARAM,
-		"%d", &options.loader.min_pps},
+		OPT_FMT_STR_ALLOC, &options.salt_param},
+	{"pot", FLG_NONE, FLG_NONE, 0, OPT_REQ_PARAM,
+	    OPT_FMT_STR_ALLOC, &options.loader.activepot},
 	{"format", FLG_FORMAT, FLG_FORMAT,
 		0, FLG_STDOUT | OPT_REQ_PARAM,
 		OPT_FMT_STR_ALLOC, &options.format},
+	{"subformat", FLG_NONE, FLG_NONE,
+		0, FLG_STDOUT | OPT_REQ_PARAM,
+		OPT_FMT_STR_ALLOC, &options.subformat},
 	{"save-memory", FLG_SAVEMEM, FLG_SAVEMEM, 0, OPT_REQ_PARAM,
 		"%u", &mem_saving_level},
+	{"mem-file-size", FLG_NONE, FLG_NONE, 0, OPT_REQ_PARAM,
+		"%u", &options.loader.max_wordfile_memory},
+	{"fix-state-delay", FLG_NONE, FLG_NONE, 0, OPT_REQ_PARAM,
+		"%u", &options.loader.max_fix_state_delay},
+	{"field-separator-char", FLG_NONE, FLG_NONE, 0, OPT_REQ_PARAM,
+		OPT_FMT_STR_ALLOC, &field_sep_char_string},
+	{"config", FLG_CONFIG_CLI, FLG_NONE, 0, OPT_REQ_PARAM,
+		OPT_FMT_STR_ALLOC, &options.config},
+	{"nolog", FLG_NOLOG, FLG_NOLOG},
 	{NULL}
 };
 
-#define JOHN_COPYRIGHT "Solar Designer"
-
-#ifdef HAVE_CRYPT
-#define MAYBE_CRYPT "/crypt"
-#else
-#define MAYBE_CRYPT ""
-#endif
+#define JOHN_COPYRIGHT \
+	"Solar Designer and others"
 
 #define JOHN_USAGE \
-"John the Ripper password cracker, version " JOHN_VERSION "\n" \
+"John the Ripper password cracker, version " JOHN_VERSION _MPI_VERSION "\n" \
 "Copyright (c) 1996-2011 by " JOHN_COPYRIGHT "\n" \
 "Homepage: http://www.openwall.com/john/\n" \
 "\n" \
 "Usage: %s [OPTIONS] [PASSWORD-FILES]\n" \
-"--single                   \"single crack\" mode\n" \
-"--wordlist=FILE --stdin    wordlist mode, read words from FILE or stdin\n" \
-"--rules                    enable word mangling rules for wordlist mode\n" \
-"--incremental[=MODE]       \"incremental\" mode [using section MODE]\n" \
-"--external=MODE            external mode or word filter\n" \
-"--stdout[=LENGTH]          just output candidate passwords [cut at LENGTH]\n" \
-"--restore[=NAME]           restore an interrupted session [called NAME]\n" \
-"--session=NAME             give a new session the NAME\n" \
-"--status[=NAME]            print status of a session [called NAME]\n" \
-"--make-charset=FILE        make a charset, FILE will be overwritten\n" \
-"--show                     show cracked passwords\n" \
-"--test[=TIME]              run tests and benchmarks for TIME seconds each\n" \
-"--users=[-]LOGIN|UID[,..]  [do not] load this (these) user(s) only\n" \
-"--groups=[-]GID[,..]       load users [not] of this (these) group(s) only\n" \
-"--shells=[-]SHELL[,..]     load users with[out] this (these) shell(s) only\n" \
-"--salts=[-]COUNT           load salts with[out] at least COUNT passwords " \
-	"only\n" \
-"--format=NAME              force hash type NAME: " \
-	"DES/BSDI/MD5/BF/AFS/LM" MAYBE_CRYPT "\n" \
-"--save-memory=LEVEL        enable memory saving, at LEVEL 1..3\n"
+"--config=FILE             use FILE instead of john.conf or john.ini\n" \
+"--single[=SECTION]        \"single crack\" mode\n" \
+"--wordlist=FILE --stdin   wordlist mode, read words from FILE or stdin\n" \
+"--utf8                    all files are encoded in UTF-8 (see documentation)\n" \
+"--rules[=SECTION]         enable word mangling rules for wordlist mode\n" \
+"--incremental[=MODE]      \"incremental\" mode [using section MODE]\n" \
+"--markov[=LEVEL[:opts]]   \"Markov\" mode (see documentation)\n" \
+"--external=MODE           external mode or word filter\n" \
+"--stdout[=LENGTH]         just output candidate passwords [cut at LENGTH]\n" \
+"--restore[=NAME]          restore an interrupted session [called NAME]\n" \
+"--session=NAME            give a new session the NAME\n" \
+"--status[=NAME]           print status of a session [called NAME]\n" \
+"--make-charset=FILE       make a charset, FILE will be overwritten\n" \
+"--show[=LEFT]             show cracked passwords [if =LEFT, then uncracked]\n" \
+"--test[=TIME]             run tests and benchmarks for TIME seconds each\n" \
+"--users=[-]LOGIN|UID[,..] [do not] load this (these) user(s) only\n" \
+"--groups=[-]GID[,..]      load users [not] of this (these) group(s) only\n" \
+"--shells=[-]SHELL[,..]    load users with[out] this (these) shell(s) only\n" \
+"--salts=[-]COUNT[:MAX]    load salts with[out] COUNT [to MAX] hashes\n" \
+"--pot=NAME                pot file to use\n" \
+"--format=NAME             force hash type NAME: "
+
+/* The format-list is automatically generated now */
+
+#define JOHN_USAGE_TAIL \
+"--subformat=LIST          get a listing of all md5-gen(n) formats\n" \
+"--save-memory=LEVEL       enable memory saving, at LEVEL 1..3\n" \
+"--mem-file-size=SIZE      size threshold for wordlist preload (default 5 MB)\n" \
+"--field-separator-char=c  use 'c' instead of the ':' in input and pot files\n" \
+"--fix-state-delay=N       performance tweak, see documentation\n" \
+"--nolog                   disables creation and writing to john.log file\n" \
+
+
+#define USAGE_INDENT \
+"                          "
+
+static void formatted_print_item(char *label)
+{
+	static int col = 48;
+	static int doslash = 0;
+
+	if (col + strlen(label) > 80) {
+		printf("\n" USAGE_INDENT);
+		col = strlen(USAGE_INDENT);
+		doslash = 0;
+	}
+	col += strlen(label) + 1;
+	if (doslash++)
+		printf("/");
+	printf("%s", label);
+}
+
+static void list_formats(void)
+{
+	int md5gens = 0;
+	struct fmt_main *format;
+	if ((format = fmt_list)) {
+		do {
+			// Skip all md5-gens, print it last
+			if (!strncmp(format->params.label, "md5-gen", 7))
+				md5gens++;
+			else
+				formatted_print_item(format->params.label);
+		} while ((format = format->next));
+		if (md5gens)
+			formatted_print_item("md5-gen(n)");
+		printf("\n");
+	} else
+		printf(USAGE_INDENT "** Error listing formats **\n");
+}
 
 void opt_init(char *name, int argc, char **argv)
 {
 	if (argc < 2) {
 		printf(JOHN_USAGE, name);
+		list_formats();
+		printf(JOHN_USAGE_TAIL);
 		exit(0);
 	}
 
 	memset(&options, 0, sizeof(options));
 
+	options.loader.field_sep_char = options.field_sep_char = ':';
+	options.loader.max_fix_state_delay = 0;
+	options.loader.max_wordfile_memory = 5000000;
+
 	list_init(&options.passwd);
 
 	options.loader.flags = DB_LOGIN;
@@ -143,6 +235,14 @@ void opt_init(char *name, int argc, char
 		return;
 	}
 
+	if (options.subformat && !strcasecmp(options.subformat, "list"))
+	{
+		md5_gen_DISPLAY_ALL_FORMATS();
+		// NOTE if we have other 'generics', like sha1, sha2, rc4, ....  then EACH of
+		// them should have a DISPLAY_ALL_FORMATS() function and we can call them here.
+		exit(0);
+	}
+
 	if (options.flags & FLG_STATUS_CHK) {
 		rec_restore_args(0);
 		options.flags |= FLG_STATUS_SET;
@@ -152,15 +252,43 @@ void opt_init(char *name, int argc, char
 	}
 
 	if (options.flags & FLG_SALTS)
-	if (options.loader.min_pps < 0) {
-		options.loader.max_pps = -1 - options.loader.min_pps;
-		options.loader.min_pps = 0;
+	{
+		int two_salts = 0;
+		if (sscanf(options.salt_param, "%d:%d", &options.loader.min_pps, &options.loader.max_pps) == 2)
+			two_salts = 1;
+		if (!two_salts && sscanf(options.salt_param, "%d,%d", &options.loader.min_pps, &options.loader.max_pps) == 2)
+			two_salts = 1;
+		if (!two_salts){
+			sscanf(options.salt_param, "%d", &options.loader.min_pps);
+			if (options.loader.min_pps < 0) {
+				options.loader.max_pps = -1 - options.loader.min_pps;
+				options.loader.min_pps = 0;
+			}
+			else
+				options.loader.max_pps = 0x7fffffff;
+		} else if (options.loader.min_pps < 0) {
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "Usage of negative -salt min is not 'valid' if using Min and Max salt range of values\n");
+			error();
+		}
+		if (options.loader.min_pps > options.loader.max_pps) {
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "Min number salts wanted is less than Max salts wanted\n");
+			error();
+		}
 	}
 
 	if (options.length < 0)
 		options.length = PLAINTEXT_BUFFER_SIZE - 3;
 	else
 	if (options.length < 1 || options.length > PLAINTEXT_BUFFER_SIZE - 3) {
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Invalid plaintext length requested\n");
 		error();
 	}
@@ -168,17 +296,137 @@ void opt_init(char *name, int argc, char
 	if (options.flags & FLG_STDOUT) options.flags &= ~FLG_PWD_REQ;
 
 	if ((options.flags & (FLG_PASSWD | FLG_PWD_REQ)) == FLG_PWD_REQ) {
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Password files required, "
 			"but none specified\n");
 		error();
 	}
 
 	if ((options.flags & (FLG_PASSWD | FLG_PWD_SUP)) == FLG_PASSWD) {
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Password files specified, "
 			"but no option would use them\n");
 		error();
 	}
 
+	if (options.flags & FLG_MKV_CHK) {
+		char * token;
+
+		options.mkv_start = 0;
+		options.mkv_end = 0;
+		options.mkv_maxlen = 0;
+		options.mkv_minlevel = 0;
+		options.mkv_minlen = 0;
+		if (options.mkv_param)
+		{
+			token = strtok(options.mkv_param, ":");
+			if(sscanf(token, "%d-%d", &options.mkv_minlevel, &options.mkv_level) != 2)
+			{
+				options.mkv_minlevel = 0;
+				if (sscanf(token, "%d", &options.mkv_level) != 1)
+				{
+#ifdef HAVE_MPI
+					if (mpi_id == 0)
+#endif
+					fprintf(stderr, "Could not parse markov parameters\n");
+					error();
+				}
+			}
+			token = strtok(NULL, ":");
+			if( (token != NULL) && (sscanf(token, LLd, &options.mkv_start)==1) )
+			{
+				token = strtok(NULL, ":");
+				if( (token != NULL) && (sscanf(token, LLd, &options.mkv_end)==1) )
+				{
+					token = strtok(NULL, ":");
+					if( (token != NULL) && (sscanf(token, "%d-%d", &options.mkv_minlen, &options.mkv_maxlen)!=2) )
+					{
+						options.mkv_minlen = 0;
+						sscanf(token, "%d", &options.mkv_maxlen);
+					}
+				}
+			}
+		}
+		if(options.mkv_level<options.mkv_minlevel)
+		{
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "Warning: max level(%d) < min level(%d), min level set to %d\n", options.mkv_level, options.mkv_minlevel, options.mkv_level);
+			options.mkv_minlevel = options.mkv_level;
+		}
+		if(options.mkv_minlen > options.mkv_maxlen)
+		{
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "Warning: minimum length(%d) < maximum length(%d), minimum length set to %d\n", options.mkv_minlen, options.mkv_maxlen, options.mkv_maxlen);
+			options.mkv_minlen = options.mkv_maxlen;
+		}
+	}
+
+#ifdef HAVE_MPI
+	if (options.flags & (FLG_STDIN_CHK | FLG_SHOW_CHK | FLG_MAKECHR_CHK ) && (mpi_p > 1)) {
+		if (mpi_id == 0) fprintf(stderr, "Chosen mode not suitable for running on multiple nodes\n");
+		error();
+	}
+#endif
+
+	if ( (options.flags & FLG_SHOW_SET) && options.showuncracked_str) {
+		if (!strcasecmp( options.showuncracked_str, "left"))  {
+			options.loader.showuncracked = 1;
+			// Note we 'do' want the pot file to load normally, but during that load,
+			// we print out hashes left. At the end of the load, john exits.  However
+			// we do NOT want the 'special' -SHOW_CHK logic to happen (which happens
+			// instead of normal loading if we are in 'normal' show mode)
+			options.flags &= ~FLG_SHOW_CHK;
+		}
+		else {
+			fprintf(stderr, "Invalid option in --show switch.\nOnly --show or --show=left are valid\n");
+			error();
+		}
+	}
+
+	if (options.loader.activepot == NULL)
+		options.loader.activepot = str_alloc_copy(POT_NAME);
+
+	if (options.loader.activewordlistrules == NULL)
+		options.loader.activewordlistrules = str_alloc_copy(SUBSECTION_WORDLIST);
+
+	if (options.loader.activesinglerules == NULL)
+		options.loader.activesinglerules = str_alloc_copy(SUBSECTION_SINGLE);
+
+	if (field_sep_char_string != NULL)
+	{
+		if (strlen(field_sep_char_string) == 1)
+			options.field_sep_char = *field_sep_char_string;
+		else if (field_sep_char_string[0] == '\\' && (field_sep_char_string[1]=='x'||field_sep_char_string[1]=='X'))
+		{
+			unsigned xTmp=0;
+			sscanf(&field_sep_char_string[2], "%x", &xTmp);
+			if (!xTmp || xTmp > 255)
+			{
+#ifdef HAVE_MPI
+				if (mpi_id == 0)
+#endif
+				fprintf (stderr, "trying to use an invalid field separator char:  %s\n", field_sep_char_string);
+				error();
+			}
+			options.field_sep_char = (char)xTmp;
+		}
+
+		options.loader.field_sep_char = options.field_sep_char;
+		if (options.loader.field_sep_char != ':')
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf (stderr, "using field sep char '%c' (0x%02x)\n", options.field_sep_char, options.field_sep_char);
+	}
+
 	rec_argc = argc; rec_argv = argv;
 	rec_check = 0;
 }
diff -rupN john-1.7.8/src/options.h john-1.7.8-jumbo-2/src/options.h
--- john-1.7.8/src/options.h	2009-09-09 07:09:01.000000000 +0200
+++ john-1.7.8-jumbo-2/src/options.h	2011-05-17 21:36:33.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-98,2003,2006 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by various authors
  */
 
 /*
@@ -26,7 +28,7 @@
 /* An option requires password files */
 #define FLG_PWD_REQ			(0x00000008 | FLG_PWD_SUP)
 /* Some option that doesn't have its own flag is specified */
-#define FLG_NONE			0x00000010
+#define FLG_NONE			0x00000000
 /* A cracking mode enabled */
 #define FLG_CRACKING_CHK		0x00000020
 #define FLG_CRACKING_SUP		0x00000040
@@ -36,6 +38,8 @@
  * if reading from stdin. */
 #define FLG_WORDLIST_CHK		0x00000080
 #define FLG_WORDLIST_SET		(FLG_WORDLIST_CHK | FLG_CRACKING_SET)
+/* UTF-8 mode enabled, affects some formats and rules */
+#define FLG_UTF8			0x00000010
 /* Wordlist mode enabled, reading from stdin */
 #define FLG_STDIN_CHK			0x00000100
 #define FLG_STDIN_SET			(FLG_STDIN_CHK | FLG_WORDLIST_SET)
@@ -82,6 +86,13 @@
 #define FLG_FORMAT			0x02000000
 /* Memory saving enabled */
 #define FLG_SAVEMEM			0x04000000
+/* Command-line config file */
+#define FLG_CONFIG_CLI      0x10000000
+/* Turn off logging */
+#define FLG_NOLOG			0x20000000
+/* Markov mode enabled */
+#define FLG_MKV_CHK			0x40000000
+#define FLG_MKV_SET			(FLG_MKV_CHK | FLG_CRACKING_SET)
 
 /*
  * Structure with option flags and all the parameters.
@@ -102,6 +113,9 @@ struct options_main {
 /* Ciphertext format name */
 	char *format;
 
+/* Ciphertext subformat name */
+	char *subformat;
+
 /* Wordlist file name */
 	char *wordlist;
 
@@ -111,8 +125,24 @@ struct options_main {
 /* External mode or word filter name */
 	char *external;
 
+/* Markov stuff */
+	char *mkv_param;
+	unsigned long long mkv_start;
+	unsigned long long mkv_end;
+	unsigned int mkv_level;
+	unsigned int mkv_maxlen;
+	unsigned int mkv_minlevel;
+	unsigned int mkv_minlen;
+
 /* Maximum plaintext length for stdout mode */
 	int length;
+
+/* Configuration file name */
+	char *config;
+
+	char *showuncracked_str;
+	char *salt_param;
+	char field_sep_char;
 };
 
 extern struct options_main options;
diff -rupN john-1.7.8/src/oracle11_fmt_plug.c john-1.7.8-jumbo-2/src/oracle11_fmt_plug.c
--- john-1.7.8/src/oracle11_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/oracle11_fmt_plug.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,260 @@
+/*
+ * Copyright (c) 2008 Alexandre Hamelin
+ * alexandre.hamelin(@)gmail.com
+ * Based on saltSHA1 format source.
+ *
+ * Oracle 11g SHA1 cracker
+ *
+ * Please note that a much better way to crack Oracle 11g passwords exists than
+ * brute forcing the SHA1 hash since the pre-Oracle 10g hash is still stored in
+ * the SYS.USER$ table in the column PASSWORD.
+ *
+ * $ uname -a
+ * Linux xyz 2.6.22-hardened-r8 #1 SMP Fri Jan 11 23:24:31 EST 2008 x86_64 AMD Athlon(tm) 64 X2 Dual Core Processor 5200+ AuthenticAMD GNU/Linux
+ * $ ./john --test
+ * [...]
+ * Benchmarking: Oracle 11g [oracle11]... DONE
+ * Many salts:     2387K c/s real, 2507K c/s virtual
+ * Only one salt:  2275K c/s real, 2275K c/s virtual
+ * [...]
+ *
+ * To use:
+ *  1. Connect as a DBA to Oracle 11g with sqlplus
+ *  2. set heading off
+ *     set feedback off
+ *     set pagesize 1000
+ *     set linesize 100
+ *     spool ora11-passwds.txt
+ *  3. SELECT name || ':' || SUBSTR(spare4,3)
+ *     FROM sys.user$
+ *     WHERE spare4 IS NOT NULL
+ *     ORDER BY name;
+ *  4. spool off
+ *     quit
+ *  5. Remove extra spaces (%s:/\s\+$//) and extra lines (:g!/:\w/d) in output.
+ *  6. ./john [-f:oracle11] ora11-passwds.txt
+ *
+ * TODO:
+ * The prefix "S:" suggests that other hashing functions might be used to store
+ * user passwords; if this is indeed possible (I've not verified in the docs
+ * yet) maybe implement other 11g cracking functions in the same oracle11_fmt.c
+ * file.
+ * Change the hash format for JtR? Prefix with "O11$" or "S:" ? (but "S:" might
+ * not be possible due to the way JtR parses password files)
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "sha.h"
+#include <ctype.h>
+
+#define FORMAT_LABEL			"oracle11"
+#define FORMAT_NAME			"Oracle 11g"
+#define ALGORITHM_NAME			"oracle11"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+/* Maximum length of password in characters. Oracle supports identifiers of 30
+ * characters max. (ALTER USER user IDENTIFIED BY 30lettersPassword) */
+#define PLAINTEXT_LENGTH		30
+/* Length in characters of the cipher text, as seen in the password file.
+ * Excludes prefix if any. */
+#define CIPHERTEXT_LENGTH		60
+
+/* Length of hashed value without the salt, in bytes. */
+#define BINARY_SIZE			20
+/* Length of salt in bytes. */
+#define SALT_SIZE			10
+
+/* Sanity check. Don't change. */
+#if (BINARY_SIZE + SALT_SIZE) * 2 != CIPHERTEXT_LENGTH
+#error Incorrect binary sizes or cipher text length.
+#endif
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests tests[] = {
+	/* 160 bits of SHA1, followed by 80 bits of salt. No "S:" prefix. */
+	{"5FDAB69F543563582BA57894FE1C1361FB8ED57B903603F2C52ED1B4D642", "abc123"},
+	{"450F957ECBE075D2FA009BA822A9E28709FBC3DA82B44D284DDABEC14C42", "SyStEm123!@#"},
+	{"3437FF72BD69E3FB4D10C750B92B8FB90B155E26227B9AB62D94F54E5951", "oracle"},
+	{"61CE616647A4F7980AFD7C7245261AF25E0AFE9C9763FCF0D54DA667D4E6", "11g"},
+	{"B9E7556F53500C8C78A58F50F24439D79962DE68117654B6700CE7CC71CF", "11g"},
+	{NULL}
+};
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static int saved_key_length;
+static unsigned char saved_salt[SALT_SIZE];
+static SHA_CTX ctx;
+static ARCH_WORD_32 crypt_out[BINARY_SIZE / 4];
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+
+	for (i = 0; i < CIPHERTEXT_LENGTH; i++)
+		if (atoi16[ARCH_INDEX(ciphertext[i])] == 0x7F)
+			return 0;
+	return !ciphertext[i];
+}
+
+static void *salt(char *ciphertext)
+{
+	static unsigned char salt[SALT_SIZE];
+	int i;
+
+    for (i = 0; i < SALT_SIZE; i++) {
+		salt[i] = atoi16[ARCH_INDEX(ciphertext[BINARY_SIZE*2+i*2+0])]*16 +
+				  atoi16[ARCH_INDEX(ciphertext[BINARY_SIZE*2+i*2+1])];
+    }
+
+	return (void *)salt;
+}
+
+static void set_salt(void *salt)
+{
+	memcpy(saved_salt, salt, SALT_SIZE);
+}
+
+static void set_key(char *key, int index) {
+	saved_key_length = strlen(key);
+	if (saved_key_length > PLAINTEXT_LENGTH)
+		saved_key_length = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, saved_key_length);
+	saved_key[saved_key_length] = 0;
+}
+
+static char *get_key(int index) {
+	return saved_key;
+}
+
+static int cmp_all(void *binary, int index) {
+	return !memcmp(binary, crypt_out, BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int count) {
+	return 1;
+}
+
+static void crypt_all(int count) {
+	SHA1_Init( &ctx );
+	SHA1_Update( &ctx, (unsigned char *) saved_key, saved_key_length );
+	SHA1_Update( &ctx, saved_salt, SALT_SIZE );
+	SHA1_Final( (unsigned char *)crypt_out, &ctx);
+}
+
+static void * binary(char *ciphertext)
+{
+	static unsigned char realcipher[BINARY_SIZE];
+
+	int i;
+	for(i=0;i<BINARY_SIZE;i++)
+		realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2])]*16 +
+						atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+	return (void *)realcipher;
+}
+
+static int binary_hash_0(void *binary)
+{
+  return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+  return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+  return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+  return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+  return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+  return crypt_out[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+  return crypt_out[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+  return crypt_out[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+  return crypt_out[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+  return crypt_out[0] & 0xFFFFF;
+}
+
+struct fmt_main fmt_oracle11 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		binary,
+		salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		fmt_default_salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_all,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/oracle_fmt_plug.c john-1.7.8-jumbo-2/src/oracle_fmt_plug.c
--- john-1.7.8/src/oracle_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/oracle_fmt_plug.c	2011-07-02 22:20:34.000000000 +0200
@@ -0,0 +1,339 @@
+/*
+ * Copyright (c) 2004 Simon Marechal
+ * simon.marechal at thales-security.com
+ *
+ * UTF-8 support by magnum 2011, no rights reserved
+ */
+
+#include <string.h>
+#include <openssl/des.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "unicode.h"
+
+#define FORMAT_LABEL			"oracle"
+#define FORMAT_NAME			"Oracle"
+#define ALGORITHM_NAME			"oracle"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		120 // worst case UTF-8 is 40 characters of Unicode, that'll do
+
+#define BINARY_SIZE			8
+#define SALT_SIZE			(32 + 2)
+#define CIPHERTEXT_LENGTH		16
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests oracle_tests[] = {
+	{"O$SYSTEM#9EEDFA0AD26C6D52", "THALES" },
+	{"O$SIMON#4F8BC1809CB2AF77", "A"},
+	{"O$SIMON#183D72325548EF11", "THALES2" },
+	{"O$SIMON#C4EB3152E17F24A4", "TST" },
+	{"O$BOB#b02c8e79ed2e7f46", "LAPIN" },
+	{"O$BOB#6bb4e95898c88011", "LAPINE" },
+	{"O$BOB#cdc6b483874b875b", "GLOUGLOU" },
+	{"O$BOB#ef1f9139db2d5279", "GLOUGLOUTER" },
+	{"O$BOB#c0ee5107c9a080c1", "AZERTYUIOP" },
+	{"O$BOB#99e8b231d33772f9", "CANARDWC" },
+	{"O$BOB#da3224126a67c8ed", "COUCOU_COUCOU" },
+	{"O$BOB#ec8147abb3373d53", "LONG_MOT_DE_PASSE_OUI" },
+
+	{"9EEDFA0AD26C6D52", "THALES",        {"SYSTEM"} },
+	{"4F8BC1809CB2AF77", "A",             {"SIMON"} },
+	{"183D72325548EF11", "THALES2",       {"SIMON"} },
+	{"C4EB3152E17F24A4", "TST",           {"SIMON"} },
+	{"b02c8e79ed2e7f46", "LAPIN",         {"BOB"} },
+	{"6bb4e95898c88011", "LAPINE",        {"BOB"} },
+	{"cdc6b483874b875b", "GLougLou",      {"bob"} },  // put some low case in there, to make SURE the up case conversion works.
+	{"ef1f9139db2d5279", "Glouglouter",   {"bob"} },
+	{"c0ee5107c9a080c1", "AZERTYUIOP",    {"BOB"} },
+	{"99e8b231d33772f9", "CANARDWC",      {"BOB"} },
+	{"da3224126a67c8ed", "COUCOU_COUCOU", {"BOB"} },
+	{"ec8147abb3373d53", "LONG_MOT_DE_PASSE_OUI",   {"BOB"} },
+	{NULL}
+};
+
+#if ARCH_LITTLE_ENDIAN
+#define ENDIAN_SHIFT_L  << 8
+#define ENDIAN_SHIFT_R  >> 8
+#else
+#define ENDIAN_SHIFT_L
+#define ENDIAN_SHIFT_R
+#endif
+
+static ARCH_WORD_32 crypt_key[2];
+
+static UTF16 cur_salt[SALT_SIZE / 2 + PLAINTEXT_LENGTH];
+static UTF16 cur_key[PLAINTEXT_LENGTH + 1];
+static UTF8 saved_plain[PLAINTEXT_LENGTH + 1];
+
+static DES_key_schedule desschedule1;
+static DES_key_schedule desschedule2;
+
+static int salt_length;
+static int key_length;
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+	int l;
+
+	/*
+	 * 2 cases
+	 * 1 - it comes from the disk, and does not have O$ + salt
+	 * 2 - it comes from memory, and has got O$ + salt + # + blah
+	 */
+
+	if (!memcmp(ciphertext, "O$", 2))
+	{
+		l = strlen(ciphertext) - CIPHERTEXT_LENGTH;
+		if(ciphertext[l-1]!='#')
+			return 0;
+	}
+	else
+	{
+		if(strlen(ciphertext)!=CIPHERTEXT_LENGTH)
+			return 0;
+		l = 0;
+	}
+	for (i = l; i < l + CIPHERTEXT_LENGTH; i++){
+		if (!(  (('0' <= ciphertext[i])&&(ciphertext[i] <= '9')) ||
+			(('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))
+			|| (('A' <= ciphertext[i])&&(ciphertext[i] <= 'F'))))
+			return 0;
+	}
+
+	return 1;
+}
+
+static char *prepare(char *split_fields[10], struct fmt_main *pFmt)
+{
+//	} else if (db->format == &fmt_oracle) {
+//		piece = (char *) mem_alloc_tiny(strlen(login) + strlen(ciphertext) + 4, MEM_ALIGN_NONE);
+//		sprintf(piece, "O$%s#%s", login, ciphertext);
+	char *cp;
+
+	/**  TODO.  Upcase the user name here (between O$ and the #), so that we do not have to
+	     upcase it all the time at a later point in code */
+	if (!strncmp(split_fields[1], "O$", 2))
+		return split_fields[1];
+	cp = mem_alloc(strlen(split_fields[0]) + strlen(split_fields[1]) + 4);
+	sprintf (cp, "O$%s#%s", split_fields[0], split_fields[1]);
+	if (valid(cp, pFmt))
+	{
+		char *cipher = str_alloc_copy(cp);
+		MEM_FREE(cp);
+		return cipher;
+	}
+	MEM_FREE(cp);
+	return split_fields[1];
+}
+
+static void oracle_init(struct fmt_main *pFmt)
+{
+	unsigned char deskey[8];
+
+	deskey[0] = 0x01;
+	deskey[1] = 0x23;
+	deskey[2] = 0x45;
+	deskey[3] = 0x67;
+	deskey[4] = 0x89;
+	deskey[5] = 0xab;
+	deskey[6] = 0xcd;
+	deskey[7] = 0xef;
+
+	DES_set_key((DES_cblock *)deskey, &desschedule1);
+}
+
+static void oracle_set_salt(void *salt) {
+	salt_length = ((unsigned short *)salt)[0];
+	memcpy(cur_salt, &((unsigned short *)salt)[1], salt_length);
+}
+
+static void oracle_set_key(char *key, int index) {
+	int i = 0;
+
+	strnzcpy((char *)saved_plain, key, sizeof(saved_plain));
+
+	key_length = plaintowcs((UTF16 *)cur_key, PLAINTEXT_LENGTH, saved_plain, strlen((char*)saved_plain));
+
+	if (key_length <= 0) {
+		saved_plain[-key_length] = 0; // match truncation
+		key_length = strlen16(cur_key);
+	}
+
+	// This must be byte-swapped regardless of arch endianness
+	// We also uppercase here, currently only ASCII
+	for(;i<key_length;i++) {
+		UTF16 *c = &cur_key[i];
+#if (ARCH_LITTLE_ENDIAN)
+		if((*c >= 'a') && (*c <= 'z'))
+			*c = ((*c ^ 0x0020) << 8) | (*c >> 8);
+#else
+		if((*c >= ('a' << 8)) && (*c <= ('z' << 8)))
+			*c = ((*c ^ 0x2000) >> 8) | (*c << 8);
+#endif
+		else
+			*c = (*c << 8) | (*c >> 8);
+	}
+	key_length *= sizeof(UTF16);
+}
+
+static char *oracle_get_key(int index) {
+	return (char*)saved_plain;
+}
+
+static void oracle_crypt_all(int count)
+{
+	unsigned char buf[sizeof(cur_salt)];
+	unsigned int l;
+
+	l = salt_length + key_length;
+	crypt_key[0] = 0;
+	crypt_key[1] = 0;
+	memcpy((char *)cur_salt + salt_length, cur_key, key_length);
+	DES_ncbc_encrypt((unsigned char *)cur_salt, buf, l, &desschedule1, (DES_cblock *) crypt_key, DES_ENCRYPT);
+	DES_set_key((DES_cblock *)crypt_key, &desschedule2);
+	crypt_key[0] = 0;
+	crypt_key[1] = 0;
+	DES_ncbc_encrypt((unsigned char *)cur_salt, buf, l, &desschedule2, (DES_cblock *) crypt_key, DES_ENCRYPT);
+}
+
+static void * oracle_binary(char *ciphertext)
+{
+	static unsigned char *out3;
+	int l;
+	int i;
+
+	if (!out3) out3 = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	l = strlen(ciphertext) - CIPHERTEXT_LENGTH;
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		out3[i] = atoi16[ARCH_INDEX(ciphertext[i*2+l])]*16
+			+ atoi16[ARCH_INDEX(ciphertext[i*2+l+1])];
+	}
+	return out3;
+}
+
+static inline UTF8 upper(UTF8 c)
+{
+	if( (c>='a') && (c<='z'))
+		return c ^ 0x20;
+	return c;
+}
+
+static void * oracle_get_salt(char * ciphertext)
+{
+	static UTF16 *out;
+	UTF8 salt[SALT_SIZE + 1];
+	int i, l;
+
+	if (!out) out = mem_alloc_tiny(SALT_SIZE, MEM_ALIGN_WORD);
+	l = 2;
+	while( ciphertext[l] && (ciphertext[l]!='#') )
+	{
+		salt[l-2] = upper(ciphertext[l]);
+		l++;
+		if (l-2 >= SALT_SIZE-2) break;
+	}
+	salt[l-2] = 0;
+
+	l = plaintowcs((UTF16 *)&out[1], (SALT_SIZE>>1) - 1, (UTF8 *)salt, l-2);
+
+	if (l <= 0)
+		l = strlen16(&out[1]);
+
+	// This must be byte-swapped regardless of arch endianness
+	// We also uppercase here, currently only ASCII
+	for(i=1;i<=l;i++) {
+		out[i] = (out[i] << 8) | (out[i] >> 8);
+	}
+	out[0] = l * sizeof(UTF16);
+	return out;
+}
+
+// Public domain hash function by DJ Bernstein (salt is a username)
+static int salt_hash(void *salt)
+{
+	UTF16 *s = salt + 2;
+	unsigned int hash = 5381;
+
+	while (*s)
+		hash = ((hash << 5) + hash) ^ *s++;
+
+	return hash & (SALT_HASH_SIZE - 1);
+}
+
+static int binary_hash0(void * binary) { return (((ARCH_WORD_32 *)binary)[0] & 0xf); }
+static int binary_hash1(void * binary) { return (((ARCH_WORD_32 *)binary)[0] & 0xff); }
+static int binary_hash2(void * binary) { return (((ARCH_WORD_32 *)binary)[0] & 0xfff); }
+static int binary_hash3(void * binary) { return (((ARCH_WORD_32 *)binary)[0] & 0xffff); }
+static int binary_hash4(void * binary) { return (((ARCH_WORD_32 *)binary)[0] & 0xfffff); }
+
+static int get_hash0(int index) { return crypt_key[0] & 0xf; }
+static int get_hash1(int index) { return crypt_key[0] & 0xff; }
+static int get_hash2(int index) { return crypt_key[0] & 0xfff; }
+static int get_hash3(int index) { return crypt_key[0] & 0xffff; }
+static int get_hash4(int index) { return crypt_key[0] & 0xfffff; }
+
+static int oracle_cmp_all(void *binary, int index) {
+	return !memcmp(binary, crypt_key, sizeof(crypt_key));
+}
+
+static int oracle_cmp_exact(char *source, int count) {
+	return 1;
+}
+
+struct fmt_main fmt_oracle = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_8_BIT | FMT_UNICODE | FMT_UTF8,
+		oracle_tests
+	}, {
+		oracle_init,
+		prepare,
+		valid,
+		fmt_default_split,
+		oracle_binary,
+		oracle_get_salt,
+		{
+			binary_hash0,
+			binary_hash1,
+			binary_hash2,
+			binary_hash3,
+			binary_hash4
+		},
+		salt_hash,
+		oracle_set_salt,
+		oracle_set_key,
+		oracle_get_key,
+		fmt_default_clear_keys,
+		oracle_crypt_all,
+		{
+			get_hash0,
+			get_hash1,
+			get_hash2,
+			get_hash3,
+			get_hash4
+		},
+		oracle_cmp_all,
+		oracle_cmp_all,
+		oracle_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/params.h john-1.7.8-jumbo-2/src/params.h
--- john-1.7.8/src/params.h	2011-06-22 15:38:55.000000000 +0200
+++ john-1.7.8-jumbo-2/src/params.h	2011-07-02 22:00:31.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by various authors
  */
 
 /*
@@ -15,7 +17,7 @@
 /*
  * John's version number.
  */
-#define JOHN_VERSION			"1.7.8"
+#define JOHN_VERSION			"1.7.8-jumbo-2"
 
 /*
  * Notes to packagers of John for *BSD "ports", Linux distributions, etc.:
@@ -93,7 +95,7 @@
 /*
  * Default benchmark time in seconds (per cracking algorithm).
  */
-#define BENCHMARK_TIME			5
+#define BENCHMARK_TIME			1
 
 /*
  * Number of salts to assume when benchmarking.
@@ -110,11 +112,19 @@
 #define CFG_PRIVATE_ALT_NAME		JOHN_PRIVATE_HOME "/john.ini"
 #define POT_NAME			JOHN_PRIVATE_HOME "/john.pot"
 #define LOG_NAME			JOHN_PRIVATE_HOME "/john.log"
+#ifdef HAVE_MPI
+#define RECOVERY_NAME			JOHN_PRIVATE_HOME "/john"
+#else
 #define RECOVERY_NAME			JOHN_PRIVATE_HOME "/john.rec"
+#endif /* HAVE_MPI */
 #else
 #define POT_NAME			"$JOHN/john.pot"
 #define LOG_NAME			"$JOHN/john.log"
+#ifdef HAVE_MPI
+#define RECOVERY_NAME			"$JOHN/john"
+#else
 #define RECOVERY_NAME			"$JOHN/john.rec"
+#endif /* HAVE_MPI */
 #endif
 #define LOG_SUFFIX			".log"
 #define RECOVERY_SUFFIX			".rec"
@@ -189,9 +199,9 @@ extern int password_hash_thresholds[PASS
 /*
  * Hash and buffer sizes for unique.
  */
-#define UNIQUE_HASH_LOG			20
+#define UNIQUE_HASH_LOG			21
 #define UNIQUE_HASH_SIZE		(1 << UNIQUE_HASH_LOG)
-#define UNIQUE_BUFFER_SIZE		0x4000000
+#define UNIQUE_BUFFER_SIZE		0x8000000
 
 /*
  * Maximum number of GECOS words per password to load.
@@ -264,7 +274,7 @@ extern int password_hash_thresholds[PASS
 /*
  * Buffer size for fgets().
  */
-#define LINE_BUFFER_SIZE		0x400
+#define LINE_BUFFER_SIZE		0x4000
 
 /*
  * john.pot and log file buffer sizes, can be zero.
@@ -281,4 +291,8 @@ extern int password_hash_thresholds[PASS
 #define PATH_BUFFER_SIZE		0x400
 #endif
 
+/* Markov mode stuff */
+#define MAX_MKV_LVL 400
+#define MAX_MKV_LEN 30
+
 #endif
diff -rupN john-1.7.8/src/pdf2john.c john-1.7.8-jumbo-2/src/pdf2john.c
--- john-1.7.8/src/pdf2john.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdf2john.c	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,170 @@
+ /**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ *
+ * Re-factored for JtR by Dhiru Kholia during June, 2011 for GSoC.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "stdint.h"
+#include <signal.h>
+#include <string.h>
+#include <unistd.h>
+#include "pdfparser.h"
+#include "pdfcrack.h"
+#include "common.h"
+
+#define VERSION_MAJOR 0
+#define VERSION_MINOR 11
+
+/* print some help for the user */
+static void printHelp(char *progname)
+{
+	printf("Usage: %s [OPTIONS] filename\n"
+	    "OPTIONS:\n"
+	    "-o, --owner\t\tWork with the ownerpassword (default is userpassword)\n"
+	    "-p, --password=STRING\tGive userpassword to speed up breaking\n"
+	    "\t\t\townerpassword (implies -o)\n"
+	    "-v, --version\t\tPrint version and exit\n", progname);
+}
+
+int pdf2john(int argc, char **argv)
+{
+	int ret = 0;
+	FILE *file = NULL;
+	uint8_t *userpassword = NULL;
+	char *inputfile = NULL;
+	unsigned char *p;
+	EncData *e = calloc(1, sizeof(EncData));
+	e->work_with_user = true;
+
+	/* parse arguments */
+	while (true) {
+		int c;
+		c = getopt(argc, argv, "op:v");
+		/* Detect the end of the options. */
+		if (c == -1)
+			break;
+
+		switch (c) {
+		case 'o':
+			e->work_with_user = false;
+			break;
+		case 'p':
+			userpassword = (uint8_t *) strdup(optarg);
+			e->work_with_user = false;
+			e->have_userpassword = true;
+			break;
+		case 'v':
+			printf("pdfcrack version %d.%d\n", VERSION_MAJOR,
+			    VERSION_MINOR);
+			return 0;
+		default:
+			printHelp(argv[0]);
+			ret = 1;
+		}
+	}
+	int i = optind;
+	if (i > 0) {
+		if (i < argc)
+			inputfile = strdup(argv[i++]);
+	}
+
+	if (!inputfile) {
+		printHelp(argv[0]);
+		ret = 1;
+		goto cleanup;
+	}
+
+	if ((file = fopen(inputfile, "r")) == 0) {
+		fprintf(stderr, "Error: file %s not found\n", inputfile);
+		ret = 2;
+		goto cleanup;
+	}
+
+	if (!openPDF(file, e)) {
+		fprintf(stderr, "Error: Not a valid PDF\n");
+		ret = 3;
+		goto cleanup;
+	}
+
+	ret = getEncryptedInfo(file, e);
+	if (ret) {
+		if (ret == EENCNF)
+			fprintf(stderr,
+			    "Error: Could not extract encryption information\n");
+		else if (ret == ETRANF || ret == ETRENF || ret == ETRINF)
+			fprintf(stderr,
+			    "Error: Encryption not detected (is the document password protected?)\n");
+		ret = 4;
+		goto cleanup;
+	} else if (e->revision < 2 || (strcmp(e->s_handler, "Standard") != 0)) {
+		fprintf(stderr,
+		    "The specific version is not supported (%s - %d)\n",
+		    e->s_handler, e->revision);
+		ret = 5;
+		goto cleanup;
+	}
+
+	if (fclose(file)) {
+		fprintf(stderr, "Error: closing file %s\n", inputfile);
+	}
+#ifdef UNPDF_DEBUG
+	printEncData(e);
+#endif
+    /* try to initialize the cracking-engine */
+    if (!initPDFCrack(e, userpassword, e->work_with_user)) {
+        cleanPDFCrack();
+        fprintf(stderr, "Wrong userpassword given, '%s'\n", userpassword);
+        exit(-1);
+    }
+
+	/* deep serialize "e" structure */
+	printf("%s:$pdf$%s*", inputfile, e->s_handler);
+	p = e->o_string;
+	for (i = 0; i < 32; i++)
+		printf("%c%c", itoa16[ARCH_INDEX(p[i] >> 4)],
+		    itoa16[ARCH_INDEX(p[i] & 0x0f)]);
+	printf("*");
+	p = e->u_string;
+	for (i = 0; i < 32; i++)
+		printf("%c%c",
+		    itoa16[ARCH_INDEX(p[i] >> 4)],
+		    itoa16[ARCH_INDEX(p[i] & 0x0f)]);
+	printf("*%d*", e->fileIDLen);
+	p = e->fileID;
+	for (i = 0; i < e->fileIDLen; i++)
+		printf("%c%c",
+		    itoa16[ARCH_INDEX(p[i] >> 4)],
+		    itoa16[ARCH_INDEX(p[i] & 0x0f)]);
+	printf("*%d*%d*%d*%u*%u*%d*%d*%d*%d", e->encryptMetaData,
+	    e->work_with_user, e->have_userpassword, e->version_major,
+	    e->version_minor, e->length, e->permissions, e->revision,
+	    e->version);
+	if (e->have_userpassword)
+		printf("*%s\n", userpassword);
+	else
+		printf("\n");
+
+	exit(0);
+
+cleanup:
+
+	return ret;
+}
diff -rupN john-1.7.8/src/pdf_fmt.c john-1.7.8-jumbo-2/src/pdf_fmt.c
--- john-1.7.8/src/pdf_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdf_fmt.c	2011-06-08 18:15:59.000000000 +0200
@@ -0,0 +1,229 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ *
+ * Re-factored for JtR by Dhiru Kholia during June, 2011 for GSoC.
+ *
+ * References:
+ *
+ * http://www.adobe.com/devnet/pdf/pdf_reference.html
+ * http://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
+ * http://www.novapdf.com/kb/pdf-example-files-created-with-with-novapdf-138.html
+ *
+ * TODO: add support for detecting AESV2 and AESV3 encrypted documents
+ * lacking "trailer dictionary" to pdfparser.c */
+
+#include <string.h>
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+
+#include <openssl/ssl.h>
+#include <openssl/bio.h>
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+
+#include "pdfcrack.h"
+#include "pdfparser.h"
+
+#define FORMAT_LABEL        "pdf"
+#define FORMAT_NAME         "pdf"
+#define ALGORITHM_NAME      "32/" ARCH_BITS_STR
+#define BENCHMARK_COMMENT   ""
+#define BENCHMARK_LENGTH    0
+#define PLAINTEXT_LENGTH    32
+#define BINARY_SIZE         0
+#define SALT_SIZE           5120
+#define MIN_KEYS_PER_CRYPT  1
+#define MAX_KEYS_PER_CRYPT  1
+
+static EncData e;
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static char has_been_cracked;
+
+static struct fmt_tests pdf_tests[] = {
+    {"$pdf$Standard*badad1e86442699427116d3e5d5271bc80a27814fc5e80f815efeef839354c5f*289ece9b5ce451a5d7064693dab3badf101112131415161718191a1b1c1d1e1f*16*34b1b6e593787af681a9b63fa8bf563b*1*1*0*1*4*128*-4*3*2", "test"},
+	{NULL}
+};
+
+static void init(struct fmt_main *pFmt)
+{
+	/* OpenSSL init, cleanup part is left to OS */
+	SSL_load_error_strings();
+	SSL_library_init();
+	OpenSSL_add_all_algorithms();
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	return !strncmp(ciphertext, "$pdf$", 5);
+}
+
+static void *get_salt(char *ciphertext)
+{
+	char *copy = strdup(ciphertext);
+	return (void *) copy;
+}
+
+static void set_salt(void *salt)
+{
+#ifdef PDF_FMT_DEBUG
+	printf("%s\n", (char *)salt);
+#endif
+	salt += 5;		/* skip over "$pdf$" marker */
+	int i;
+	char *p;
+	char *copy = strdup(salt);
+	unsigned char *userpassword = NULL;
+
+	/* restore serialized data */
+	e.s_handler = strdup(strtok(copy, "*"));
+	e.o_string = (uint8_t *) malloc(32);
+	p = strtok(NULL, "*");
+	for (i = 0; i < 32; i++)
+		e.o_string[i] =
+		    atoi16[ARCH_INDEX(p[i * 2])] * 16 +
+		    atoi16[ARCH_INDEX(p[i * 2 + 1])];
+	e.u_string = (uint8_t *) malloc(32);
+	p = strtok(NULL, "*");
+	for (i = 0; i < 32; i++)
+		e.u_string[i] =
+		    atoi16[ARCH_INDEX(p[i * 2])] * 16 +
+		    atoi16[ARCH_INDEX(p[i * 2 + 1])];
+	p = strtok(NULL, "*");
+	e.fileIDLen = atoi(p);
+	e.fileID = (uint8_t *) malloc(e.fileIDLen);
+	p = strtok(NULL, "*");
+	for (i = 0; i < e.fileIDLen; i++)
+		e.fileID[i] =
+		    atoi16[ARCH_INDEX(p[i * 2])] * 16 +
+		    atoi16[ARCH_INDEX(p[i * 2 + 1])];
+	p = strtok(NULL, "*");
+	e.encryptMetaData = atoi(p);
+	p = strtok(NULL, "*");
+	e.work_with_user = atoi(p);
+	p = strtok(NULL, "*");
+	e.have_userpassword = atoi(p);
+	p = strtok(NULL, "*");
+	e.version_major = atoi(p);
+	p = strtok(NULL, "*");
+	e.version_minor = atoi(p);
+	p = strtok(NULL, "*");
+	e.length = atoi(p);
+	p = strtok(NULL, "*");
+	e.permissions = atoi(p);
+	p = strtok(NULL, "*");
+	e.revision = atoi(p);
+	p = strtok(NULL, "*");
+	e.version = atoi(p);
+	if (e.have_userpassword) {
+	    printf("received userpassword\n");
+		userpassword = (unsigned char *)strtok(NULL, "*");
+	}
+#ifdef PDF_FMT_DEBUG
+	printEncData(&e);
+#endif
+	/* try to initialize the cracking-engine */
+	if (!initPDFCrack(&e, userpassword, e.work_with_user)) {
+		cleanPDFCrack();
+		fprintf(stderr, "Wrong userpassword, '%s'\n", userpassword);
+		exit(-1);
+	}
+}
+
+static void pdf_set_key(char *key, int index)
+{
+	int len = strlen(key);
+	if (len > PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, len);
+	saved_key[len] = 0;
+	has_been_cracked = 0;
+}
+
+static char *get_key(int index)
+{
+	return saved_key;
+}
+
+static void crypt_all(int count)
+{
+    /* do the actual crunching */
+    has_been_cracked = runCrack(saved_key);
+#ifdef PDF_FMT_DEBUG
+    if(has_been_cracked)
+        printf("*** found password : %s\n", saved_key);
+#endif
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return 1;
+}
+
+static int cmp_one(void *binary, int index)
+{
+	return has_been_cracked;
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return has_been_cracked;
+}
+
+struct fmt_main fmt_pdf = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		pdf_tests
+	},
+	{
+		init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		fmt_default_binary,
+		get_salt,
+		{
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		set_salt,
+		pdf_set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			fmt_default_get_hash
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/pdfcrack.c john-1.7.8-jumbo-2/src/pdfcrack.c
--- john-1.7.8/src/pdfcrack.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack.c	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,428 @@
+/**
+ * Copyright (C) 2006-2008 Henning Norn
+ * Copyright (C) 1996-2005 Glyph & Cog, LLC.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <stdbool.h>
+#include "stdint.h"
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <ctype.h>
+#include "pdfcrack.h"
+#include "pdfcrack_md5.h"
+#include "pdfcrack_rc4.h"
+
+/** sets the number of bytes to decrypt for partial test in revision 3.
+    Three should be a good number for this as this mean a match should only
+    happen every 256^3=16777216 check and that should be unique enough to
+    motivate a full retry on that entry.
+ */
+#define PARTIAL_TEST_SIZE 3
+
+static const uint8_t pad[32] = {
+	0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41,
+	0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,
+	0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80,
+	0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A
+};
+
+/** buffers for stuff that we can precompute before the actual cracking */
+static uint8_t *encKeyWorkSpace;
+static uint8_t password_user[33];
+static uint8_t *rev3TestKey;
+static unsigned int ekwlen;
+
+/** points to the current password in clear-text */
+static unsigned char *currPW;
+/** current length of the password we are working with */
+static unsigned int currPWLen;
+
+/** pointer to the actual encoding-data from the pdf */
+static const EncData *encdata;
+
+/** some configuration switches */
+static bool knownPassword;
+static bool workWithUser;
+
+/**
+ * Initialisation of the encryption key workspace to manage a bit faster
+ * switching between keys
+ */
+static unsigned int
+initEncKeyWorkSpace(const int revision, const bool encMetaData,
+    const int permissions, const uint8_t * ownerkey,
+    const uint8_t * fileID, const unsigned int fileIDLen)
+{
+  /**
+   *   Algorithm 3.2 Computing an encryption key (PDF Reference, v 1.7, p.125)
+   *
+   *   Make space for:
+   *   field           | bytes
+   *   -----------------------
+   *   padded password | 32
+   *   O entry         | 32
+   *   P entry         |  4
+   *   fileID          | <fileIDLEn>
+   *   [extra padding] | [4] (Special for step 6)
+   **/
+	unsigned int size = (revision > 3 && !encMetaData) ? 72 : 68;
+	encKeyWorkSpace = malloc(size + fileIDLen);
+
+  /** Just to be sure we have no uninitalized stuff in the workspace */
+	memcpy(encKeyWorkSpace, pad, 32);
+
+  /** 3 */
+	memcpy(encKeyWorkSpace + 32, ownerkey, 32);
+
+  /** 4 */
+	encKeyWorkSpace[64] = permissions & 0xff;
+	encKeyWorkSpace[65] = (permissions >> 8) & 0xff;
+	encKeyWorkSpace[66] = (permissions >> 16) & 0xff;
+	encKeyWorkSpace[67] = (permissions >> 24) & 0xff;
+
+  /** 5 */
+	memcpy(encKeyWorkSpace + 68, fileID, fileIDLen);
+
+  /** 6 */
+	if (revision > 3 && !encMetaData) {
+		encKeyWorkSpace[68 + fileIDLen] = 0xff;
+		encKeyWorkSpace[69 + fileIDLen] = 0xff;
+		encKeyWorkSpace[70 + fileIDLen] = 0xff;
+		encKeyWorkSpace[71 + fileIDLen] = 0xff;
+	}
+
+	return size + fileIDLen;
+}
+
+#if 0
+/** For debug */
+static void printHexString(const uint8_t * str, const unsigned int len)
+{
+	unsigned int i;
+	for (i = 0; i < len; i++)
+		printf("%x ", str[i]);
+	printf("\n");
+}
+
+static void printString(const uint8_t * str, const unsigned int len)
+{
+	unsigned int i;
+	for (i = 0; i < len; i++)
+		printf("%d ", str[i]);
+	printf("\n");
+}
+#endif
+
+/** Common handling of the key for all rev3-functions */
+#define RC4_DECRYPT_REV3(n) {			\
+    for(i = 19; i >= 0; --i) {			\
+      for(j = 0; j < length; ++j)		\
+	tmpkey[j] = enckey[j] ^ i;		\
+      rc4Decrypt(tmpkey, test, n, test);	\
+    }						\
+  }
+
+/** Checks if the rev2-password set up in encKeyWorkSpace is the correct one
+    and return true if it is and false otherwise.
+*/
+static bool isUserPasswordRev2(void)
+{
+	uint8_t enckey[16];
+
+	md5(encKeyWorkSpace, ekwlen, enckey);
+
+	return rc4Match40b(enckey, encdata->u_string, pad);
+}
+
+/** Checks if the rev3-password set up in encKeyWorkSpace is the correct one
+    and return true if it is and false otherwise.
+*/
+static bool isUserPasswordRev3(void)
+{
+	uint8_t test[16], enckey[16], tmpkey[16];
+	int i;
+	unsigned int length, j;
+
+	length = encdata->length / 8;
+	md5(encKeyWorkSpace, ekwlen, enckey);
+	md5_50(enckey);
+	memcpy(test, encdata->u_string, 16);
+
+	RC4_DECRYPT_REV3(PARTIAL_TEST_SIZE);
+
+  /** if partial test succeeds we make a full check to be sure */
+	if (unlikely(memcmp(test, rev3TestKey, PARTIAL_TEST_SIZE) == 0)) {
+		memcpy(test, encdata->u_string, 16);
+		RC4_DECRYPT_REV3(16);
+		if (memcmp(test, rev3TestKey, 16) == 0) {
+			return true;
+		}
+	}
+	return false;
+}
+
+bool runCrackRev2_o(void)
+{
+	uint8_t enckey[16];
+	currPWLen = strlen((const char *)currPW);
+	if(currPWLen > 32)
+	    currPWLen = 32;
+	memcpy(currPW + currPWLen, pad, 32 - currPWLen);
+
+	md5(currPW, 32, enckey);
+
+	rc4Decrypt(enckey, encdata->o_string, 32, encKeyWorkSpace);
+	md5(encKeyWorkSpace, ekwlen, enckey);
+	if (rc4Match40b(enckey, encdata->u_string, pad)) {
+		memcpy(password_user, encKeyWorkSpace, 32);
+		return true;
+	}
+
+	return false;
+}
+
+bool runCrackRev3_o(void)
+{
+	uint8_t test[32], enckey[16], tmpkey[16];
+	unsigned int j, length;
+	int i;
+
+	length = encdata->length / 8;
+	currPWLen = strlen((const char *)currPW);
+	if(currPWLen > 32)
+	    currPWLen = 32;
+	memcpy(currPW + currPWLen, pad, 32 - currPWLen);
+
+	md5(currPW, 32, enckey);
+	md5_50(enckey);
+
+	memcpy(test, encdata->o_string, 32);
+	RC4_DECRYPT_REV3(32);
+	memcpy(encKeyWorkSpace, test, 32);
+
+	if (isUserPasswordRev3()) {
+		memcpy(password_user, encKeyWorkSpace, 32);
+		return true;
+	}
+
+	return false;
+}
+
+bool runCrackRev2_of(void)
+{
+	uint8_t enckey[16];
+	currPWLen = strlen((const char *)currPW);
+	if(currPWLen > 32)
+	    currPWLen = 32;
+	memcpy(currPW + currPWLen, pad, 32 - currPWLen);
+
+	md5(encKeyWorkSpace, 32, enckey);
+
+	/* Algorithm 3.4 reversed */
+	if (rc4Match40b(enckey, encdata->o_string, password_user))
+		return true;
+
+	return false;
+}
+
+bool runCrackRev3_of(void)
+{
+	uint8_t test[32], enckey[16], tmpkey[16];
+	unsigned int j, length;
+	int i;
+
+	length = encdata->length / 8;
+	currPWLen = strlen((const char *)currPW);
+	if(currPWLen > 32)
+	    currPWLen = 32;
+	memcpy(currPW + currPWLen, pad, 32 - currPWLen);
+
+	md5(encKeyWorkSpace, 32, enckey);
+	md5_50(enckey);
+
+	memcpy(test, encdata->o_string, 32);
+	RC4_DECRYPT_REV3(PARTIAL_TEST_SIZE);
+
+      /** if partial test succeeds we make a full check to be sure */
+	if (unlikely(memcmp(test, password_user, PARTIAL_TEST_SIZE) == 0)) {
+		memcpy(test, encdata->o_string, 32);
+		RC4_DECRYPT_REV3(32);
+		if (memcmp(test, password_user, 32) == 0)
+			return true;
+	}
+	return false;
+}
+
+bool runCrackRev3(void)
+{
+	uint8_t test[16], enckey[16], tmpkey[16];
+	unsigned int j, length;
+	int i;
+
+	length = encdata->length / 8;
+	currPWLen = strlen((const char *)currPW);
+	if(currPWLen > 32)
+	    currPWLen = 32;
+	memcpy(currPW + currPWLen, pad, 32 - currPWLen);
+
+	md5(encKeyWorkSpace, ekwlen, enckey);
+	md5_50(enckey);
+	memcpy(test, encdata->u_string, 16);
+
+     /** Algorithm 3.5 reversed */
+	RC4_DECRYPT_REV3(PARTIAL_TEST_SIZE);
+
+      /** if partial test succeeds we make a full check to be sure */
+	if (unlikely(memcmp(test, rev3TestKey, PARTIAL_TEST_SIZE) == 0)) {
+		memcpy(test, encdata->u_string, 16);
+		RC4_DECRYPT_REV3(16);
+		if (memcmp(test, rev3TestKey, 16) == 0)
+			return true;
+	}
+	return false;
+}
+
+
+bool runCrackRev2(void)
+{
+	uint8_t enckey[16];
+	currPWLen = strlen((const char *)currPW);
+	if(currPWLen > 32)
+	    currPWLen = 32;
+	memcpy(currPW + currPWLen, pad, 32 - currPWLen);
+
+	md5(encKeyWorkSpace, ekwlen, enckey);
+
+	/* Algorithm 3.4 reversed */
+	if (rc4Match40b(enckey, encdata->u_string, pad))
+		return true;
+
+	return false;
+}
+
+/** Start cracking and does not stop until it has either been interrupted by
+    a signal or the password either is found or wordlist or charset is exhausted
+*/
+int runCrack(char *password)
+{
+	bool found = false;
+	uint8_t cpw[32];
+	if (strlen(password) < 32)
+		strcpy((char*)currPW, password);
+    else {
+		strncpy((char*)currPW, password, 32);
+    }
+
+	if (!workWithUser && !knownPassword) {
+		memcpy(cpw, pad, 32);
+		currPW = cpw;
+		if (encdata->revision == 2)
+			found = runCrackRev2_o();
+		else
+			found = runCrackRev3_o();
+	} else if (encdata->revision == 2) {
+		if (workWithUser)
+			found = runCrackRev2();
+		else
+	     /** knownPassword */
+			found = runCrackRev2_of();
+	} else {
+		if (workWithUser)
+			found = runCrackRev3();
+		else
+	     /** knownPassword */
+			found = runCrackRev3_of();
+	}
+	return found;
+}
+
+/** cleans up everything as is needed to do a any initPDFCrack-calls after the
+    first one.
+*/
+void cleanPDFCrack(void)
+{
+	if (rev3TestKey) {
+    /** Do a really ugly const to non-const cast but this one time it should
+	be safe
+    */
+		free((uint8_t *) rev3TestKey);
+		rev3TestKey = NULL;
+	}
+	if (encKeyWorkSpace) {
+		free(encKeyWorkSpace);
+		encKeyWorkSpace = NULL;
+	}
+	knownPassword = false;
+}
+
+/** initPDFCrack is doing all the initialisations before you are able to call
+    runCrack(). Make sure that you run cleanPDFCrack before you call this
+    after the first time.
+*/
+bool initPDFCrack(const EncData * e, const uint8_t * upw, const bool user)
+{
+	uint8_t buf[128];
+	unsigned int upwlen;
+	uint8_t *tmp;
+
+	ekwlen =
+	    initEncKeyWorkSpace(e->revision, e->encryptMetaData,
+	    e->permissions, e->o_string, e->fileID, e->fileIDLen);
+
+	encdata = e;
+	currPW = encKeyWorkSpace;
+	currPWLen = 0;
+	workWithUser = user;
+	setrc4DecryptMethod((const unsigned int) e->length);
+	if (upw) {
+		upwlen = strlen((const char *) upw);
+		if (upwlen > 32)
+			upwlen = 32;
+		memcpy(password_user, upw, upwlen);
+		memcpy(password_user + upwlen, pad, 32 - upwlen);
+		memcpy(encKeyWorkSpace, password_user, 32);
+		knownPassword = true;
+	}
+
+	if (encdata->revision == 2) {
+		if (knownPassword) {
+			if (!isUserPasswordRev2())
+				return false;
+			memcpy(encKeyWorkSpace, pad, 32);
+		} else {
+			memcpy(password_user, pad, 32);
+			knownPassword = isUserPasswordRev2();
+		}
+	} else if (e->revision >= 3) {
+		memcpy(buf, pad, 32);
+		memcpy(buf + 32, e->fileID, e->fileIDLen);
+		tmp = malloc(sizeof(uint8_t) * 16);
+		md5(buf, 32 + e->fileIDLen, tmp);
+		rev3TestKey = tmp;
+		if (knownPassword) {
+			if (!isUserPasswordRev3())
+				return false;
+			memcpy(encKeyWorkSpace, pad, 32);
+		} else {
+			memcpy(password_user, pad, 32);
+			knownPassword = isUserPasswordRev3();
+		}
+	}
+	return true;
+}
diff -rupN john-1.7.8/src/pdfcrack.h john-1.7.8-jumbo-2/src/pdfcrack.h
--- john-1.7.8/src/pdfcrack.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack.h	2011-06-08 02:54:18.000000000 +0200
@@ -0,0 +1,49 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _PDFCRACK_H_
+#define _PDFCRACK_H_
+
+#include <stdio.h>
+#include "pdfcrack_common.h"
+
+bool initPDFCrack(const EncData * e, const uint8_t * upw, const bool user);
+
+void cleanPDFCrack(void);
+
+bool runCrackRev2(void);
+
+bool runCrackRev2_o(void);
+
+bool runCrackRev2_of(void);
+
+bool runCrackRev3(void);
+
+bool runCrackRev3_o(void);
+
+bool runCrackRev3_of(void);
+
+int runCrack(char *password);
+
+bool printProgress(void);
+
+unsigned int getNrProcessed(void);
+
+
+#endif /** _PDFCRACK_H_ */
diff -rupN john-1.7.8/src/pdfcrack_common.c john-1.7.8-jumbo-2/src/pdfcrack_common.c
--- john-1.7.8/src/pdfcrack_common.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack_common.c	2011-06-08 02:54:18.000000000 +0200
@@ -0,0 +1,83 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "pdfcrack_common.h"
+
+void freeEncData(EncData * e)
+{
+	if (!e)
+		return;
+	if (e->o_string)
+		free(e->o_string);
+	if (e->u_string)
+		free(e->u_string);
+	if (e->fileID)
+		free(e->fileID);
+	if (e->s_handler)
+		free(e->s_handler);
+	free(e);
+}
+
+void printEncData(EncData * e)
+{
+	unsigned int i;
+	uint8_t ch;
+
+	printf("PDF version %d.%d\n", e->version_major, e->version_minor);
+	if (e->s_handler)
+		printf("Security Handler: %s\n", e->s_handler);
+	printf("V: %d\nR: %d\nP: %d\nLength: %d\nEncrypted Metadata: %s\n",
+	    e->version, e->revision, e->permissions, e->length,
+	    e->encryptMetaData ? "True" : "False");
+	printf("FileID: ");
+	for (i = 0; i < e->fileIDLen; i++) {
+		ch = e->fileID[i];
+		if (ch < 16)
+			printf("0%x", ch);
+		else
+			printf("%x", ch);
+	}
+
+  /** Assume u_string and o_string is of length 32. Not safe, but the code
+      as a whole needs a rewrite anyway
+  */
+	if (e->u_string) {
+		printf("\nU: ");
+		for (i = 0; i < 32; i++) {
+			ch = e->u_string[i];
+			if (ch < 16)
+				printf("0%x", ch);
+			else
+				printf("%x", ch);
+		}
+	}
+	if (e->o_string) {
+		printf("\nO: ");
+		for (i = 0; i < 32; i++) {
+			ch = e->o_string[i];
+			if (ch < 16)
+				printf("0%x", ch);
+			else
+				printf("%x", ch);
+		}
+	}
+	printf("\n");
+}
diff -rupN john-1.7.8/src/pdfcrack_common.h john-1.7.8-jumbo-2/src/pdfcrack_common.h
--- john-1.7.8/src/pdfcrack_common.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack_common.h	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,58 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _PDFCOMMON_H_
+#define _PDFCOMMON_H_
+
+#include "stdint.h"
+#include <stdbool.h>
+
+#define likely(x)       __builtin_expect((x),1)
+#define unlikely(x)     __builtin_expect((x),0)
+
+/**
+    EncData holds all the information regarding the encryption-setting of a
+    specific pdf.
+    s_handler - Security handler string.
+    o_string - Owner-string, 32 bytes, not null-terminated
+    u_string - User-string, 32 bytes, not null-terminated
+    fileID - file ID in fileIDLen bytes, not null-terminated
+*/
+typedef struct EncData {
+	char *s_handler;
+	uint8_t *o_string;
+	uint8_t *u_string;
+	uint8_t *fileID;
+	bool encryptMetaData;
+	bool work_with_user;
+	bool have_userpassword;
+	unsigned int fileIDLen;
+	unsigned int version_major;
+	unsigned int version_minor;
+	int length;
+	int permissions;
+	int revision;
+	int version;
+} EncData;
+
+void freeEncData(EncData * e);
+
+void printEncData(EncData * e);
+
+#endif /** _PDFCOMMON_H_ */
diff -rupN john-1.7.8/src/pdfcrack_md5.c john-1.7.8-jumbo-2/src/pdfcrack_md5.c
--- john-1.7.8/src/pdfcrack_md5.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack_md5.c	2011-06-08 02:54:18.000000000 +0200
@@ -0,0 +1,321 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ * Copyright (C) 1996-2005 Glyph & Cog, LLC.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include "pdfcrack_md5.h"
+
+#define ROTATE_LEFT(x, r) ((x << r) | (x >> (32 - r)))
+
+#define RnA(a, b, s) a = ROTATE_LEFT(a, s); a += b
+
+/** MD5_ROUND1 optimized according to Colin Plumb's implementation */
+#define MD5_ROUND1(a, b, c, d, Xk, s, Ti) \
+  a += (d ^ (b & (c ^ d))) + Xk + Ti;	  \
+  RnA(a,b,s)
+
+/** MD5_ROUND2 optimized like above */
+#define MD5_ROUND2(a, b, c, d, Xk, s, Ti) \
+  a += (c ^ (d & (b ^ c))) + Xk + Ti;	  \
+  RnA(a,b,s)
+
+#define MD5_ROUND3(a, b, c, d, Xk, s, Ti) \
+  a += (b ^ c ^ d) + Xk + Ti;		  \
+  RnA(a,b,s)
+
+#define MD5_ROUND4(a, b, c, d, Xk, s, Ti) \
+  a += (c ^ (b | ~d)) + Xk + Ti;	  \
+  RnA(a,b,s)
+
+#define AA 0x67452301
+#define BB 0xefcdab89
+#define CC 0x98badcfe
+#define DD 0x10325476
+
+void md5(const uint8_t * msg, const unsigned int msgLen, uint8_t * digest)
+{
+	uint32_t x[16];
+	register uint32_t a, b, c, d;
+	uint32_t aa, bb, cc, dd;
+	int n64;
+	int i, j;
+	unsigned int k;
+
+  /** compute number of 64-byte blocks
+      (length + pad byte (0x80) + 8 bytes for length) */
+	n64 = (msgLen + 72) / 64;
+
+  /** initialize a, b, c, d */
+	a = AA;
+	b = BB;
+	c = CC;
+	d = DD;
+
+  /** loop through blocks */
+	k = 0;
+	for (i = 0; i < n64; ++i) {
+
+    /** grab a 64-byte block */
+		for (j = 0; j < 16 && k < msgLen - 3; ++j, k += 4)
+			x[j] =
+			    (((((msg[k + 3] << 8) + msg[k + 2]) << 8) + msg[k +
+				    1]) << 8) + msg[k];
+		if (i == n64 - 1) {
+			if (k == msgLen - 3)
+				x[j] =
+				    0x80000000 + (((msg[k + 2] << 8) + msg[k +
+					    1]) << 8) + msg[k];
+			else if (k == msgLen - 2)
+				x[j] = 0x800000 + (msg[k + 1] << 8) + msg[k];
+			else if (k == msgLen - 1)
+				x[j] = 0x8000 + msg[k];
+			else
+				x[j] = 0x80;
+			++j;
+			while (j < 16)
+				x[j++] = 0;
+			x[14] = msgLen << 3;
+		}
+
+    /** save a, b, c, d */
+		aa = a;
+		bb = b;
+		cc = c;
+		dd = d;
+
+    /** round 1 */
+		MD5_ROUND1(a, b, c, d, x[0], 7, 0xd76aa478);
+		MD5_ROUND1(d, a, b, c, x[1], 12, 0xe8c7b756);
+		MD5_ROUND1(c, d, a, b, x[2], 17, 0x242070db);
+		MD5_ROUND1(b, c, d, a, x[3], 22, 0xc1bdceee);
+		MD5_ROUND1(a, b, c, d, x[4], 7, 0xf57c0faf);
+		MD5_ROUND1(d, a, b, c, x[5], 12, 0x4787c62a);
+		MD5_ROUND1(c, d, a, b, x[6], 17, 0xa8304613);
+		MD5_ROUND1(b, c, d, a, x[7], 22, 0xfd469501);
+		MD5_ROUND1(a, b, c, d, x[8], 7, 0x698098d8);
+		MD5_ROUND1(d, a, b, c, x[9], 12, 0x8b44f7af);
+		MD5_ROUND1(c, d, a, b, x[10], 17, 0xffff5bb1);
+		MD5_ROUND1(b, c, d, a, x[11], 22, 0x895cd7be);
+		MD5_ROUND1(a, b, c, d, x[12], 7, 0x6b901122);
+		MD5_ROUND1(d, a, b, c, x[13], 12, 0xfd987193);
+		MD5_ROUND1(c, d, a, b, x[14], 17, 0xa679438e);
+		MD5_ROUND1(b, c, d, a, x[15], 22, 0x49b40821);
+
+    /** round 2 */
+		MD5_ROUND2(a, b, c, d, x[1], 5, 0xf61e2562);
+		MD5_ROUND2(d, a, b, c, x[6], 9, 0xc040b340);
+		MD5_ROUND2(c, d, a, b, x[11], 14, 0x265e5a51);
+		MD5_ROUND2(b, c, d, a, x[0], 20, 0xe9b6c7aa);
+		MD5_ROUND2(a, b, c, d, x[5], 5, 0xd62f105d);
+		MD5_ROUND2(d, a, b, c, x[10], 9, 0x02441453);
+		MD5_ROUND2(c, d, a, b, x[15], 14, 0xd8a1e681);
+		MD5_ROUND2(b, c, d, a, x[4], 20, 0xe7d3fbc8);
+		MD5_ROUND2(a, b, c, d, x[9], 5, 0x21e1cde6);
+		MD5_ROUND2(d, a, b, c, x[14], 9, 0xc33707d6);
+		MD5_ROUND2(c, d, a, b, x[3], 14, 0xf4d50d87);
+		MD5_ROUND2(b, c, d, a, x[8], 20, 0x455a14ed);
+		MD5_ROUND2(a, b, c, d, x[13], 5, 0xa9e3e905);
+		MD5_ROUND2(d, a, b, c, x[2], 9, 0xfcefa3f8);
+		MD5_ROUND2(c, d, a, b, x[7], 14, 0x676f02d9);
+		MD5_ROUND2(b, c, d, a, x[12], 20, 0x8d2a4c8a);
+
+    /** round 3 */
+		MD5_ROUND3(a, b, c, d, x[5], 4, 0xfffa3942);
+		MD5_ROUND3(d, a, b, c, x[8], 11, 0x8771f681);
+		MD5_ROUND3(c, d, a, b, x[11], 16, 0x6d9d6122);
+		MD5_ROUND3(b, c, d, a, x[14], 23, 0xfde5380c);
+		MD5_ROUND3(a, b, c, d, x[1], 4, 0xa4beea44);
+		MD5_ROUND3(d, a, b, c, x[4], 11, 0x4bdecfa9);
+		MD5_ROUND3(c, d, a, b, x[7], 16, 0xf6bb4b60);
+		MD5_ROUND3(b, c, d, a, x[10], 23, 0xbebfbc70);
+		MD5_ROUND3(a, b, c, d, x[13], 4, 0x289b7ec6);
+		MD5_ROUND3(d, a, b, c, x[0], 11, 0xeaa127fa);
+		MD5_ROUND3(c, d, a, b, x[3], 16, 0xd4ef3085);
+		MD5_ROUND3(b, c, d, a, x[6], 23, 0x04881d05);
+		MD5_ROUND3(a, b, c, d, x[9], 4, 0xd9d4d039);
+		MD5_ROUND3(d, a, b, c, x[12], 11, 0xe6db99e5);
+		MD5_ROUND3(c, d, a, b, x[15], 16, 0x1fa27cf8);
+		MD5_ROUND3(b, c, d, a, x[2], 23, 0xc4ac5665);
+
+    /** round 4 */
+		MD5_ROUND4(a, b, c, d, x[0], 6, 0xf4292244);
+		MD5_ROUND4(d, a, b, c, x[7], 10, 0x432aff97);
+		MD5_ROUND4(c, d, a, b, x[14], 15, 0xab9423a7);
+		MD5_ROUND4(b, c, d, a, x[5], 21, 0xfc93a039);
+		MD5_ROUND4(a, b, c, d, x[12], 6, 0x655b59c3);
+		MD5_ROUND4(d, a, b, c, x[3], 10, 0x8f0ccc92);
+		MD5_ROUND4(c, d, a, b, x[10], 15, 0xffeff47d);
+		MD5_ROUND4(b, c, d, a, x[1], 21, 0x85845dd1);
+		MD5_ROUND4(a, b, c, d, x[8], 6, 0x6fa87e4f);
+		MD5_ROUND4(d, a, b, c, x[15], 10, 0xfe2ce6e0);
+		MD5_ROUND4(c, d, a, b, x[6], 15, 0xa3014314);
+		MD5_ROUND4(b, c, d, a, x[13], 21, 0x4e0811a1);
+		MD5_ROUND4(a, b, c, d, x[4], 6, 0xf7537e82);
+		MD5_ROUND4(d, a, b, c, x[11], 10, 0xbd3af235);
+		MD5_ROUND4(c, d, a, b, x[2], 15, 0x2ad7d2bb);
+		MD5_ROUND4(b, c, d, a, x[9], 21, 0xeb86d391);
+
+    /** increment a, b, c, d */
+		a += aa;
+		b += bb;
+		c += cc;
+		d += dd;
+	}
+
+  /** break digest into bytes */
+	digest[0] = (uint8_t) (a & 0xff);
+	digest[1] = (uint8_t) ((a >>= 8) & 0xff);
+	digest[2] = (uint8_t) ((a >>= 8) & 0xff);
+	digest[3] = (uint8_t) ((a >>= 8) & 0xff);
+	digest[4] = (uint8_t) (b & 0xff);
+	digest[5] = (uint8_t) ((b >>= 8) & 0xff);
+	digest[6] = (uint8_t) ((b >>= 8) & 0xff);
+	digest[7] = (uint8_t) ((b >>= 8) & 0xff);
+	digest[8] = (uint8_t) (c & 0xff);
+	digest[9] = (uint8_t) ((c >>= 8) & 0xff);
+	digest[10] = (uint8_t) ((c >>= 8) & 0xff);
+	digest[11] = (uint8_t) ((c >>= 8) & 0xff);
+	digest[12] = (uint8_t) (d & 0xff);
+	digest[13] = (uint8_t) ((d >>= 8) & 0xff);
+	digest[14] = (uint8_t) ((d >>= 8) & 0xff);
+	digest[15] = (uint8_t) ((d >>= 8) & 0xff);
+}
+
+/** fast version of "for(i=0; i<50; i++) { md5(msg, 16, msg); }" */
+void md5_50(uint8_t * msg)
+{
+	register uint32_t a, b, c, d;
+	int i;
+
+	a = (((((msg[3] << 8) + msg[2]) << 8) + msg[1]) << 8) + msg[0];
+	b = (((((msg[7] << 8) + msg[6]) << 8) + msg[5]) << 8) + msg[4];
+	c = (((((msg[11] << 8) + msg[10]) << 8) + msg[9]) << 8) + msg[8];
+	d = (((((msg[15] << 8) + msg[14]) << 8) + msg[13]) << 8) + msg[12];
+
+	for (i = 0; i < 50; ++i) {
+		uint32_t aa, bb, cc, dd;
+
+		dd = d;
+		cc = c;
+		bb = b;
+		aa = a;
+
+    /** round 1 */
+    /**MD5_ROUND1(a,BB,CC,DD, aa, 7, 0xd76aa478);
+       MD5_ROUND1(d, a,BB,CC, bb,12, 0xe8c7b756);
+       MD5_ROUND1(c, d, a,BB, cc,17, 0x242070db);
+       MD5_ROUND1(b, c, d, a, dd,22, 0xc1bdceee);*/
+		a += 0xd76aa477;
+		RnA(a, BB, 7);
+		d = 0xf8fa0bcc + b + (CC ^ (a & 0x77777777));
+		RnA(d, a, 12);
+		c += 0xbcdb4dd9 + (BB ^ (d & (a ^ BB)));
+		RnA(c, d, 17);
+		b = 0xb18b7a77 + dd + (a ^ (c & (d ^ a)));
+		RnA(b, c, 22);
+		MD5_ROUND1(a, b, c, d, 0x80, 7, 0xf57c0faf);
+		MD5_ROUND1(d, a, b, c, 0, 12, 0x4787c62a);
+		MD5_ROUND1(c, d, a, b, 0, 17, 0xa8304613);
+		MD5_ROUND1(b, c, d, a, 0, 22, 0xfd469501);
+		MD5_ROUND1(a, b, c, d, 0, 7, 0x698098d8);
+		MD5_ROUND1(d, a, b, c, 0, 12, 0x8b44f7af);
+		MD5_ROUND1(c, d, a, b, 0, 17, 0xffff5bb1);
+		MD5_ROUND1(b, c, d, a, 0, 22, 0x895cd7be);
+		MD5_ROUND1(a, b, c, d, 0, 7, 0x6b901122);
+		MD5_ROUND1(d, a, b, c, 0, 12, 0xfd987193);
+		MD5_ROUND1(c, d, a, b, 0x80, 17, 0xa679438e);
+		MD5_ROUND1(b, c, d, a, 0, 22, 0x49b40821);
+
+    /** round 2 */
+		MD5_ROUND2(a, b, c, d, bb, 5, 0xf61e2562);
+		MD5_ROUND2(d, a, b, c, 0, 9, 0xc040b340);
+		MD5_ROUND2(c, d, a, b, 0, 14, 0x265e5a51);
+		MD5_ROUND2(b, c, d, a, aa, 20, 0xe9b6c7aa);
+		MD5_ROUND2(a, b, c, d, 0, 5, 0xd62f105d);
+		MD5_ROUND2(d, a, b, c, 0, 9, 0x02441453);
+		MD5_ROUND2(c, d, a, b, 0, 14, 0xd8a1e681);
+		MD5_ROUND2(b, c, d, a, 0x80, 20, 0xe7d3fbc8);
+		MD5_ROUND2(a, b, c, d, 0, 5, 0x21e1cde6);
+		MD5_ROUND2(d, a, b, c, 0x80, 9, 0xc33707d6);
+		MD5_ROUND2(c, d, a, b, dd, 14, 0xf4d50d87);
+		MD5_ROUND2(b, c, d, a, 0, 20, 0x455a14ed);
+		MD5_ROUND2(a, b, c, d, 0, 5, 0xa9e3e905);
+		MD5_ROUND2(d, a, b, c, cc, 9, 0xfcefa3f8);
+		MD5_ROUND2(c, d, a, b, 0, 14, 0x676f02d9);
+		MD5_ROUND2(b, c, d, a, 0, 20, 0x8d2a4c8a);
+
+    /** round 3 */
+		MD5_ROUND3(a, b, c, d, 0, 4, 0xfffa3942);
+		MD5_ROUND3(d, a, b, c, 0, 11, 0x8771f681);
+		MD5_ROUND3(c, d, a, b, 0, 16, 0x6d9d6122);
+		MD5_ROUND3(b, c, d, a, 0x80, 23, 0xfde5380c);
+		MD5_ROUND3(a, b, c, d, bb, 4, 0xa4beea44);
+		MD5_ROUND3(d, a, b, c, 0x80, 11, 0x4bdecfa9);
+		MD5_ROUND3(c, d, a, b, 0, 16, 0xf6bb4b60);
+		MD5_ROUND3(b, c, d, a, 0, 23, 0xbebfbc70);
+		MD5_ROUND3(a, b, c, d, 0, 4, 0x289b7ec6);
+		MD5_ROUND3(d, a, b, c, aa, 11, 0xeaa127fa);
+		MD5_ROUND3(c, d, a, b, dd, 16, 0xd4ef3085);
+		MD5_ROUND3(b, c, d, a, 0, 23, 0x04881d05);
+		MD5_ROUND3(a, b, c, d, 0, 4, 0xd9d4d039);
+		MD5_ROUND3(d, a, b, c, 0, 11, 0xe6db99e5);
+		MD5_ROUND3(c, d, a, b, 0, 16, 0x1fa27cf8);
+		MD5_ROUND3(b, c, d, a, cc, 23, 0xc4ac5665);
+
+    /** round 4 */
+		MD5_ROUND4(a, b, c, d, aa, 6, 0xf4292244);
+		MD5_ROUND4(d, a, b, c, 0, 10, 0x432aff97);
+		MD5_ROUND4(c, d, a, b, 0x80, 15, 0xab9423a7);
+		MD5_ROUND4(b, c, d, a, 0, 21, 0xfc93a039);
+		MD5_ROUND4(a, b, c, d, 0, 6, 0x655b59c3);
+		MD5_ROUND4(d, a, b, c, dd, 10, 0x8f0ccc92);
+		MD5_ROUND4(c, d, a, b, 0, 15, 0xffeff47d);
+		MD5_ROUND4(b, c, d, a, bb, 21, 0x85845dd1);
+		MD5_ROUND4(a, b, c, d, 0, 6, 0x6fa87e4f);
+		MD5_ROUND4(d, a, b, c, 0, 10, 0xfe2ce6e0);
+		MD5_ROUND4(c, d, a, b, 0, 15, 0xa3014314);
+		MD5_ROUND4(b, c, d, a, 0, 21, 0x4e0811a1);
+		MD5_ROUND4(a, b, c, d, 0x80, 6, 0xf7537e82);
+		MD5_ROUND4(d, a, b, c, 0, 10, 0xbd3af235);
+		MD5_ROUND4(c, d, a, b, cc, 15, 0x2ad7d2bb);
+		MD5_ROUND4(b, c, d, a, 0, 21, 0xeb86d391);
+
+		a += AA;
+		b += BB;
+		c += CC;
+		d += DD;
+	}
+
+  /** break digest into bytes */
+	msg[0] = (uint8_t) (a & 0xff);
+	msg[1] = (uint8_t) ((a >>= 8) & 0xff);
+	msg[2] = (uint8_t) ((a >>= 8) & 0xff);
+	msg[3] = (uint8_t) ((a >>= 8) & 0xff);
+	msg[4] = (uint8_t) (b & 0xff);
+	msg[5] = (uint8_t) ((b >>= 8) & 0xff);
+	msg[6] = (uint8_t) ((b >>= 8) & 0xff);
+	msg[7] = (uint8_t) ((b >>= 8) & 0xff);
+	msg[8] = (uint8_t) (c & 0xff);
+	msg[9] = (uint8_t) ((c >>= 8) & 0xff);
+	msg[10] = (uint8_t) ((c >>= 8) & 0xff);
+	msg[11] = (uint8_t) ((c >>= 8) & 0xff);
+	msg[12] = (uint8_t) (d & 0xff);
+	msg[13] = (uint8_t) ((d >>= 8) & 0xff);
+	msg[14] = (uint8_t) ((d >>= 8) & 0xff);
+	msg[15] = (uint8_t) ((d >>= 8) & 0xff);
+}
diff -rupN john-1.7.8/src/pdfcrack_md5.h john-1.7.8-jumbo-2/src/pdfcrack_md5.h
--- john-1.7.8/src/pdfcrack_md5.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack_md5.h	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,28 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _MD5_H_
+#define _MD5_H_
+#include "stdint.h"
+
+void md5(const uint8_t * msg, const unsigned int msgLen, uint8_t * digest);
+
+void md5_50(uint8_t * msg);
+
+#endif /** _MD5_H_ */
diff -rupN john-1.7.8/src/pdfcrack_rc4.c john-1.7.8-jumbo-2/src/pdfcrack_rc4.c
--- john-1.7.8/src/pdfcrack_rc4.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack_rc4.c	2011-06-08 02:54:18.000000000 +0200
@@ -0,0 +1,213 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+#include <string.h>
+#include <assert.h>
+#include "pdfcrack_rc4.h"
+
+#define likely(x)       __builtin_expect((x),1)
+#define unlikely(x)     __builtin_expect((x),0)
+
+/** Seems to faster to do a memcpy of this on my machine than to create
+    the array with a loop
+*/
+static const uint8_t
+initial_state[256] = {
+  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
+  0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
+  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23,
+  0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
+  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b,
+  0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
+  0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53,
+  0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
+  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b,
+  0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77,
+  0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83,
+  0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
+  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b,
+  0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
+  0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3,
+  0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
+  0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb,
+  0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7,
+  0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3,
+  0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
+  0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb,
+  0xfc, 0xfd, 0xfe, 0xff};
+
+#define key_pass(n) {				\
+    tmp = state[++i];				\
+    j = (j + tmp + key[n]);			\
+    state[i] = state[j];			\
+    state[j] = tmp;				\
+  }
+
+/** Do rc4-decrypt with key on bs of length 32 and compare it to match */
+__attribute__ ((pure)) bool
+rc4Match40b(const uint8_t *key, const uint8_t *bs,const uint8_t *match) {
+  uint8_t state[256];
+  register unsigned int i;
+  register uint8_t j, tmp;
+
+  /** initialize the state */
+  memcpy(state, initial_state, 256);
+
+  /** do the shuffle */
+  j = key[0];
+  state[0] = j;
+  state[j] = 0;
+  i = 0;
+  do {
+    key_pass(1);
+    key_pass(2);
+    key_pass(3);
+    key_pass(4);
+    key_pass(0);
+  } while(i < 255);
+
+  j = 0;
+  for(i=1;i<=32;++i) {
+    tmp = state[i];
+    j += tmp;
+    state[i] = state[j];
+    state[j] = tmp;
+
+    /**
+	Only continue if we match the match-strings characters.
+	The match should only happen once every 256 try or so and that is
+	the motivation behind the likely-hint
+    */
+    tmp += state[i];
+    if(likely((bs[i-1]^state[tmp]) != match[i-1]))
+      return false;
+  }
+  return true;
+}
+
+static void
+(*rc4d)(const uint8_t *key, const uint8_t *bs,
+	const unsigned int len, uint8_t *out) = NULL;
+
+/** Do 40-bit rc4-decrypt with key on bs of length len and
+    put the result in out
+*/
+static void
+rc4Decrypt40b(const uint8_t *key, const uint8_t *bs,
+	      const unsigned int len, uint8_t *out) {
+  uint8_t state[256];
+  register unsigned int i;
+  register uint8_t j, tmp;
+
+  assert(len < 256);
+
+  /** initialize the state */
+  memcpy(state, initial_state, 256);
+
+  /** do the shuffle */
+  j = key[0];
+  state[0] = j;
+  state[j] = 0;
+  i = 0;
+  do {
+    key_pass(1);
+    key_pass(2);
+    key_pass(3);
+    key_pass(4);
+    key_pass(0);
+  } while(i < 255);
+
+  j = 0;
+  for(i=1;i<=len;++i) {
+    tmp = state[i];
+    j += tmp;
+    state[i] = state[j];
+    state[j] = tmp;
+
+    tmp += state[i];
+    out[i-1] = bs[i-1]^state[tmp];
+  }
+}
+
+/** Do 128-bit rc4-decrypt with key on bs of length len and
+    put the result in out
+*/
+static void
+rc4Decrypt128b(const uint8_t *key, const uint8_t *bs,
+	       const unsigned int len, uint8_t *out) {
+  uint8_t state[256];
+  register int i;
+  register uint8_t j, tmp;
+
+  assert(len < 256);
+
+  /** initialize the state */
+  memcpy(state, initial_state, 256);
+
+  /** do the shuffle */
+  j = 0;
+  i = -1;
+  do {
+    key_pass( 0);
+    key_pass( 1);
+    key_pass( 2);
+    key_pass( 3);
+    key_pass( 4);
+    key_pass( 5);
+    key_pass( 6);
+    key_pass( 7);
+    key_pass( 8);
+    key_pass( 9);
+    key_pass(10);
+    key_pass(11);
+    key_pass(12);
+    key_pass(13);
+    key_pass(14);
+    key_pass(15);
+  } while(i < 255);
+
+  j = 0;
+  for(i=1;(unsigned int)i<=len;++i) {
+    tmp = state[i];
+    j += tmp;
+    state[i] = state[j];
+    state[j] = tmp;
+
+    tmp += state[i];
+    out[i-1] = bs[i-1]^state[tmp];
+  }
+}
+
+/** Just a wrapper for the function optimized for a specific length */
+inline void
+rc4Decrypt(const uint8_t *key, const uint8_t *bs,
+	   const unsigned int len, uint8_t *out) {
+  rc4d(key, bs, len, out);
+}
+
+/** sets which function the wrapper should call */
+__attribute__ ((pure)) bool
+setrc4DecryptMethod(const unsigned int length) {
+  if(length == 128)
+    rc4d = &rc4Decrypt128b;
+  else if(length == 40)
+    rc4d = &rc4Decrypt40b;
+  else
+    return false;
+  return true;
+}
diff -rupN john-1.7.8/src/pdfcrack_rc4.h john-1.7.8-jumbo-2/src/pdfcrack_rc4.h
--- john-1.7.8/src/pdfcrack_rc4.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfcrack_rc4.h	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,35 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _RC4_H_
+#define _RC4_H_
+#include "stdint.h"
+#include <stdbool.h>
+
+void
+rc4Decrypt(const uint8_t *key, const uint8_t *bs,
+	   const unsigned int len, uint8_t *out);
+
+bool
+rc4Match40b(const uint8_t *key, const uint8_t *bs, const uint8_t *match);
+
+bool
+setrc4DecryptMethod(const unsigned int length);
+
+#endif /** _RC4_H_ */
diff -rupN john-1.7.8/src/pdfparser.c john-1.7.8-jumbo-2/src/pdfparser.c
--- john-1.7.8/src/pdfparser.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfparser.c	2011-06-08 02:54:55.000000000 +0200
@@ -0,0 +1,608 @@
+/**
+ * Copyright (C) 2006-2008 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#include "pdfparser.h"
+#include <stdlib.h>
+#include <string.h>
+
+#define BUFFSIZE 256
+
+/** Please rewrite all of this file in a clean and stable way */
+
+struct p_str {
+  uint8_t *content;
+  uint8_t len;
+};
+
+typedef struct p_str p_str;
+
+__attribute__ ((pure)) static inline bool
+isWhiteSpace(const int ch) {
+  return (ch == 0x20 || (ch >= 0x09 && ch <= 0x0d) || ch == 0x00);
+}
+
+__attribute__ ((pure)) static bool
+isDelimiter(const int ch) {
+  switch(ch) {
+  case '(':
+  case ')':
+  case '<':
+  case '>':
+  case '[':
+  case ']':
+  case '{':
+  case '}':
+  case '/':
+  case '%':
+    return true;
+  default:
+    return false;
+  }
+}
+
+__attribute__ ((pure)) static inline bool
+isEndOfLine(const int ch) {
+  return (ch == 0x0a || ch == 0x0d);
+}
+
+static int
+parseIntWithC(FILE *file, const int c) {
+  bool neg = false;
+  int i = 0;
+  int ch = c;
+
+  if(ch == '-') {
+    neg = true;
+    ch = getc(file);
+  }
+  else if(ch == '+')
+    ch = getc(file);
+  while(ch >= '0' && ch <= '9') {
+    i *= 10;
+    i += ch-'0';
+    ch = getc(file);
+  }
+  ungetc(ch,file);
+  if(neg)
+    i *= -1;
+
+  return i;
+}
+
+static int
+parseInt(FILE *file) {
+  return parseIntWithC(file, getc(file));
+}
+
+
+static char
+parseWhiteSpace(FILE *file) {
+  int ch;
+  do {
+    ch = getc(file);
+  } while(isWhiteSpace(ch));
+  return ch;
+}
+
+static char*
+parseName(FILE *file) {
+  int ch;
+  unsigned int i;
+  char *ret;
+  char buff[BUFFSIZE];
+
+  ch = parseWhiteSpace(file);
+
+  if(ch != '/') {
+    ungetc(ch, file);
+    return NULL;
+  }
+  ch = getc(file);
+  for(i=0; i<BUFFSIZE && !isWhiteSpace(ch) &&
+	!isDelimiter(ch) && ch != EOF; ++i) {
+    buff[i] = ch;
+    ch = getc(file);
+  }
+  ungetc(ch, file);
+  buff[i++] = '\0';
+  ret = malloc(sizeof(char)*i);
+  memcpy(ret, buff, i);
+  return ret;
+}
+
+/**
+static bool
+isName(FILE *file, const char *str) {
+  int ch;
+  unsigned int i;
+
+  ch = parseWhiteSpace(file);
+
+  if(ch != '/') {
+    ungetc(ch, file);
+    return false;
+  }
+  for(i=0; i<strlen(str); ++i) {
+    ch = getc(file);
+    if(ch != str[i])
+      return false;
+  }
+  return true;
+}
+*/
+
+static bool
+isWord(FILE *file, const char *str) {
+  int ch;
+  unsigned int i;
+  for(i=0; i<strlen(str); ++i)
+    if((ch = getc(file)) != str[i])
+      goto ret;
+  return true;
+ ret:
+  ungetc(ch,file);
+  return false;
+}
+
+bool
+openPDF(FILE *file, EncData *e) {
+  bool ret = false;
+  int minor_v = 0, major_v = 0;
+  if(getc(file) == '%' && getc(file) == 'P' && getc(file) == 'D'
+     && getc(file) == 'F' && getc(file) == '-') {
+    major_v = parseInt(file);
+    if(getc(file) == '.')
+      minor_v = parseInt(file);
+    if(major_v >= 0)
+      ret = true;
+  }
+
+  if(ret) {
+    e->version_major = major_v;
+    e->version_minor = minor_v;
+  }
+  return ret;
+}
+
+__attribute__ ((pure)) static uint8_t
+hexToInt(const int b) {
+  if(b >= '0' && b <= '9')
+    return b-'0';
+  else if(b >= 'a' && b <= 'f')
+    return b-'a'+10;
+  else if(b >= 'A' && b <= 'F')
+    return b-'A'+10;
+  else
+    return 0;
+}
+
+static p_str*
+parseHexString(const uint8_t *buf, const unsigned int len) {
+  unsigned int i,j;
+  p_str *ret;
+
+  ret = malloc(sizeof(p_str));
+  ret->content = malloc(sizeof(uint8_t)*(len/2));
+  ret->len = (len/2);
+
+  for(i=0, j=0; i<len; i += 2) {
+    ret->content[j] = hexToInt(buf[i]) * 16;
+    ret->content[j] += hexToInt(buf[i+1]);
+    j++;
+  }
+
+  return ret;
+}
+
+static p_str*
+objStringToByte(const uint8_t* str, const unsigned int len) {
+  unsigned int i, j, l;
+  uint8_t b, d;
+  uint8_t tmp[len];
+  p_str *ret;
+
+  for(i=0, l=0; i<len; i++, l++) {
+    b = str[i];
+    if(b == '\\') {
+      /**
+       * We have reached a special character or the beginning of a octal
+       * up to three digit number and should skip the initial backslash
+       **/
+      i++;
+      switch(str[i]) {
+      case 'n':
+	b = 0x0a;
+	break;
+      case 'r':
+	b = 0x0d;
+	break;
+      case 't':
+	b = 0x09;
+	break;
+      case 'b':
+	b = 0x08;
+	break;
+      case 'f':
+	b = 0x0c;
+	break;
+      case '(':
+	b = '(';
+	break;
+      case ')':
+	b = ')';
+	break;
+      case '\\':
+	b = '\\';
+	break;
+      default:
+	if(str[i] >= '0' && str[i] < '8') {
+	  d = 0;
+	  for(j=0; i < len && j < 3 &&
+		str[i] >= '0' && str[i] < '8' &&
+		(d*8)+(str[i]-'0') < 256; j++, i++) {
+	    d *= 8;
+	    d += (str[i]-'0');
+	  }
+	  /**
+	   * We need to step back one step if we reached the end of string
+	   * or the end of digits (like for example \0000)
+	   **/
+	  if(i < len || j < 3) {
+	    i--;
+	  }
+
+	  b = d;
+	}
+      }
+    }
+    tmp[l] = b;
+  }
+
+  ret = malloc(sizeof(p_str));
+  ret->content = malloc(sizeof(uint8_t)*(l));
+  ret->len = l-1;
+
+  memcpy(ret->content, tmp, l);
+
+  return ret;
+}
+
+static p_str*
+parseRegularString(FILE *file) {
+  unsigned int len, p;
+  int ch;
+  p_str *ret;
+  uint8_t buf[BUFFSIZE];
+  bool skip = false;
+
+  ch = parseWhiteSpace(file);
+  if(ch == '(') {
+    p = 1;
+    ch = getc(file);
+    for(len=0; len < BUFFSIZE && p > 0 && ch != EOF; len++) {
+      buf[len] = ch;
+      if(skip == false) {
+	if(ch == '(')
+	  p++;
+	else if(ch == ')')
+	  p--;
+	if(ch == '\\')
+	  skip = true;
+      }
+      else
+	skip = false;
+      ch = getc(file);
+    }
+    ungetc(ch, file);
+    ret = objStringToByte(buf, len);
+  }
+  else if(ch == '<') {
+    len = 0;
+    while(ch != '>' && len < BUFFSIZE && ch != EOF) {
+      if((ch >= '0' && ch <= '9') ||
+	 (ch >= 'a' && ch <= 'f') ||
+	 (ch >= 'A' && ch <= 'F')) {
+	buf[len++] = ch;
+      }
+      ch = getc(file);
+    }
+    ungetc(ch,file);
+    ret = parseHexString(buf,len);
+  }
+  else
+    ret = NULL;
+return ret;
+}
+
+static int
+findTrailer(FILE *file, EncData *e) {
+  int ch;
+  /**  int pos_i; */
+  bool encrypt = false;
+  bool id = false;
+  int e_pos = -1;
+  p_str *str = NULL;
+
+  ch = getc(file);
+  while(ch != EOF) {
+    if(isEndOfLine(ch)) {
+      if(isWord(file, "trailer")) {
+	/**	printf("found trailer\n");*/
+	ch = parseWhiteSpace(file);
+	if(ch == '<' && getc(file) == '<') {
+	  /** we can be pretty sure to have found the trailer.
+	      start looking for the Encrypt-entry */
+
+	  /**
+	  pos_i = ftell(file);
+	  printf("found Trailer at pos %x\n", pos_i);
+	  */
+	  ch = getc(file);
+	  while(ch != EOF) {
+	    if(ch == '>') {
+	      ch = getc(file);
+	      if(ch == '>')
+		break;
+	    }
+	    while(ch != '/' && ch != EOF) {
+	      ch = getc(file);
+	    }
+	    ch = getc(file);
+	    /**printf("found a name: %c\n", ch);*/
+	    if(e_pos < 0 && ch == 'E' && isWord(file, "ncrypt")) {
+	      e_pos = parseIntWithC(file,parseWhiteSpace(file));
+	      if(e_pos >= 0) {
+		/**
+		   pos_i = ftell(file);
+		   printf("found Encrypt at pos %x, ", pos_i);
+		   printf("%d\n", e_pos);
+		*/
+		encrypt = true;
+	      }
+	    }
+	    else if(ch == 'I' && getc(file) == 'D') {
+	      ch = parseWhiteSpace(file);
+	      while(ch != '[' && ch != EOF)
+		ch = getc(file);
+
+	      if(str) {
+		if(str->content)
+		  free(str->content);
+		free(str);
+	      }
+
+	      str = parseRegularString(file);
+	      /**
+	      pos_i = ftell(file);
+	      printf("found ID at pos %x\n", pos_i);
+	      */
+	      if(str)
+		id = true;
+	      ch = getc(file);
+	    }
+	    else
+	      ch = getc(file);
+	    if(encrypt && id) {
+	      /**printf("found all, returning: epos: %d\n",e_pos);*/
+	      e->fileID = str->content;
+	      e->fileIDLen = str->len;
+	      free(str);
+	      return e_pos;
+	    }
+	  }
+	}
+      }
+      else {
+	ch = getc(file);
+      }
+    }
+    else
+      ch = getc(file);
+  }
+  /**  printf("finished searching\n");*/
+
+  if(str) {
+    if(str->content)
+      	free(str->content);
+    free(str);
+  }
+
+  if(!encrypt && id)
+      return ETRENF;
+  else if(!id && encrypt)
+    return ETRINF;
+  else
+    return ETRANF;
+}
+
+static bool
+parseEncrypObject(FILE *file, EncData *e) {
+  int ch, dict = 1;
+  bool fe = false;
+  bool ff = false;
+  bool fl = false;
+  bool fo = false;
+  bool fp = false;
+  bool fr = false;
+  bool fu = false;
+  bool fv = false;
+  p_str *str = NULL;
+
+  ch = getc(file);
+  while(ch != EOF) {
+    if(ch == '>') {
+      ch = getc(file);
+      if(ch == '>') {
+	dict--;
+	if(dict <= 0)
+	   break;
+      }
+    }
+    else if(ch == '<') {
+      ch = getc(file);
+      if(ch == '<') {
+	dict++;
+      }
+    }
+    if(ch == '/') {
+      ch = getc(file);
+      switch(ch) {
+      case 'E':
+	if(isWord(file, "ncryptMetadata")) {
+	  ungetc(parseWhiteSpace(file), file);
+	  if(isWord(file, "false"))
+	    fe = true;
+	}
+	break;
+      case 'F':
+	if(isWord(file, "ilter")) {
+	  char *s_handler = parseName(file);
+	  if(s_handler != NULL) {
+	    e->s_handler = s_handler;
+	    ff = true;
+	  }
+	  break;
+	}
+      case 'L':
+	if(isWord(file, "ength")) {
+	  int tmp_l = parseIntWithC(file,parseWhiteSpace(file));
+	  if(!fl) {
+	    /* BZZZT!!  This is sooo wrong but will work for most cases.
+	       only use the first length we stumble upon */
+	    e->length = tmp_l;
+	  }
+	  fl = true;
+	}
+	break;
+      case 'O':
+	str = parseRegularString(file);
+	if(!str)
+	  break;
+	if(str->len != 32)
+	  fprintf(stderr, "WARNING: O-String != 32 Bytes: %d\n", str->len);
+	e->o_string = str->content;
+	free(str);
+	fo = true;
+	break;
+      case 'P':
+	ch = getc(file);
+	if(isWhiteSpace(ch)) {
+	  ch = parseWhiteSpace(file);
+	  e->permissions = parseIntWithC(file,ch);
+	  fp = true;
+	}
+	break;
+      case 'R':
+	ch = getc(file);
+	if(isWhiteSpace(ch)) {
+	  ch = parseWhiteSpace(file);
+	  e->revision = parseIntWithC(file,ch);
+	  fr = true;
+	}
+	break;
+      case 'U':
+	str = parseRegularString(file);
+	if(!str)
+	  break;
+	if(str->len != 32)
+	  fprintf(stderr, "WARNING: U-String != 32 Bytes: %d\n", str->len);
+	e->u_string = str->content;
+	free(str);
+	fu = true;
+	break;
+      case 'V':
+	ch = getc(file);
+	if(isWhiteSpace(ch)) {
+	  e->version = parseIntWithC(file, parseWhiteSpace(file));
+	  fv = true;
+	}
+	break;
+      default:
+	break;
+      }
+    }
+    ch = parseWhiteSpace(file);
+  }
+
+  if(!fe)
+    e->encryptMetaData = true;
+  if(!fl)
+    e->length = 40;
+  if(!fv)
+    e->version = 0;
+
+  if(strcmp(e->s_handler,"Standard") != 0)
+    return true;
+
+  return ff & fo && fp && fr && fu;
+}
+
+/**
+    This is not a really definitive search.
+    Should be replaced with something better
+*/
+static bool
+findEncryptObject(FILE *file, const int e_pos, EncData *e) {
+  int ch;
+
+  /** only find the encrypt object if e_pos > -1 */
+  if(e_pos < 0)
+    return false;
+
+  ch = getc(file);
+  while(ch != EOF) {
+    if(isEndOfLine(ch)) {
+      if(parseInt(file) == e_pos) {
+	ch = parseWhiteSpace(file);
+	if(ch >= '0' && ch <= '9') {
+	  ch = parseWhiteSpace(file);
+	  if(ch == 'o' && getc(file) == 'b' && getc(file) == 'j' &&
+	     parseWhiteSpace(file) == '<' && getc(file) == '<') {
+	    return parseEncrypObject(file, e);
+	  }
+	}
+      }
+    }
+    ch = getc(file);
+  }
+  return false;
+}
+
+
+int
+getEncryptedInfo(FILE *file, EncData *e) {
+  int e_pos = -1;
+  bool ret;
+
+  if(fseek(file, 0L, SEEK_END-1024))
+    e_pos = findTrailer(file, e);
+  if(e_pos < 0) {
+    rewind(file);
+    e_pos = findTrailer(file, e);
+  }
+  if(e_pos < 0) {
+    return e_pos;
+  }
+  rewind(file);
+  ret = findEncryptObject(file, e_pos, e);
+  if(!ret)
+    return EENCNF;
+
+  return 0;
+}
diff -rupN john-1.7.8/src/pdfparser.h john-1.7.8-jumbo-2/src/pdfparser.h
--- john-1.7.8/src/pdfparser.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pdfparser.h	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,39 @@
+/**
+ * Copyright (C) 2006 Henning Norn
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,
+ * USA.
+ */
+
+#ifndef _PDFPARSER_H_
+#define _PDFPARSER_H_
+#include <stdio.h>
+#include "stdint.h"
+#include <stdbool.h>
+#include "pdfcrack_common.h"
+
+#define EENCNF -1 /* Encryption Object Not Found */
+#define ETRANF -2 /* Trailer Information Not Found */
+#define ETRENF -3 /* Trailer: Encryption Object Not Found */
+#define ETRINF -4 /* Trailer: FileID Object Not Found */
+
+bool
+openPDF(FILE *file, EncData *e);
+
+int
+getEncryptedInfo(FILE *file, EncData *e);
+
+
+#endif /** _PDFPARSER_H_ */
diff -rupN john-1.7.8/src/phpassMD5_fmt_plug.c john-1.7.8-jumbo-2/src/phpassMD5_fmt_plug.c
--- john-1.7.8/src/phpassMD5_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/phpassMD5_fmt_plug.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,152 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Cracks phpass 'portable' hashes, and phpBBv3 hashes, which
+ * are simply phpass portable, with a slightly different signature.
+ * These are 8 byte salted hashes, with a 1 byte 'salt' that
+ * defines the number of loops to compute.  Internally we work
+ * with 8 byte salt (the 'real' salt), but let john track it as
+ * 9 byte salts (the loop count byte is appended to the 'real'
+ * 8 byte salt value.
+ *
+ * code should be pretty fast, and pretty well debugged.  Works
+ * even if there are multiple loop count values in the set of
+ * hashes. PHPv5 kicked up the default loop number, but it is
+ * programatically allowed to have different looping counts.
+ * This format should handle all valid loop values.
+ *
+ * This format is now a 'shell'.  It simply is used to filter out
+ * the $H$??????? hashes, and convert them into md5_gen(17)??????
+ * and setup and forward the 'work' to the md5_gen to do the 'real'
+ * work.
+ *
+ */
+
+#include <string.h>
+
+#include "common.h"
+#include "formats.h"
+#include "md5_gen.h"
+
+#define FORMAT_LABEL			"phpass-md5"
+#define FORMAT_NAME				"PHPass MD5"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME			"phpass-MD5 MMX"
+#else
+#define ALGORITHM_NAME			"phpass-MD5 SSE2"
+#endif
+#else
+#define ALGORITHM_NAME			"phpass-md5"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		64
+#define CIPHERTEXT_LENGTH		34
+
+#define BINARY_SIZE				16
+#define SALT_SIZE				8
+
+static struct fmt_tests phpassmd5_tests[] = {
+		{"$H$9aaaaaSXBjgypwqm.JsMssPLiS8YQ00", "test1"},
+		{"$H$9PE8jEklgZhgLmZl5.HYJAzfGCQtzi1", "123456"},
+		{"$H$9pdx7dbOW3Nnt32sikrjAxYFjX8XoK1", "123456"},
+		{"$P$912345678LIjjb6PhecupozNBmDndU0", "thisisalongertestPW"},
+		{"$H$9A5she.OeEiU583vYsRXZ5m2XIpI68/", "123456"},
+		{"$P$917UOZtDi6ksoFt.y2wUYvgUI6ZXIK/", "test1"},
+		{"$P$91234567AQwVI09JXzrV1hEC6MSQ8I0", "thisisalongertest"},
+		{"$P$9234560A8hN6sXs5ir0NfozijdqT6f0", "test2"},
+		{"$P$9234560A86ySwM77n2VA/Ey35fwkfP0", "test3"},
+		{"$P$9234560A8RZBZDBzO5ygETHXeUZX5b1", "test4"},
+		{"$P$612345678si5M0DDyPpmRCmcltU/YW/", "JohnRipper"}, // note smaller loop count
+		{"$H$712345678WhEyvy1YWzT4647jzeOmo0", "JohnRipper"}, // note smaller loop count (phpbb w/older PHP version)
+		{"$P$B12345678L6Lpt4BxNotVIMILOa9u81", "JohnRipper"}, // note larber loop count  (Wordpress)
+		{"$P$91234567xogA.H64Lkk8Cx8vlWBVzH0", "thisisalongertst"},
+		{NULL}
+};
+
+static char Conv_Buf[80];
+static struct fmt_main *pFmt_MD5_gen_17;
+static void phpassmd5_init(struct fmt_main *pFmt);
+
+/* this function converts a 'native' phpass signature string into a md5_gen(17) syntax string */
+static char *Convert(char *Buf, char *ciphertext)
+{
+	sprintf(Buf, "md5_gen(17)%s%10.10s", &ciphertext[3+8+1], &ciphertext[2]);
+	return Buf;
+}
+
+static int phpassmd5_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+		int i;
+		unsigned count_log2;
+
+		if (strlen(ciphertext) != 34)
+				return 0;
+		// Handle both the phpass signature, and the phpBB v3 signature (same formula)
+		// NOTE we are only dealing with the 'portable' encryption method
+		if (strncmp(ciphertext, "$P$", 3) != 0 && strncmp(ciphertext, "$H$", 3) != 0)
+				return 0;
+		for (i = 3; i < 34; ++i)
+				if (atoi64[ARCH_INDEX(ciphertext[i])] == 0x7F)
+						return 0;
+
+		count_log2 = atoi64[ARCH_INDEX(ciphertext[3])];
+		if (count_log2 < 7 || count_log2 > 31)
+				return 0;
+
+		if (!pFmt_MD5_gen_17)
+			phpassmd5_init(pFmt);
+		return pFmt_MD5_gen_17->methods.valid(Convert(Conv_Buf, ciphertext), pFmt_MD5_gen_17);
+}
+
+static void * our_salt(char *ciphertext)
+{
+	return pFmt_MD5_gen_17->methods.salt(Convert(Conv_Buf, ciphertext));
+}
+static void * our_binary(char *ciphertext)
+{
+	return pFmt_MD5_gen_17->methods.binary(Convert(Conv_Buf, ciphertext));
+}
+
+struct fmt_main fmt_phpassmd5 =
+{
+	{
+		// setup the labeling and stuff. NOTE the max and min crypts are set to 1
+		// here, but will be reset within our init() function.
+		FORMAT_LABEL, FORMAT_NAME, ALGORITHM_NAME, BENCHMARK_COMMENT, BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH, BINARY_SIZE, SALT_SIZE+1, 1, 1, FMT_CASE | FMT_8_BIT, phpassmd5_tests
+	},
+	{
+		/*  All we setup here, is the pointer to valid, and the pointer to init */
+		/*  within the call to init, we will properly set this full object      */
+		phpassmd5_init,
+		fmt_default_prepare,
+		phpassmd5_valid
+	}
+};
+
+static void phpassmd5_init(struct fmt_main *pFmt)
+{
+	if (pFmt->private.initialized == 0) {
+		pFmt_MD5_gen_17 = md5_gen_THIN_FORMAT_LINK(&fmt_phpassmd5, Convert(Conv_Buf, phpassmd5_tests[0].ciphertext), "phpass");
+		fmt_phpassmd5.methods.salt   = our_salt;
+		fmt_phpassmd5.methods.binary = our_binary;
+		pFmt->private.initialized = 1;
+	}
+}
diff -rupN john-1.7.8/src/pixMD5_fmt_plug.c john-1.7.8-jumbo-2/src/pixMD5_fmt_plug.c
--- john-1.7.8/src/pixMD5_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/pixMD5_fmt_plug.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,284 @@
+/*
+ * This software is Copyright  2004 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5.h"
+
+#define FORMAT_LABEL			"pix-md5"
+#define FORMAT_NAME			"PIX MD5"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME			"pix-md5 MMX"
+#else
+#define ALGORITHM_NAME			"pix-md5 SSE2"
+#endif
+#else
+#define ALGORITHM_NAME			"pix-md5"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		16
+
+#define SALT_SIZE			0
+
+#ifdef MMX_COEF
+#define BINARY_SIZE			16
+#define MIN_KEYS_PER_CRYPT		MMX_COEF
+#define MAX_KEYS_PER_CRYPT		MMX_COEF
+#define GETPOS(i, index)		( (index)*4 + ((i) & (0xffffffff-3) )*MMX_COEF + ((i)&3) )
+#else
+#define BINARY_SIZE			(4 * sizeof(ARCH_WORD_32))
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+static struct fmt_tests pixmd5_tests[] = {
+	{"2KFQnbNIdI.2KYOU", "cisco"},
+	{"TRPEas6f/aa6JSPL", "test1"},
+	{"OMT6mXmAvGyzrCtp", "test2"},
+	{"gTC7RIy1XJzagmLm", "test3"},
+	{"oWC1WRwqlBlbpf/O", "test4"},
+	{"NuLKvvWGg.x9HEKO", "password"},
+	{"8Ry2YjIyt7RRXU24", ""},
+	{".7nfVBEIEu4KbF/1","0123456789abcdef"},        // added a exact 16 byte password, to make sure it works properly
+	{NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define saved_key pixMD5_saved_key
+#define crypt_key pixMD5_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) char saved_key[PLAINTEXT_LENGTH*MMX_COEF*2 + 1];
+__declspec(align(16)) char crypt_key[BINARY_SIZE*MMX_COEF];
+#else
+char saved_key[PLAINTEXT_LENGTH*MMX_COEF*2 + 1] __attribute__ ((aligned(16)));
+char crypt_key[BINARY_SIZE*MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+static unsigned long total_len;
+static unsigned char out[PLAINTEXT_LENGTH + 1];
+#else
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static MD5_CTX ctx;
+#endif
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	unsigned int i;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+
+	for (i = 0; i < CIPHERTEXT_LENGTH; i++)
+		if(atoi64[ARCH_INDEX(ciphertext[i])] == 0x7F)
+			return 0;
+	return 1;
+}
+
+static void pixmd5_init(struct fmt_main *pFmt)
+{
+#ifdef MMX_COEF
+	unsigned int i;
+
+	total_len = 0;
+	for(i=0;i<MMX_COEF;i++)
+		total_len += 16 << ( ( (32/MMX_COEF) * i ) );
+#endif
+}
+
+static void pixmd5_set_key(char *key, int index) {
+#ifdef MMX_COEF
+	int i;
+	if(index==0)
+        {
+		memset(saved_key, 0, sizeof(saved_key));
+        }
+
+	for(i=0;key[i];i++)
+		saved_key[GETPOS(i, index)] = key[i];
+	for(;i<16;i++)
+		saved_key[GETPOS(i, index)] = 0;
+
+	saved_key[GETPOS(i, index)] = 0x80;
+#else
+	strncpy(saved_key, key, 16);
+/* NUL padding is needed because pixmd5_crypt_all() passes 16 bytes of
+ * saved_key[] to MD5_Update() unconditionally. */
+#endif
+}
+
+static char *pixmd5_get_key(int index) {
+#ifdef MMX_COEF
+	unsigned int i,s;
+
+	s = (total_len >> (((32/MMX_COEF)*(index)))) & 0xff;
+	for(i=0;i<s;i++)
+		out[i] = saved_key[ GETPOS(i, index) ];
+	out[i] = 0;
+	return (char*)out;
+#else
+	saved_key[16] = 0;
+	return saved_key;
+#endif
+}
+
+#define MASK 0x00ffffff
+
+static int pixmd5_cmp_all(void *binary, int index) {
+#ifdef MMX_COEF
+	int i=0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != (((unsigned long *)crypt_key)[i*MMX_COEF] & MASK))
+			&& ( ((unsigned long *)binary)[i] != (((unsigned long *)crypt_key)[i*MMX_COEF+1] & MASK))
+#if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != (((unsigned long *)crypt_key)[i*MMX_COEF+2] & MASK))
+			&& ( ((unsigned long *)binary)[i] != (((unsigned long *)crypt_key)[i*MMX_COEF+3] & MASK))
+#endif
+		)
+			return 0;
+		i++;
+	}
+#else
+	if (((ARCH_WORD_32 *)binary)[1] != (ctx.b & MASK)) return 0;
+	if (((ARCH_WORD_32 *)binary)[2] != (ctx.c & MASK)) return 0;
+	if (((ARCH_WORD_32 *)binary)[3] != (ctx.d & MASK)) return 0;
+	if (((ARCH_WORD_32 *)binary)[0] != (ctx.a & MASK)) return 0;
+#endif
+	return 1;
+}
+
+static int pixmd5_cmp_exact(char *source, int count){
+  return (1);
+}
+
+#ifdef MMX_COEF
+static int pixmd5_cmp_one(void * binary, int index)
+{
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != (((unsigned long *)crypt_key)[i*MMX_COEF+index] & MASK ) )
+			return 0;
+	return 1;
+}
+#else
+#define pixmd5_cmp_one pixmd5_cmp_all
+#endif
+
+static void pixmd5_crypt_all(int count) {
+  // get plaintext input in saved_key put it into ciphertext crypt_key
+#ifdef MMX_COEF
+
+	mdfivemmx((unsigned char*)crypt_key, (unsigned char*)saved_key, total_len);
+#else
+	MD5_Init( &ctx );
+	MD5_Update( &ctx, saved_key, 16 );
+	MD5_PreFinal(&ctx);
+#endif
+}
+
+static void * pixmd5_binary(char *ciphertext)
+{
+	static ARCH_WORD_32 realcipher[4];
+	int i;
+
+	for(i = 0; i < 4; i++) {
+		realcipher[i] =
+			atoi64[ARCH_INDEX(ciphertext[i*4 + 0])] +
+			(atoi64[ARCH_INDEX(ciphertext[i*4 + 1])] << 6) +
+			(atoi64[ARCH_INDEX(ciphertext[i*4 + 2])] << 12) +
+			(atoi64[ARCH_INDEX(ciphertext[i*4 + 3])] << 18);
+	}
+	return (void *)realcipher;
+}
+
+static int get_hash1(int index)
+{
+#ifdef MMX_COEF
+	return (((unsigned char *)crypt_key)[index*4] & 0xf);
+#else
+	return ctx.a & 0xf;
+#endif
+}
+static int get_hash2(int index)
+{
+#ifdef MMX_COEF
+	return ((unsigned char *)crypt_key)[index*4];
+#else
+	return ctx.a & 0xff;
+#endif
+}
+static int get_hash3(int index)
+{
+#ifdef MMX_COEF
+	return ((ARCH_WORD_32 *)crypt_key)[index] & 0xfff;
+#else
+	return ctx.a & 0xfff;
+#endif
+}
+
+static int binary_hash1(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xf; }
+static int binary_hash2(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xff; }
+static int binary_hash3(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfff; }
+
+struct fmt_main fmt_pixMD5 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		16, /* not exactly PLAINTEXT_LENGTH, the code is dirty */
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		pixmd5_tests
+	}, {
+		pixmd5_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		pixmd5_binary,
+		fmt_default_salt,
+		{
+			binary_hash1,
+			binary_hash2,
+			binary_hash3,
+			NULL,
+			NULL
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		pixmd5_set_key,
+		pixmd5_get_key,
+		fmt_default_clear_keys,
+		pixmd5_crypt_all,
+		{
+			get_hash1,
+			get_hash2,
+			get_hash3,
+			NULL,
+			NULL
+		},
+		pixmd5_cmp_all,
+		pixmd5_cmp_one,
+		pixmd5_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/rar2john.c john-1.7.8-jumbo-2/src/rar2john.c
--- john-1.7.8/src/rar2john.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/rar2john.c	2011-07-02 22:17:15.000000000 +0200
@@ -0,0 +1,195 @@
+/* rar2john utility for RAR 3.x files, written in April of 2011 by Dhiru Kholia for GSoC.
+ * rar2john processes input RAR files into a format suitable for use with JtR.
+ *
+ * This software is Copyright  2011, Dhiru Kholia <dhiru.kholia at gmail.com>,
+ * and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted.
+ *
+ * Huge thanks to Marc Bevand <m.bevand (at) gmail.com> for releasing unrarhp
+ * (http://www.zorinaq.com/unrarhp/) and documenting the RAR encryption scheme.
+ * This patch is made possible by unrarhp's documentation.
+ *
+ * Usage:
+ *
+ * 1. Run rar2john on rar file(s) as "rar2john [rar files]".
+ *    Output is written to standard output.
+ * 2. Run JtR on the output generated by rar2john as "john [output file]".
+ *
+ * Output Line Format:
+ *
+ * For type = 0 for files encrypted with "rar -hp ..." option
+ * filename:$rar3$*type*hex(salt)*:hex(partial-file-contents)
+ *
+ * For type = 1 for files encrypted with "rar -p ..." option
+ * filename:$rar3$*type*hex(salt)*hex(crc):PACK_SIZE:UNP_SIZE:filename:file-offset-for-ciphertext-data
+ *
+ * Note that the PACK_SIZE can be huge which implies that it can't be
+ * stored in type 0's compact "rardump" format */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "stdint.h"
+#include <limits.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+
+#include "misc.h"
+#include "common.h"
+#include "arch.h"
+#include "params.h"
+#include "crc32.h"
+
+static void process_file(const char *filename)
+{
+	FILE *fp;
+	unsigned char marker_block[7];
+	unsigned char archive_header_block[13];
+	unsigned char file_header_block[40];
+	int i, count, type;
+
+	if (!(fp = fopen(filename, "rb"))) {
+		fprintf(stderr, "! %s : %s\n", filename, strerror(errno));
+		return;
+	}
+	/* marker block */
+	memset(marker_block, 0, 7);
+	count = fread(marker_block, 7, 1, fp);
+	assert(count == 1);
+	if (memcmp(marker_block, "\x52\x61\x72\x21\x1a\x07\x00", 7)) {
+		fprintf(stderr, "! %s : Not a RAR file\n", filename);
+		fclose(fp);
+		return;
+	}
+	/* archive header block */
+	count = fread(archive_header_block, 13, 1, fp);
+	assert(count == 1);
+	assert(archive_header_block[2] == 0x73);
+	/* find encryption mode used (called type in output line format) */
+	uint16_t archive_header_head_flags =
+	    archive_header_block[4] << 8 | archive_header_block[3];
+	if (archive_header_head_flags & 0x0080) {	/* file header block is encrypted */
+		type = 0;	/* RAR file was created using -hp flag */
+	} else
+		type = 1;
+	/* file header block */
+	count = fread(file_header_block, 32, 1, fp);
+	assert(count == 1);
+	if (type == 1)
+		assert(file_header_block[2] == 0x74);
+	uint16_t file_header_head_flags =
+	    file_header_block[4] << 8 | file_header_block[3];
+	/* if type = 1, check if encryption is being used? */
+	if (type == 1 && !(file_header_head_flags & 0x04)) {
+		fprintf(stderr, "! %s : RAR file is not encrypted\n",
+		    filename);
+		fclose(fp);
+		return;
+	}
+
+	/* process -hp mode files */
+	if (type == 0) {	/* use Marc's end-of-archive block decrypt trick */
+		printf("%s:$rar3$*%d*", filename, type);
+		fseek(fp, -24, SEEK_END);
+		unsigned char buf[24];
+		count = fread(buf, 24, 1, fp);
+		assert(count == 1);
+		for (i = 0; i < 8; i++) { /* salt */
+			printf("%c%c", itoa16[ARCH_INDEX(buf[i] >> 4)],
+			    itoa16[ARCH_INDEX(buf[i] & 0x0f)]);
+		}
+		printf("*");
+		for (i = 8; i < 24; i++) {  /* encrypted block with known plaintext */
+			printf("%c%c", itoa16[ARCH_INDEX(buf[i] >> 4)],
+			    itoa16[ARCH_INDEX(buf[i] & 0x0f)]);
+		}
+		printf("\n");
+	} else {    /* TODO: process -p mode files */
+		if (!(file_header_head_flags & 0x8000)) {
+			fprintf(stderr, "bailing out ...\n");
+			return;
+		}
+		uint16_t file_header_head_size =
+		    file_header_block[6] << 8 | file_header_block[5];
+		int file_header_pack_size;
+		memcpy(&file_header_pack_size, file_header_block + 7, 4);
+		int file_header_unp_size;
+		memcpy(&file_header_unp_size, file_header_block + 11, 4);
+		fprintf(stderr, "HEAD_SIZE : %d, PACK_SIZE : %d, UNP_SIZE : %d\n",
+		    file_header_head_size, file_header_pack_size,
+		    file_header_unp_size);
+
+		/* calculate EXT_TIME size */
+		int EXT_TIME_SIZE = file_header_head_size - 32;
+
+		char rejbuf[32];
+		if (file_header_head_flags & 0x100) {
+			fprintf(stderr, "! HIGH_PACK_SIZE present\n");
+			count = fread(rejbuf, 4, 1, fp);
+			assert(count == 1);
+			EXT_TIME_SIZE -= 4;
+		}
+		if (file_header_head_flags & 0x100) {
+			fprintf(stderr, "! HIGH_UNP_SIZE present\n");
+			count = fread(rejbuf, 4, 1, fp);
+			assert(count == 1);
+			EXT_TIME_SIZE -= 4;
+		}
+		/* file name processing */
+		uint16_t file_name_size =
+		    file_header_block[27] << 8 | file_header_block[26];
+		fprintf(stderr, "file name size : %d bytes\n", file_name_size);
+		unsigned char file_name[128];
+		count = fread(file_name, file_name_size, 1, fp);
+		assert(count == 1);
+		file_name[file_name_size] = 0;
+		fprintf(stderr, "file name : %s\n", file_name);
+		EXT_TIME_SIZE -= file_name_size;
+		/* SALT processing */
+		unsigned char SALT[8];
+		if (file_header_head_flags & 0x400) {
+			EXT_TIME_SIZE -= 8;
+			count = fread(SALT, 8, 1, fp);
+			assert(count == 1);
+		}
+		/* EXT_TIME processing */
+		if (file_header_head_flags & 0x1000) {
+			fprintf(stderr, "! EXT_TIME present with size %d\n",
+			    EXT_TIME_SIZE);
+			fread(rejbuf, EXT_TIME_SIZE, 1, fp);
+			assert(count == 1);
+		}
+		/* process encrypted data of size "file_header_pack_size" */
+		printf("%s:$rar3$*%d*", filename, type);
+		for (i = 0; i < 8; i++) { /* encode SALT */
+			printf("%c%c", itoa16[ARCH_INDEX(SALT[i] >> 4)],
+			    itoa16[ARCH_INDEX(SALT[i] & 0x0f)]);
+		}
+		printf("*");
+		unsigned char FILE_CRC[4];
+		memcpy(FILE_CRC, file_header_block + 16, 4);
+		for (i = 0; i < 4; i++) { /* encode FILE_CRC */
+			printf("%c%c", itoa16[ARCH_INDEX(FILE_CRC[i] >> 4)],
+			    itoa16[ARCH_INDEX(FILE_CRC[i] & 0x0f)]);
+		}
+		/* fp is at ciphertext location */
+		long pos = ftell(fp);
+		printf("*%d*%d*%s*%ld\n",file_header_pack_size, file_header_unp_size, filename, pos);
+	}
+	fclose(fp);
+}
+
+int rar2john(int argc, char **argv)
+{
+	int i;
+
+	if (argc < 2) {
+		puts("Usage: rar2john [rar files]");
+		return 0;
+	}
+	for (i = 1; i < argc; i++)
+		process_file(argv[i]);
+
+	return 0;
+}
diff -rupN john-1.7.8/src/rar_fmt.c john-1.7.8-jumbo-2/src/rar_fmt.c
--- john-1.7.8/src/rar_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/rar_fmt.c	2011-07-02 23:08:49.000000000 +0200
@@ -0,0 +1,306 @@
+/* RAR 3.x cracker patch for JtR. Hacked together during
+ * April of 2011 by Dhiru Kholia <dhiru.kholia at gmail.com> for GSoC.
+ *
+ * This software is Copyright  2011, Dhiru Kholia <dhiru.kholia at gmail.com>,
+ * and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted.
+ *
+ * This program uses code present in the public domain unrar utility written by
+ * Alexander Roshal (http://www.rarlab.com/rar/unrarsrc-4.0.7.tar.gz). Specifically,
+ * lines 240 to 274 from crypt.cpp are used.
+ *
+ * Huge thanks to Marc Bevand <m.bevand (at) gmail.com> for releasing unrarhp
+ * (http://www.zorinaq.com/unrarhp/) and documenting the RAR encryption scheme.
+ * This patch is made possible by unrarhp's documentation.
+ *
+ * http://anrieff.net/ucbench/technical_qna.html is another useful reference
+ * for RAR encryption scheme.
+ *
+ * rar -p mode support is based on rar's technote.txt documentation and is
+ * currently incomplete. */
+
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+#include "arch.h"
+#include "crc32.h"
+#include "misc.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+#include <openssl/aes.h>
+#include <openssl/sha.h>
+#include <openssl/ssl.h>
+
+#define FORMAT_LABEL        "rar"
+#define FORMAT_NAME         "rar"
+#define ALGORITHM_NAME      "32/" ARCH_BITS_STR
+#define BENCHMARK_COMMENT   ""
+#define BENCHMARK_LENGTH    -1
+#define PLAINTEXT_LENGTH    32
+#define BINARY_SIZE         2
+#define SALT_SIZE           512
+#define MIN_KEYS_PER_CRYPT  1
+#define MAX_KEYS_PER_CRYPT  1
+#if ARCH_LITTLE_ENDIAN
+#define BYTESWAP32(n) ( \
+	(((n)&0x000000ff) << 24) | \
+	(((n)&0x0000ff00) << 8 ) | \
+	(((n)&0x00ff0000) >> 8 ) | \
+	(((n)&0xff000000) >> 24) )
+#else
+#define BYTESWAP32(n) (n)
+#endif
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static int has_been_cracked = 0;
+static unsigned char saved_salt[8];
+static unsigned char saved_ct[16];
+static int type;  /* type of rar file */
+
+/* for rar -p mode */
+static unsigned FILE_CRC[4];
+static int PACK_SIZE;
+static int UNP_SIZE;
+static unsigned char *ciphertext;
+static unsigned char *plaintext;
+
+static struct fmt_tests rar_tests[] = {
+	{"$rar3$*0*c9dea41b149b53b4*fcbdb66122d8ebdb32532c22ca7ab9ec*24",
+	    "password"},
+	{NULL}
+};
+
+static void init(struct fmt_main *pFmt)
+{
+	/* OpenSSL init, cleanup part is left to OS */
+	SSL_load_error_strings();
+	SSL_library_init();
+	OpenSSL_add_all_algorithms();
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	return !strncmp(ciphertext, "$rar3$*", 7);
+}
+
+static void *get_salt(char *ciphertext)
+{
+	return ciphertext;
+}
+
+static void set_salt(void *salt)
+{
+	int i, count;
+	/* extract data from "salt" */
+	char *saltcopy = strdup(salt);
+	saltcopy += 7;		/* skip over "$rar3$*" */
+	type = atoi(strtok(saltcopy, "*"));
+	char *encoded_salt = strtok(NULL, "*");
+	for (i = 0; i < 8; i++)
+		saved_salt[i] = atoi16[ARCH_INDEX(encoded_salt[i * 2])] * 16
+		    + atoi16[ARCH_INDEX(encoded_salt[i * 2 + 1])];
+	if (type == 0) {	/* rar-hp mode */
+		char *encoded_ct = strtok(NULL, "*");
+		for (i = 0; i < 16; i++)
+			saved_ct[i] = atoi16[ARCH_INDEX(encoded_ct[i * 2])]
+			    * 16 + atoi16[ARCH_INDEX(encoded_ct[i * 2 + 1])];
+	} else {
+		char *p = strtok(NULL, "*");
+		for (i = 0; i < 4; i++)
+			FILE_CRC[i] = atoi16[ARCH_INDEX(p[i * 2])] * 16 +
+			    atoi16[ARCH_INDEX(p[i * 2 + 1])];
+		PACK_SIZE = atoi(strtok(NULL, "*"));
+		UNP_SIZE = atoi(strtok(NULL, "*"));
+		char *filename = strtok(NULL, "*");
+		long pos = atol(strtok(NULL, "*"));
+		/* load ciphertext */
+		FILE *fp;
+		if (!(fp = fopen(filename, "rb"))) {
+			fprintf(stderr, "! %s : %s\n", filename,
+			    strerror(errno));
+			error();
+		}
+		fseek(fp, pos, SEEK_SET);
+		ciphertext = (unsigned char *) malloc(PACK_SIZE);
+		plaintext = (unsigned char *) malloc(PACK_SIZE);
+		count = fread(ciphertext, 1, PACK_SIZE, fp);
+		assert(count == PACK_SIZE);
+		fclose(fp);
+	}
+	has_been_cracked = 0;
+}
+
+/* could be DES set_key of old OpenSSL, which isn't what we mean */
+#undef set_key
+
+static void set_key(char *key, int index)
+{
+	int saved_key_length = strlen(key);
+	if (saved_key_length > PLAINTEXT_LENGTH)
+		saved_key_length = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, saved_key_length);
+	saved_key[saved_key_length] = 0;
+}
+
+static char *get_key(int index)
+{
+	return saved_key;
+}
+
+static void crypt_all(int count)
+{
+	int i = 0, j = 0;
+
+	/* UCS-2 encode the password */
+	char encoded_key[2 * PLAINTEXT_LENGTH];
+	memset(encoded_key, 0, 2 * PLAINTEXT_LENGTH);
+	for (i = 0; i < strlen(saved_key); i++) {
+		encoded_key[j] = saved_key[i];
+		j += 2;
+	}
+
+	/* derive IV and key for AES from saved_key and saved_salt,
+	 * this code block is based on unrarhp's and unrar's sources */
+	int plen = 2 * strlen(saved_key);
+	unsigned char RawPsw[plen + 8];
+	unsigned char aes_key[16];
+	unsigned char aes_iv[16];
+	int RawLength = plen + 8;
+	SHA_CTX ctx;
+	memcpy(RawPsw, encoded_key, plen);
+	memcpy(RawPsw + plen, saved_salt, 8);
+	SHA1_Init(&ctx);
+	const int HashRounds = 0x40000;
+	for (i = 0; i < HashRounds; i++) {
+		SHA1_Update(&ctx, RawPsw, RawLength);
+		unsigned char PswNum[3];
+		PswNum[0] = (unsigned char) i;
+		PswNum[1] = (unsigned char) (i >> 8);
+		PswNum[2] = (unsigned char) (i >> 16);
+		SHA1_Update(&ctx, PswNum, 3);
+		if (i % (HashRounds / 16) == 0) {
+			SHA_CTX tempctx = ctx;
+			unsigned int digest[5];
+			SHA1_Final((unsigned char *) digest, &tempctx);
+			for (j = 0; j < 5; j++)  /* reverse byte order */
+				digest[j] = BYTESWAP32(digest[j]);
+			aes_iv[i / (HashRounds / 16)] =
+			    (unsigned char) digest[4];
+		}
+	}
+	unsigned int digest[5];
+	SHA1_Final((unsigned char *) digest, &ctx);
+	for (j = 0; j < 5; j++)	/* reverse byte order */
+		digest[j] = BYTESWAP32(digest[j]);
+	for (i = 0; i < 4; i++)
+		for (j = 0; j < 4; j++)
+			aes_key[i * 4 + j] =
+			    (unsigned char) (digest[i] >> (j * 8));
+
+	if (type == 0) {	/* use Marc's method for -hp mode */
+		char ct[16];
+		memcpy(ct, saved_ct, 16);
+		/* AES decrypt, uses aes_iv, aes_key and saved_ct */
+		AES_KEY key;
+		unsigned char output[16];
+		AES_set_decrypt_key((unsigned char *) aes_key, 16 * 8, &key);	/* AES-128 */
+		AES_cbc_encrypt((unsigned char *) ct, output, 16, &key,
+		    (unsigned char *) aes_iv, AES_DECRYPT);
+		if (!memcmp(output, "\xc4\x3d\x7b\x00\x40\x07\x00", 7))
+			has_been_cracked = 1;
+	} else {
+		/* use full decryption with CRC check */
+		AES_KEY key;
+		AES_set_decrypt_key((unsigned char *) aes_key, 16 * 8, &key);
+		AES_cbc_encrypt((unsigned char *) ciphertext, plaintext,
+		    PACK_SIZE, &key, (unsigned char *) aes_iv, AES_DECRYPT);
+
+		/* The code above works fine. I did a manual compressed plaintext attack
+		 * with the correct password */
+
+		/* TODO: use unrar's decompression engine (written in C++), this is
+		 * needed to compute CRC and compare it with stored CRC (FILE_CRC). */
+
+		/* TODO: decompress compressed plaintext block using unrar's sources
+		 *
+		 * Can we avoid writing a full blown rar decompressor by writing some
+		 * sort of probabilistic attacker with some heuristics (correct
+		 * compressed stream tends to have trailing zeroes)?
+		 * Can we detect some fixed strings / structures within the recovered
+		 * compressed stream? Does RAR internally use a HMAC (undocumented)? */
+
+		/* compute CRC of the decompressed plaintext block
+		   CRC32_t crc;
+		   CRC32_Init(&crc);
+		   CRC32_Update(&crc, plaintext, UNP_SIZE);
+		   unsigned char crc_out[4];
+		   CRC32_Final(crc_out, crc);
+		   printf("saved key : %s, CRC : \n", saved_key);
+		   for (i = 0; i < 4; i++) {
+		   printf("%02x ", crc_out[i]);
+		   }
+		   printf("\n"); */
+
+		/* TODO: compare computed CRC with stored CRC (FILE_CRC) */
+
+		/* warn about missing -p mode support */
+		fprintf(stderr, "RAR -p mode support is not complete yet!\n");
+		// error();
+	}
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return has_been_cracked;
+}
+
+static int cmp_one(void *binary, int index)
+{
+	return 1;
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main rar_fmt = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		rar_tests
+	}, {
+		init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		fmt_default_binary,
+		get_salt,
+		{
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			fmt_default_get_hash
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/rawMD4_fmt_plug.c john-1.7.8-jumbo-2/src/rawMD4_fmt_plug.c
--- john-1.7.8/src/rawMD4_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/rawMD4_fmt_plug.c	2011-05-22 01:36:41.000000000 +0200
@@ -0,0 +1,215 @@
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 2010 by Solar Designer
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+#include "md4.h"
+
+#define FORMAT_LABEL			"raw-md4"
+#define FORMAT_NAME			"Raw MD4"
+#define ALGORITHM_NAME			"32/" ARCH_BITS_STR
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		125
+#define CIPHERTEXT_LENGTH		32
+
+#define BINARY_SIZE			16
+#define SALT_SIZE			0
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests tests[] = {
+	{"8a9d093f14f8701df17732b2bb182c74", "password"},
+	{"$MD4$8a9d093f14f8701df17732b2bb182c74", "password"},
+	{NULL}
+};
+
+static int saved_key_length;
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static MD4_CTX ctx;
+static ARCH_WORD_32 crypt_out[4];
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *p, *q;
+
+	p = ciphertext;
+	if (!strncmp(p, "$MD4$", 5))
+		p += 5;
+
+	q = p;
+	while (atoi16[ARCH_INDEX(*q)] != 0x7F) {
+		if (*q >= 'A' && *q <= 'F') /* support lowercase only */
+			return 0;
+		q++;
+	}
+	return !*q && q - p == CIPHERTEXT_LENGTH;
+}
+
+static char *split(char *ciphertext, int index)
+{
+	static char out[5 + CIPHERTEXT_LENGTH + 1];
+
+	if (!strncmp(ciphertext, "$MD4$", 5))
+		return ciphertext;
+
+	memcpy(out, "$MD4$", 5);
+	memcpy(out + 5, ciphertext, CIPHERTEXT_LENGTH + 1);
+	return out;
+}
+
+static void *get_binary(char *ciphertext)
+{
+	static unsigned char *out;
+	char *p;
+	int i;
+
+	if (!out) out = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	p = ciphertext + 5;
+	for (i = 0; i < BINARY_SIZE; i++) {
+		out[i] =
+		    (atoi16[ARCH_INDEX(*p)] << 4) |
+		    atoi16[ARCH_INDEX(p[1])];
+		p += 2;
+	}
+
+	return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return crypt_out[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return crypt_out[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return crypt_out[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return crypt_out[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return crypt_out[0] & 0xFFFFF;
+}
+
+static void set_key(char *key, int index)
+{
+	saved_key_length = strlen(key);
+	if (saved_key_length > PLAINTEXT_LENGTH)
+		saved_key_length = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, saved_key_length);
+}
+
+static char *get_key(int index)
+{
+	saved_key[saved_key_length] = 0;
+	return saved_key;
+}
+
+static void crypt_all(int count)
+{
+	MD4_Init(&ctx);
+	MD4_Update(&ctx, saved_key, saved_key_length);
+	MD4_Final((unsigned char *)crypt_out, &ctx);
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return !memcmp(binary, crypt_out, BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_rawMD4 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		split,
+		get_binary,
+		fmt_default_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_all,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/rawMD5go_fmt_plug.c john-1.7.8-jumbo-2/src/rawMD5go_fmt_plug.c
--- john-1.7.8/src/rawMD5go_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/rawMD5go_fmt_plug.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,111 @@
+/*
+ * This software is Copyright  2004 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ *
+ * Minor changes by David Luyer <david at luyer.net> to
+ * use a modified (faster) version of Solar Designer's
+ * md5 implementation.
+ *
+ * More improvement by
+ * Balzs Bucsay - earthquake at rycon.hu - http://www.rycon.hu/
+ * (2times faster, but it's only works up to 54characters)
+ *
+ * Finally, support for SSE intrinsics
+ *
+  * This format is now 'thin', and links to md5_gen(0) format.
+  * JimF, March, 2011
+ *
+ */
+
+#include <string.h>
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5_gen.h"
+
+#define FORMAT_LABEL			"raw-md5"
+#define FORMAT_NAME			"Raw MD5"
+#define ALGORITHM_NAME			"gen"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		48
+#define CIPHERTEXT_LENGTH		32
+#define BINARY_SIZE				16
+#define SALT_SIZE				0
+
+static struct fmt_tests rawmd5_tests[] = {
+	{"5a105e8b9d40e1329780d62ea2265d8a", "test1"},
+	{"ad0234829205b9033196ba818f7a872b", "test2"},
+	{"8ad8757baa8564dc136c1e07507f4a98", "test3"},
+	{"86985e105f79b95d6bc918fb45ec7727", "test4"},
+	{"378e2c4a07968da2eca692320136433d", "thatsworking"},
+	{"8db219468effb0a1b8a420602ff5621d", "BathanBathan"},
+	{"5c3d7e2282483ac33fa27ec21842a5a5", "waleedabdullah"},
+	{"d41d8cd98f00b204e9800998ecf8427e", ""},
+	{NULL}
+};
+
+static char Conv_Buf[80];
+static struct fmt_main *pFmt_MD5_gen_0;
+static void rawmd5_init(struct fmt_main *pFmt);
+
+/* this function converts a 'native' raw md5 signature string into a md5_gen(0) syntax string */
+static char *Convert(char *Buf, char *ciphertext)
+{
+	if (strlen(ciphertext)!=32)
+		return "*";
+	sprintf(Buf, "md5_gen(0)%s", ciphertext);
+	return Buf;
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH) return 0;
+	for (i = 0; i < CIPHERTEXT_LENGTH; i++){
+		if (!(  (('0' <= ciphertext[i])&&(ciphertext[i] <= '9')) ||
+					(('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))  ))
+			return 0;
+	}
+	if (!pFmt_MD5_gen_0)
+		rawmd5_init(pFmt);
+	return pFmt_MD5_gen_0->methods.valid(Convert(Conv_Buf, ciphertext), pFmt_MD5_gen_0);
+}
+
+static void * our_salt(char *ciphertext)
+{
+	return pFmt_MD5_gen_0->methods.salt(Convert(Conv_Buf, ciphertext));
+}
+static void * our_binary(char *ciphertext)
+{
+	return pFmt_MD5_gen_0->methods.binary(Convert(Conv_Buf, ciphertext));
+}
+
+struct fmt_main fmt_rawMD5go =
+{
+	{
+		// setup the labeling and stuff. NOTE the max and min crypts are set to 1
+		// here, but will be reset within our init() function.
+		FORMAT_LABEL, FORMAT_NAME, ALGORITHM_NAME, BENCHMARK_COMMENT, BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH, BINARY_SIZE, SALT_SIZE, 1, 1, FMT_CASE | FMT_8_BIT, rawmd5_tests
+	}, {
+		/*  All we setup here, is the pointer to valid, and the pointer to init */
+		/*  within the call to init, we will properly set this full object      */
+		rawmd5_init,
+		fmt_default_prepare,
+		valid
+	}
+};
+
+static void rawmd5_init(struct fmt_main *pFmt)
+{
+	if (pFmt->private.initialized == 0) {
+		pFmt_MD5_gen_0 = md5_gen_THIN_FORMAT_LINK(&fmt_rawMD5go, Convert(Conv_Buf, rawmd5_tests[0].ciphertext), "raw-md5");
+		fmt_rawMD5go.methods.binary = our_binary;
+		fmt_rawMD5go.methods.salt = our_salt;
+		pFmt->private.initialized = 1;
+	}
+}
diff -rupN john-1.7.8/src/rawMD5unicode_fmt_plug.c john-1.7.8-jumbo-2/src/rawMD5unicode_fmt_plug.c
--- john-1.7.8/src/rawMD5unicode_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/rawMD5unicode_fmt_plug.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,521 @@
+/*
+ * This is a copy of the old "thick" raw-md5 format, modified for hashes made
+ * from UTF-16 plaintexts. It is also supporting the --utf8 flag, making
+ * it convert from UTF-8 instead of the default, ISO-8859-1. My changes are
+ * released under the same terms as stated below.
+ * This will be replaced by a "thin" md5_gen format as soon as md5_gen supports
+ * md5(unicode($p)).
+ * magnum, 2011
+ *
+ * This software is Copyright  2004 bartavelle, <bartavelle at bandecon.com>,
+ * and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * Minor changes by David Luyer <david at luyer.net> to
+ * use a modified (faster) version of Solar Designer's
+ * md5 implementation.
+ *
+ * More improvement by
+ * Balzs Bucsay - earthquake at rycon.hu - http://www.rycon.hu/
+ * (2times faster, but it's only works up to 54characters)
+ *
+ * Added in SSE2 (and MMX) support from md5-mmx.S by
+ * Jim Fougeron - jfoug at cox dot net
+ * (1.5 to 3.5x faster, depending upon core type).
+ * Done in blocks of 64 hashs per 'run' (to avoid
+ * fseek() slowdown issues in wordlist.c code
+ *
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "options.h"
+#include "unicode.h"
+
+#ifdef MMX_COEF
+#include "md5.h"
+#else
+#if ARCH_LITTLE_ENDIAN
+#define MD5_out MD5_out_eq
+#else
+#define MD5_out MD5_bitswapped_out_eq
+#endif
+typedef unsigned int MD5_u32plus;
+extern void MD5_Go_eq(unsigned char *data, unsigned int len, int index);
+extern void MD5_Go2_eq(unsigned char *data, unsigned int len, int index);
+#endif
+
+#define FORMAT_LABEL		"raw-md5-unicode"
+#define FORMAT_NAME			"Raw MD5 of Unicode plaintext"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME		"raw-md5-unicode MMX 32x2"
+#else
+#define ALGORITHM_NAME		"raw-md5-unicode SSE2 16x4"
+#endif
+#else
+#define ALGORITHM_NAME		"raw-md5-unicode 64x1"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT	MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		-1
+
+#ifdef MMX_COEF
+#define PLAINTEXT_LENGTH		54 // octets, not characters
+#else
+#define PLAINTEXT_LENGTH		54
+#endif
+#define CIPHERTEXT_LENGTH		32
+
+#define BINARY_SIZE				16
+#define SALT_SIZE				0
+
+#ifdef MMX_COEF
+#if MMX_COEF==2
+#define BLOCK_LOOPS 32
+#else
+#define BLOCK_LOOPS 16
+#endif
+#define MIN_KEYS_PER_CRYPT	MMX_COEF*BLOCK_LOOPS
+#define MAX_KEYS_PER_CRYPT	MMX_COEF*BLOCK_LOOPS
+#define GETPOS(i, index)		( (index)*4 + ((i) & (0xffffffff-3) )*MMX_COEF + ((i)&3) )
+#else
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	64
+extern ARCH_WORD_32 MD5_out[MAX_KEYS_PER_CRYPT];
+extern char MD5_tmp[MAX_KEYS_PER_CRYPT][CIPHERTEXT_LENGTH + 1];
+#endif
+
+/* Note some plaintexts will be replaced in init() if running UTF-8 */
+static struct fmt_tests rawmd5_tests[] = {
+	{"16c47151c18ac087cd12b3a70746c790", "test1"},
+	{"ea7ab2b5c07650badab30790d0c9b63e", "\xFC"},	// German u-umlaut in iso-8859-1
+	{"f0a0b9f1dea0e458cec9a284ff434d44", "\xFC\xFC"},
+	{"d25a0b436b768777cc9a343d283dbf5a", "\xFC\xFC\xFC"},
+	{"719917322bf12168f8c55939e4fec8de", "\xFC\xFC\xFC\xFC"},
+	{"d41d8cd98f00b204e9800998ecf8427e", ""},
+	{"9c3abef89ff76f8acd80eae37b35f64f", "test2"},
+	{"849ee1b88b5d887bdb058180a666b450", "test3"},
+	{"8c4cb7e8b33b56a833cdaa8673f3b425", "test4"},
+	{"537e738b1ac5551f65106368dc301ece", "thatsworking"},
+	{NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define saved_key rawMD5unicode_saved_key
+#define crypt_key rawMD5unicode_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) unsigned char saved_key[BLOCK_LOOPS][64*MMX_COEF];
+__declspec(align(16)) unsigned char crypt_key[BLOCK_LOOPS][BINARY_SIZE*MMX_COEF];
+#else
+unsigned char saved_key[BLOCK_LOOPS][64 * MMX_COEF] __attribute__ ((aligned(16)));
+unsigned char crypt_key[BLOCK_LOOPS][BINARY_SIZE * MMX_COEF] __attribute__ ((aligned(16)));
+#endif
+static unsigned long total_len[BLOCK_LOOPS];
+#else
+static unsigned char saved_key[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1 + 128 /* MD5 scratch space */ ];
+static unsigned int saved_key_len[MAX_KEYS_PER_CRYPT];
+#endif
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+	for (i = 0; i < CIPHERTEXT_LENGTH; i++) {
+		if (!((('0' <= ciphertext[i]) && (ciphertext[i] <= '9')) ||
+			(('a' <= ciphertext[i]) && (ciphertext[i] <= 'f'))))
+			return 0;
+	}
+	return 1;
+}
+
+static void rawmd5_set_key_utf8(char *_key, int index);
+extern struct fmt_main fmt_rawMD5unicode;
+
+static void rawmd5_init(struct fmt_main *pFmt)
+{
+	if (options.flags & FLG_UTF8) {
+		fmt_rawMD5unicode.methods.set_key = rawmd5_set_key_utf8;
+		// We may need three bytes of input to produce two bytes of key
+		fmt_rawMD5unicode.params.plaintext_length = PLAINTEXT_LENGTH / 2 * 3;
+		rawmd5_tests[1].ciphertext = "94a4e171de16580742c4d141e6607bf7";
+		rawmd5_tests[1].plaintext = "\xE2\x82\xAC";	// Euro sign
+		rawmd5_tests[2].ciphertext = "03c60810f0e54d16e826aca385d776c8";
+		rawmd5_tests[2].plaintext = "\xE2\x82\xAC\xE2\x82\xAC";	// 2 x euro
+		rawmd5_tests[3].ciphertext = "2d554433d7cde7ec8d16aaf126c3be6b";
+		rawmd5_tests[3].plaintext = "\xE2\x82\xAC\xC3\xBC";	// euro and u-umlaut
+		rawmd5_tests[4].ciphertext = "8007d9070b27db7b30433df2cd10abc1";
+		rawmd5_tests[4].plaintext = "\xC3\xBC\xE2\x82\xAC";	// u-umlaut and euro
+	} else {
+		// We *will* produce a key twice as large as input (in octets)
+		fmt_rawMD5unicode.params.plaintext_length = PLAINTEXT_LENGTH >> 1;
+	}
+}
+
+static void rawmd5_set_key(char *_key, int index)
+{
+	unsigned char *key = (unsigned char *) _key;
+	unsigned int i, outlen;
+#ifdef MMX_COEF
+	unsigned int idx;
+#endif
+
+	outlen = 2 * strlen(_key);
+	if (outlen > PLAINTEXT_LENGTH)
+		outlen = PLAINTEXT_LENGTH;
+#ifdef MMX_COEF
+	idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	if (index == 0) {
+		memset(saved_key, 0, sizeof(saved_key));
+		memset(total_len, 0, sizeof(total_len));
+	}
+	for (i = 0; i < outlen; i += 2)
+		saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))] = key[i >> 1];
+	saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))] = 0x80;
+	total_len[idx] +=
+	    (outlen << (((32 / MMX_COEF) * (index & (MMX_COEF - 1)))));
+#else
+	saved_key_len[index] = outlen;
+	for (i = 0; i < outlen; i += 2) {
+		saved_key[index][i] = key[i >> 1];
+		saved_key[index][i + 1] = 0;
+	}
+#endif
+}
+
+static void rawmd5_set_key_utf8(char *_key, int index)
+{
+	int utf8len = strlen(_key);
+	unsigned char *key = (unsigned char *) _key;
+	UTF16 utf16key[PLAINTEXT_LENGTH + 1];
+	int outlen;
+	int i;
+#ifdef MMX_COEF
+	unsigned int idx;
+#endif
+
+	outlen =
+	    utf8towcs(utf16key, PLAINTEXT_LENGTH >> 1, key,
+	    utf8len) * sizeof(UTF16);
+	if (outlen <= 0) {
+		utf8len = -outlen;
+		if (outlen != 0)
+			outlen = strlen16(utf16key) * sizeof(UTF16);
+	}
+#ifdef MMX_COEF
+	idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	if (index == 0) {
+		memset(saved_key, 0, sizeof(saved_key));
+		memset(total_len, 0, sizeof(total_len));
+	}
+	for (i = 0; i < outlen; i += 2) {
+		saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))] =
+		    (char) utf16key[i >> 1];
+		saved_key[idx][GETPOS(i + 1, index & (MMX_COEF - 1))] =
+		    (char) (utf16key[i >> 1] >> 8);
+	}
+	saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))] = 0x80;
+	total_len[idx] +=
+	    (outlen << (((32 / MMX_COEF) * (index & (MMX_COEF - 1)))));
+#else
+	for (i = 0; i < outlen; i += 2) {
+#if ARCH_LITTLE_ENDIAN
+		saved_key[index][i] = (char) utf16key[i >> 1];
+		saved_key[index][i + 1] = (char) (utf16key[i >> 1] >> 8);
+#else
+		saved_key[index][i + 1] = (char) utf16key[i >> 1];
+		saved_key[index][i] = (char) (utf16key[i >> 1] >> 8);
+#endif
+	}
+	saved_key_len[index] = outlen;
+#endif
+}
+
+static char *rawmd5_get_key(int index)
+{
+	unsigned int i;
+	int outlen = 0;
+#ifdef MMX_COEF
+	unsigned int idx;
+	idx = (((unsigned) index) >> (MMX_COEF >> 1));
+#endif
+	if (options.flags & FLG_UTF8) {
+		static UTF16 key[PLAINTEXT_LENGTH / 2 + 1];
+#ifdef MMX_COEF
+		for (i = 0; saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))] != 0x80; i += 2)
+			key[outlen++] = saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))] |
+				saved_key[idx][GETPOS(i + 1, index & (MMX_COEF - 1))] << 8;
+#else
+		for (i = 0; i < saved_key_len[index]; i += 2) {
+			key[outlen++] = saved_key[index][i] |
+				saved_key[index][i + 1] << 8;
+		}
+#endif
+		key[outlen] = 0;
+		return (char *)utf16toutf8(key);
+	} else {
+		static unsigned char key[PLAINTEXT_LENGTH + 1];
+#ifdef MMX_COEF
+		for (i = 0; saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))] != 0x80; i += 2)
+			key[outlen++] = saved_key[idx][GETPOS(i, index & (MMX_COEF - 1))];
+#else
+		for (i = 0; i < saved_key_len[index]; i += 2) {
+			key[outlen++] = saved_key[index][i];
+		}
+#endif
+		key[outlen] = 0;
+		return (char *)key;
+	}
+}
+
+static int rawmd5_cmp_all(void *binary, int count)
+{
+#ifdef MMX_COEF
+	unsigned int i, j;
+	unsigned int cnt =
+	    (((unsigned) count + MMX_COEF - 1) >> (MMX_COEF >> 1));
+	for (j = 0; j < cnt; ++j) {
+		int SomethingGood = 1;
+		i = 0;
+		while (i < (BINARY_SIZE / 4)) {
+			if ((((unsigned long *) binary)[i] !=
+				((unsigned long *) &(crypt_key[j]))[i *
+				    MMX_COEF])
+			    && (((unsigned long *) binary)[i] !=
+				((unsigned long *) &(crypt_key[j]))[i *
+				    MMX_COEF + 1])
+#if (MMX_COEF > 3)
+			    && (((unsigned long *) binary)[i] !=
+				((unsigned long *) &(crypt_key[j]))[i *
+				    MMX_COEF + 2])
+			    && (((unsigned long *) binary)[i] !=
+				((unsigned long *) &(crypt_key[j]))[i *
+				    MMX_COEF + 3])
+#endif
+			    ) {
+				SomethingGood = 0;
+				break;
+			}
+			++i;
+		}
+		if (SomethingGood)
+			return 1;
+	}
+	return 0;
+#else
+	unsigned int i;
+
+	for (i = 0; i < count; i++) {
+		if (!(*((unsigned int *) binary) -
+			*((unsigned int *) &MD5_out[i])))
+			return 1;
+	}
+
+	return 0;
+#endif
+}
+
+static int rawmd5_cmp_one(void *binary, int index)
+{
+#ifdef MMX_COEF
+	unsigned int idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	return ((((ARCH_WORD_32 *) binary)[0] ==
+		((ARCH_WORD_32 *) & (crypt_key[idx]))[0 * MMX_COEF +
+		    (index & (MMX_COEF - 1))]) &&
+	    (((ARCH_WORD_32 *) binary)[1] ==
+		((ARCH_WORD_32 *) & (crypt_key[idx]))[1 * MMX_COEF +
+		    (index & (MMX_COEF - 1))])
+#if (MMX_COEF > 3)
+	    &&
+	    (((ARCH_WORD_32 *) binary)[2] ==
+		((ARCH_WORD_32 *) & (crypt_key[idx]))[2 * MMX_COEF +
+		    (index & (MMX_COEF - 1))]) &&
+	    (((ARCH_WORD_32 *) binary)[3] ==
+		((ARCH_WORD_32 *) & (crypt_key[idx]))[3 * MMX_COEF +
+		    (index & (MMX_COEF - 1))])
+#endif
+	    );
+#else
+	return (!(*((unsigned int *) binary) - (unsigned int) MD5_out[index]));
+#endif
+}
+
+static int rawmd5_cmp_exact(char *source, int index)
+{
+#ifdef MMX_COEF
+	return 1;
+#else
+	MD5_Go2_eq((unsigned char *) saved_key[index], saved_key_len[index],
+	    index);
+	return !memcmp(source, MD5_tmp[index], CIPHERTEXT_LENGTH);
+#endif
+}
+
+static void rawmd5_crypt_all(int count)
+{
+	// get plaintext input in saved_key put it into ciphertext crypt_key
+#ifdef MMX_COEF
+	unsigned int cnt =
+	    (((unsigned) count + MMX_COEF - 1) >> (MMX_COEF >> 1));
+	unsigned i;
+	for (i = 0; i < cnt; ++i)
+		mdfivemmx((unsigned char *) &(crypt_key[i]),
+		    (unsigned char *) &(saved_key[i]), total_len[i]);
+#else
+	unsigned int i;
+
+	for (i = 0; i < count; i++)
+		MD5_Go_eq((unsigned char *) saved_key[i], saved_key_len[i], i);
+#endif
+}
+
+static int rawmd5_binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *) binary)[0] & 0xf;
+}
+
+static int rawmd5_binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *) binary)[0] & 0xff;
+}
+
+static int rawmd5_binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *) binary)[0] & 0xfff;
+}
+
+static int rawmd5_binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *) binary)[0] & 0xffff;
+}
+
+static int rawmd5_binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *) binary)[0] & 0xfffff;
+}
+
+static int rawmd5_get_hash_0(int index)
+{
+#ifdef MMX_COEF
+	unsigned int idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	return ((ARCH_WORD_32 *) & (crypt_key[idx]))[index & (MMX_COEF -
+		1)] & 0xf;
+#else
+	return MD5_out[index] & 0xF;
+#endif
+}
+
+static int rawmd5_get_hash_1(int index)
+{
+#ifdef MMX_COEF
+	unsigned int idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	return ((ARCH_WORD_32 *) & (crypt_key[idx]))[index & (MMX_COEF -
+		1)] & 0xff;
+#else
+	return MD5_out[index] & 0xFF;
+#endif
+}
+
+static int rawmd5_get_hash_2(int index)
+{
+#ifdef MMX_COEF
+	unsigned int idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	return ((ARCH_WORD_32 *) & (crypt_key[idx]))[index & (MMX_COEF -
+		1)] & 0xfff;
+#else
+	return MD5_out[index] & 0xFFF;
+#endif
+}
+
+static int rawmd5_get_hash_3(int index)
+{
+#ifdef MMX_COEF
+	unsigned int idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	return ((ARCH_WORD_32 *) & (crypt_key[idx]))[index & (MMX_COEF -
+		1)] & 0xffff;
+#else
+	return MD5_out[index] & 0xFFFF;
+#endif
+}
+
+static int rawmd5_get_hash_4(int index)
+{
+#ifdef MMX_COEF
+	unsigned int idx = (((unsigned) index) >> (MMX_COEF >> 1));
+	return ((ARCH_WORD_32 *) & (crypt_key[idx]))[index & (MMX_COEF -
+		1)] & 0xfffff;
+#else
+	return MD5_out[index] & 0xFFFFF;
+#endif
+}
+
+
+static void *rawmd5_binary(char *ciphertext)
+{
+	static char *realcipher;
+	int i;
+	if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	for (i = 0; i < BINARY_SIZE; i++) {
+		realcipher[i] =
+		    atoi16[ARCH_INDEX(ciphertext[i * 2])] * 16 +
+		    atoi16[ARCH_INDEX(ciphertext[i * 2 + 1])];
+	}
+	return (void *) realcipher;
+}
+
+struct fmt_main fmt_rawMD5unicode = {
+	{
+		    FORMAT_LABEL,
+		    FORMAT_NAME,
+		    ALGORITHM_NAME,
+		    BENCHMARK_COMMENT,
+		    BENCHMARK_LENGTH,
+		    PLAINTEXT_LENGTH,
+		    BINARY_SIZE,
+		    SALT_SIZE,
+		    MIN_KEYS_PER_CRYPT,
+		    MAX_KEYS_PER_CRYPT,
+		    FMT_CASE | FMT_8_BIT | FMT_UNICODE | FMT_UTF8,
+		    rawmd5_tests
+	}, {
+		    rawmd5_init,
+		    fmt_default_prepare,
+		    valid,
+		    fmt_default_split,
+		    rawmd5_binary,
+		    fmt_default_salt,
+		    {
+				rawmd5_binary_hash_0,
+				rawmd5_binary_hash_1,
+				rawmd5_binary_hash_2,
+				rawmd5_binary_hash_3,
+			rawmd5_binary_hash_4},
+		    fmt_default_salt_hash,
+		    fmt_default_set_salt,
+		    rawmd5_set_key,
+		    rawmd5_get_key,
+		    fmt_default_clear_keys,
+		    rawmd5_crypt_all,
+		    {
+				rawmd5_get_hash_0,
+				rawmd5_get_hash_1,
+				rawmd5_get_hash_2,
+				rawmd5_get_hash_3,
+			rawmd5_get_hash_4},
+		    rawmd5_cmp_all,
+		    rawmd5_cmp_one,
+	    rawmd5_cmp_exact}
+};
diff -rupN john-1.7.8/src/rawSHA1_fmt_plug.c john-1.7.8-jumbo-2/src/rawSHA1_fmt_plug.c
--- john-1.7.8/src/rawSHA1_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/rawSHA1_fmt_plug.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,359 @@
+/*
+ * Copyright (c) 2004 bartavelle
+ * bartavelle at bandecon.com
+ */
+
+#include <string.h>
+
+#include "arch.h"
+
+#ifdef SHA1_SSE_PARA
+#define MMX_COEF	4
+#include "sse-intrinsics.h"
+#define NBKEYS	(MMX_COEF * SHA1_SSE_PARA)
+#elif MMX_COEF
+#define NBKEYS	MMX_COEF
+#endif
+
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "sha.h"
+
+#define FORMAT_LABEL			"raw-sha1"
+#define FORMAT_NAME				"Raw SHA-1"
+#define ALGORITHM_NAME			"SHA-1"
+
+#ifdef SHA1_N_STR
+#define BENCHMARK_COMMENT		"(" SHA1_N_STR ")"
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		55
+#define CIPHERTEXT_LENGTH		40
+
+#define BINARY_SIZE				20
+#define SALT_SIZE				0
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		NBKEYS
+#define MAX_KEYS_PER_CRYPT		NBKEYS
+//#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + ((i)&3) ) //std getpos
+//#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) ) //for endianity conversion
+//#define GETPOS(i, index)		( (index&3)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) + (index>>2)*80*MMX_COEF*4 ) //for endianity conversion
+// this version works properly for MMX, SSE2 (.S) and SSE2 intrinsic.
+#define GETPOS(i, index)		( (index&(MMX_COEF-1))*4 + ((i)&(0xffffffff-3))*MMX_COEF + (3-((i)&3)) + (index>>(MMX_COEF>>1))*80*MMX_COEF*4 ) //for endianity conversion
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+static struct fmt_tests rawsha1_tests[] = {
+	{"c3e337f070b64a50e9d31ac3f9eda35120e29d6c", "digipalmw221u"},
+	{"2fbf0eba37de1d1d633bc1ed943b907f9b360d4c", "azertyuiop1"},
+	{"A9993E364706816ABA3E25717850C26C9CD0D89D", "abc"},
+	{"f879f8090e92232ed07092ebed6dc6170457a21d", "azertyuiop2"},
+	{"1813c12f25e64931f3833b26e999e26e81f9ad24", "azertyuiop3"},
+	{"095bec1163897ac86e393fa16d6ae2c2fce21602", "7850"},
+	{"dd3fbb0ba9e133c4fd84ed31ac2e5bc597d61774", "7858"},
+	{NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define saved_key rawSHA1_saved_key
+#define crypt_key rawSHA1_crypt_key
+#if defined (_MSC_VER)
+__declspec(align(16)) char saved_key[80*4*NBKEYS];
+__declspec(align(16)) char crypt_key[BINARY_SIZE*NBKEYS];
+#else
+char saved_key[80*4*NBKEYS] __attribute__ ((aligned(16)));
+char crypt_key[BINARY_SIZE*NBKEYS] __attribute__ ((aligned(16)));
+#endif
+static unsigned long total_len;
+static unsigned char out[PLAINTEXT_LENGTH + 1];
+#else
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static SHA_CTX ctx;
+#endif
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH) return 0;
+	for (i = 0; i < CIPHERTEXT_LENGTH; i++){
+		if (!(  (('0' <= ciphertext[i])&&(ciphertext[i] <= '9')) ||
+					(('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))
+					|| (('A' <= ciphertext[i])&&(ciphertext[i] <= 'F'))))
+			return 0;
+	}
+	return 1;
+}
+
+static void rawsha1_init(struct fmt_main *pFmt)
+{
+#ifdef MMX_COEF
+	memset(saved_key, 0, sizeof(saved_key));
+#endif
+}
+
+static void rawsha1_set_key(char *key, int index) {
+#ifdef MMX_COEF
+	int len;
+	int i;
+
+	if(index==0)
+	{
+		total_len = 0;
+		//memset(saved_key, 0, sizeof(saved_key));
+		i = 0;
+#ifdef SHA1_SSE_PARA
+		for (; i < SHA1_SSE_PARA; ++i)
+#endif
+			memset(&saved_key[i*4*80*MMX_COEF], 0, 56*MMX_COEF);
+	}
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+
+	for(i=0;i<len;i++)
+		saved_key[GETPOS(i, index)] = key[i];
+
+	saved_key[GETPOS(i, index)] = 0x80;
+#ifdef SHA1_SSE_PARA
+	((unsigned int *)saved_key)[15*MMX_COEF + (index&3) + (index>>2)*80*MMX_COEF] = i<<3;
+#else
+	total_len += len << ( ( (32/MMX_COEF) * index ) );
+#endif
+
+#else
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+#endif
+}
+
+static char *rawsha1_get_key(int index) {
+#ifdef MMX_COEF
+	unsigned int i,s;
+
+#ifdef SHA1_SSE_PARA
+	s = ((unsigned int *)saved_key)[15*MMX_COEF + (index&3) + (index>>2)*80*MMX_COEF] >> 3;
+#else
+	s = (total_len >> (((32/MMX_COEF)*(index)))) & 0xff;
+#endif
+	for(i=0;i<s;i++)
+		out[i] = saved_key[ GETPOS(i, index) ];
+	out[i] = 0;
+	return (char *) out;
+#else
+	return saved_key;
+#endif
+}
+
+static int rawsha1_cmp_all(void *binary, int count) {
+#ifdef MMX_COEF
+// NOTE the cmp_all and cmp_one can likely work fine, using just the PARA blocks.  however, the original code has been kept (for now)
+# ifdef SHA1_SSE_PARA
+	unsigned int x,y=0;
+
+#ifdef SHA1_SSE_PARA
+	for(;y<SHA1_SSE_PARA;y++)
+#endif
+	for(x=0;x<MMX_COEF;x++)
+	{
+		if( ((unsigned int *)binary)[0] == ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] )
+			return 1;
+	}
+	return 0;
+# else
+	int i=0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#   if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#   endif
+		)
+			return 0;
+		i++;
+	}
+	return 1;
+# endif
+#else
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int rawsha1_cmp_exact(char *source, int count){
+  return (1);
+}
+
+static int rawsha1_cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+# if SHA1_SSE_PARA
+	unsigned int x,y;
+	x = index&3;
+	y = index/4;
+
+	if( ((unsigned int *)binary)[0] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] )
+		return 0;
+	if( ((unsigned int *)binary)[1] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+4] )
+		return 0;
+	if( ((unsigned int *)binary)[2] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+8] )
+		return 0;
+	if( ((unsigned int *)binary)[3] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+12] )
+		return 0;
+	if( ((unsigned int *)binary)[4] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+16] )
+		return 0;
+	return 1;
+# else
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+# endif
+#else
+	return rawsha1_cmp_all(binary, index);
+#endif
+}
+
+static void rawsha1_crypt_all(int count) {
+  // get plaintext input in saved_key put it into ciphertext crypt_key
+#ifdef MMX_COEF
+
+# if SHA1_SSE_PARA
+	SSESHA1body(saved_key, (unsigned int *)crypt_key, 1);
+# else
+	shammx((unsigned char *) crypt_key, (unsigned char *) saved_key, total_len);
+# endif
+
+#else
+	SHA1_Init( &ctx );
+	SHA1_Update( &ctx, (unsigned char *) saved_key, strlen( saved_key ) );
+	SHA1_Final( (unsigned char *) crypt_key, &ctx);
+#endif
+
+}
+
+static void * rawsha1_binary(char *ciphertext)
+{
+	static unsigned char realcipher[BINARY_SIZE];
+	int i;
+
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		realcipher[i] = atoi16[ARCH_INDEX(ciphertext[i*2])]*16 + atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+	}
+// if we try to unify the rawsha1_cmp_one() and and rawsha1_cmp_all() functions, we should endian alter for all MMX_COEF.
+// Right now, for MMX/SSE non-para, we keep the older methods.
+#ifdef SHA1_SSE_PARA
+	alter_endianity(realcipher, BINARY_SIZE);
+#endif
+	return (void *)realcipher;
+}
+
+static int binary_hash_0(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xf; }
+static int binary_hash_1(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xff; }
+static int binary_hash_2(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfff; }
+static int binary_hash_3(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xffff; }
+static int binary_hash_4(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfffff; }
+
+#ifdef MMX_COEF
+static int get_hash_0(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xf;
+}
+static int get_hash_1(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xff;
+}
+static int get_hash_2(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xfff;
+}
+static int get_hash_3(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xffff;
+}
+static int get_hash_4(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xfffff;
+}
+#else
+static int get_hash_0(int index) { return ((unsigned int *)crypt_key)[0] & 0xf; }
+static int get_hash_1(int index) { return ((unsigned int *)crypt_key)[0] & 0xff; }
+static int get_hash_2(int index) { return ((unsigned int *)crypt_key)[0] & 0xfff; }
+static int get_hash_3(int index) { return ((unsigned int *)crypt_key)[0] & 0xffff; }
+static int get_hash_4(int index) { return ((unsigned int *)crypt_key)[0] & 0xfffff; }
+#endif
+
+struct fmt_main fmt_rawSHA1 = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		rawsha1_tests
+	}, {
+		rawsha1_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		rawsha1_binary,
+		fmt_default_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		fmt_default_salt_hash,
+		fmt_default_set_salt,
+		rawsha1_set_key,
+		rawsha1_get_key,
+		fmt_default_clear_keys,
+		rawsha1_crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		rawsha1_cmp_all,
+		rawsha1_cmp_one,
+		rawsha1_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/recovery.c john-1.7.8-jumbo-2/src/recovery.c
--- john-1.7.8/src/recovery.c	2011-03-20 15:58:07.000000000 +0100
+++ john-1.7.8-jumbo-2/src/recovery.c	2011-06-02 17:19:49.000000000 +0200
@@ -1,17 +1,31 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2003,2005,2006,2009,2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by JimF.
  */
 
 #define _XOPEN_SOURCE 500 /* for fdopen(3), fileno(3), fsync(2), ftruncate(2) */
+
 #include <stdio.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#else
+#include <io.h>
+#pragma warning ( disable : 4996 )
+#endif
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#ifndef _MSC_VER
 #include <sys/file.h>
+#endif
 #include <errno.h>
 #include <string.h>
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#include "signals.h"
+#endif
 
 #if defined(__CYGWIN32__) && !defined(__CYGWIN__)
 extern int ftruncate(int fd, size_t length);
@@ -29,7 +43,11 @@ extern int ftruncate(int fd, size_t leng
 #include "recovery.h"
 
 char *rec_name = RECOVERY_NAME;
+#ifdef HAVE_MPI
+int rec_name_completed = 0;
+#else
 int rec_name_completed = 1;
+#endif
 int rec_version = 0;
 int rec_argc = 0;
 char **rec_argv;
@@ -44,7 +62,21 @@ static void (*rec_save_mode)(FILE *file)
 static void rec_name_complete(void)
 {
 	if (rec_name_completed) return;
+#ifdef HAVE_MPI
+	char *mpi_suffix;
+	mpi_suffix = mem_alloc_tiny(strlen(id2string()) + 1 +
+	    strlen(RECOVERY_SUFFIX) + 1, MEM_ALIGN_NONE);
+	mpi_suffix[0] = 0;
+	if (mpi_p > 1) {
+		strcat(mpi_suffix, ".");
+		strcat(mpi_suffix, id2string());
+	}
+	strcat(mpi_suffix, RECOVERY_SUFFIX);
+
+	rec_name = path_session(rec_name, mpi_suffix);
+#else
 	rec_name = path_session(rec_name, RECOVERY_SUFFIX);
+#endif
 	rec_name_completed = 1;
 }
 
@@ -53,8 +85,13 @@ static void rec_lock(void)
 {
 	if (flock(rec_fd, LOCK_EX | LOCK_NB)) {
 		if (errno == EWOULDBLOCK) {
+#ifdef HAVE_MPI
+			fprintf(stderr, "Node %d@%s: Crash recovery file is locked: %s\n",
+			        mpi_id, mpi_name, path_expand(rec_name));
+#else
 			fprintf(stderr, "Crash recovery file is locked: %s\n",
 				path_expand(rec_name));
+#endif
 			error();
 		} else
 			pexit("flock");
@@ -84,7 +121,7 @@ void rec_init(struct db_main *db, void (
 
 void rec_save(void)
 {
-	int save_format;
+	int save_format, hund;
 	long size;
 	char **opt;
 
@@ -93,7 +130,9 @@ void rec_save(void)
 	if (!rec_file) return;
 
 	if (fseek(rec_file, 0, SEEK_SET)) pexit("fseek");
-#ifdef __CYGWIN32__
+#ifdef _MSC_VER
+	if (_write(fileno(rec_file), "", 0)) pexit("ftruncate");
+#elif __CYGWIN32__
 	if (ftruncate(rec_fd, 0)) pexit("ftruncate");
 #endif
 
@@ -116,7 +155,7 @@ void rec_save(void)
 		status.crypts.lo,
 		status.crypts.hi,
 		status.pass,
-		status_get_progress ? status_get_progress() : -1,
+		status_get_progress ? status_get_progress(&hund) : -1,
 		rec_check);
 
 	if (rec_save_mode) rec_save_mode(rec_file);
@@ -125,8 +164,10 @@ void rec_save(void)
 
 	if ((size = ftell(rec_file)) < 0) pexit("ftell");
 	if (fflush(rec_file)) pexit("fflush");
+#ifndef _MSC_VER
 	if (ftruncate(rec_fd, size)) pexit("ftruncate");
-#ifndef __CYGWIN32__
+#endif
+#if !defined(__CYGWIN32__) && !defined(__MINGW32__) && !defined (_MSC_VER)
 	if (fsync(rec_fd)) pexit("fsync");
 #endif
 }
@@ -138,7 +179,31 @@ void rec_done(int save)
 	if (save)
 		rec_save();
 	else
+#ifdef HAVE_MPI
+	{
 		log_flush();
+		if (mpi_p > 1) {
+			if (rec_db->password_count) {
+#ifdef JOHN_MPI_BARRIER
+				int time = status_get_time();
+				if (nice(20) < 0) fprintf(stderr, "nice() failed\n");
+				fprintf(stderr, "Node %d finished at %u:%02u:%02u:%02u.\n", mpi_id, time / 86400, time % 86400 / 3600, time % 3600 / 60, time % 60);
+				MPI_Barrier(MPI_COMM_WORLD);
+#endif
+			} else {
+#ifdef JOHN_MPI_ABORT
+				int time = status_get_time();
+				fprintf(stderr, "Node %d: All hashes cracked at %u:%02u:%02u:%02u! Aborting other nodes.\n", mpi_id, time / 86400, time % 86400 / 3600, time % 3600 / 60, time % 60);
+				MPI_Abort(MPI_COMM_WORLD, 0);
+#else
+				fprintf(stderr, "Node %d: All hashes cracked! Abort the other nodes manually!\n", mpi_id);
+#endif
+			}
+		}
+	}
+#else
+	log_flush();
+#endif
 
 	if (fclose(rec_file)) pexit("fclose");
 	rec_file = NULL;
diff -rupN john-1.7.8/src/rules.c john-1.7.8-jumbo-2/src/rules.c
--- john-1.7.8/src/rules.c	2011-03-20 02:33:41.000000000 +0100
+++ john-1.7.8-jumbo-2/src/rules.c	2011-05-17 15:49:29.000000000 +0200
@@ -6,6 +6,10 @@
 #include <stdio.h>
 #include <string.h>
 
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
+
 #include "arch.h"
 #include "misc.h"
 #include "params.h"
@@ -16,6 +20,7 @@
 #include "logger.h"
 #include "rpp.h"
 #include "rules.h"
+#include "options.h"
 
 char *rules_errors[] = {
 	NULL,	/* No error */
@@ -183,8 +188,15 @@ static void rules_init_class(char name,
 
 static void rules_init_classes(void)
 {
+	static unsigned char eightbitchars[129];
+	int i;
 	memset(rules_classes, 0, sizeof(rules_classes));
 
+	// this is an ugly hack but it works fine, used for 'b' below
+	for(i=0;i<128;i++)
+		eightbitchars[i] = i+128;
+	eightbitchars[128] = 0;
+
 	rules_init_class('?', "?");
 	rules_init_class('v', "aeiouAEIOU");
 	rules_init_class('c', "bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ");
@@ -196,6 +208,7 @@ static void rules_init_classes(void)
 	rules_init_class('d', CHARS_DIGITS);
 	rules_init_class('a', CHARS_LOWER CHARS_UPPER);
 	rules_init_class('x', CHARS_LOWER CHARS_UPPER CHARS_DIGITS);
+	rules_init_class('b', (char *)&eightbitchars);
 	rules_init_class('Z', "");
 }
 
@@ -297,6 +310,16 @@ char *rules_reject(char *rule, int split
 			rules_errno = RULES_ERROR_END;
 			return NULL;
 
+		case 'u':
+			if (!db) continue;
+			if (options.flags & FLG_UTF8) continue;
+			return NULL;
+
+		case 'U':
+			if (!db) continue;
+			if (!(options.flags & FLG_UTF8)) continue;
+			return NULL;
+
 		default:
 			rules_errno = RULES_ERROR_REJECT;
 			return NULL;
@@ -988,6 +1011,9 @@ int rules_count(struct rpp_context *star
 	if (!(count = rules_check(start, split))) {
 		log_event("! Invalid rule at line %d: %.100s",
 			rules_line, rules_errors[rules_errno]);
+#ifdef HAVE_MPI
+		if (mpi_id == 0)
+#endif
 		fprintf(stderr, "Invalid rule in %s at line %d: %s\n",
 			cfg_name, rules_line,
 			rules_errors[rules_errno]);
diff -rupN john-1.7.8/src/salted_sha1_fmt_plug.c john-1.7.8-jumbo-2/src/salted_sha1_fmt_plug.c
--- john-1.7.8/src/salted_sha1_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/salted_sha1_fmt_plug.c	2011-06-08 01:46:10.000000000 +0200
@@ -0,0 +1,452 @@
+/*
+ * generic salted-sha1 support for LDAP style password storage
+ * only works with salt that are powers of 2
+ *
+ * by bartavelle?
+ * XXX: need a licensing statement
+ */
+
+#define MAX_SALT_LEN	16
+
+#include <string.h>
+
+#include "misc.h"
+#include "formats.h"
+#include "arch.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
+
+#ifdef SHA1_SSE_PARA
+#define MMX_COEF	4
+#include "sse-intrinsics.h"
+#define NBKEYS	(MMX_COEF * SHA1_SSE_PARA)
+#elif MMX_COEF
+#define NBKEYS	MMX_COEF
+#endif
+
+#include "common.h"
+
+#include "sha.h"
+#include "base64.h"
+
+#define FORMAT_LABEL			"salted-sha"
+#define FORMAT_NAME			"Salted SHA"
+#define SHA_TYPE                        "SHA-1"
+
+#ifdef SHA1_N_STR
+#define BENCHMARK_COMMENT		"(" SHA1_N_STR ")"
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		32
+#define CIPHERTEXT_LENGTH		48
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			(MAX_SALT_LEN + sizeof(unsigned int))
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT		NBKEYS
+#define MAX_KEYS_PER_CRYPT		NBKEYS
+//#define GETPOS(i, index)		( (index&3)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) + (index>>2)*80*MMX_COEF*4 ) //for endianity conversion
+//#define GETPOS(i, index)		( (index&(MMX_COEF-1))*4 + ((i)&(0xffffffff-3))*MMX_COEF + (3-((i)&(MMX_COEF-1))) + (index>>(MMX_COEF>>1))*80*MMX_COEF*4 ) //for endianity conversion
+#define GETPOS(i, index)		( (index&(MMX_COEF-1))*4 + ((i)&(0xffffffff-3))*MMX_COEF + (3-((i)&3)) + (index>>(MMX_COEF>>1))*80*MMX_COEF*4 ) //for endianity conversion
+//#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + (3-((i)&3)) )
+#else
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+#endif
+
+#define NSLDAP_MAGIC "{ssha}"
+#define NSLDAP_MAGIC_LENGTH 6
+
+struct s_salt
+{
+	unsigned int len;
+	union {
+		unsigned char c[MAX_SALT_LEN];
+		ARCH_WORD_32 w32;
+	} data;
+} saved_salt;
+
+static struct fmt_tests tests[] = {
+	{"{SSHA}bPXG4M1KkwZh2Hbgnuoszvpat0T/OS86", "thales"},
+	{"{SSHA}hHSEPW3qeiOo5Pl2MpHQCXh0vgfyVR/X", "test1"},
+	{"{SSHA}pXp4yIiRmppvKYn7cKCT+lngG4qELq4h", "test2"},
+	{"{SSHA}Bv8tu3wB8WTMJj3tcOsl1usm5HzGwEmv", "test3"},
+	{"{SSHA}kXyh8wLCKbN+QRbL2F2aUbkP62BJ/bRg", "lapin"},
+	{"{SSHA}rnMVxsf1YJPg0L5CBhbVLIsJF+o/vkoE", "canard"},
+	{"{SSHA}Uf2x9YxSWZZNAi2t1QXbG2PmT07AtURl", "chien"},
+	{"{SSHA}XXGLZ7iKpYSBpF6EwoeTl27U0L/kYYsY", "hibou"},
+	{"{SSHA}HYRPmcQIIzIIg/c1L8cZKlYdNpyeZeml", "genou"},
+	{"{SSHA}Zm/0Wll7rLNpBU4HFUKhbASpXr94eSTc", "caillou"},
+	{"{SSHA}Qc9OB+aEFA/mJ5MNy0AB4hRIkNiAbqDb", "doudou"},
+/*
+	{"{SSHA}WTT3B9Jjr8gOt0Q7WMs9/XvukyhTQj0Ns0jMKQ==", "Password9"},
+	{"{SSHA}ypkVeJKLzbXakEpuPYbn+YBnQvFmNmB+kQhmWQ==", "qVv3uQ45"},
+	{"{SSHA}cKFVqtf358j0FGpPsEIK1xh3T0mtDNV1kAaBNg==", "salles"},
+	{"{SSHA}W3ipFGmzS3+j6/FhT7ZC39MIfqFcct9Ep0KEGA==", "asddsa123"},
+	{"{SSHA}YbB2R1D2AlzYc9wk/YPtslG7NoiOWaoMOztLHA==", "ripthispassword"},
+*/
+	{NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define saved_key SALT_SHA_saved_key
+#define crypt_key SALT_SHA_crypt_key
+#ifdef _MSC_VER
+__declspec(align(16)) unsigned char saved_key[80*4*NBKEYS];
+__declspec(align(16)) unsigned char crypt_key[BINARY_SIZE*NBKEYS];
+#else
+unsigned char saved_key[80*4*NBKEYS] __attribute__ ((aligned(16)));
+unsigned char crypt_key[BINARY_SIZE*NBKEYS] __attribute__ ((aligned(16)));
+#endif
+static unsigned int saved_len[NBKEYS];
+static unsigned char out[PLAINTEXT_LENGTH + 1];
+static unsigned int salt_sizes;
+static unsigned int max_salt_size;
+#else
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static SHA_CTX ctx;
+#endif
+
+static void init(struct fmt_main *pFmt)
+{
+#ifdef MMX_COEF
+	salt_sizes = 0;
+	max_salt_size = 0;
+#endif
+}
+
+static void * binary(char *ciphertext) {
+	static char *realcipher;
+
+	if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE + 9, MEM_ALIGN_WORD);
+
+	/* stupid overflows */
+	memset(realcipher, 0, BINARY_SIZE + 9);
+	base64_decode(NSLDAP_MAGIC_LENGTH+ciphertext, strlen(ciphertext)-NSLDAP_MAGIC_LENGTH, realcipher);
+// if we try to unify the rawsha1_cmp_one() and and rawsha1_cmp_all() functions, we should endian alter for all MMX_COEF.
+// Right now, for MMX/SSE non-para, we keep the older methods.
+#ifdef SHA1_SSE_PARA
+	alter_endianity((unsigned char *)realcipher, BINARY_SIZE);
+#endif
+	return (void *)realcipher;
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+//	printf("%s %s\n", __func__, ciphertext);
+	if(strlen(ciphertext) > (CIPHERTEXT_LENGTH + NSLDAP_MAGIC_LENGTH) )
+		return 0;
+	return !strncasecmp(ciphertext, NSLDAP_MAGIC, NSLDAP_MAGIC_LENGTH);
+}
+
+static int binary_hash_0(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xf; }
+static int binary_hash_1(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xff; }
+static int binary_hash_2(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfff; }
+static int binary_hash_3(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xffff; }
+static int binary_hash_4(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfffff; }
+
+static void set_key(char *key, int index) {
+#ifdef MMX_COEF
+	int len;
+	int i;
+
+	if(index==0)
+	{
+		memset(saved_len, 0, sizeof(saved_len));
+		//memset(saved_key, 0, sizeof(saved_key));
+		i = 0;
+#ifdef SHA1_SSE_PARA
+		for (; i < SHA1_SSE_PARA; ++i)
+#endif
+			memset(&saved_key[i*4*80*MMX_COEF], 0, 56*MMX_COEF);
+	}
+	len = strlen(key);
+	if(len>PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+	saved_len[index] = len;
+
+	for(i=0;i<len;i++)
+		saved_key[GETPOS(i, index)] = key[i];
+
+
+	saved_key[GETPOS(i, index)] = 0x80;
+	((unsigned int *)saved_key)[15*MMX_COEF + (index&3) + (index>>2)*80*MMX_COEF] = len<<3;
+
+#else
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+#endif
+}
+
+static void * get_salt(char * ciphertext)
+{
+	static struct s_salt cursalt;
+	char realcipher[BINARY_SIZE + (MAX_SALT_LEN*4/3) + 9];
+
+//	printf("%s %s\n", __func__, ciphertext);
+
+	memset(realcipher, 0, sizeof(realcipher));
+	memset(&cursalt, 0, sizeof(struct s_salt));
+	base64_decode(NSLDAP_MAGIC_LENGTH+ciphertext, strlen(ciphertext) - NSLDAP_MAGIC_LENGTH, realcipher);
+	switch( strlen(ciphertext ) )
+	{
+		case 38:
+			cursalt.len = 4;
+			break;
+		case 46:
+			cursalt.len = 8;
+			break;
+		default:
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
+			fprintf(stderr, "unknown salt size for %s (total len=%ld)\n", ciphertext, (long)strlen(ciphertext));
+			return NULL;
+	}
+#ifdef MMX_COEF
+	salt_sizes |= cursalt.len;
+	if(cursalt.len > max_salt_size)
+		max_salt_size = cursalt.len;
+#endif
+	memcpy(cursalt.data.c, realcipher+BINARY_SIZE, cursalt.len);
+	return &cursalt;
+}
+
+static char *get_key(int index) {
+#ifdef MMX_COEF
+	unsigned int i,s;
+
+//	s = ((unsigned int *)saved_key)[15*MMX_COEF + (index&3) + (index>>2)*80*MMX_COEF] >> 3;
+	s = saved_len[index];
+	for(i=0;i<s;i++)
+		out[i] = saved_key[ GETPOS(i, index) ];
+	out[i] = 0;
+	return (char *) out;
+#else
+	return saved_key;
+#endif
+}
+
+static int cmp_all(void *binary, int count) {
+#ifdef MMX_COEF
+# ifdef SHA1_SSE_PARA
+	unsigned int x,y=0;
+
+#ifdef SHA1_SSE_PARA
+	for(;y<SHA1_SSE_PARA;y++)
+#endif
+	for(x=0;x<MMX_COEF;x++)
+	{
+		if( ((unsigned int *)binary)[0] == ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] )
+			return 1;
+	}
+	return 0;
+# else
+	int i=0;
+	while(i< (BINARY_SIZE/4) )
+	{
+		if (
+			( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+1])
+#   if (MMX_COEF > 3)
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+2])
+			&& ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+3])
+#   endif
+		)
+			return 0;
+		i++;
+	}
+	return 1;
+# endif
+#else
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+#endif
+}
+
+static int cmp_exact(char *source, int count){
+  return (1);
+}
+
+static int cmp_one(void * binary, int index)
+{
+#ifdef MMX_COEF
+# if SHA1_SSE_PARA
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+
+        if( ((unsigned int *)binary)[0] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] )
+                return 0;
+        if( ((unsigned int *)binary)[1] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+4] )
+                return 0;
+        if( ((unsigned int *)binary)[2] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+8] )
+                return 0;
+        if( ((unsigned int *)binary)[3] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+12] )
+                return 0;
+        if( ((unsigned int *)binary)[4] != ((unsigned int *)crypt_key)[x+y*MMX_COEF*5+16] )
+                return 0;
+        return 1;
+# else
+	int i = 0;
+	for(i=0;i<(BINARY_SIZE/4);i++)
+		if ( ((unsigned long *)binary)[i] != ((unsigned long *)crypt_key)[i*MMX_COEF+index] )
+			return 0;
+	return 1;
+# endif
+#else
+	return cmp_all(binary, index);
+#endif
+}
+
+
+static void set_salt(void *salt) {
+	memcpy(&saved_salt, salt, sizeof(struct s_salt));
+/*
+data is not a pointer, so this check did not make sense
+	if(saved_salt.data == NULL)
+		printf("data is NULL\n");
+*/
+}
+
+#ifdef MMX_COEF
+static void set_onesalt(int index)
+{
+	unsigned int i;
+	for(i=0;i<saved_salt.len;i++)
+		saved_key[GETPOS(i + saved_len[index], index)] = saved_salt.data.c[i];
+	if(saved_salt.len != max_salt_size) /* more than one salt size at the same time */
+		for(i=0;i<max_salt_size-saved_salt.len;i++)
+			saved_key[GETPOS(i+saved_salt.len+saved_len[index], index)] = 0;
+
+	saved_key[GETPOS(saved_salt.len + saved_len[index], index)] = 0x80;
+
+	((unsigned int *)saved_key)[15*MMX_COEF + (index&3) + (index>>2)*80*MMX_COEF] = (saved_salt.len + saved_len[index])<<3;
+}
+#endif
+
+static void crypt_all(int count) {
+#ifdef MMX_COEF
+	unsigned int i;
+	for(i=0;i<NBKEYS;i++)
+		set_onesalt(i);
+# if SHA1_SSE_PARA
+	SSESHA1body(saved_key, (unsigned int *)crypt_key, 1);
+# else
+	shammx_nosizeupdate((unsigned char *) crypt_key, (unsigned char *) saved_key, 1);
+
+# endif
+
+#else
+	SHA1_Init( &ctx );
+	SHA1_Update( &ctx, (unsigned char *) saved_key, strlen( saved_key ) );
+	SHA1_Update( &ctx, (unsigned char *) saved_salt.data.c, saved_salt.len);
+	SHA1_Final( (unsigned char *) crypt_key, &ctx);
+//	dump_stuff((unsigned char *)crypt_key, 20);
+//	exit(1);
+#endif
+
+}
+
+#ifdef MMX_COEF
+static int get_hash_0(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xf;
+}
+static int get_hash_1(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xff;
+}
+static int get_hash_2(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xfff;
+}
+static int get_hash_3(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xffff;
+}
+static int get_hash_4(int index)
+{
+	unsigned int x,y;
+        x = index&3;
+        y = index/4;
+	return ((unsigned int *)crypt_key)[x+y*MMX_COEF*5] & 0xfffff;
+}
+#else
+static int get_hash_0(int index) { return ((unsigned int *)crypt_key)[0] & 0xf; }
+static int get_hash_1(int index) { return ((unsigned int *)crypt_key)[0] & 0xff; }
+static int get_hash_2(int index) { return ((unsigned int *)crypt_key)[0] & 0xfff; }
+static int get_hash_3(int index) { return ((unsigned int *)crypt_key)[0] & 0xffff; }
+static int get_hash_4(int index) { return ((unsigned int *)crypt_key)[0] & 0xfffff; }
+#endif
+
+static int salt_hash(void *salt)
+{
+	struct s_salt * mysalt = salt;
+	return mysalt->data.w32 & (SALT_HASH_SIZE - 1);
+}
+
+struct fmt_main fmt_saltedsha = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		SHA_TYPE,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		binary,
+		get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/sapB_fmt_plug.c john-1.7.8-jumbo-2/src/sapB_fmt_plug.c
--- john-1.7.8/src/sapB_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/sapB_fmt_plug.c	2011-07-02 22:46:01.000000000 +0200
@@ -0,0 +1,306 @@
+/*
+ * this is a SAP-BCODE plugin for john the ripper.
+ * tested on linux/x86 only, rest is up to you.. at least, someone did the reversing :-)
+ *
+ * please note: this code is in a "works for me"-state, feel free to modify/speed up/clean/whatever it...
+ *
+ * (c) x7d8 sap loverz, public domain, btw
+ * cheers: see test-cases.
+ */
+
+/* char transition table for BCODE (from disp+work) */
+#define TRANSTABLE_LENGTH 16*16
+unsigned char transtable[TRANSTABLE_LENGTH]=
+{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0x3F, 0x40, 0x41, 0x50, 0x43, 0x44, 0x45, 0x4B, 0x47, 0x48, 0x4D, 0x4E, 0x54, 0x51, 0x53, 0x46,
+ 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x56, 0x55, 0x5C, 0x49, 0x5D, 0x4A,
+ 0x42, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
+ 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x58, 0x5B, 0x59, 0xFF, 0x52,
+ 0x4C, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
+ 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x57, 0x5E, 0x5A, 0x4F, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
+ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+
+#define BCODE_ARRAY_LENGTH 3*16
+unsigned char bcodeArr[BCODE_ARRAY_LENGTH]=
+{0x14,0x77,0xF3,0xD4,0xBB,0x71,0x23,0xD0,0x03,0xFF,0x47,0x93,0x55,0xAA,0x66,0x91,
+0xF2,0x88,0x6B,0x99,0xBF,0xCB,0x32,0x1A,0x19,0xD9,0xA7,0x82,0x22,0x49,0xA2,0x51,
+0xE2,0xB7,0x33,0x71,0x8B,0x9F,0x5D,0x01,0x44,0x70,0xAE,0x11,0xEF,0x28,0xF0,0x0D};
+
+
+#include <string.h>
+#include <ctype.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+
+#include "md5.h"
+
+#define FORMAT_LABEL			"sapb"
+#define FORMAT_NAME			"SAP BCODE"
+#define ALGORITHM_NAME			"sapb"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define SALT_SIZE			40	/* the max username length */
+#define PLAINTEXT_LENGTH		8	/* passwordlength max 8 chars */
+#define CIPHERTEXT_LENGTH		SALT_SIZE + 1 + 16	/* SALT + $ + 2x8 bytes for BCODE-representation */
+
+#define BINARY_SIZE			8	/* half of md5 */
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests sapbcode_tests[] = {
+ 	{"F                                       $E3A65AAA9676060F", "X"},
+	{"JOHNNY                                  $7F7207932E4DE471", "CYBERPUNK"},
+	{"VAN                                     $487A2A40A7BA2258", "HAUSER"},
+	{"ROOT                                    $8366A4E9E6B72CB0", "KID"},
+	{"MAN                                     $9F48E7CE5B184D2E", "u"},
+	{"----------------------------------------$08CEDAFED0C750A0", "-------"},
+	{"SAP*                                    $7016BFF7C5472F1B", "MAsTeR"},
+	{"DDIC                                    $C94E2F7DD0178374", "DDIC"},
+	{"DOLLAR$$$---                            $C3413C498C48EB67", "dollar$$$---"},
+	{NULL}
+};
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static char crypt_key[BINARY_SIZE];
+static MD5_CTX ctx;
+static char theSalt[SALT_SIZE];
+
+static int sapbcode_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+
+	if(strlen(ciphertext)!=CIPHERTEXT_LENGTH)
+		return 0;
+
+	if (ciphertext[SALT_SIZE]!='$')
+		return 0;
+
+	for (i = SALT_SIZE+1; i< CIPHERTEXT_LENGTH; i++)
+		if (!(((ciphertext[i]>='A' && ciphertext[i]<='F')) ||
+			((ciphertext[i]>='a' && ciphertext[i]<='f')) ||
+			((ciphertext[i]>='0' && ciphertext[i]<='9')) ))
+			return 0;
+	return 1;
+}
+
+static void sapbcode_set_salt(void *salt)
+{
+	memcpy(theSalt, salt, SALT_SIZE);
+}
+
+
+void strToUpper_B(char* str)
+{
+	int i=0;
+	if (NULL==str)
+		return;
+	for (i=0; i<strlen(str);i++)
+		if ((str[i] >= 'a') && (str[i] <= 'z')) str[i] ^= 0x20;
+}
+
+
+static void sapbcode_set_key(char *key, int index) {
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+}
+
+static char *sapbcode_get_key(int index) {
+	return saved_key;
+}
+
+static int sapbcode_cmp_all(void *binary, int index) {
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+}
+
+static int sapbcode_cmp_exact(char *source, int count){
+  return 1;
+}
+
+static int sapbcode_cmp_one(void * binary, int index)
+{
+	return sapbcode_cmp_all(binary, index);
+}
+
+
+/*
+ * this function is needed to determine the actual size of the salt (==username)
+ * theSalt has to point at the beginning of the actual salt. no more checks are done; relies on valid()
+ * this is needed because, afaik, john only supports salts w/ fixed length. sap uses the username, so we have to
+ * "strip" the padding (blanks at the end) for the calculation....
+ * usernames w/ spaces at the end are not supported (SAP does not support them either)
+ */
+int calcActualSaltSize_B(char* theSalt)
+{
+    int i;
+	if (NULL==theSalt)
+		return 0;
+	i=SALT_SIZE-1;
+	while (theSalt[i--]==0x20);
+	return i+2;
+}
+
+
+#define TEMP_ARRAY_SIZE 4*16
+static void sapbcode_crypt_all(int count) {
+	static unsigned char temp_key[BINARY_SIZE*2];
+	static unsigned char final_key[BINARY_SIZE*2];
+	static char username[SALT_SIZE+1], password[PLAINTEXT_LENGTH+1];
+	static char unConverted[SALT_SIZE+1], pwConverted[PLAINTEXT_LENGTH+1];
+	unsigned int i;
+	unsigned int sum20;
+	int I1, I2;
+	int revI1;
+	int I3;
+	int strlenUN, strlenPW;
+	char destArray[TEMP_ARRAY_SIZE];
+	int I4;
+
+	//username: theSalt (we have to determine the right length...)
+	//password: saved_key
+	strnzcpy(username, theSalt, calcActualSaltSize_B(theSalt)+1);
+	strnzcpy(password, saved_key, PLAINTEXT_LENGTH+1);
+
+  	strToUpper_B(password); //only UPPERCASE passwords accepted for BCODE
+
+	//transform...
+	for (i=0; i<strlen(username); i++)
+		unConverted[i]=transtable[ARCH_INDEX(username[i])];
+	unConverted[i]='\0';
+
+	for (i=0; i<strlen(password); i++)
+		pwConverted[i]=transtable[ARCH_INDEX(password[i])];
+	pwConverted[i]='\0';
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, pwConverted, strlen(pwConverted));
+	MD5_Update(&ctx, unConverted, strlen(unConverted));
+	MD5_Final(temp_key,&ctx);
+
+	//some magic in between....yes, #4 is ignored...
+	sum20 = temp_key[5]%4 + temp_key[3]%4 + temp_key[2]%4 + temp_key[1]%4 + temp_key[0]%4 +0x20;
+
+
+	strlenUN=strlen(username);
+	strlenPW=strlen(password);
+	memset(destArray,0,TEMP_ARRAY_SIZE);
+#define DEFAULT_OFFSET 15
+	I1=0;
+	I2=0;
+	revI1=0;
+	I3=0;
+
+	//now: walld0rf-magic [tm], (c), <g>
+	do {
+		if (I1<strlenPW) {
+			if ((temp_key[DEFAULT_OFFSET+revI1] % 2) != 0)
+				destArray[I2++]=bcodeArr[BCODE_ARRAY_LENGTH+revI1-1];
+			destArray[I2++]=pwConverted[I1++];
+			revI1--;
+		}
+		if (I3<strlenUN)
+			destArray[I2++]=unConverted[I3++];
+
+		I4=I2-I1-I3;
+		I2++;
+		destArray[I2-1]=bcodeArr[I4];
+		I2++;
+	} while (I2<sum20);
+	//end of walld0rf-magic [tm], (c), <g>
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, destArray, sum20);
+	MD5_Final(final_key, &ctx);
+
+	for (i=0; i<8; i++)
+		crypt_key[i]=final_key[i+8]^final_key[i];
+}
+
+static void * sapbcode_binary(char *ciphertext)
+{
+	static char realcipher[BINARY_SIZE];
+	int i;
+
+	char* newCiphertextPointer=&ciphertext[SALT_SIZE+1];
+
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		realcipher[i] = atoi16[ARCH_INDEX(newCiphertextPointer[i*2])]*16 + atoi16[ARCH_INDEX(newCiphertextPointer[i*2+1])];
+	}
+	return (void *)realcipher;
+}
+
+static void *sapbcode_get_salt(char *ciphertext)
+{
+	static unsigned char uglyStaticStackSalt[SALT_SIZE];
+	memcpy(uglyStaticStackSalt, ciphertext, SALT_SIZE); //salt is in the beginning of the ciphertext
+	return uglyStaticStackSalt;
+}
+
+char *sapbcode_split(char *ciphertext, int index)
+{
+	static char out[CIPHERTEXT_LENGTH + 1];
+  	memset(out, 0, CIPHERTEXT_LENGTH + 1);
+	memcpy(out, ciphertext, CIPHERTEXT_LENGTH);
+	strToUpper_B(out); //username (==salt) && resulting hash can be uppercase...
+	return out;
+}
+
+struct fmt_main fmt_sapB = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE,
+		sapbcode_tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		sapbcode_valid,
+		sapbcode_split,
+		sapbcode_binary,
+		sapbcode_get_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		sapbcode_set_salt,
+		sapbcode_set_key,
+		sapbcode_get_key,
+		fmt_default_clear_keys,
+		sapbcode_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		sapbcode_cmp_all,
+		sapbcode_cmp_one,
+		sapbcode_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/sapG_fmt_plug.c john-1.7.8-jumbo-2/src/sapG_fmt_plug.c
--- john-1.7.8/src/sapG_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/sapG_fmt_plug.c	2011-06-02 17:20:46.000000000 +0200
@@ -0,0 +1,422 @@
+/*
+ * this is a SAP PASSCODE (CODEVN G) plugin for john the ripper.
+ * tested on linux/x86 only, rest is up to you.. at least, someone did the reversing :-)
+ *
+ * please note: this code is in a "works for me"-state, feel free to modify/speed up/clean/whatever it...
+ *
+ * (c) x7d8 sap loverz, public domain, btw
+ * cheers: see test-cases.
+ *
+ * sligthly modified by magnum 2011 to support the --utf8 flag (which will turn
+ * off the incomplete iso-8859-1 conversion in translatePassword(), actually
+ * boosting performance). No rights reserved.
+ */
+
+//this array is from disp+work (sap's worker process)
+#define MAGIC_ARRAY_SIZE 160
+unsigned char theMagicArray[MAGIC_ARRAY_SIZE]=
+{0x91, 0xAC, 0x51, 0x14, 0x9F, 0x67, 0x54, 0x43, 0x24, 0xE7, 0x3B, 0xE0, 0x28, 0x74, 0x7B, 0xC2,
+ 0x86, 0x33, 0x13, 0xEB, 0x5A, 0x4F, 0xCB, 0x5C, 0x08, 0x0A, 0x73, 0x37, 0x0E, 0x5D, 0x1C, 0x2F,
+ 0x33, 0x8F, 0xE6, 0xE5, 0xF8, 0x9B, 0xAE, 0xDD, 0x16, 0xF2, 0x4B, 0x8D, 0x2C, 0xE1, 0xD4, 0xDC,
+ 0xB0, 0xCB, 0xDF, 0x9D, 0xD4, 0x70, 0x6D, 0x17, 0xF9, 0x4D, 0x42, 0x3F, 0x9B, 0x1B, 0x11, 0x94,
+ 0x9F, 0x5B, 0xC1, 0x9B, 0x06, 0x05, 0x9D, 0x03, 0x9D, 0x5E, 0x13, 0x8A, 0x1E, 0x9A, 0x6A, 0xE8,
+ 0xD9, 0x7C, 0x14, 0x17, 0x58, 0xC7, 0x2A, 0xF6, 0xA1, 0x99, 0x63, 0x0A, 0xD7, 0xFD, 0x70, 0xC3,
+ 0xF6, 0x5E, 0x74, 0x13, 0x03, 0xC9, 0x0B, 0x04, 0x26, 0x98, 0xF7, 0x26, 0x8A, 0x92, 0x93, 0x25,
+ 0xB0, 0xA2, 0x0D, 0x23, 0xED, 0x63, 0x79, 0x6D, 0x13, 0x32, 0xFA, 0x3C, 0x35, 0x02, 0x9A, 0xA3,
+ 0xB3, 0xDD, 0x8E, 0x0A, 0x24, 0xBF, 0x51, 0xC3, 0x7C, 0xCD, 0x55, 0x9F, 0x37, 0xAF, 0x94, 0x4C,
+ 0x29, 0x08, 0x52, 0x82, 0xB2, 0x3B, 0x4E, 0x37, 0x9F, 0x17, 0x07, 0x91, 0x11, 0x3B, 0xFD, 0xCD };
+
+
+#include <string.h>
+#include <ctype.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "sha.h"
+#include "options.h"
+
+#define FORMAT_LABEL			"sapg"
+#define FORMAT_NAME			"SAP CODVN G (PASSCODE)"
+#define ALGORITHM_NAME			"sapg"
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		48	/* netweaver 2004s limit */
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			40	/* the max username length */
+#define CIPHERTEXT_LENGTH		SALT_SIZE + 1 + 40	/* SALT + $ + 2x20 bytes for SHA1-representation */
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+
+static struct fmt_tests sapcodvng_tests[] = {
+	{"F                                       $646A0AD270DF651065669A45D171EDD62DFE39A1", "X"},
+	{"JOHNNY                                  $7D79B478E70CAAE63C41E0824EAB644B9070D10A", "CYBERPUNK"},
+	{"VAN                                     $D15597367F24090F0A501962788E9F19B3604E73", "hauser"},
+	{"ROOT                                    $1194E38F14B9F3F8DA1B181F14DEB70E7BDCC239", "KID"},
+	{"MAN                                     $22886450D0AB90FDA7F91C4F3DD5619175B372EA", "u"},
+	{"----------------------------------------$D594002761406B589A75CE86042A8B4A922AA74F", "-------"},
+	{"SAP*                                    $60A0F7E06D95BC9FB45F605BDF1F7B660E5D5D4E", "MaStEr"},
+	{"DDIC                                    $6066CD3147915331EC4C602847D27A75EB3E8F0A", "DDIC"},
+	{"DoLlAR$$$---                            $E0180FD4542D8B6715E7D0D9EDE7E2D2E40C3D4D", "Dollar$$$---"},
+	{NULL}
+};
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static ARCH_WORD_32 crypt_key[BINARY_SIZE / 4];
+static SHA_CTX ctx;
+
+static char theSalt[SALT_SIZE];
+
+static int sapcodvng_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	int i;
+	if (NULL==ciphertext)
+		return 0;
+
+	if (ciphertext[SALT_SIZE]!='$')
+		return 0;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+
+	for (i = SALT_SIZE+1; i < CIPHERTEXT_LENGTH; i++){
+		if (!(
+			(('0' <= ciphertext[i])&&(ciphertext[i] <= '9'))
+				|| (('a' <= ciphertext[i])&&(ciphertext[i] <= 'f'))
+				|| (('A' <= ciphertext[i])&&(ciphertext[i] <= 'F'))
+			))
+			return 0;
+	}
+
+	return 1;
+}
+
+static void sapcodvng_set_salt(void *salt)
+{
+	memcpy(theSalt, salt, SALT_SIZE);
+}
+
+static void *sapcodvng_get_salt(char *ciphertext)
+{
+	static unsigned char sssalt[SALT_SIZE];
+	memcpy(sssalt, ciphertext, SALT_SIZE);
+	return sssalt;
+}
+
+static void sapcodvng_init(struct fmt_main *pFmt)
+{ }
+
+static void sapcodvng_set_key(char *key, int index)
+{
+	strnzcpy(saved_key, key, PLAINTEXT_LENGTH+1);
+}
+
+static char *sapcodvng_get_key(int index) {
+	return saved_key;
+}
+
+static int sapcodvng_cmp_all(void *binary, int index) {
+	return !memcmp(binary, crypt_key, BINARY_SIZE);
+}
+
+static int sapcodvng_cmp_exact(char *source, int count){
+  return (1);
+}
+
+static int sapcodvng_cmp_one(void * binary, int index)
+{
+	return sapcodvng_cmp_all(binary, index);
+}
+
+
+/*
+ * this function is needed to determine the actual size of the salt (==username)
+ * theSalt has to point at the beginning of the actual salt. no more checks are done; relies on valid()
+ * this is needed because, afaik, john only supports salts w/ fixed length. sap uses the username, so we have to
+ * "strip" the padding (blanks at the end) for the calculation....
+ * usernames w/ spaces at the end are not supported (SAP does not support them either)
+ */
+int calcActualSaltSize_G(char* theSalt)
+{
+    int i;
+	if (NULL==theSalt)
+		return 0;
+	i=SALT_SIZE-1;
+	while (theSalt[i--]==0x20);
+	return SALT_SIZE-(SALT_SIZE-i)+2;
+}
+
+/*
+ * calculate the length of data that has to be hashed from the magic array. pass the first hash result in here.
+ * this is part of the walld0rf-magic
+ */
+unsigned int extractLengthOfMagicArray(unsigned char *pbHashArray)
+{
+	unsigned int modSum=0, i;
+
+	for (i=0; i<=9; i++)
+		modSum+=pbHashArray[i]%6;
+
+	return modSum+0x20; //0x20 is hardcoded...
+}
+
+/*
+ * Calculate the offset into the magic array. pass the first hash result in here
+ * part of the walld0rf-magic
+ */
+unsigned int extractOffsetToMagicArray(unsigned char *pbHashArray)
+{
+	unsigned int modSum=0, i;
+
+	for (i=19; i>=10; i--)
+		modSum+=pbHashArray[i]%8;
+
+	return modSum;
+}
+
+/*
+ * used to alter the username which is always(!) uppercase...
+ */
+void strToUpper_G(char* str)
+{
+	int i=0;
+	if (NULL==str)
+		return;
+	for (i=0; i<strlen(str);i++)
+		if ((str[i] >= 'a') && (str[i] <= 'z')) str[i] ^= 0x20;
+}
+
+/*
+ * translation for passwords (chars >7bit ascii).
+ * translates just some >7bit chars to some weird magic bytes (not unicode?!)
+ * works for most west-european (e.g. french) passwords...
+ *
+ * Addendum by magnum:
+ * The "weird magic" is actually UTF-8. The format uses UTF-8 internally so I
+ * added the FMT_UTF8 to the format flags, and skip calling this ISO-8859-1
+ * translation in case the --utf8 option is used.
+ */
+static char* translatePassword(char* origPassword)
+{
+	static char password[PLAINTEXT_LENGTH*2];
+	unsigned int j=0, i;
+
+	for (i=0; i<strlen(origPassword); i++) {
+		if (origPassword[i] & 0x80) {
+			switch ((unsigned char)origPassword[i]) {
+				case 0xFC:
+					password[j]=0xC3; password[j+1]=0xBC; j+=2; break;
+				case 0xF6:
+					password[j]=0xC3; password[j+1]=0xB6; j+=2; break;
+				case 0xE4:
+					password[j]=0xC3; password[j+1]=0xA4; j+=2; break;
+				case 0xDC:
+					password[j]=0xC3; password[j+1]=0x9C; j+=2; break;
+				case 0xD6:
+					password[j]=0xC3; password[j+1]=0x96; j+=2; break;
+				case 0xC4:
+					password[j]=0xC3; password[j+1]=0x84; j+=2; break;
+				case 0xDF:
+					password[j]=0xC3; password[j+1]=0x9F; j+=2; break;
+				case 0xBA:
+					password[j]=0xC2; password[j+1]=0xB0; j+=2; break;
+				case 0xB4:
+					password[j]=0xC2; password[j+1]=0xB4; j+=2; break;
+				case 0xE9:
+					password[j]=0xC3; password[j+1]=0xA9; j+=2; break;
+				case 0xEA:
+					password[j]=0xC3; password[j+1]=0xAA; j+=2; break;
+				case 0xE8:
+					password[j]=0xC3; password[j+1]=0xA8; j+=2; break;
+				case 0xC9:
+					password[j]=0xC3; password[j+1]=0x89; j+=2; break;
+				case 0xCA:
+					password[j]=0xC3; password[j+1]=0x8A; j+=2; break;
+				case 0xC8:
+					password[j]=0xC3; password[j+1]=0x88; j+=2; break;
+				case 0xA7:
+					password[j]=0xC2; password[j+1]=0xA7; j+=2; break;
+				default:
+					password[j]=origPassword[i]; j++;
+					break;
+				} //switch
+			} else
+				password[j++]=origPassword[i];
+	}
+	password[j]='\0';
+	return password;
+}
+
+static void sapcodvng_crypt_all(int count) {
+	static char temp_key[BINARY_SIZE+1];
+	unsigned int offsetMagicArray;
+	unsigned int lengthIntoMagicArray;
+	unsigned char secondHashData[PLAINTEXT_LENGTH*2+MAGIC_ARRAY_SIZE]; //max size...
+	size_t secondHashDataLen;
+	size_t pwLen, unLen;
+	char tempVar[PLAINTEXT_LENGTH*2]; 	//PLAINTEXT_LENGTH is maxlen of password AND maxlen of username
+	char* trPassword;
+
+	//0.	translate special characters in the password
+	if (options.flags & FLG_UTF8)
+		trPassword = saved_key;
+	else
+		trPassword=translatePassword(saved_key);
+
+	pwLen=strlen(trPassword);
+
+	unLen=calcActualSaltSize_G(theSalt);
+
+	//1.	we need to SHA1 the password and username
+	strnzcpy(tempVar, trPassword, PLAINTEXT_LENGTH);  //first: the password
+	strnzcpy(tempVar+strlen(tempVar), theSalt, unLen+1); //second: the salt(username)
+
+
+	SHA1_Init(&ctx);
+	SHA1_Update(&ctx, (unsigned char*)tempVar, strlen(tempVar));
+	SHA1_Final((unsigned char*)&temp_key, &ctx);
+
+	lengthIntoMagicArray=extractLengthOfMagicArray((unsigned char*)temp_key);
+	offsetMagicArray=extractOffsetToMagicArray((unsigned char*)temp_key);
+
+	//2.     now, hash again --> sha1($password+$partOfMagicArray+$username) --> this is CODVNG passcode...
+	memcpy(secondHashData, trPassword, pwLen);
+	memcpy(secondHashData+pwLen, &theMagicArray[offsetMagicArray], lengthIntoMagicArray);
+	memcpy(secondHashData+pwLen+lengthIntoMagicArray, theSalt, unLen+1);
+	secondHashDataLen=pwLen+lengthIntoMagicArray+unLen;
+
+	SHA1_Init(&ctx);
+	SHA1_Update(&ctx, secondHashData, secondHashDataLen);
+	SHA1_Final((unsigned char*)crypt_key, &ctx);
+
+}
+
+static void * sapcodvng_binary(char *ciphertext)
+{
+	static char *realcipher;
+	int i;
+	char* newCiphertextPointer=&ciphertext[SALT_SIZE+1];
+
+	if (!realcipher) realcipher = mem_alloc_tiny(BINARY_SIZE, MEM_ALIGN_WORD);
+
+	for(i=0;i<BINARY_SIZE;i++)
+	{
+		realcipher[i] = atoi16[ARCH_INDEX(newCiphertextPointer[i*2])]*16 + atoi16[ARCH_INDEX(newCiphertextPointer[i*2+1])];
+	}
+	return (void *)realcipher;
+}
+
+
+static int binary_hash_0(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return ((ARCH_WORD_32 *)binary)[0] & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return crypt_key[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return crypt_key[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return crypt_key[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return crypt_key[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return crypt_key[0] & 0xFFFFF;
+}
+
+
+char *sapcodvng_split(char *ciphertext, int index)
+{
+	static char out[CIPHERTEXT_LENGTH + 1];
+  	memset(out, 0, CIPHERTEXT_LENGTH + 1);
+	memcpy(out, ciphertext, CIPHERTEXT_LENGTH);
+	strToUpper_G(out); //username (==salt) && resulting hash can be uppercase...
+	return out;
+}
+
+
+struct fmt_main fmt_sapG = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT | FMT_SPLIT_UNIFIES_CASE | FMT_UTF8,
+		sapcodvng_tests
+	}, {
+		sapcodvng_init,
+		fmt_default_prepare,
+		sapcodvng_valid,
+		sapcodvng_split,
+		sapcodvng_binary,
+		sapcodvng_get_salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		fmt_default_salt_hash,
+		sapcodvng_set_salt,
+		sapcodvng_set_key,
+		sapcodvng_get_key,
+		fmt_default_clear_keys,
+		sapcodvng_crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		sapcodvng_cmp_all,
+		sapcodvng_cmp_one,
+		sapcodvng_cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/sha.h john-1.7.8-jumbo-2/src/sha.h
--- john-1.7.8/src/sha.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/sha.h	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,35 @@
+#ifndef JOHN_SHA_H
+#define JOHN_SHA_H
+
+#include <openssl/sha.h>
+
+#ifdef MMX_COEF
+#ifdef _MSC_VER
+// NOTE, in VC, void __fastcall f(unsigned char *out, unsigned char *in, int n)
+//
+// puts these registers:
+//  n   -> pushed on stack
+//  ECX -> out
+//  EDX -> in
+//  Thus to get into this code, we ECX -> EAX and get ECX from the stack (minusthe return push)
+//  Also do a ret 4 after the emms in the mdfivemmx_noinit (to pop the push of eax)
+int __fastcall shammx_VC(unsigned char *out, unsigned char *in, int n);
+int __fastcall shammx_nofinalbyteswap_VC(unsigned char *out, unsigned char *in, int n);
+int __fastcall shammx_nosizeupdate_VC(unsigned char *out, unsigned char *in, int n);
+int __fastcall shammx_nosizeupdate_nofinalbyteswap_VC(unsigned char *out, unsigned char *in, int n);
+int __fastcall shammx_noinit_uniformsizeupdate_VC(unsigned char *out, unsigned char *in, int n);
+#define shammx                              shammx_VC
+#define shammx_nofinalbyteswap              shammx_nofinalbyteswap_VC
+#define shammx_nosizeupdate                 shammx_nosizeupdate_VC
+#define shammx_nosizeupdate_nofinalbyteswap shammx_nosizeupdate_nofinalbyteswap_VC
+#define shammx_noinit_uniformsizeupdate     shammx_noinit_uniformsizeupdate_VC
+#else
+extern int shammx(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+extern int shammx_nofinalbyteswap(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+extern int shammx_nosizeupdate(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+extern int shammx_nosizeupdate_nofinalbyteswap(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+extern int shammx_noinit_uniformsizeupdate(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+#endif
+#endif
+
+#endif
diff -rupN john-1.7.8/src/sha1-mmx.S john-1.7.8-jumbo-2/src/sha1-mmx.S
--- john-1.7.8/src/sha1-mmx.S	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/sha1-mmx.S	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,693 @@
+
+// extern int mdfourmmx(unsigned char *out, unsigned char *in, int n) __attribute__((regparm(3)));
+
+#include "arch.h"
+#ifdef UNDERSCORES
+#define shammx	_shammx
+#define shammx_nofinalbyteswap	_shammx_nofinalbyteswap
+#define shammx_nosizeupdate _shammx_nosizeupdate
+#define shammx_nosizeupdate_nofinalbyteswap _shammx_nosizeupdate_nofinalbyteswap
+#define shammx_noinit_uniformsizeupdate _shammx_noinit_uniformsizeupdate
+// These are the VC 'param marshalling' function stubs.  They are __fastcall functions, and have
+// to be 'properly' decorated with the @'s   The @12 trailing is due to 12 bytes of params.
+#ifdef __MINGW32__
+#define shammx_VC @shammx_VC@12
+#define shammx_nofinalbyteswap_VC	@shammx_nofinalbyteswap_VC@12
+#define shammx_nosizeupdate_VC @shammx_nosizeupdate_VC@12
+#define shammx_nosizeupdate_nofinalbyteswap_VC @shammx_nosizeupdate_nofinalbyteswap_VC@12
+#define shammx_noinit_uniformsizeupdate_VC @shammx_noinit_uniformsizeupdate_VC@12
+#endif
+
+#endif
+
+.globl shammx;
+.globl shammx_nofinalbyteswap
+.globl shammx_nosizeupdate;
+.globl shammx_nosizeupdate_nofinalbyteswap;
+.globl shammx_noinit_uniformsizeupdate;
+#ifdef __MINGW32__
+.globl shammx_VC;
+.globl shammx_nofinalbyteswap_VC;
+.globl shammx_nosizeupdate_VC;
+.globl shammx_nosizeupdate_nofinalbyteswap_VC;
+.globl shammx_noinit_uniformsizeupdate_VC;
+#endif
+
+.data
+#if defined (MD5_SSE_PARA) && !defined (MMX_COEF)
+#define MMX_COEF 4
+#endif
+#if defined (__MINGW32__)
+.align(4*MMX_COEF)
+#else
+.align(2*MMX_COEF)
+#endif
+const_init_a:
+.long 0x67452301
+.long 0x67452301
+#if (MMX_COEF>=4)
+.long 0x67452301
+.long 0x67452301
+#endif
+const_init_b:
+.long 0xefcdab89
+.long 0xefcdab89
+#if (MMX_COEF>=4)
+.long 0xefcdab89
+.long 0xefcdab89
+#endif
+const_init_c:
+.long 0x98badcfe
+.long 0x98badcfe
+#if (MMX_COEF>=4)
+.long 0x98badcfe
+.long 0x98badcfe
+#endif
+const_init_d:
+.long 0x10325476
+.long 0x10325476
+#if (MMX_COEF>=4)
+.long 0x10325476
+.long 0x10325476
+#endif
+const_init_e:
+.long 0xc3d2e1f0
+.long 0xc3d2e1f0
+#if (MMX_COEF>=4)
+.long 0xc3d2e1f0
+.long 0xc3d2e1f0
+#endif
+
+.align(2*MMX_COEF)
+const_stage0:
+.long 0x5a827999
+.long 0x5a827999
+#if (MMX_COEF>=4)
+.long 0x5a827999
+.long 0x5a827999
+#endif
+const_stage1:
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+#if (MMX_COEF>=4)
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+#endif
+const_stage2:
+.long 0x8f1bbcdc
+.long 0x8f1bbcdc
+#if (MMX_COEF>=4)
+.long 0x8f1bbcdc
+.long 0x8f1bbcdc
+#endif
+const_stage3:
+.long 0xca62c1d6
+.long 0xca62c1d6
+#if (MMX_COEF>=4)
+.long 0xca62c1d6
+.long 0xca62c1d6
+#endif
+
+.align(2*MMX_COEF)
+mask0f0f:
+.long 0x00ff00ff
+.long 0x00ff00ff
+#if (MMX_COEF>=4)
+.long 0x00ff00ff
+.long 0x00ff00ff
+#endif
+maskf0f0:
+.long 0xff00ff00
+.long 0xff00ff00
+#if (MMX_COEF>=4)
+.long 0xff00ff00
+.long 0xff00ff00
+#endif
+
+#if (MMX_COEF == 2)
+#define MMXMOVE movq
+#define REGMM0 %mm0
+#define REGMM1 %mm1
+#define REGMM2 %mm2
+#define REGMM3 %mm3
+#define REGMM4 %mm4
+#define REGMM5 %mm5
+#define REGMM6 %mm6
+#define REGMM7 %mm7
+storea: ; .long 0 ; .long 0
+storeb: ; .long 0 ; .long 0
+storec: ; .long 0 ; .long 0
+stored: ; .long 0 ; .long 0
+storee: ; .long 0 ; .long 0
+#else
+#define MMXMOVE movapd
+#define REGMM0 %xmm0
+#define REGMM1 %xmm1
+#define REGMM2 %xmm2
+#define REGMM3 %xmm3
+#define REGMM4 %xmm4
+#define REGMM5 %xmm5
+#define REGMM6 %xmm6
+#define REGMM7 %xmm7
+storea: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+storeb: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+storec: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+stored: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+storee: ; .long 0 ; .long 0 ; .long 0 ; .long 0
+#endif
+
+// if this is set to 1, final endianity byteswap is not done. Used to leave
+// a proper byte ordered 'binary residue', so that if we have to feed that
+// binary result back into SHA1, it will be 'valid'.  In other words, we
+// 'know' we are little endian, but we chose to leave it in big endian
+// because we will be using it as input to another round of sha1.
+nobytesswap: ; .long 0
+
+#define ctxa REGMM0
+#define ctxb REGMM1
+#define ctxc REGMM2
+#define ctxd REGMM3
+#define ctxe REGMM4
+#define tmp1 REGMM5
+#define tmp2 REGMM6
+#define tmp3 REGMM7
+
+//ft(x,y,z) = (x AND y) OR ((NOT x) AND z) ( 0 <= t <= 19)
+#define F0(x,y,z) \
+	MMXMOVE x, tmp2; \
+	MMXMOVE x, tmp1; \
+	pand y, tmp2; \
+	pandn z, tmp1; \
+	por tmp2, tmp1;
+
+//ft(x,y,z) = x XOR y XOR z (20 <= t <= 39)
+#define F1(x,y,z) \
+	MMXMOVE z, tmp1; \
+	pxor y, tmp1; \
+	pxor x, tmp1
+
+//ft(x,y,z) = (x AND y) OR (x AND z) OR (y AND z) (40 <= t <= 59)
+//ft(x,y,z) = (x AND y) | ((x OR y) AND z) (40 <= t <= 59)
+#define F2(x,y,z) \
+	MMXMOVE x, tmp1; \
+	MMXMOVE x, tmp2; \
+	pand y, tmp1; \
+	por y, tmp2; \
+	pand z, tmp2; \
+	por tmp2, tmp1;
+
+//ft(x,y,z) = x XOR y XOR z (60 <= t <= 79).  = la seconde
+
+
+#define expand(t) \
+	MMXMOVE ((t-3)*4*MMX_COEF)(%edx), tmp1; \
+	pxor ((t-8)*4*MMX_COEF)(%edx), tmp1; \
+	pxor ((t-14)*4*MMX_COEF)(%edx), tmp1; \
+	pxor ((t-16)*4*MMX_COEF)(%edx), tmp1; \
+	MMXMOVE tmp1, tmp2; \
+	pslld $1, tmp1; \
+	psrld $31, tmp2; \
+	por tmp2, tmp1; \
+	MMXMOVE tmp1, (t*4*MMX_COEF)(%edx)
+
+#define subRound(a, b, c, d, e, f, k, data) \
+	f(b,c,d); \
+	MMXMOVE a, tmp2; \
+	MMXMOVE a, tmp3; \
+	paddd tmp1, e; \
+	pslld $5, tmp2; \
+	psrld $27, tmp3; \
+	por tmp3, tmp2; \
+	paddd tmp2, e; \
+	MMXMOVE b, tmp2; \
+	pslld $30, b; \
+	paddd k, e; \
+	paddd (data*4*MMX_COEF)(%edx), e; \
+	psrld $2, tmp2; \
+	por tmp2, b;
+
+#define subRoundu(a, b, c, d, e, f, k, data) \
+	expand(data); \
+	paddd tmp1, e; \
+	f(b,c,d); \
+	MMXMOVE a, tmp2; \
+	MMXMOVE a, tmp3; \
+	paddd tmp1, e; \
+	pslld $5, tmp2; \
+	psrld $27, tmp3; \
+	por tmp3, tmp2; \
+	paddd tmp2, e; \
+	MMXMOVE b, tmp2; \
+	pslld $30, b; \
+	paddd k, e; \
+	psrld $2, tmp2; \
+	por tmp2, b;
+
+.text
+/*
+ * Try to do some asm md4 w/ mmx
+ * %eax ptr -> out
+ * %edx ptr -> in (80*MMX_WIDTH mots)
+ * %ecx n
+ */
+
+init_ctx:
+	MMXMOVE const_init_a, ctxa
+	MMXMOVE const_init_b, ctxb
+	MMXMOVE const_init_c, ctxc
+	MMXMOVE const_init_d, ctxd
+	MMXMOVE const_init_e, ctxe
+	ret
+
+sizeupdate:
+	 //MD4 Init
+#if (MMX_COEF == 2)
+	shl $3, %ecx
+	mov %ecx, %ebx
+	and $0xffff, %ecx
+	shrl $16,  %ebx
+	// %ecx contient la taille du premier mdp
+	// %edx celle du second
+	mov %ecx, (15*4*MMX_COEF)(%edx)
+	mov %ebx, (15*4*MMX_COEF+4)(%edx)
+#else
+	mov %ecx, %ebx
+        shr $8, %ecx
+        and $0xff, %ebx
+        shl $3, %ebx
+        mov %ebx, (15*16)(%edx)
+
+        mov %ecx, %ebx
+        shr $8, %ecx
+        and $0xff, %ebx
+        shl $3, %ebx
+        mov %ebx, (15*16+4)(%edx)
+
+        mov %ecx, %ebx
+        shr $8, %ecx
+        and $0xff, %ebx
+        shl $3, %ebx
+        mov %ebx, (15*16+8)(%edx)
+
+        and $0xff, %ecx
+        shl $3, %ecx
+        mov %ecx, (15*16+12)(%edx)
+#endif
+	ret
+
+
+uniformsizeupdate:
+	shl $3, %ecx
+	mov %ecx, (14*4*MMX_COEF)(%edx)
+	mov %ecx, (14*4*MMX_COEF+4)(%edx)
+#if (MMX_COEF == 4)
+	mov %ecx, (14*4*MMX_COEF+8)(%edx)
+	mov %ecx, (14*4*MMX_COEF+12)(%edx)
+#endif
+	ret
+
+
+shammx_noinit_sizeupdate:
+	pusha
+	call sizeupdate
+	jmp shammx_noinit
+
+shammx_noinit_uniformsizeupdate:
+	pusha
+	call uniformsizeupdate
+	jmp shammx_noinit
+
+shammx:
+	pusha
+	call sizeupdate
+	call init_ctx
+	jmp shammx_noinit
+
+shammx_nosizeupdate_nofinalbyteswap:
+	pusha
+	call init_ctx
+	movl $1, nobytesswap
+	jmp shammx_noinit
+
+shammx_nofinalbyteswap:
+	pusha
+	call sizeupdate
+	call init_ctx
+	movl $1, nobytesswap
+	jmp shammx_noinit
+
+shammx_nosizeupdate:
+	pusha
+	call init_ctx
+	jmp shammx_noinit
+
+#ifdef __MINGW32__
+// These are 'magic' param marshalling calls.  I am using VC with __fastcall
+// syntax.  For that, the edx is correct.  The stack has what should go into
+// ecx on it, THEN the return.  Thus, since we do the pusha here, the popa
+// at the end of the mdfilemmx_noinit function, and return from there, we
+// MUST return back here, and handle the return with a ret $4.  Thus the
+// small amount of monkeying around.  The overhead is very minimal, only an
+// op or 2 more than the 'native' __atribute(param(3)) type.
+shammx_noinit_uniformsizeupdate_VC:
+    lea shammx_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call uniformsizeupdate
+    jmp shammx_noinit
+
+shammx_VC:
+    lea shammx_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call sizeupdate
+    call init_ctx
+    jmp shammx_noinit
+shammx_VC_exit:
+    ret $4
+
+shammx_nofinalbyteswap_VC:
+    lea shammx_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call sizeupdate
+    call init_ctx
+	movl $1, nobytesswap
+    jmp shammx_noinit
+
+shammx_nosizeupdate_nofinalbyteswap_VC:
+    lea shammx_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call init_ctx
+	movl $1, nobytesswap
+    jmp shammx_noinit
+
+
+shammx_nosizeupdate_VC:
+    lea shammx_VC_exit, %eax
+    push %eax
+    pusha
+    mov %ecx, %eax
+    mov 40(%esp), %ecx
+    call init_ctx
+    jmp shammx_noinit
+#endif
+
+shammx_noinit:
+	MMXMOVE ctxa, storea
+	MMXMOVE ctxb, storeb
+	MMXMOVE ctxc, storec
+	MMXMOVE ctxd, stored
+	MMXMOVE ctxe, storee
+
+round0:
+	prefetchnta (%edx)
+	subRound( ctxa, ctxb, ctxc, ctxd, ctxe, F0, const_stage0,  0 );
+	subRound( ctxe, ctxa, ctxb, ctxc, ctxd, F0, const_stage0,  1 );
+	subRound( ctxd, ctxe, ctxa, ctxb, ctxc, F0, const_stage0,  2 );
+	subRound( ctxc, ctxd, ctxe, ctxa, ctxb, F0, const_stage0,  3 );
+	subRound( ctxb, ctxc, ctxd, ctxe, ctxa, F0, const_stage0,  4 );
+	subRound( ctxa, ctxb, ctxc, ctxd, ctxe, F0, const_stage0,  5 );
+	subRound( ctxe, ctxa, ctxb, ctxc, ctxd, F0, const_stage0,  6 );
+	subRound( ctxd, ctxe, ctxa, ctxb, ctxc, F0, const_stage0,  7 );
+	subRound( ctxc, ctxd, ctxe, ctxa, ctxb, F0, const_stage0,  8 );
+	subRound( ctxb, ctxc, ctxd, ctxe, ctxa, F0, const_stage0,  9 );
+	subRound( ctxa, ctxb, ctxc, ctxd, ctxe, F0, const_stage0, 10 );
+	subRound( ctxe, ctxa, ctxb, ctxc, ctxd, F0, const_stage0, 11 );
+	subRound( ctxd, ctxe, ctxa, ctxb, ctxc, F0, const_stage0, 12 );
+	subRound( ctxc, ctxd, ctxe, ctxa, ctxb, F0, const_stage0, 13 );
+	subRound( ctxb, ctxc, ctxd, ctxe, ctxa, F0, const_stage0, 14 );
+	subRound( ctxa, ctxb, ctxc, ctxd, ctxe, F0, const_stage0, 15 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F0, const_stage0, 16 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F0, const_stage0, 17 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F0, const_stage0, 18 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F0, const_stage0, 19 );
+
+round1:
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage1, 20 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage1, 21 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage1, 22 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage1, 23 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage1, 24 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage1, 25 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage1, 26 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage1, 27 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage1, 28 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage1, 29 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage1, 30 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage1, 31 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage1, 32 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage1, 33 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage1, 34 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage1, 35 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage1, 36 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage1, 37 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage1, 38 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage1, 39 );
+
+round2:
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F2, const_stage2, 40 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F2, const_stage2, 41 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F2, const_stage2, 42 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F2, const_stage2, 43 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F2, const_stage2, 44 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F2, const_stage2, 45 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F2, const_stage2, 46 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F2, const_stage2, 47 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F2, const_stage2, 48 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F2, const_stage2, 49 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F2, const_stage2, 50 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F2, const_stage2, 51 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F2, const_stage2, 52 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F2, const_stage2, 53 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F2, const_stage2, 54 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F2, const_stage2, 55 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F2, const_stage2, 56 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F2, const_stage2, 57 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F2, const_stage2, 58 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F2, const_stage2, 59 );
+
+round3:
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage3, 60 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage3, 61 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage3, 62 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage3, 63 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage3, 64 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage3, 65 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage3, 66 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage3, 67 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage3, 68 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage3, 69 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage3, 70 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage3, 71 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage3, 72 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage3, 73 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage3, 74 );
+	subRoundu( ctxa, ctxb, ctxc, ctxd, ctxe, F1, const_stage3, 75 );
+	subRoundu( ctxe, ctxa, ctxb, ctxc, ctxd, F1, const_stage3, 76 );
+	subRoundu( ctxd, ctxe, ctxa, ctxb, ctxc, F1, const_stage3, 77 );
+	subRoundu( ctxc, ctxd, ctxe, ctxa, ctxb, F1, const_stage3, 78 );
+	subRoundu( ctxb, ctxc, ctxd, ctxe, ctxa, F1, const_stage3, 79 );
+
+	paddd storea, ctxa
+	paddd storeb, ctxb
+	paddd storec, ctxc
+	paddd stored, ctxd
+	paddd storee, ctxe
+	MMXMOVE ctxa, storea
+	MMXMOVE ctxb, storeb
+	MMXMOVE ctxc, storec
+	MMXMOVE ctxd, stored
+	MMXMOVE ctxe, storee
+
+	cmpl $1, nobytesswap
+	je  skip_endianity
+	jmp endianity
+
+skip_endianity:
+// for encryption that will re-encrypt the 'raw-sha1' binary data, we do NOT want to
+// change endianity.  We simply want to dump that data. This will allow sha1(binary(sha1($P)))^N
+// to be done, without double endianity changing between the sha calls.
+	MMXMOVE ctxa, 0(%eax)
+	MMXMOVE ctxb, 4*MMX_COEF(%eax)
+	MMXMOVE ctxc, 8*MMX_COEF(%eax)
+	MMXMOVE ctxd, 12*MMX_COEF(%eax)
+	MMXMOVE ctxe, 16*MMX_COEF(%eax)
+
+	popa
+	emms
+	// clear the nobyteswap variable. This is done, so that if the next call is to sha1mmx, that
+	// the proper endianity is done.
+	movl $0, nobytesswap
+	ret
+
+endianity:
+
+//reverse indianity w/ rotate & and
+//mmx has no rotate instructions ..
+#define ENDIAN(a) \
+	MMXMOVE a, tmp1; \
+	MMXMOVE maskf0f0, tmp3; \
+	pand tmp3, a; \
+	MMXMOVE mask0f0f, tmp3; \
+	pand tmp3, tmp1; \
+	psrld $8, a; \
+	pslld $8, tmp1; \
+	por tmp1, a; \
+	MMXMOVE a, tmp1; \
+	psrld $16, a; \
+	pslld $16, tmp1; \
+	por tmp1, a
+
+// why is this so slow ?
+#define ENDIAN2(a) \
+	pshuflw $177,a,a; \
+	pshufhw $177,a,a; \
+	movq a,tmp1; \
+	pand maskf0f0, a; \
+	pand mask0f0f, tmp1; \
+	psrld $8, a; \
+	pslld $8, tmp1; \
+	por tmp1, a
+
+//changes indianity ...
+	MMXMOVE maskf0f0, tmp3
+	MMXMOVE ctxa, tmp1
+	MMXMOVE ctxb, tmp2
+	pand tmp3, ctxa
+	pand tmp3, ctxb
+	MMXMOVE mask0f0f, tmp3
+	pand tmp3, tmp1
+	pand tmp3, tmp2
+	psrld $8, ctxa
+	psrld $8, ctxb
+	pslld $8, tmp1
+	pslld $8, tmp2
+	por tmp1, ctxa
+	por tmp2, ctxb
+	MMXMOVE ctxa, tmp1
+	MMXMOVE ctxb, tmp2
+	psrld $16, ctxa
+	psrld $16, ctxb
+	pslld $16, tmp1
+	pslld $16, tmp2
+	por tmp1, ctxa
+	por tmp2, ctxb
+	MMXMOVE ctxa, 0(%eax)
+	MMXMOVE ctxb, 4*MMX_COEF(%eax)
+
+
+//now 2 more register to play with ..
+#define tmp4 ctxa
+#define tmp5 ctxb
+
+	MMXMOVE maskf0f0, tmp5
+	MMXMOVE ctxc, tmp1
+	MMXMOVE ctxd, tmp2
+	MMXMOVE ctxe, tmp3
+	pand tmp5, ctxc
+	pand tmp5, ctxd
+	pand tmp5, ctxe
+	MMXMOVE mask0f0f, tmp5
+	pand tmp5, tmp1
+	pand tmp5, tmp2
+	pand tmp5, tmp3
+	psrld $8, ctxc
+	psrld $8, ctxd
+	psrld $8, ctxe
+	pslld $8, tmp1
+	pslld $8, tmp2
+	pslld $8, tmp3
+	por tmp1, ctxc
+	por tmp2, ctxd
+	por tmp3, ctxe
+	MMXMOVE ctxc, tmp1
+	MMXMOVE ctxd, tmp2
+	MMXMOVE ctxe, tmp3
+	psrld $16, ctxc
+	psrld $16, ctxd
+	psrld $16, ctxe
+	pslld $16, tmp1
+	pslld $16, tmp2
+	pslld $16, tmp3
+	por tmp1, ctxc
+	por tmp2, ctxd
+	por tmp3, ctxe
+
+	MMXMOVE ctxc, 8*MMX_COEF(%eax)
+	MMXMOVE ctxd, 12*MMX_COEF(%eax)
+	MMXMOVE ctxe, 16*MMX_COEF(%eax)
+
+	//mov %ecx, %eax
+	//movd ctxe, %eax
+	popa
+	emms
+
+	ret
+
+/*
+ alternate endianity conversion
+ shouldn't be so slow ...
+	pshuflw $177, ctxa, ctxa
+	pshuflw $177, ctxb, ctxb
+	pshuflw $177, ctxc, ctxc
+	pshuflw $177, ctxd, ctxd
+	pshuflw $177, ctxe, ctxe
+	movq maskf0f0, tmp3
+	pshufhw $177, ctxa, ctxa
+	pshufhw $177, ctxb, ctxb
+	pshufhw $177, ctxc, ctxc
+	pshufhw $177, ctxd, ctxd
+	pshufhw $177, ctxe, ctxe
+	movq ctxa, tmp1
+	movq ctxb, tmp2
+	pand tmp3, ctxa
+	pand tmp3, ctxb
+	movq mask0f0f, tmp3
+	pand tmp3, tmp1
+	pand tmp3, tmp2
+	psrld $8, ctxa
+	psrld $8, ctxb
+	pslld $8, tmp1
+	pslld $8, tmp2
+	por tmp1, ctxa
+	por tmp2, ctxb
+	MMXMOVE ctxa, 0(%eax)
+	MMXMOVE ctxb, 4*MMX_COEF(%eax)
+
+//now 2 more register to play with ..
+#define tmp4 ctxa
+#define tmp5 ctxb
+	movq ctxc, tmp1
+	movq ctxd, tmp2
+	movq ctxe, tmp4
+	pand tmp3, tmp1
+	pand tmp3, tmp2
+	pand tmp3, tmp4
+	movq maskf0f0, tmp3
+	pand tmp3, ctxc
+	pand tmp3, ctxd
+	pand tmp3, ctxe
+	psrld $8, ctxc
+	psrld $8, ctxd
+	psrld $8, ctxe
+	pslld $8, tmp1
+	pslld $8, tmp2
+	pslld $8, tmp4
+	por tmp1, ctxc
+	por tmp2, ctxd
+	por tmp4, ctxe
+*/
+
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",@progbits
+#endif
diff -rupN john-1.7.8/src/sha1_gen_fmt_plug.c john-1.7.8-jumbo-2/src/sha1_gen_fmt_plug.c
--- john-1.7.8/src/sha1_gen_fmt_plug.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/sha1_gen_fmt_plug.c	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,253 @@
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 2010 by Solar Designer
+ */
+
+#include <string.h>
+#include <openssl/sha.h>
+
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL			"sha1-gen"
+#define FORMAT_NAME			"Generic salted SHA-1"
+#define ALGORITHM_NAME			"32/" ARCH_BITS_STR
+
+#define BENCHMARK_COMMENT		""
+#define BENCHMARK_LENGTH		0
+
+#define PLAINTEXT_LENGTH		125
+#define CIPHERTEXT_LENGTH		40
+
+#define BINARY_SIZE			20
+#define SALT_SIZE			64 /* length + type + 62 chars */
+
+#define MIN_KEYS_PER_CRYPT		1
+#define MAX_KEYS_PER_CRYPT		1
+
+static struct fmt_tests tests[] = {
+	{"$SHA1p$salt$59b3e8d637cf97edbe2384cf59cb7453dfe30789", "password"},
+	{"$SHA1s$salt$c88e9c67041a74e0357befdff93f87dde0904214", "password"},
+	{NULL}
+};
+
+static char saved_salt[SALT_SIZE];
+static int saved_key_length;
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static SHA_CTX ctx;
+static ARCH_WORD_32 crypt_out[5];
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	char *p, *q;
+
+	if (strncmp(ciphertext, "$SHA1", 5) ||
+	    (ciphertext[5] != 'p' && ciphertext[5] != 's') ||
+	    ciphertext[6] != '$')
+		return 0;
+
+	p = strrchr(ciphertext, '$');
+	if (!p || /* can't happen */
+	    p - ciphertext < 7 || /* must not be the 1st or 2nd '$' */
+	    p - ciphertext > 7 + SALT_SIZE - 2)
+		return 0;
+
+	q = ++p;
+	while (atoi16[ARCH_INDEX(*q)] != 0x7F)
+		q++;
+	return !*q && q - p == CIPHERTEXT_LENGTH;
+}
+
+static void *get_binary(char *ciphertext)
+{
+	static unsigned char out[BINARY_SIZE];
+	char *p;
+	int i;
+
+	p = strrchr(ciphertext, '$') + 1;
+	for (i = 0; i < sizeof(out); i++) {
+		out[i] =
+		    (atoi16[ARCH_INDEX(*p)] << 4) |
+		    atoi16[ARCH_INDEX(p[1])];
+		p += 2;
+	}
+
+	return out;
+}
+
+static void *salt(char *ciphertext)
+{
+	static unsigned char out[SALT_SIZE];
+	char *p;
+	int length;
+
+	memset(out, 0, sizeof(out));
+	p = ciphertext + 7;
+	length = strrchr(ciphertext, '$') - p;
+	out[0] = length;
+	out[1] = ciphertext[5];
+	memcpy(out + 2, p, length);
+
+	return out;
+}
+
+static int binary_hash_0(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xF;
+}
+
+static int binary_hash_1(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFF;
+}
+
+static int binary_hash_2(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFF;
+}
+
+static int binary_hash_3(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFF;
+}
+
+static int binary_hash_4(void *binary)
+{
+	return *(ARCH_WORD_32 *)binary & 0xFFFFF;
+}
+
+static int get_hash_0(int index)
+{
+	return crypt_out[0] & 0xF;
+}
+
+static int get_hash_1(int index)
+{
+	return crypt_out[0] & 0xFF;
+}
+
+static int get_hash_2(int index)
+{
+	return crypt_out[0] & 0xFFF;
+}
+
+static int get_hash_3(int index)
+{
+	return crypt_out[0] & 0xFFFF;
+}
+
+static int get_hash_4(int index)
+{
+	return crypt_out[0] & 0xFFFFF;
+}
+
+static int salt_hash(void *salt)
+{
+	unsigned int hash = 0;
+	char *p = (char *)salt;
+
+	while (*p) {
+		hash <<= 1;
+		hash += (unsigned char)*p++;
+		if (hash >> 10) {
+			hash ^= hash >> 10;
+			hash &= 0x3FF;
+		}
+	}
+
+	hash ^= hash >> 10;
+	hash &= 0x3FF;
+
+	return hash;
+}
+
+static void set_salt(void *salt)
+{
+	memcpy(saved_salt, salt, *(unsigned char *)salt + 2);
+}
+
+static void set_key(char *key, int index)
+{
+	saved_key_length = strlen(key);
+	if (saved_key_length > PLAINTEXT_LENGTH)
+		saved_key_length = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, saved_key_length);
+}
+
+static char *get_key(int index)
+{
+	saved_key[saved_key_length] = 0;
+	return saved_key;
+}
+
+static void crypt_all(int count)
+{
+	SHA1_Init(&ctx);
+	if (saved_salt[1] == 'p') {
+		SHA1_Update(&ctx, &saved_salt[2], (unsigned char)saved_salt[0]);
+		SHA1_Update(&ctx, saved_key, saved_key_length);
+	} else {
+		SHA1_Update(&ctx, saved_key, saved_key_length);
+		SHA1_Update(&ctx, &saved_salt[2], (unsigned char)saved_salt[0]);
+	}
+	SHA1_Final((unsigned char *)crypt_out, &ctx);
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return !memcmp(binary, crypt_out, BINARY_SIZE);
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_sha1_gen = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		tests
+	}, {
+		fmt_default_init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		get_binary,
+		salt,
+		{
+			binary_hash_0,
+			binary_hash_1,
+			binary_hash_2,
+			binary_hash_3,
+			binary_hash_4
+		},
+		salt_hash,
+		set_salt,
+		set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			get_hash_0,
+			get_hash_1,
+			get_hash_2,
+			get_hash_3,
+			get_hash_4
+		},
+		cmp_all,
+		cmp_all,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/signals.c john-1.7.8-jumbo-2/src/signals.c
--- john-1.7.8/src/signals.c	2011-03-26 07:15:13.000000000 +0100
+++ john-1.7.8-jumbo-2/src/signals.c	2011-05-25 18:41:37.000000000 +0200
@@ -1,8 +1,19 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2003,2006,2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC, by JimF.
  */
 
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
+#if defined (__MINGW32__) || defined (_MSC_VER)
+#define __CYGWIN32__
+#define SIGALRM SIGFPE
+#define SIGHUP SIGILL
+#endif
+
 #define _XOPEN_SOURCE 500 /* for setitimer(2) and siginterrupt(3) */
 
 #ifdef __ultrix__
@@ -14,11 +25,13 @@
 #include <limits.h>
 #endif
 #include <stdio.h>
+#if !defined (_MSC_VER)
+#include <sys/time.h>
 #include <unistd.h>
+#endif
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
-#include <sys/time.h>
 #include <errno.h>
 
 #ifdef __DJGPP__
@@ -46,7 +59,9 @@ static clock_t timer_ticksafety_interval
 #if !OS_TIMER
 
 #include <time.h>
+#if !defined (__MINGW32__) && !defined (_MSC_VER)
 #include <sys/times.h>
+#endif
 
 static clock_t timer_emu_interval = 0;
 static unsigned int timer_emu_count = 0, timer_emu_max = 0;
@@ -61,11 +76,17 @@ void sig_timer_emu_tick(void)
 {
 	static clock_t last = 0;
 	clock_t current;
+#if !defined (__MINGW32__) && !defined (_MSC_VER)
 	struct tms buf;
+#endif
 
 	if (++timer_emu_count < timer_emu_max) return;
 
+#if defined (__MINGW32__) || defined (_MSC_VER)
+	current = clock();
+#else
 	current = times(&buf);
+#endif
 
 	if (!last) {
 		last = current;
@@ -92,6 +113,9 @@ static void sig_handle_update(int signum
 {
 	event_save = event_pending = 1;
 
+#ifdef HAVE_MPI
+	event_status = 1;
+#endif
 #ifndef SA_RESTART
 	sig_install_update();
 #endif
@@ -106,14 +130,23 @@ static void sig_install_update(void)
 	sa.sa_handler = sig_handle_update;
 	sa.sa_flags = SA_RESTART;
 	sigaction(SIGHUP, &sa, NULL);
+#ifdef HAVE_MPI
+	sigaction(SIGUSR1, &sa, NULL);
+#endif /* HAVE_MPI */
 #else
 	signal(SIGHUP, sig_handle_update);
+#ifdef HAVE_MPI
+	signal(SIGUSR1, sig_handle_update);
+#endif /* HAVE_MPI */
 #endif
 }
 
 static void sig_remove_update(void)
 {
 	signal(SIGHUP, SIG_IGN);
+#ifdef HAVE_MPI
+	signal(SIGUSR1, SIG_DFL);
+#endif
 }
 
 void check_abort(int be_async_signal_safe)
@@ -124,6 +157,12 @@ void check_abort(int be_async_signal_saf
 
 	if (be_async_signal_safe) {
 		write_loop(2, "Session aborted\n", 16);
+#if defined(HAVE_MPI) && defined(JOHN_MPI_ABORT)
+		if (mpi_p > 1) {
+			write_loop(2, "Aborting other nodes...\n", 24);
+			MPI_Abort(MPI_COMM_WORLD,1);
+		}
+#endif
 		_exit(1);
 	}
 
@@ -149,12 +188,20 @@ static void sig_handle_abort(int signum)
 }
 
 #ifdef __CYGWIN32__
+#if defined (_MSC_VER)
+static BOOL WINAPI sig_handle_abort_ctrl(DWORD ctrltype)
+{
+	sig_handle_abort(SIGINT);
+	return TRUE;
+}
+#else
 static CALLBACK BOOL sig_handle_abort_ctrl(DWORD ctrltype)
 {
 	sig_handle_abort(SIGINT);
 	return TRUE;
 }
 #endif
+#endif
 
 static void sig_install_abort(void)
 {
@@ -167,7 +214,9 @@ static void sig_install_abort(void)
 #endif
 
 	signal(SIGINT, sig_handle_abort);
+#ifndef HAVE_MPI
 	signal(SIGTERM, sig_handle_abort);
+#endif
 #ifdef SIGXCPU
 	signal(SIGXCPU, sig_handle_abort);
 #endif
@@ -183,7 +232,9 @@ static void sig_remove_abort(void)
 #endif
 
 	signal(SIGINT, SIG_DFL);
+#ifndef HAVE_MPI
 	signal(SIGTERM, SIG_DFL);
+#endif
 #ifdef SIGXCPU
 	signal(SIGXCPU, SIG_DFL);
 #endif
diff -rupN john-1.7.8/src/signals.h john-1.7.8-jumbo-2/src/signals.h
--- john-1.7.8/src/signals.h	2006-02-27 07:28:54.000000000 +0100
+++ john-1.7.8-jumbo-2/src/signals.h	2011-05-17 18:13:03.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2006 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC, by JimF.
  */
 
 /*
@@ -29,7 +31,11 @@ extern volatile int event_ticksafety;	/*
 /*
  * Timer emulation for systems with no setitimer(2).
  */
+#if defined (__MINGW32__) || defined (_MSC_VER)
+#include <time.h>
+#else
 #include <sys/times.h>
+#endif
 
 extern void sig_timer_emu_init(clock_t interval);
 extern void sig_timer_emu_tick(void);
diff -rupN john-1.7.8/src/single.c john-1.7.8-jumbo-2/src/single.c
--- john-1.7.8/src/single.c	2010-07-12 04:05:28.000000000 +0200
+++ john-1.7.8-jumbo-2/src/single.c	2011-06-08 01:57:38.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003,2004,2006,2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by JimF.
  */
 
 #include <stdio.h>
@@ -18,6 +20,9 @@
 #include "rules.h"
 #include "external.h"
 #include "cracker.h"
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+#endif
 
 static int progress = 0;
 static int rec_rule;
@@ -49,10 +54,16 @@ static int restore_state(FILE *file)
 	return restore_rule_number();
 }
 
-static int get_progress(void)
+static int get_progress(int *hundth)
 {
-	if (progress) return progress;
+	if (progress) {
+		if (hundth)
+			*hundth = 0;
+		return progress;
+	}
 
+	if (hundth)
+		*hundth = (rule_number * 10000 / (rule_count + 1)) % 100;
 	return rule_number * 100 / (rule_count + 1);
 }
 
@@ -88,7 +99,7 @@ static void single_init(void)
 	key_count = single_db->format->params.min_keys_per_crypt;
 	if (key_count < SINGLE_HASH_MIN) key_count = SINGLE_HASH_MIN;
 
-	if (rpp_init(rule_ctx, SUBSECTION_SINGLE)) {
+	if (rpp_init(rule_ctx, single_db->options->activesinglerules)) {
 		log_event("! No \"single crack\" mode rules found");
 		fprintf(stderr, "No \"single crack\" mode rules found in %s\n",
 			cfg_name);
@@ -101,6 +112,16 @@ static void single_init(void)
 
 	log_event("- %d preprocessed word mangling rules", rule_count);
 
+#ifdef HAVE_MPI
+	if (mpi_p > 1) {
+		log_event("MPI hack active: processsing 1/%d of rules, total %d for "
+		    "this node", mpi_p, (rule_count / mpi_p) +
+		    (rule_count % mpi_p > mpi_id ? 1 : 0));
+		if (mpi_id == 0) fprintf(stderr,"MPI: each node processing 1/%d of %d "
+		    "rules. (%seven split)\n",
+		    mpi_p, rule_count, rule_count % mpi_p ? "un" : "");
+	}
+#endif
 	status_init(get_progress, 0);
 
 	rec_restore_mode(restore_state);
@@ -384,6 +405,13 @@ static void single_run(void)
 
 	saved_min = rec_rule;
 	while ((prerule = rpp_next(rule_ctx))) {
+#ifdef HAVE_MPI
+		// MPI distribution: leapfrog rules
+		if (rule_number % mpi_p != mpi_id) {
+			rule_number++;
+			continue;
+		}
+#endif
 		if (!(rule = rules_reject(prerule, 0, NULL, single_db))) {
 			log_event("- Rule #%d: '%.100s' rejected",
 				++rule_number, prerule);
@@ -444,7 +472,7 @@ static void single_done(void)
 			} while ((salt = salt->next));
 		}
 
-		progress = 100;
+		progress = 100; // For reporting DONE when finished
 	}
 
 	rec_done(event_abort || (status.pass && single_db->salts));
diff -rupN john-1.7.8/src/sse-intrinsics.c john-1.7.8-jumbo-2/src/sse-intrinsics.c
--- john-1.7.8/src/sse-intrinsics.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/sse-intrinsics.c	2011-06-08 04:17:11.000000000 +0200
@@ -0,0 +1,722 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+
+#include "arch.h"
+#include <string.h>
+#include <emmintrin.h>
+#include "memory.h"
+#include "md5.h"
+#define MD5_in_sse_intrinsics
+#include "MD5_std.h"
+#undef MD5_in_sse_intrinsics
+
+#ifndef MMX_COEF
+#define MMX_COEF 4
+#endif
+
+#define MD5_SSE_NUM_KEYS	(MMX_COEF*MD5_SSE_PARA)
+#define MD5_PARA_DO(x)	for((x)=0;(x)<MD5_SSE_PARA;(x)++)
+
+#define MD5_F(x,y,z) \
+	MD5_PARA_DO(i) tmp[i] = _mm_xor_si128((y[i]),(z[i])); \
+	MD5_PARA_DO(i) tmp[i] = _mm_and_si128((tmp[i]),(x[i])); \
+	MD5_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]),(z[i]));
+
+#define MD5_G(x,y,z) \
+	MD5_PARA_DO(i) tmp[i] = _mm_xor_si128((y[i]),(x[i])); \
+	MD5_PARA_DO(i) tmp[i] = _mm_and_si128((tmp[i]),(z[i])); \
+	MD5_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]), (y[i]) );
+
+#define MD5_H(x,y,z) \
+	MD5_PARA_DO(i) tmp[i] = _mm_xor_si128((y[i]),(z[i])); \
+	MD5_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]),(x[i]));
+
+#define MD5_I(x,y,z) \
+	MD5_PARA_DO(i) tmp[i] = _mm_andnot_si128((z[i]), mask); \
+	MD5_PARA_DO(i) tmp[i] = _mm_or_si128((tmp[i]),(x[i])); \
+	MD5_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]),(y[i]));
+
+#define MD5_STEP(f, a, b, c, d, x, t, s) \
+	MD5_PARA_DO(i) a[i] = _mm_add_epi32( a[i], _mm_set_epi32(t,t,t,t) ); \
+	f((b),(c),(d)) \
+	MD5_PARA_DO(i) a[i] = _mm_add_epi32( a[i], tmp[i] ); \
+	MD5_PARA_DO(i) a[i] = _mm_add_epi32( a[i], data[i*16+x] ); \
+	MD5_PARA_DO(i) a[i] = _mm_or_si128(_mm_slli_epi32((a[i]), (s)), _mm_srli_epi32((a[i]), 32-(s))); \
+	MD5_PARA_DO(i) a[i] = _mm_add_epi32( a[i], b[i] );
+
+unsigned int debug = 0;
+
+void sse_debug(void)
+{
+	debug = 1;
+}
+
+void SSEmd5body(__m128i* data, unsigned int * out, int init)
+{
+	__m128i a[MD5_SSE_PARA];
+	__m128i b[MD5_SSE_PARA];
+	__m128i c[MD5_SSE_PARA];
+	__m128i d[MD5_SSE_PARA];
+	__m128i tmp[MD5_SSE_PARA];
+	__m128i mask;
+	unsigned int i;
+
+	mask = _mm_set1_epi32(0Xffffffff);
+
+	if(init)
+	{
+		MD5_PARA_DO(i)
+		{
+			a[i] = _mm_set1_epi32(0x67452301);
+			b[i] = _mm_set1_epi32(0xefcdab89);
+			c[i] = _mm_set1_epi32(0x98badcfe);
+			d[i] = _mm_set1_epi32(0x10325476);
+		}
+	}
+	else
+	{
+		MD5_PARA_DO(i)
+		{
+			a[i] = _mm_load_si128((__m128i *)&out[i*16+0]);
+			b[i] = _mm_load_si128((__m128i *)&out[i*16+4]);
+			c[i] = _mm_load_si128((__m128i *)&out[i*16+8]);
+			d[i] = _mm_load_si128((__m128i *)&out[i*16+12]);
+		}
+	}
+
+/* Round 1 */
+		MD5_STEP(MD5_F, a, b, c, d, 0, 0xd76aa478, 7)
+		MD5_STEP(MD5_F, d, a, b, c, 1, 0xe8c7b756, 12)
+		MD5_STEP(MD5_F, c, d, a, b, 2, 0x242070db, 17)
+		MD5_STEP(MD5_F, b, c, d, a, 3, 0xc1bdceee, 22)
+		MD5_STEP(MD5_F, a, b, c, d, 4, 0xf57c0faf, 7)
+		MD5_STEP(MD5_F, d, a, b, c, 5, 0x4787c62a, 12)
+		MD5_STEP(MD5_F, c, d, a, b, 6, 0xa8304613, 17)
+		MD5_STEP(MD5_F, b, c, d, a, 7, 0xfd469501, 22)
+		MD5_STEP(MD5_F, a, b, c, d, 8, 0x698098d8, 7)
+		MD5_STEP(MD5_F, d, a, b, c, 9, 0x8b44f7af, 12)
+		MD5_STEP(MD5_F, c, d, a, b, 10, 0xffff5bb1, 17)
+		MD5_STEP(MD5_F, b, c, d, a, 11, 0x895cd7be, 22)
+		MD5_STEP(MD5_F, a, b, c, d, 12, 0x6b901122, 7)
+		MD5_STEP(MD5_F, d, a, b, c, 13, 0xfd987193, 12)
+		MD5_STEP(MD5_F, c, d, a, b, 14, 0xa679438e, 17)
+		MD5_STEP(MD5_F, b, c, d, a, 15, 0x49b40821, 22)
+
+/* Round 2 */
+		MD5_STEP(MD5_G, a, b, c, d, 1, 0xf61e2562, 5)
+		MD5_STEP(MD5_G, d, a, b, c, 6, 0xc040b340, 9)
+		MD5_STEP(MD5_G, c, d, a, b, 11, 0x265e5a51, 14)
+		MD5_STEP(MD5_G, b, c, d, a, 0, 0xe9b6c7aa, 20)
+		MD5_STEP(MD5_G, a, b, c, d, 5, 0xd62f105d, 5)
+		MD5_STEP(MD5_G, d, a, b, c, 10, 0x02441453, 9)
+		MD5_STEP(MD5_G, c, d, a, b, 15, 0xd8a1e681, 14)
+		MD5_STEP(MD5_G, b, c, d, a, 4, 0xe7d3fbc8, 20)
+		MD5_STEP(MD5_G, a, b, c, d, 9, 0x21e1cde6, 5)
+		MD5_STEP(MD5_G, d, a, b, c, 14, 0xc33707d6, 9)
+		MD5_STEP(MD5_G, c, d, a, b, 3, 0xf4d50d87, 14)
+		MD5_STEP(MD5_G, b, c, d, a, 8, 0x455a14ed, 20)
+		MD5_STEP(MD5_G, a, b, c, d, 13, 0xa9e3e905, 5)
+		MD5_STEP(MD5_G, d, a, b, c, 2, 0xfcefa3f8, 9)
+		MD5_STEP(MD5_G, c, d, a, b, 7, 0x676f02d9, 14)
+		MD5_STEP(MD5_G, b, c, d, a, 12, 0x8d2a4c8a, 20)
+
+/* Round 3 */
+		MD5_STEP(MD5_H, a, b, c, d, 5, 0xfffa3942, 4)
+		MD5_STEP(MD5_H, d, a, b, c, 8, 0x8771f681, 11)
+		MD5_STEP(MD5_H, c, d, a, b, 11, 0x6d9d6122, 16)
+		MD5_STEP(MD5_H, b, c, d, a, 14, 0xfde5380c, 23)
+		MD5_STEP(MD5_H, a, b, c, d, 1, 0xa4beea44, 4)
+		MD5_STEP(MD5_H, d, a, b, c, 4, 0x4bdecfa9, 11)
+		MD5_STEP(MD5_H, c, d, a, b, 7, 0xf6bb4b60, 16)
+		MD5_STEP(MD5_H, b, c, d, a, 10, 0xbebfbc70, 23)
+		MD5_STEP(MD5_H, a, b, c, d, 13, 0x289b7ec6, 4)
+		MD5_STEP(MD5_H, d, a, b, c, 0, 0xeaa127fa, 11)
+		MD5_STEP(MD5_H, c, d, a, b, 3, 0xd4ef3085, 16)
+		MD5_STEP(MD5_H, b, c, d, a, 6, 0x04881d05, 23)
+		MD5_STEP(MD5_H, a, b, c, d, 9, 0xd9d4d039, 4)
+		MD5_STEP(MD5_H, d, a, b, c, 12, 0xe6db99e5, 11)
+		MD5_STEP(MD5_H, c, d, a, b, 15, 0x1fa27cf8, 16)
+		MD5_STEP(MD5_H, b, c, d, a, 2, 0xc4ac5665, 23)
+
+/* Round 4 */
+		MD5_STEP(MD5_I, a, b, c, d, 0, 0xf4292244, 6)
+		MD5_STEP(MD5_I, d, a, b, c, 7, 0x432aff97, 10)
+		MD5_STEP(MD5_I, c, d, a, b, 14, 0xab9423a7, 15)
+		MD5_STEP(MD5_I, b, c, d, a, 5, 0xfc93a039, 21)
+		MD5_STEP(MD5_I, a, b, c, d, 12, 0x655b59c3, 6)
+		MD5_STEP(MD5_I, d, a, b, c, 3, 0x8f0ccc92, 10)
+		MD5_STEP(MD5_I, c, d, a, b, 10, 0xffeff47d, 15)
+		MD5_STEP(MD5_I, b, c, d, a, 1, 0x85845dd1, 21)
+		MD5_STEP(MD5_I, a, b, c, d, 8, 0x6fa87e4f, 6)
+		MD5_STEP(MD5_I, d, a, b, c, 15, 0xfe2ce6e0, 10)
+		MD5_STEP(MD5_I, c, d, a, b, 6, 0xa3014314, 15)
+		MD5_STEP(MD5_I, b, c, d, a, 13, 0x4e0811a1, 21)
+		MD5_STEP(MD5_I, a, b, c, d, 4, 0xf7537e82, 6)
+		MD5_STEP(MD5_I, d, a, b, c, 11, 0xbd3af235, 10)
+		MD5_STEP(MD5_I, c, d, a, b, 2, 0x2ad7d2bb, 15)
+		MD5_STEP(MD5_I, b, c, d, a, 9, 0xeb86d391, 21)
+	MD5_PARA_DO(i)
+	{
+		a[i] = _mm_add_epi32(a[i], _mm_set1_epi32(0x67452301));
+		b[i] = _mm_add_epi32(b[i], _mm_set1_epi32(0xefcdab89));
+		c[i] = _mm_add_epi32(c[i], _mm_set1_epi32(0x98badcfe));
+		d[i] = _mm_add_epi32(d[i], _mm_set1_epi32(0x10325476));
+		_mm_store_si128((__m128i *)&out[i*16+0], a[i]);
+		_mm_store_si128((__m128i *)&out[i*16+4], b[i]);
+		_mm_store_si128((__m128i *)&out[i*16+8], c[i]);
+		_mm_store_si128((__m128i *)&out[i*16+12], d[i]);
+	}
+}
+
+#define GETPOS(i, index)                ( (index&3)*4 + (i& (0xffffffff-3) )*MMX_COEF + ((i)&3) )
+
+void mmxput(void * buf, unsigned int index, unsigned int bid, unsigned int offset, unsigned char * src, unsigned int len)
+{
+	unsigned char * nbuf;
+	unsigned int i;
+
+	nbuf = ((unsigned char*)buf) + (index>>2)*64*MMX_COEF + bid*64*MD5_SSE_NUM_KEYS;
+	for(i=0;i<len;i++)
+		nbuf[ GETPOS((offset+i), index) ] = src[i];
+
+}
+
+void mmxput2(void * buf, unsigned int bid, void * src)
+{
+	unsigned char * nbuf;
+	unsigned int i;
+
+	nbuf = ((unsigned char*)buf) + bid*64*MD5_SSE_NUM_KEYS;
+	MD5_PARA_DO(i)
+		memcpy( nbuf+i*64*MMX_COEF, ((unsigned char*)src)+i*64, 64);
+}
+
+void mmxput3(void * buf, unsigned int bid, unsigned int * offset, int mult, int saltlen, void * src)
+{
+	unsigned char * nbuf;
+	unsigned int noff;
+	unsigned int noffd;
+	unsigned int i,j;
+	unsigned int dec;
+
+	MD5_PARA_DO(j)
+	{
+		nbuf = ((unsigned char*)buf) + bid*64*MD5_SSE_NUM_KEYS + j*64*MMX_COEF;
+		for(i=0;i<MMX_COEF;i++)
+		{
+			noff = offset[i+j*MMX_COEF]*mult + saltlen;
+			dec = (noff&3)*8;
+			if(dec)
+			{
+				noffd = noff & (~3);
+				((unsigned int *)(nbuf+noffd*4))[i] &= (0xffffffff>>(32-dec));
+				((unsigned int *)(nbuf+noffd*4))[i] |= (((unsigned int *)src)[i+j*16+0] << dec);
+				((unsigned int *)(nbuf+noffd*4))[i+4] = (((unsigned int *)src)[i+j*16+4] << dec) | (((unsigned int *)src)[i+j*16+0] >> (32-dec));
+				((unsigned int *)(nbuf+noffd*4))[i+8] = (((unsigned int *)src)[i+j*16+8] << dec) | (((unsigned int *)src)[i+j*16+4] >> (32-dec));
+				((unsigned int *)(nbuf+noffd*4))[i+12] = (((unsigned int *)src)[i+j*16+12] << dec) | (((unsigned int *)src)[i+j*16+8] >> (32-dec));
+				((unsigned int *)(nbuf+noffd*4))[i+16] &= (0xffffffff<<dec);
+				((unsigned int *)(nbuf+noffd*4))[i+16] |= (((unsigned int *)src)[i+j*16+12] >> (32-dec));
+			}
+			else
+			{
+				((unsigned int *)(nbuf+noff*4))[i] = ((unsigned int *)src)[i+j*16+0];
+				((unsigned int *)(nbuf+noff*4))[i+4] = ((unsigned int *)src)[i+j*16+4];
+				((unsigned int *)(nbuf+noff*4))[i+8] = ((unsigned int *)src)[i+j*16+8];
+				((unsigned int *)(nbuf+noff*4))[i+12] = ((unsigned int *)src)[i+j*16+12];
+			}
+		}
+	}
+
+}
+
+void dispatch(unsigned char buffers[8][64*MD5_SSE_NUM_KEYS], unsigned int f[4*MD5_SSE_NUM_KEYS], unsigned int length[MD5_SSE_NUM_KEYS], unsigned int saltlen)
+{
+	unsigned int j;
+	unsigned int bufferid;
+
+	for(j=0;j<1000;j++)
+	{
+		switch(j%42)
+		{
+			case 0:
+				bufferid = 0;
+				mmxput2(buffers, bufferid, f);
+				break;
+			case 21:
+				bufferid = 1;
+				mmxput3(buffers, bufferid, length, 1, 0, f);
+				break;
+			case 3:
+			case 9:
+			case 15:
+			case 27:
+			case 33:
+			case 39:
+				bufferid = 2;
+				mmxput3(buffers, bufferid, length, 2, 0, f);
+				break;
+			case 6:
+			case 12:
+			case 18:
+			case 24:
+			case 30:
+			case 36:
+				bufferid = 3;
+				mmxput2(buffers, bufferid, f);
+				break;
+			case 7:
+			case 35:
+				bufferid = 4;
+				mmxput3(buffers, bufferid, length, 1, saltlen, f);
+				break;
+			case 14:
+			case 28:
+				bufferid = 5;
+				mmxput2(buffers, bufferid, f);
+				break;
+			case 2:
+			case 4:
+			case 8:
+			case 10:
+			case 16:
+			case 20:
+			case 22:
+			case 26:
+			case 32:
+			case 34:
+			case 38:
+			case 40:
+				bufferid = 6;
+				mmxput2(buffers, bufferid, f);
+				break;
+			default:
+				bufferid = 7;
+				mmxput3(buffers, bufferid, length, 2, saltlen, f);
+				break;
+		}
+		SSEmd5body((__m128i*)&buffers[bufferid], f, 1);
+	}
+}
+
+
+#define buffers MD5_INTR_buffers
+#define F MD5_INTR_F
+#ifdef _MSC_VER
+	__declspec(align(16)) unsigned char buffers[8][64*MD5_SSE_NUM_KEYS];
+	__declspec(align(16)) unsigned int F[4*MD5_SSE_NUM_KEYS];
+#else
+	unsigned char buffers[8][64*MD5_SSE_NUM_KEYS] __attribute__ ((aligned(16)));
+	unsigned int F[4*MD5_SSE_NUM_KEYS] __attribute__ ((aligned(16)));
+#endif
+
+void md5cryptsse(unsigned char pwd[MD5_SSE_NUM_KEYS][16], unsigned char * salt, char * out, int md5_type)
+{
+	unsigned int length[MD5_SSE_NUM_KEYS];
+	unsigned int saltlen;
+	unsigned int * bt;
+	unsigned int tf[4];
+	unsigned int i,j;
+	MD5_CTX ctx;
+	MD5_CTX tctx;
+
+	memset(F,0,sizeof(F));
+	memset(buffers, 0, sizeof(buffers));
+	saltlen = strlen((char *)salt);
+	for(i=0;i<MD5_SSE_NUM_KEYS;i++)
+	{
+		length[i] = strlen((char *)pwd[i]);
+		/* cas 0 fs */
+		mmxput(buffers, i, 0, 16, pwd[i], length[i]);
+		mmxput(buffers, i, 0, length[i]+16, (unsigned char *)"\x80", 1);
+		/* cas 1 sf */
+		mmxput(buffers, i, 1, 0, pwd[i], length[i]);
+		mmxput(buffers, i, 1, length[i]+16, (unsigned char *)"\x80", 1);
+		/* cas 2 ssf */
+		mmxput(buffers, i, 2, 0, pwd[i], length[i]);
+		mmxput(buffers, i, 2, length[i], pwd[i], length[i]);
+		mmxput(buffers, i, 2, length[i]*2+16, (unsigned char *)"\x80", 1);
+		/* cas 3 fss */
+		mmxput(buffers, i, 3, 16, pwd[i], length[i]);
+		mmxput(buffers, i, 3, 16+length[i], pwd[i], length[i]);
+		mmxput(buffers, i, 3, length[i]*2+16, (unsigned char *)"\x80", 1);
+		/* cas 4 scf */
+		mmxput(buffers, i, 4, 0, pwd[i], length[i]);
+		mmxput(buffers, i, 4, length[i], salt, saltlen);
+		mmxput(buffers, i, 4, saltlen+length[i]+16, (unsigned char *)"\x80", 1);
+		/* cas 5 fcs */
+		mmxput(buffers, i, 5, 16, salt, saltlen);
+		mmxput(buffers, i, 5, 16+saltlen, pwd[i], length[i]);
+		mmxput(buffers, i, 5, saltlen+length[i]+16, (unsigned char *)"\x80", 1);
+		/* cas 6 fcss */
+		mmxput(buffers, i, 6, 16, salt, saltlen);
+		mmxput(buffers, i, 6, 16+saltlen, pwd[i], length[i]);
+		mmxput(buffers, i, 6, 16+saltlen+length[i], pwd[i], length[i]);
+		mmxput(buffers, i, 6, saltlen+2*length[i]+16, (unsigned char *)"\x80", 1);
+		/* cas 7 scsf */
+		mmxput(buffers, i, 7, 0, pwd[i], length[i]);
+		mmxput(buffers, i, 7, length[i], salt, saltlen);
+		mmxput(buffers, i, 7, length[i]+saltlen, pwd[i], length[i]);
+		mmxput(buffers, i, 7, saltlen+2*length[i]+16, (unsigned char *)"\x80", 1);
+
+		bt = (unsigned int *) &buffers[0]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]+16)<<3;
+		bt = (unsigned int *) &buffers[1]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]+16)<<3;
+		bt = (unsigned int *) &buffers[2]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]*2+16)<<3;
+		bt = (unsigned int *) &buffers[3]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]*2+16)<<3;
+		bt = (unsigned int *) &buffers[4]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]+saltlen+16)<<3;
+		bt = (unsigned int *) &buffers[5]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]+saltlen+16)<<3;
+		bt = (unsigned int *) &buffers[6]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]*2+saltlen+16)<<3;
+		bt = (unsigned int *) &buffers[7]; bt[14*MMX_COEF + (i&3) + (i>>2)*64] = (length[i]*2+saltlen+16)<<3;
+
+		MD5_Init(&ctx);
+		MD5_Update(&ctx, pwd[i], length[i]);
+		if(md5_type == MD5_TYPE_APACHE)
+			MD5_Update(&ctx, "$apr1$", 6);
+		else
+			MD5_Update(&ctx, "$1$", 3);
+		MD5_Update(&ctx, salt, saltlen);
+		MD5_Init(&tctx);
+		MD5_Update(&tctx, pwd[i], length[i]);
+		MD5_Update(&tctx, salt, saltlen);
+		MD5_Update(&tctx, pwd[i], length[i]);
+		MD5_Final((unsigned char *)tf, &tctx);
+		MD5_Update(&ctx, tf, length[i]);
+		for(j=length[i];j;j>>=1)
+			if(j&1)
+				MD5_Update(&ctx, "\0", 1);
+			else
+				MD5_Update(&ctx, pwd[i], 1);
+		MD5_Final((unsigned char *)tf, &ctx);
+		F[(i>>2)*16 + (i&3)] = tf[0];
+		F[(i>>2)*16 + (i&3) + 4] = tf[1];
+		F[(i>>2)*16 + (i&3) + 8] = tf[2];
+		F[(i>>2)*16 + (i&3) + 12] = tf[3];
+	}
+	dispatch(buffers, F, length, saltlen);
+	memcpy(out, F, MD5_SSE_NUM_KEYS*16);
+}
+
+#define MD4_SSE_NUM_KEYS	(MMX_COEF*MD4_SSE_PARA)
+#define MD4_PARA_DO(x)	for((x)=0;(x)<MD4_SSE_PARA;(x)++)
+
+#define MD4_F(x,y,z) \
+	MD4_PARA_DO(i) tmp[i] = _mm_xor_si128((y[i]),(z[i])); \
+	MD4_PARA_DO(i) tmp[i] = _mm_and_si128((tmp[i]),(x[i])); \
+	MD4_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]),(z[i]));
+
+#define MD4_G(x,y,z) \
+	MD4_PARA_DO(i) tmp[i] = _mm_or_si128((y[i]),(z[i])); \
+	MD4_PARA_DO(i) tmp2[i] = _mm_and_si128((y[i]),(z[i])); \
+	MD4_PARA_DO(i) tmp[i] = _mm_and_si128((tmp[i]),(x[i])); \
+	MD4_PARA_DO(i) tmp[i] = _mm_or_si128((tmp[i]), (tmp2[i]) );
+
+#define MD4_H(x,y,z) \
+	MD4_PARA_DO(i) tmp[i] = _mm_xor_si128((y[i]),(z[i])); \
+	MD4_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]),(x[i]));
+
+#define MD4_STEP(f, a, b, c, d, x, t, s) \
+	MD4_PARA_DO(i) a[i] = _mm_add_epi32( a[i], t ); \
+	f((b),(c),(d)) \
+	MD4_PARA_DO(i) a[i] = _mm_add_epi32( a[i], tmp[i] ); \
+	MD4_PARA_DO(i) a[i] = _mm_add_epi32( a[i], data[i*16+x] ); \
+	MD4_PARA_DO(i) a[i] = _mm_or_si128(_mm_slli_epi32((a[i]), (s)), _mm_srli_epi32((a[i]), 32-(s)));
+
+void SSEmd4body(__m128i* data, unsigned int * out, int init)
+{
+	__m128i a[MD4_SSE_PARA];
+	__m128i b[MD4_SSE_PARA];
+	__m128i c[MD4_SSE_PARA];
+	__m128i d[MD4_SSE_PARA];
+	__m128i tmp[MD4_SSE_PARA];
+	__m128i tmp2[MD4_SSE_PARA];
+	__m128i	cst;
+	unsigned int i;
+
+	if(init)
+	{
+		MD4_PARA_DO(i)
+		{
+			a[i] = _mm_set1_epi32(0x67452301);
+			b[i] = _mm_set1_epi32(0xefcdab89);
+			c[i] = _mm_set1_epi32(0x98badcfe);
+			d[i] = _mm_set1_epi32(0x10325476);
+		}
+	}
+	else
+	{
+		MD4_PARA_DO(i)
+		{
+			a[i] = _mm_load_si128((__m128i *)&out[i*16+0]);
+			b[i] = _mm_load_si128((__m128i *)&out[i*16+4]);
+			c[i] = _mm_load_si128((__m128i *)&out[i*16+8]);
+			d[i] = _mm_load_si128((__m128i *)&out[i*16+12]);
+		}
+	}
+
+/* Round 1 */
+		cst = _mm_set_epi32(0,0,0,0);
+		MD4_STEP(MD4_F, a, b, c, d, 0, cst, 3)
+		MD4_STEP(MD4_F, d, a, b, c, 1, cst, 7)
+		MD4_STEP(MD4_F, c, d, a, b, 2, cst, 11)
+		MD4_STEP(MD4_F, b, c, d, a, 3, cst, 19)
+		MD4_STEP(MD4_F, a, b, c, d, 4, cst, 3)
+		MD4_STEP(MD4_F, d, a, b, c, 5, cst, 7)
+		MD4_STEP(MD4_F, c, d, a, b, 6, cst, 11)
+		MD4_STEP(MD4_F, b, c, d, a, 7, cst, 19)
+		MD4_STEP(MD4_F, a, b, c, d, 8, cst, 3)
+		MD4_STEP(MD4_F, d, a, b, c, 9, cst, 7)
+		MD4_STEP(MD4_F, c, d, a, b, 10, cst, 11)
+		MD4_STEP(MD4_F, b, c, d, a, 11, cst, 19)
+		MD4_STEP(MD4_F, a, b, c, d, 12, cst, 3)
+		MD4_STEP(MD4_F, d, a, b, c, 13, cst, 7)
+		MD4_STEP(MD4_F, c, d, a, b, 14, cst, 11)
+		MD4_STEP(MD4_F, b, c, d, a, 15, cst, 19)
+
+/* Round 2 */
+		cst = _mm_set_epi32(0x5A827999L,0x5A827999L,0x5A827999L,0x5A827999L);
+		MD4_STEP(MD4_G, a, b, c, d, 0, cst, 3)
+		MD4_STEP(MD4_G, d, a, b, c, 4, cst, 5)
+		MD4_STEP(MD4_G, c, d, a, b, 8, cst, 9)
+		MD4_STEP(MD4_G, b, c, d, a, 12, cst, 13)
+		MD4_STEP(MD4_G, a, b, c, d, 1, cst, 3)
+		MD4_STEP(MD4_G, d, a, b, c, 5, cst, 5)
+		MD4_STEP(MD4_G, c, d, a, b, 9, cst, 9)
+		MD4_STEP(MD4_G, b, c, d, a, 13, cst, 13)
+		MD4_STEP(MD4_G, a, b, c, d, 2, cst, 3)
+		MD4_STEP(MD4_G, d, a, b, c, 6, cst, 5)
+		MD4_STEP(MD4_G, c, d, a, b, 10, cst, 9)
+		MD4_STEP(MD4_G, b, c, d, a, 14, cst, 13)
+		MD4_STEP(MD4_G, a, b, c, d, 3, cst, 3)
+		MD4_STEP(MD4_G, d, a, b, c, 7, cst, 5)
+		MD4_STEP(MD4_G, c, d, a, b, 11, cst, 9)
+		MD4_STEP(MD4_G, b, c, d, a, 15, cst, 13)
+
+/* Round 3 */
+		cst = _mm_set_epi32(0x6ED9EBA1L,0x6ED9EBA1L,0x6ED9EBA1L,0x6ED9EBA1L);
+		MD4_STEP(MD4_H, a, b, c, d, 0, cst, 3)
+		MD4_STEP(MD4_H, d, a, b, c, 8, cst, 9)
+		MD4_STEP(MD4_H, c, d, a, b, 4, cst, 11)
+		MD4_STEP(MD4_H, b, c, d, a, 12, cst, 15)
+		MD4_STEP(MD4_H, a, b, c, d, 2, cst, 3)
+		MD4_STEP(MD4_H, d, a, b, c, 10, cst, 9)
+		MD4_STEP(MD4_H, c, d, a, b, 6, cst, 11)
+		MD4_STEP(MD4_H, b, c, d, a, 14, cst, 15)
+		MD4_STEP(MD4_H, a, b, c, d, 1, cst, 3)
+		MD4_STEP(MD4_H, d, a, b, c, 9, cst, 9)
+		MD4_STEP(MD4_H, c, d, a, b, 5, cst, 11)
+		MD4_STEP(MD4_H, b, c, d, a, 13, cst, 15)
+		MD4_STEP(MD4_H, a, b, c, d, 3, cst, 3)
+		MD4_STEP(MD4_H, d, a, b, c, 11, cst, 9)
+		MD4_STEP(MD4_H, c, d, a, b, 7, cst, 11)
+		MD4_STEP(MD4_H, b, c, d, a, 15, cst, 15)
+
+	MD4_PARA_DO(i)
+	{
+		a[i] = _mm_add_epi32(a[i], _mm_set1_epi32(0x67452301));
+		b[i] = _mm_add_epi32(b[i], _mm_set1_epi32(0xefcdab89));
+		c[i] = _mm_add_epi32(c[i], _mm_set1_epi32(0x98badcfe));
+		d[i] = _mm_add_epi32(d[i], _mm_set1_epi32(0x10325476));
+		_mm_store_si128((__m128i *)&out[i*16+0], a[i]);
+		_mm_store_si128((__m128i *)&out[i*16+4], b[i]);
+		_mm_store_si128((__m128i *)&out[i*16+8], c[i]);
+		_mm_store_si128((__m128i *)&out[i*16+12], d[i]);
+	}
+}
+
+
+
+#define SHA1_SSE_NUM_KEYS	(MMX_COEF*SHA1_SSE_PARA)
+#define SHA1_PARA_DO(x)		for((x)=0;(x)<SHA1_SSE_PARA;(x)++)
+
+#define SHA1_F(x,y,z) \
+	SHA1_PARA_DO(i) tmp[i] = _mm_xor_si128((y[i]),(z[i])); \
+	SHA1_PARA_DO(i) tmp[i] = _mm_and_si128((tmp[i]),(x[i])); \
+	SHA1_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]),(z[i]));
+
+#define SHA1_G(x,y,z) \
+	SHA1_PARA_DO(i) tmp[i] = _mm_xor_si128((y[i]),(z[i])); \
+	SHA1_PARA_DO(i) tmp[i] = _mm_xor_si128((tmp[i]),(x[i]));
+
+#define SHA1_H(x,y,z) \
+	SHA1_PARA_DO(i) tmp[i] = _mm_and_si128((x[i]),(y[i])); \
+	SHA1_PARA_DO(i) tmp2[i] = _mm_or_si128((x[i]),(y[i])); \
+	SHA1_PARA_DO(i) tmp2[i] = _mm_and_si128((tmp2[i]),(z[i])); \
+	SHA1_PARA_DO(i) tmp[i] = _mm_or_si128((tmp[i]),(tmp2[i])); \
+
+#define SHA1_I(x,y,z) SHA1_G(x,y,z)
+
+#define SHA1_EXPAND(t) \
+	SHA1_PARA_DO(i) tmp[i] = _mm_xor_si128( data[i*80+t-3], data[i*80+t-8] ); \
+	SHA1_PARA_DO(i) tmp[i] = _mm_xor_si128( tmp[i], data[i*80+t-14] ); \
+	SHA1_PARA_DO(i) tmp[i] = _mm_xor_si128( tmp[i], data[i*80+t-16] ); \
+	SHA1_PARA_DO(i) data[i*80+t] = _mm_or_si128(_mm_slli_epi32((tmp[i]), 1), _mm_srli_epi32((tmp[i]), 31));
+
+#define SHA1_ROUND(a,b,c,d,e,F,t) \
+	F(b,c,d) \
+	SHA1_PARA_DO(i) e[i] = _mm_add_epi32( e[i], tmp[i] ); \
+	SHA1_PARA_DO(i) tmp[i] = _mm_or_si128(_mm_slli_epi32((a[i]), 5), _mm_srli_epi32((a[i]), 27)); \
+	SHA1_PARA_DO(i) e[i] = _mm_add_epi32( e[i], tmp[i] ); \
+	SHA1_PARA_DO(i) e[i] = _mm_add_epi32( e[i], cst ); \
+	SHA1_PARA_DO(i) e[i] = _mm_add_epi32( e[i], data[i*80+t] ); \
+	SHA1_PARA_DO(i) b[i] = _mm_or_si128(_mm_slli_epi32((b[i]), 30), _mm_srli_epi32((b[i]), 2)); \
+
+void SSESHA1body(__m128i* data, unsigned int * out, int init)
+{
+	__m128i a[SHA1_SSE_PARA];
+	__m128i b[SHA1_SSE_PARA];
+	__m128i c[SHA1_SSE_PARA];
+	__m128i d[SHA1_SSE_PARA];
+	__m128i e[SHA1_SSE_PARA];
+	__m128i tmp[SHA1_SSE_PARA];
+	__m128i tmp2[SHA1_SSE_PARA];
+	__m128i	cst;
+	unsigned int i,j;
+
+	for(j=16;j<80;j++)
+	{
+		SHA1_EXPAND(j);
+	}
+
+	if(init)
+	{
+		SHA1_PARA_DO(i)
+		{
+			a[i] = _mm_set1_epi32(0x67452301);
+			b[i] = _mm_set1_epi32(0xefcdab89);
+			c[i] = _mm_set1_epi32(0x98badcfe);
+			d[i] = _mm_set1_epi32(0x10325476);
+			e[i] = _mm_set1_epi32(0xC3D2E1F0);
+		}
+	}
+	else
+	{
+		SHA1_PARA_DO(i)
+		{
+			a[i] = _mm_load_si128((__m128i *)&out[i*20+0]);
+			b[i] = _mm_load_si128((__m128i *)&out[i*20+4]);
+			c[i] = _mm_load_si128((__m128i *)&out[i*20+8]);
+			d[i] = _mm_load_si128((__m128i *)&out[i*20+12]);
+			e[i] = _mm_load_si128((__m128i *)&out[i*20+16]);
+		}
+	}
+
+	cst = _mm_set1_epi32(0x5A827999);
+	SHA1_ROUND( a, b, c, d, e, SHA1_F,  0 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_F,  1 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_F,  2 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_F,  3 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_F,  4 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_F,  5 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_F,  6 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_F,  7 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_F,  8 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_F,  9 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_F, 10 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_F, 11 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_F, 12 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_F, 13 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_F, 14 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_F, 15 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_F, 16 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_F, 17 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_F, 18 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_F, 19 );
+
+	cst = _mm_set1_epi32(0x6ED9EBA1);
+	SHA1_ROUND( a, b, c, d, e, SHA1_G, 20 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_G, 21 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_G, 22 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_G, 23 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_G, 24 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_G, 25 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_G, 26 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_G, 27 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_G, 28 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_G, 29 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_G, 30 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_G, 31 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_G, 32 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_G, 33 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_G, 34 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_G, 35 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_G, 36 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_G, 37 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_G, 38 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_G, 39 );
+
+	cst = _mm_set1_epi32(0x8F1BBCDC);
+	SHA1_ROUND( a, b, c, d, e, SHA1_H, 40 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_H, 41 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_H, 42 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_H, 43 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_H, 44 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_H, 45 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_H, 46 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_H, 47 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_H, 48 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_H, 49 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_H, 50 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_H, 51 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_H, 52 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_H, 53 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_H, 54 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_H, 55 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_H, 56 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_H, 57 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_H, 58 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_H, 59 );
+
+	cst = _mm_set1_epi32(0xCA62C1D6);
+	SHA1_ROUND( a, b, c, d, e, SHA1_I, 60 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_I, 61 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_I, 62 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_I, 63 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_I, 64 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_I, 65 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_I, 66 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_I, 67 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_I, 68 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_I, 69 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_I, 70 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_I, 71 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_I, 72 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_I, 73 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_I, 74 );
+	SHA1_ROUND( a, b, c, d, e, SHA1_I, 75 );
+	SHA1_ROUND( e, a, b, c, d, SHA1_I, 76 );
+	SHA1_ROUND( d, e, a, b, c, SHA1_I, 77 );
+	SHA1_ROUND( c, d, e, a, b, SHA1_I, 78 );
+	SHA1_ROUND( b, c, d, e, a, SHA1_I, 79 );
+
+	if(init)
+	{
+		SHA1_PARA_DO(i)
+		{
+			a[i] = _mm_add_epi32(a[i], _mm_set1_epi32(0x67452301));
+			b[i] = _mm_add_epi32(b[i], _mm_set1_epi32(0xefcdab89));
+			c[i] = _mm_add_epi32(c[i], _mm_set1_epi32(0x98badcfe));
+			d[i] = _mm_add_epi32(d[i], _mm_set1_epi32(0x10325476));
+			e[i] = _mm_add_epi32(e[i], _mm_set1_epi32(0xC3D2E1F0));
+		}
+	}
+	else
+	{
+		SHA1_PARA_DO(i)
+		{
+			a[i] = _mm_add_epi32(a[i], _mm_load_si128((__m128i *)&out[i*20+0]));
+			b[i] = _mm_add_epi32(b[i], _mm_load_si128((__m128i *)&out[i*20+4]));
+			c[i] = _mm_add_epi32(c[i], _mm_load_si128((__m128i *)&out[i*20+8]));
+			d[i] = _mm_add_epi32(d[i], _mm_load_si128((__m128i *)&out[i*20+12]));
+			e[i] = _mm_add_epi32(e[i], _mm_load_si128((__m128i *)&out[i*20+16]));
+		}
+	}
+	SHA1_PARA_DO(i)
+	{
+		_mm_store_si128((__m128i *)&out[i*20+0], a[i]);
+		_mm_store_si128((__m128i *)&out[i*20+4], b[i]);
+		_mm_store_si128((__m128i *)&out[i*20+8], c[i]);
+		_mm_store_si128((__m128i *)&out[i*20+12], d[i]);
+		_mm_store_si128((__m128i *)&out[i*20+16], e[i]);
+	}
+}
diff -rupN john-1.7.8/src/sse-intrinsics.h john-1.7.8-jumbo-2/src/sse-intrinsics.h
--- john-1.7.8/src/sse-intrinsics.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/sse-intrinsics.h	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,12 @@
+/*
+ * This software is Copyright  2010 bartavelle, <bartavelle at bandecon.com>, and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification, are permitted.
+ */
+#ifndef _EMMINTRIN_H_INCLUDED
+#define __m128i void
+#endif
+
+void md5cryptsse(unsigned char * buf, unsigned char * salt, char * out, int md5_type);
+void SSEmd5body(__m128i* data, unsigned int * out, int init);
+void SSEmd4body(__m128i* data, unsigned int * out, int init);
+void SSESHA1body(__m128i* data, unsigned int * out, int init);
diff -rupN john-1.7.8/src/ssh2john.c john-1.7.8-jumbo-2/src/ssh2john.c
--- john-1.7.8/src/ssh2john.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/ssh2john.c	2011-06-08 22:27:37.000000000 +0200
@@ -0,0 +1,119 @@
+/* ssh2john utility, written in April of 2011 by Dhiru Kholia for GSoC.
+ *
+ * This software is Copyright  2011, Dhiru Kholia <dhiru.kholia at gmail.com>,
+ * and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted.
+ *
+ * Usage:
+ *
+ * 1. Run ssh2john on private key file(s) as "ssh2john [key file(s)]". Output
+ *    is written to standard output.
+ * 2. Run JtR on the output generated by ssh2john as "john [output file]".
+ *
+ * Notes:
+ *
+ * Output Line Format: filename:$ssh2$hex-encoding-of-entire-file-contents*file-length
+ *
+ * TODO:
+ *
+ * 1. Support more formats of SSH private keys. */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+#include <errno.h>
+#include <string.h>
+
+#include <openssl/ssl.h>
+#include <openssl/bio.h>
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+
+#include "misc.h"
+#include "common.h"
+#include "arch.h"
+#include "params.h"
+
+static void process_file(const char *filename)
+{
+	FILE *keyfile;
+	int i, count;
+	unsigned char buffer[LINE_BUFFER_SIZE];
+	if (!(keyfile = fopen(filename, "rb"))) {
+	    fprintf(stderr, "! %s : %s\n", filename, strerror(errno));
+	    return;
+	}
+	/* verify input files using OpenSSL */
+	BIO *bp = BIO_new(BIO_s_file());
+	if(!bp) {
+	    fprintf(stderr, "OpenSSL BIO allocation failure\n");
+	    return;
+	}
+	if(!BIO_read_filename(bp, filename)) {
+	    ERR_print_errors_fp(stderr);
+	    return;
+	}
+	/* PEM_bytes_read_bio function in crypto/pem/pem_lib.c
+	 * check_pem function in crypto/pem/pem_lib.c */
+	char *nm = NULL, *header = NULL;
+	unsigned char *data = NULL;
+	EVP_CIPHER_INFO cipher;
+	long len;
+	for (;;) {
+		if (!PEM_read_bio(bp, &nm, &header, &data, &len)) {
+			if (ERR_GET_REASON(ERR_peek_error()) ==
+			    PEM_R_NO_START_LINE) {
+				ERR_print_errors_fp(stderr);
+	            fprintf(stderr, "! %s : %s\n", filename, "input keyfile validation failed");
+				return;
+			}
+		}
+        /* only PEM encoded DSA and RSA private keys are supported. */
+		if (!strcmp(nm, PEM_STRING_DSA)) {
+			break;
+		}
+		if (!strcmp(nm, PEM_STRING_RSA)) {
+			break;
+		}
+		OPENSSL_free(nm);
+		OPENSSL_free(header);
+		OPENSSL_free(data);
+		OPENSSL_free(bp);
+	}
+	if (!PEM_get_EVP_CIPHER_INFO(header, &cipher)) {
+		ERR_print_errors_fp(stderr);
+		return;
+	}
+
+	/* key has been verified */
+	count = fread(buffer, 1, LINE_BUFFER_SIZE, keyfile);
+	printf("%s:$ssh2$", filename);
+	for (i = 0; i < count; i++) {
+	    printf("%c%c", itoa16[ARCH_INDEX(buffer[i] >> 4)],
+	            itoa16[ARCH_INDEX(buffer[i] & 0x0f)]);
+	}
+	printf("*%d\n", count);
+	fclose(keyfile);
+}
+
+int ssh2john(int argc, char **argv)
+{
+	int i;
+
+	/* OpenSSL init, cleanup part is left to OS */
+	SSL_load_error_strings();
+	SSL_library_init();
+	OpenSSL_add_all_algorithms();
+
+	if (argc < 2) {
+		puts("Usage: ssh2john [key file(s)]");
+		return 0;
+	}
+
+	for (i = 1; i < argc; i++)
+	    process_file(argv[i]);
+
+	return 0;
+}
diff -rupN john-1.7.8/src/ssh_fmt.c john-1.7.8-jumbo-2/src/ssh_fmt.c
--- john-1.7.8/src/ssh_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/ssh_fmt.c	2011-07-02 23:08:58.000000000 +0200
@@ -0,0 +1,282 @@
+/* "SSH private key cracker" patch for JtR. Hacked together during
+ * April of 2011 by Dhiru Kholia <dhiru.kholia at gmail.com> for GSoC.
+ *
+ * This software is Copyright  2011, Dhiru Kholia <dhiru.kholia at gmail.com>,
+ * and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted.
+ *
+ * This patch is inspired by the ssh-privkey-crack program.
+ * http://neophob.com/2007/10/ssh-private-key-cracker/ */
+
+#include <string.h>
+#include "arch.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+
+/* PEM_read_bio_PrivateKey and related OpenSSL functions are too high
+ * level for brute-forcing purposes. So we drill down and find suitable
+ * low-level OpenSSL functions.*/
+
+#include <openssl/opensslv.h>
+#include <openssl/crypto.h>
+
+#include <openssl/ssl.h>
+#include <openssl/bio.h>
+#include <openssl/evp.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+
+#define FORMAT_LABEL        "ssh"
+#define FORMAT_NAME         "ssh"
+#define ALGORITHM_NAME      "32/" ARCH_BITS_STR
+#define BENCHMARK_COMMENT   ""
+#define BENCHMARK_LENGTH    -1
+#define PLAINTEXT_LENGTH    32
+#define BINARY_SIZE         0
+#define SALT_SIZE           4224
+#define MIN_KEYS_PER_CRYPT  1
+#define MAX_KEYS_PER_CRYPT  96
+
+static char saved_key[MAX_KEYS_PER_CRYPT][PLAINTEXT_LENGTH + 1];
+static char has_been_cracked[MAX_KEYS_PER_CRYPT];
+
+static struct custom_salt {
+	long len;
+	char data[4096];
+	EVP_CIPHER_INFO cipher;
+	EVP_PKEY pk;
+} *restored_custom_salt;
+
+static struct fmt_tests ssh_tests[] = {
+	{"$ssh2$2d2d2d2d2d424547494e204453412050524956415445204b45592d2d2d2d2d0a50726f632d547970653a20342c454e435259505445440a44454b2d496e666f3a204145532d3132382d4342432c35413830363832373943304634364539383230373135304133433245433631340a0a2f756954696e4a3452556a6f5a76302b705931694d763163695661724369347a2f62365a694c4161565970794a31685854327463692b593266334c61614578630a6f357772316141464d3437786d526d476f3832492f76434847413952786735776147433970574f475a5675555172447355367463556b434d422b325a344753390a354f44474364444b32674e6574446e62324a764873714154736d3443633633476468695a30734346594c71796d2b576531774359616c78734f3231572b4f676f0a42336f6746464977327232462b714a7a714d37415543794c466869357a476d7536534e6558765534477a784750464a4e47306d414f55497761614e3161446a630a4e326b3462437266796271337a366e436533444273384b3232694e2b3875526e534162434f717a5a5845645971555959354b6b6a326e654354525458494e64670a512b61535359673379355937626f4b6b6a494f727650555748654f796475512b74657273414577376e43564a7a72394e387452673271563450557631434b66700a4f49467742372f39736f6d6a59496a71576f61537a6a784b30633852777a305331706d722b7571726277792b50656f75354d3373656d486c426b4769553237660a776f684b792b4d554e4862734e6a7973535a53456c4e4b734d4950715449567a5a45316d5646412f30754d477164705133627a424f6a58325a6f36656446434f0a6d4a34775961765735774d2b6a6d75564b5056564e7939395a78796570304645644c50354b623263345a6c3053396631342f62366836415069785665377a75760a5662536b4279664a6e797a68494f5942497954374d64773134723441584a56362b5a6f457730397769774d3d0a2d2d2d2d2d454e44204453412050524956415445204b45592d2d2d2d2d0a*771", "12345"},
+	{NULL}
+};
+
+struct fmt_main fmt_ssh;
+
+static void init(struct fmt_main *pFmt)
+{
+	/* OpenSSL init, cleanup part is left to OS */
+	SSL_load_error_strings();
+	SSL_library_init();
+	OpenSSL_add_all_algorithms();
+
+#if defined(_OPENMP) && OPENSSL_VERSION_NUMBER >= 0x10000000
+	if (SSLeay() < 0x10000000) {
+		fprintf(stderr, "Warning: compiled against OpenSSL 1.0+, "
+		    "but running with an older version -\n"
+		    "disabling OpenMP for SSH because of thread-safety issues "
+		    "of older OpenSSL\n");
+		fmt_ssh.params.min_keys_per_crypt =
+		    fmt_ssh.params.max_keys_per_crypt = 1;
+		fmt_ssh.params.flags &= ~FMT_OMP;
+	}
+#endif
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	return !strncmp(ciphertext, "$ssh2$", 6);
+}
+
+static void *get_salt(char *ciphertext)
+{
+	int i;
+	char *copy = strdup(ciphertext);
+	char *encoded_data = strtok(copy, "*");
+	if (!copy || !encoded_data) {
+		fprintf(stderr, "BUG in parsing ciphertext, aborting!\n");
+		exit(-1);
+	}
+	int filelength = atoi(strtok(NULL, "*"));
+	encoded_data += 6;	/* skip over "$ssh2$ marker */
+	/* decode base64 data */
+	char *decoded_data = (char *) malloc(filelength + 1);
+	for (i = 0; i < filelength; i++)
+		decoded_data[i] =
+		    atoi16[ARCH_INDEX(encoded_data[i * 2])] * 16 +
+		    atoi16[ARCH_INDEX(encoded_data[i * 2 + 1])];
+	decoded_data[filelength] = 0;
+
+	/* load decoded data into OpenSSL structures */
+	BIO *bp = BIO_new(BIO_s_mem());
+	if (!bp) {
+		fprintf(stderr, "OpenSSL BIO allocation failure\n");
+		exit(-2);
+	}
+	BIO_puts(bp, decoded_data);
+
+	/* PEM_bytes_read_bio function in crypto/pem/pem_lib.c
+	 * check_pem function in crypto/pem/pem_lib.c */
+	char *nm = NULL, *header = NULL;
+	unsigned char *data = NULL;
+	EVP_CIPHER_INFO cipher;
+	EVP_PKEY pk;
+	long len;
+	for (;;) {
+		if (!PEM_read_bio(bp, &nm, &header, &data, &len)) {
+			if (ERR_GET_REASON(ERR_peek_error()) ==
+			    PEM_R_NO_START_LINE) {
+				ERR_print_errors_fp(stderr);
+				exit(-3);
+			}
+		}
+		/* only PEM encoded DSA and RSA private keys are supported. */
+		if (!strcmp(nm, PEM_STRING_DSA)) {
+			pk.save_type = EVP_PKEY_DSA;
+			pk.type = EVP_PKEY_type(EVP_PKEY_DSA);
+			break;
+		}
+		if (!strcmp(nm, PEM_STRING_RSA)) {
+			pk.save_type = EVP_PKEY_RSA;
+			pk.type = EVP_PKEY_type(EVP_PKEY_RSA);
+			break;
+		}
+		OPENSSL_free(nm);
+		OPENSSL_free(header);
+		OPENSSL_free(data);
+		OPENSSL_free(bp);
+	}
+	if (!PEM_get_EVP_CIPHER_INFO(header, &cipher)) {
+		ERR_print_errors_fp(stderr);
+		exit(-4);
+	}
+#ifdef SSH_FMT_DEBUG
+	printf("Header Information:\n%s\n", header);
+#endif
+
+	/* save custom_salt information */
+	static struct custom_salt cs;
+	memset(&cs, 0, sizeof(cs));
+	memcpy(&cs.cipher, &cipher, sizeof(cipher));
+	memcpy(&cs.pk, &pk, sizeof(pk));
+	memcpy(cs.data, data, len);
+	cs.len = len;
+
+	OPENSSL_free(nm);
+	OPENSSL_free(header);
+	OPENSSL_free(data);
+	BIO_free(bp);
+	if (copy)
+		free(copy);
+	if (decoded_data)
+		free(decoded_data);
+	return (void *) &cs;
+}
+
+static void set_salt(void *salt)
+{
+	/* restore custom_salt back */
+	restored_custom_salt = (struct custom_salt *) salt;
+	memset(has_been_cracked, 0, MAX_KEYS_PER_CRYPT);
+}
+
+static void ssh_set_key(char *key, int index)
+{
+	int len = strlen(key);
+	if (len > PLAINTEXT_LENGTH)
+		len = PLAINTEXT_LENGTH;
+	memcpy(saved_key[index], key, len);
+	saved_key[index][len] = 0;
+}
+
+static char *get_key(int index)
+{
+	return saved_key[index];
+}
+
+static void crypt_all(int count)
+{
+	int index;
+#if defined(_OPENMP) && OPENSSL_VERSION_NUMBER >= 0x10000000
+#pragma omp parallel for default(none) private(index) shared(count, has_been_cracked, saved_key, restored_custom_salt)
+#endif
+	for (index = 0; index < count; index++) {
+		/* copy restored items into working copy */
+		unsigned char working_data[4096];
+		long working_len = restored_custom_salt->len;
+		memcpy(working_data, restored_custom_salt->data, working_len);
+		EVP_CIPHER_INFO cipher = restored_custom_salt->cipher;
+		EVP_PKEY pk = restored_custom_salt->pk;
+		const char unsigned *dc = working_data;
+		DSA *dsapkc = NULL;
+		RSA *rsapkc = NULL;
+		if (PEM_do_header(&cipher, working_data, &working_len, NULL,
+			(char *) saved_key[index])) {
+			if (pk.save_type == EVP_PKEY_DSA) {
+				if ((dsapkc =
+					d2i_DSAPrivateKey(NULL, &dc,
+					    working_len)) != NULL) {
+					has_been_cracked[index] = 1;
+					DSA_free(dsapkc);
+				}
+			} else if (pk.save_type == EVP_PKEY_RSA) {
+				if ((rsapkc =
+					d2i_RSAPrivateKey(NULL, &dc,
+					    working_len)) != NULL) {
+					has_been_cracked[index] = 1;
+					RSA_free(rsapkc);
+				}
+			}
+		}
+	}
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return 1;
+}
+
+static int cmp_one(void *binary, int index)
+{
+	return has_been_cracked[index];
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return has_been_cracked[index];
+}
+
+struct fmt_main fmt_ssh = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+#if defined(_OPENMP) && OPENSSL_VERSION_NUMBER >= 0x10000000
+		FMT_OMP |
+#endif
+		FMT_CASE | FMT_8_BIT,
+		ssh_tests
+	}, {
+		init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		fmt_default_binary,
+		get_salt,
+		{
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		set_salt,
+		ssh_set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			fmt_default_get_hash
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
diff -rupN john-1.7.8/src/stages_mmx_md5.S john-1.7.8-jumbo-2/src/stages_mmx_md5.S
--- john-1.7.8/src/stages_mmx_md5.S	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/stages_mmx_md5.S	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,196 @@
+const_stage_1:
+.long 0xd76aa478
+.long 0xd76aa478
+const_stage_2:
+.long 0xe8c7b756
+.long 0xe8c7b756
+const_stage_3:
+.long 0x242070db
+.long 0x242070db
+const_stage_4:
+.long 0xc1bdceee
+.long 0xc1bdceee
+const_stage_5:
+.long 0xf57c0faf
+.long 0xf57c0faf
+const_stage_6:
+.long 0x4787c62a
+.long 0x4787c62a
+const_stage_7:
+.long 0xa8304613
+.long 0xa8304613
+const_stage_8:
+.long 0xfd469501
+.long 0xfd469501
+const_stage_9:
+.long 0x698098d8
+.long 0x698098d8
+const_stage_10:
+.long 0x8b44f7af
+.long 0x8b44f7af
+const_stage_11:
+.long 0xffff5bb1
+.long 0xffff5bb1
+const_stage_12:
+.long 0x895cd7be
+.long 0x895cd7be
+const_stage_13:
+.long 0x6b901122
+.long 0x6b901122
+const_stage_14:
+.long 0xfd987193
+.long 0xfd987193
+const_stage_15:
+.long 0xa679438e
+.long 0xa679438e
+const_stage_16:
+.long 0x49b40821
+.long 0x49b40821
+const_stage_17:
+.long 0xf61e2562
+.long 0xf61e2562
+const_stage_18:
+.long 0xc040b340
+.long 0xc040b340
+const_stage_19:
+.long 0x265e5a51
+.long 0x265e5a51
+const_stage_20:
+.long 0xe9b6c7aa
+.long 0xe9b6c7aa
+const_stage_21:
+.long 0xd62f105d
+.long 0xd62f105d
+const_stage_22:
+.long 0x02441453
+.long 0x02441453
+const_stage_23:
+.long 0xd8a1e681
+.long 0xd8a1e681
+const_stage_24:
+.long 0xe7d3fbc8
+.long 0xe7d3fbc8
+const_stage_25:
+.long 0x21e1cde6
+.long 0x21e1cde6
+const_stage_26:
+.long 0xc33707d6
+.long 0xc33707d6
+const_stage_27:
+.long 0xf4d50d87
+.long 0xf4d50d87
+const_stage_28:
+.long 0x455a14ed
+.long 0x455a14ed
+const_stage_29:
+.long 0xa9e3e905
+.long 0xa9e3e905
+const_stage_30:
+.long 0xfcefa3f8
+.long 0xfcefa3f8
+const_stage_31:
+.long 0x676f02d9
+.long 0x676f02d9
+const_stage_32:
+.long 0x8d2a4c8a
+.long 0x8d2a4c8a
+const_stage_33:
+.long 0xfffa3942
+.long 0xfffa3942
+const_stage_34:
+.long 0x8771f681
+.long 0x8771f681
+const_stage_35:
+.long 0x6d9d6122
+.long 0x6d9d6122
+const_stage_36:
+.long 0xfde5380c
+.long 0xfde5380c
+const_stage_37:
+.long 0xa4beea44
+.long 0xa4beea44
+const_stage_38:
+.long 0x4bdecfa9
+.long 0x4bdecfa9
+const_stage_39:
+.long 0xf6bb4b60
+.long 0xf6bb4b60
+const_stage_40:
+.long 0xbebfbc70
+.long 0xbebfbc70
+const_stage_41:
+.long 0x289b7ec6
+.long 0x289b7ec6
+const_stage_42:
+.long 0xeaa127fa
+.long 0xeaa127fa
+const_stage_43:
+.long 0xd4ef3085
+.long 0xd4ef3085
+const_stage_44:
+.long 0x04881d05
+.long 0x04881d05
+const_stage_45:
+.long 0xd9d4d039
+.long 0xd9d4d039
+const_stage_46:
+.long 0xe6db99e5
+.long 0xe6db99e5
+const_stage_47:
+.long 0x1fa27cf8
+.long 0x1fa27cf8
+const_stage_48:
+.long 0xc4ac5665
+.long 0xc4ac5665
+const_stage_49:
+.long 0xf4292244
+.long 0xf4292244
+const_stage_50:
+.long 0x432aff97
+.long 0x432aff97
+const_stage_51:
+.long 0xab9423a7
+.long 0xab9423a7
+const_stage_52:
+.long 0xfc93a039
+.long 0xfc93a039
+const_stage_53:
+.long 0x655b59c3
+.long 0x655b59c3
+const_stage_54:
+.long 0x8f0ccc92
+.long 0x8f0ccc92
+const_stage_55:
+.long 0xffeff47d
+.long 0xffeff47d
+const_stage_56:
+.long 0x85845dd1
+.long 0x85845dd1
+const_stage_57:
+.long 0x6fa87e4f
+.long 0x6fa87e4f
+const_stage_58:
+.long 0xfe2ce6e0
+.long 0xfe2ce6e0
+const_stage_59:
+.long 0xa3014314
+.long 0xa3014314
+const_stage_60:
+.long 0x4e0811a1
+.long 0x4e0811a1
+const_stage_61:
+.long 0xf7537e82
+.long 0xf7537e82
+const_stage_62:
+.long 0xbd3af235
+.long 0xbd3af235
+const_stage_63:
+.long 0x2ad7d2bb
+.long 0x2ad7d2bb
+const_stage_64:
+.long 0xeb86d391
+.long 0xeb86d391
+
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",@progbits
+#endif
diff -rupN john-1.7.8/src/stages_sse2_md5.S john-1.7.8-jumbo-2/src/stages_sse2_md5.S
--- john-1.7.8/src/stages_sse2_md5.S	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/stages_sse2_md5.S	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,324 @@
+const_stage_1:
+.long 0xd76aa478
+.long 0xd76aa478
+.long 0xd76aa478
+.long 0xd76aa478
+const_stage_2:
+.long 0xe8c7b756
+.long 0xe8c7b756
+.long 0xe8c7b756
+.long 0xe8c7b756
+const_stage_3:
+.long 0x242070db
+.long 0x242070db
+.long 0x242070db
+.long 0x242070db
+const_stage_4:
+.long 0xc1bdceee
+.long 0xc1bdceee
+.long 0xc1bdceee
+.long 0xc1bdceee
+const_stage_5:
+.long 0xf57c0faf
+.long 0xf57c0faf
+.long 0xf57c0faf
+.long 0xf57c0faf
+const_stage_6:
+.long 0x4787c62a
+.long 0x4787c62a
+.long 0x4787c62a
+.long 0x4787c62a
+const_stage_7:
+.long 0xa8304613
+.long 0xa8304613
+.long 0xa8304613
+.long 0xa8304613
+const_stage_8:
+.long 0xfd469501
+.long 0xfd469501
+.long 0xfd469501
+.long 0xfd469501
+const_stage_9:
+.long 0x698098d8
+.long 0x698098d8
+.long 0x698098d8
+.long 0x698098d8
+const_stage_10:
+.long 0x8b44f7af
+.long 0x8b44f7af
+.long 0x8b44f7af
+.long 0x8b44f7af
+const_stage_11:
+.long 0xffff5bb1
+.long 0xffff5bb1
+.long 0xffff5bb1
+.long 0xffff5bb1
+const_stage_12:
+.long 0x895cd7be
+.long 0x895cd7be
+.long 0x895cd7be
+.long 0x895cd7be
+const_stage_13:
+.long 0x6b901122
+.long 0x6b901122
+.long 0x6b901122
+.long 0x6b901122
+const_stage_14:
+.long 0xfd987193
+.long 0xfd987193
+.long 0xfd987193
+.long 0xfd987193
+const_stage_15:
+.long 0xa679438e
+.long 0xa679438e
+.long 0xa679438e
+.long 0xa679438e
+const_stage_16:
+.long 0x49b40821
+.long 0x49b40821
+.long 0x49b40821
+.long 0x49b40821
+const_stage_17:
+.long 0xf61e2562
+.long 0xf61e2562
+.long 0xf61e2562
+.long 0xf61e2562
+const_stage_18:
+.long 0xc040b340
+.long 0xc040b340
+.long 0xc040b340
+.long 0xc040b340
+const_stage_19:
+.long 0x265e5a51
+.long 0x265e5a51
+.long 0x265e5a51
+.long 0x265e5a51
+const_stage_20:
+.long 0xe9b6c7aa
+.long 0xe9b6c7aa
+.long 0xe9b6c7aa
+.long 0xe9b6c7aa
+const_stage_21:
+.long 0xd62f105d
+.long 0xd62f105d
+.long 0xd62f105d
+.long 0xd62f105d
+const_stage_22:
+.long 0x02441453
+.long 0x02441453
+.long 0x02441453
+.long 0x02441453
+const_stage_23:
+.long 0xd8a1e681
+.long 0xd8a1e681
+.long 0xd8a1e681
+.long 0xd8a1e681
+const_stage_24:
+.long 0xe7d3fbc8
+.long 0xe7d3fbc8
+.long 0xe7d3fbc8
+.long 0xe7d3fbc8
+const_stage_25:
+.long 0x21e1cde6
+.long 0x21e1cde6
+.long 0x21e1cde6
+.long 0x21e1cde6
+const_stage_26:
+.long 0xc33707d6
+.long 0xc33707d6
+.long 0xc33707d6
+.long 0xc33707d6
+const_stage_27:
+.long 0xf4d50d87
+.long 0xf4d50d87
+.long 0xf4d50d87
+.long 0xf4d50d87
+const_stage_28:
+.long 0x455a14ed
+.long 0x455a14ed
+.long 0x455a14ed
+.long 0x455a14ed
+const_stage_29:
+.long 0xa9e3e905
+.long 0xa9e3e905
+.long 0xa9e3e905
+.long 0xa9e3e905
+const_stage_30:
+.long 0xfcefa3f8
+.long 0xfcefa3f8
+.long 0xfcefa3f8
+.long 0xfcefa3f8
+const_stage_31:
+.long 0x676f02d9
+.long 0x676f02d9
+.long 0x676f02d9
+.long 0x676f02d9
+const_stage_32:
+.long 0x8d2a4c8a
+.long 0x8d2a4c8a
+.long 0x8d2a4c8a
+.long 0x8d2a4c8a
+const_stage_33:
+.long 0xfffa3942
+.long 0xfffa3942
+.long 0xfffa3942
+.long 0xfffa3942
+const_stage_34:
+.long 0x8771f681
+.long 0x8771f681
+.long 0x8771f681
+.long 0x8771f681
+const_stage_35:
+.long 0x6d9d6122
+.long 0x6d9d6122
+.long 0x6d9d6122
+.long 0x6d9d6122
+const_stage_36:
+.long 0xfde5380c
+.long 0xfde5380c
+.long 0xfde5380c
+.long 0xfde5380c
+const_stage_37:
+.long 0xa4beea44
+.long 0xa4beea44
+.long 0xa4beea44
+.long 0xa4beea44
+const_stage_38:
+.long 0x4bdecfa9
+.long 0x4bdecfa9
+.long 0x4bdecfa9
+.long 0x4bdecfa9
+const_stage_39:
+.long 0xf6bb4b60
+.long 0xf6bb4b60
+.long 0xf6bb4b60
+.long 0xf6bb4b60
+const_stage_40:
+.long 0xbebfbc70
+.long 0xbebfbc70
+.long 0xbebfbc70
+.long 0xbebfbc70
+const_stage_41:
+.long 0x289b7ec6
+.long 0x289b7ec6
+.long 0x289b7ec6
+.long 0x289b7ec6
+const_stage_42:
+.long 0xeaa127fa
+.long 0xeaa127fa
+.long 0xeaa127fa
+.long 0xeaa127fa
+const_stage_43:
+.long 0xd4ef3085
+.long 0xd4ef3085
+.long 0xd4ef3085
+.long 0xd4ef3085
+const_stage_44:
+.long 0x04881d05
+.long 0x04881d05
+.long 0x04881d05
+.long 0x04881d05
+const_stage_45:
+.long 0xd9d4d039
+.long 0xd9d4d039
+.long 0xd9d4d039
+.long 0xd9d4d039
+const_stage_46:
+.long 0xe6db99e5
+.long 0xe6db99e5
+.long 0xe6db99e5
+.long 0xe6db99e5
+const_stage_47:
+.long 0x1fa27cf8
+.long 0x1fa27cf8
+.long 0x1fa27cf8
+.long 0x1fa27cf8
+const_stage_48:
+.long 0xc4ac5665
+.long 0xc4ac5665
+.long 0xc4ac5665
+.long 0xc4ac5665
+const_stage_49:
+.long 0xf4292244
+.long 0xf4292244
+.long 0xf4292244
+.long 0xf4292244
+const_stage_50:
+.long 0x432aff97
+.long 0x432aff97
+.long 0x432aff97
+.long 0x432aff97
+const_stage_51:
+.long 0xab9423a7
+.long 0xab9423a7
+.long 0xab9423a7
+.long 0xab9423a7
+const_stage_52:
+.long 0xfc93a039
+.long 0xfc93a039
+.long 0xfc93a039
+.long 0xfc93a039
+const_stage_53:
+.long 0x655b59c3
+.long 0x655b59c3
+.long 0x655b59c3
+.long 0x655b59c3
+const_stage_54:
+.long 0x8f0ccc92
+.long 0x8f0ccc92
+.long 0x8f0ccc92
+.long 0x8f0ccc92
+const_stage_55:
+.long 0xffeff47d
+.long 0xffeff47d
+.long 0xffeff47d
+.long 0xffeff47d
+const_stage_56:
+.long 0x85845dd1
+.long 0x85845dd1
+.long 0x85845dd1
+.long 0x85845dd1
+const_stage_57:
+.long 0x6fa87e4f
+.long 0x6fa87e4f
+.long 0x6fa87e4f
+.long 0x6fa87e4f
+const_stage_58:
+.long 0xfe2ce6e0
+.long 0xfe2ce6e0
+.long 0xfe2ce6e0
+.long 0xfe2ce6e0
+const_stage_59:
+.long 0xa3014314
+.long 0xa3014314
+.long 0xa3014314
+.long 0xa3014314
+const_stage_60:
+.long 0x4e0811a1
+.long 0x4e0811a1
+.long 0x4e0811a1
+.long 0x4e0811a1
+const_stage_61:
+.long 0xf7537e82
+.long 0xf7537e82
+.long 0xf7537e82
+.long 0xf7537e82
+const_stage_62:
+.long 0xbd3af235
+.long 0xbd3af235
+.long 0xbd3af235
+.long 0xbd3af235
+const_stage_63:
+.long 0x2ad7d2bb
+.long 0x2ad7d2bb
+.long 0x2ad7d2bb
+.long 0x2ad7d2bb
+const_stage_64:
+.long 0xeb86d391
+.long 0xeb86d391
+.long 0xeb86d391
+.long 0xeb86d391
+
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",@progbits
+#endif
diff -rupN john-1.7.8/src/status.c john-1.7.8-jumbo-2/src/status.c
--- john-1.7.8/src/status.c	2011-03-26 04:49:56.000000000 +0100
+++ john-1.7.8-jumbo-2/src/status.c	2011-06-08 01:57:38.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2004,2006,2010,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by JimF.
  */
 
 #ifdef __ultrix__
@@ -12,12 +14,21 @@
 #include <limits.h>
 #endif
 #include <stdio.h>
+#include <math.h>
+#include <stdlib.h>
+#include <ctype.h>
 #include <string.h>
 #include <time.h>
+#if !defined (__MINGW32__) && !defined (_MSC_VER)
 #include <sys/times.h>
+#endif
 
 #include "times.h"
 
+#if defined(__GNUC__) && defined(__i386__)
+#include "arch.h" /* for CPU_REQ */
+#endif
+
 #include "misc.h"
 #include "math.h"
 #include "params.h"
@@ -25,20 +36,33 @@
 #include "options.h"
 #include "status.h"
 #include "bench.h"
+#include "config.h"
+
+#ifdef HAVE_MPI
+#include "logger.h"
+#include "john-mpi.h"
+#endif
 
 struct status_main status;
 unsigned int status_restored_time = 0;
-int (*status_get_progress)(void) = NULL;
+static char* timeformat = NULL;
+static double ETAthreshold = 0.05;
+int (*status_get_progress)(int *) = NULL;
 
 static clock_t get_time(void)
 {
+#if defined (__MINGW32__) || defined (_MSC_VER)
+	return clock();
+#else
 	struct tms buf;
 
 	return times(&buf);
+#endif
 }
 
-void status_init(int (*get_progress)(void), int start)
+void status_init(int (*get_progress)(int *), int start)
 {
+	char *cfg_threshold;
 	if (start) {
 		if (!status_restored_time)
 			memset(&status, 0, sizeof(status));
@@ -47,6 +71,13 @@ void status_init(int (*get_progress)(voi
 
 	status_get_progress = get_progress;
 
+	if (!(timeformat = cfg_get_param(SECTION_OPTIONS, NULL, "TimeFormat")))
+		timeformat = "%c";
+
+	if ((cfg_threshold = cfg_get_param(SECTION_OPTIONS, NULL, "ETAthreshold")))
+		if ((ETAthreshold = atof(cfg_threshold)) < 0.01)
+			ETAthreshold = 0.01;
+
 	clk_tck_init();
 }
 
@@ -123,6 +154,225 @@ static char *status_get_cps(char *buffer
 	return buffer;
 }
 
+static char *status_get_ETA(char *percent, unsigned int secs_done)
+{
+	static char s_ETA[128];
+	char *cp;
+	double sec_left, percent_left;
+	time_t t_ETA;
+	struct tm *pTm;
+
+#if CPU_REQ && defined(__GNUC__) && defined(__i386__)
+/* ETA reporting would be wrong when cracking some hash types at least on a
+ * Pentium 3 without this... */
+	__asm__ __volatile__("emms");
+#endif
+
+	/* Compute the ETA for this run.  Assumes even run time for
+	   work currently done and work left to do, and that the CPU
+	   utilization of work done and work to do will stay same
+	   which may not always a valid assumtions */
+	cp = percent;
+	while (cp && *cp && isspace(*cp))
+		++cp;
+	if (!cp || *cp == 0 || !isdigit(*cp))
+		return "";  /* dont show ETA if no valid percentage. */
+	else
+	{
+		double chk;
+		percent_left = atof(percent);
+		t_ETA = time(NULL);
+		if (percent_left >= 100.0) {
+			pTm = localtime(&t_ETA);
+			strcpy(s_ETA, " (");
+			strftime(&s_ETA[2], sizeof(s_ETA)-3, timeformat, pTm);
+			strcat(s_ETA, ")");
+			return s_ETA;
+		}
+		if (percent_left == 0 || percent_left < ETAthreshold)
+			return "";  /* mute ETA if too little progress */
+		percent_left /= 100;
+		sec_left = secs_done;
+		sec_left /= percent_left;
+		sec_left -= secs_done;
+		/* Note, many localtime() will fault if given a time_t
+		   later than Jan 19, 2038 (i.e. 0x7FFFFFFFF). We
+		   check for that here, and if so, this run will
+		   not end anyway, so simply tell user to not hold
+		   her breath */
+		chk = sec_left;
+		chk += t_ETA;
+		if (chk > 0x7FFFF000) { /* slightly less than 'max' 32 bit time_t, for safety */
+			strcpy(s_ETA, " (ETA: never)");
+			return s_ETA;
+		}
+		t_ETA += sec_left;
+		pTm = localtime(&t_ETA);
+		strcpy(s_ETA, " (ETA: ");
+		strftime(&s_ETA[7], sizeof(s_ETA)-10, timeformat, pTm);
+		strcat(s_ETA, ")");
+	}
+	return s_ETA;
+}
+
+#ifdef HAVE_MPI
+static char *status_get_totalcps(char *buffer)
+{
+	int use_ticks, bufcat = 0;
+	clock_t ticks;
+	unsigned long time, sumtime;
+	long long cps, crypts, sumcrypts;
+	unsigned cps_100;
+
+	use_ticks = !status.crypts.hi && !status_restored_time;
+
+	ticks = get_time() - status.start_time;
+	if (use_ticks)
+		time = ticks;
+	else
+		time = status_restored_time + ticks / clk_tck;
+
+	crypts = ((long long)status.crypts.hi << 32) + status.crypts.lo;
+
+	// This calculates the total cps figure (total crypts / avg run time).
+	// It will show optimistic if the nodes don't finish at the same time
+	MPI_Reduce(&time, &sumtime, 1, MPI_UNSIGNED_LONG, MPI_SUM, 0, MPI_COMM_WORLD);
+	MPI_Reduce(&crypts, &sumcrypts, 1, MPI_LONG_LONG, MPI_SUM, 0, MPI_COMM_WORLD);
+	time = sumtime / mpi_p;
+	crypts = sumcrypts;
+
+	if (use_ticks) crypts *= clk_tck;
+	cps = crypts / (time ? time : 1);
+
+	if (cps >= 1000000000000LL)
+		bufcat = sprintf(buffer, "%lluG", (cps / 1000000000));
+	else
+	if (cps >= 1000000000)
+		bufcat = sprintf(buffer, "%lluM", (cps / 1000000));
+	else
+	if (cps >= 1000000)
+		bufcat = sprintf(buffer, "%lluK", (cps / 1000));
+	else
+	if (cps >= 100)
+		bufcat = sprintf(buffer, "%llu", cps);
+	else {
+		cps_100 = (unsigned)((crypts * 100 / (time ? time : 1)) % 100);
+		bufcat = sprintf(buffer, "%llu.%02u", cps, cps_100);
+	}
+
+	cps = crypts / mpi_p / (time ? time : 1);
+
+	if (cps >= 1000000000000LL)
+		sprintf(&buffer[bufcat], " avg %lluG", (cps / 1000000000));
+	else
+	if (cps >= 1000000000)
+		sprintf(&buffer[bufcat], " avg %lluM", (cps / 1000000));
+	else
+	if (cps >= 1000000)
+		sprintf(&buffer[bufcat], " avg %lluK", (cps / 1000));
+	else
+	if (cps >= 100)
+		sprintf(&buffer[bufcat], " avg %llu", cps);
+	else {
+		cps_100 = (unsigned)((crypts * 100 / mpi_p / (time ? time : 1)) % 100);
+		sprintf(&buffer[bufcat], " avg%llu.%02u", cps, cps_100);
+	}
+	return buffer;
+}
+
+static char *status_get_totalETA(char *percent, unsigned int secs_done)
+{
+	static char s_ETA[128];
+	char *cp;
+	double sec_left, percent_left, max_sec_left;
+	time_t t_ETA;
+	struct tm *pTm;
+
+#if CPU_REQ && defined(__GNUC__) && defined(__i386__)
+/* ETA reporting would be wrong when cracking some hash types at least on a
+ * Pentium 3 without this... */
+	__asm__ __volatile__("emms");
+#endif
+
+	cp = percent;
+	while (cp && *cp && isspace(*cp))
+		++cp;
+	if (!cp || *cp == 0 || !isdigit(*cp)) {
+		// We must report to MPI_Allreduce anyway
+		sec_left = 0;
+		MPI_Allreduce(&sec_left, &max_sec_left, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
+		return "";  /* dont show ETA if no valid percentage. */
+	}
+	else
+	{
+		double chk;
+		percent_left = atof(percent);
+		t_ETA = time(NULL);
+		if (percent_left >= 100.0) {
+			// We must report to MPI_Allreduce anyway
+			sec_left = 0;
+			MPI_Allreduce(&sec_left, &max_sec_left, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
+			pTm = localtime(&t_ETA);
+			strcpy(s_ETA, " (");
+			strftime(&s_ETA[2], sizeof(s_ETA)-3, timeformat, pTm);
+			strcat(s_ETA, ")");
+			return s_ETA;
+		}
+		if (percent_left == 0 || percent_left < ETAthreshold) {
+			// We must report to MPI_Allreduce anyway
+			sec_left = 0;
+			MPI_Allreduce(&sec_left, &max_sec_left, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
+			return "";  /* mute ETA if too little progress */
+		}
+		percent_left /= 100;
+		sec_left = secs_done;
+		sec_left /= percent_left;
+		sec_left -= secs_done;
+		// Reports the worst ETA for all nodes
+		MPI_Allreduce(&sec_left, &max_sec_left, 1, MPI_DOUBLE, MPI_MAX, MPI_COMM_WORLD);
+		sec_left = max_sec_left;
+
+		chk = sec_left;
+		chk += t_ETA;
+		if (chk > 0x7FFFF000) { /* slightly less than 'max' 32 bit time_t, for safety */
+			strcpy(s_ETA, " (ETA: never)");
+			return s_ETA;
+		}
+		t_ETA += sec_left;
+		pTm = localtime(&t_ETA);
+		strcpy(s_ETA, " (ETA: ");
+		strftime(&s_ETA[7], sizeof(s_ETA)-10, timeformat, pTm);
+		strcat(s_ETA, ")");
+	}
+	return s_ETA;
+}
+
+static void status_print_total(char *totpercent)
+{
+	unsigned int max_time, time = status_get_time();
+	char s_cps[64];
+	char *tot_ETA;
+	unsigned int sum_guess;
+
+	MPI_Reduce(&status.guess_count, &sum_guess, 1, MPI_UNSIGNED, MPI_SUM, 0, MPI_COMM_WORLD);
+	MPI_Allreduce(&time, &max_time, 1, MPI_UNSIGNED, MPI_MAX, MPI_COMM_WORLD);
+	tot_ETA = status_get_totalETA(totpercent, max_time);
+	status_get_totalcps(s_cps);
+	if (mpi_id == 0) {
+		fprintf(stderr,
+		        "SUM: guesses: %u "
+		        "time: %u:%02u:%02u:%02u"
+		        "%s%s "
+		        "c/s: %s\n",
+		        sum_guess,
+		        max_time / 86400, max_time % 86400 / 3600, max_time % 3600 / 60, max_time % 60,
+		        strncmp(totpercent, " 100", 4) ? totpercent : " DONE",
+		        tot_ETA,
+		        s_cps);
+	}
+}
+#endif
+
 static void status_print_stdout(char *percent)
 {
 	unsigned int time = status_get_time();
@@ -149,11 +399,12 @@ static void status_print_stdout(char *pe
 	fprintf(stderr,
 		"words: %s  "
 		"time: %u:%02u:%02u:%02u"
-		"%s  "
+		"%s%s  "
 		"w/s: %s",
 		s_words_ptr,
 		time / 86400, time % 86400 / 3600, time % 3600 / 60, time % 60,
-		percent,
+		strncmp(percent, " 100", 4) ? percent : " DONE",
+		status_get_ETA(percent, time),
 		status_get_cps(s_wps));
 
 	if ((options.flags & FLG_STATUS_CHK) ||
@@ -178,14 +429,48 @@ static void status_print_cracking(char *
 			saved_key[0] = 0;
 	}
 
+#ifdef HAVE_MPI
+	// we need to print until cr in one call, otherwise output gets interleaved
+	char nodeid[11] = "";
+	if (mpi_p > 1)
+		snprintf(nodeid, sizeof(nodeid), "%3d: ", mpi_id);
+	nodeid[sizeof(nodeid)-1] = 0;
+	char trying[256];
+	if ((options.flags & FLG_STATUS_CHK) ||
+	    !(status.crypts.lo | status.crypts.hi))
+		trying[0] = 0;
+	else
+		snprintf(trying, sizeof(trying),
+		         "%strying: %s%s%s",
+		         mpi_p > 1 ? " " : "  ",
+		         crk_get_key1(), saved_key[0] ? " - " : "", saved_key);
+
+	fprintf(stderr,
+	        "%s"
+	        "guesses: %u%s"
+	        "time: %u:%02u:%02u:%02u"
+	        "%s%s%s"
+	        "c/s: %s"
+	        "%s\n",
+	        nodeid,
+	        status.guess_count,
+	        mpi_p > 1 ? " " : "  ",
+	        time / 86400, time % 86400 / 3600, time % 3600 / 60, time % 60,
+	        strncmp(percent, " 100", 4) ? percent : " DONE",
+	        status_get_ETA(percent,time),
+	        mpi_p > 1 ? " " : "  ",
+	        status_get_cps(s_cps),
+	        trying);
+#else
 	fprintf(stderr,
 		"guesses: %u  "
 		"time: %u:%02u:%02u:%02u"
-		"%s  "
+		"%s%s  "
 		"c/s: %s",
 		status.guess_count,
 		time / 86400, time % 86400 / 3600, time % 3600 / 60, time % 60,
-		percent,
+		strncmp(percent, " 100", 4) ? percent : " DONE",
+		status_get_ETA(percent,time),
 		status_get_cps(s_cps));
 
 	if ((options.flags & FLG_STATUS_CHK) ||
@@ -195,11 +480,12 @@ static void status_print_cracking(char *
 		fprintf(stderr,
 			"  trying: %s%s%s\n",
 			crk_get_key1(), saved_key[0] ? " - " : "", saved_key);
+#endif
 }
 
 void status_print(void)
 {
-	int percent_value;
+	int percent_value, hund_percent = 0;
 	char s_percent[32];
 
 	percent_value = -1;
@@ -207,18 +493,41 @@ void status_print(void)
 		percent_value = status.progress;
 	else
 	if (status_get_progress)
-		percent_value = status_get_progress();
+		percent_value = status_get_progress(&hund_percent);
 
 	s_percent[0] = 0;
-	if (percent_value >= 0)
-		sprintf(s_percent, status.pass ? " %d%% (%d)" : " %d%%",
-			percent_value, status.pass);
+	if (percent_value >= 0 && hund_percent >= 0)
+		sprintf(s_percent, status.pass ? " %d.%02d%% (%d)" : " %d.%02d%%",
+			percent_value, hund_percent, status.pass);
 	else
 	if (status.pass)
 		sprintf(s_percent, " (%d)", status.pass);
 
 	if (options.flags & FLG_STDOUT)
 		status_print_stdout(s_percent);
+#ifdef HAVE_MPI
+	else {
+		status_print_cracking(s_percent);
+		if (mpi_p > 1 && (options.flags & FLG_STATUS_CHK)) {
+			int sum_percent;
+			percent_value = 100 * percent_value + hund_percent;
+			MPI_Allreduce(&percent_value, &sum_percent, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+			hund_percent = (sum_percent / mpi_p) % 100;
+			percent_value = (sum_percent / mpi_p) / 100;
+
+			s_percent[0] = 0;
+			if (percent_value >= 0 && hund_percent >= 0)
+				sprintf(s_percent, status.pass ? " %d.%02d%% (%d)" : " %d.%02d%%",
+				        percent_value, hund_percent, status.pass);
+			else
+				if (status.pass)
+					sprintf(s_percent, " (%d)", status.pass);
+
+			status_print_total(s_percent);
+		}
+	}
+#else
 	else
 		status_print_cracking(s_percent);
+#endif
 }
diff -rupN john-1.7.8/src/status.h john-1.7.8-jumbo-2/src/status.h
--- john-1.7.8/src/status.h	2006-02-27 07:28:54.000000000 +0100
+++ john-1.7.8-jumbo-2/src/status.h	2011-05-17 18:13:03.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2006 by Solar Designer
+ *
+ * ...with changes in the jumbo patch, by JimF.
  */
 
 /*
@@ -27,7 +29,7 @@ struct status_main {
 
 extern struct status_main status;
 
-extern int (*status_get_progress)(void);
+extern int (*status_get_progress)(int *hundth);
 
 /*
  * Elapsed time of previous sessions and excess ticks (if any), in seconds.
@@ -39,7 +41,7 @@ extern unsigned int status_restored_time
  * fields to zero. Always initializes the get_progress() handler (can be
  * NULL).
  */
-extern void status_init(int (*get_progress)(void), int start);
+extern void status_init(int (*get_progress)(int*), int start);
 
 /*
  * Checks the number of ticks elapsed since start_time and moves some excess
diff -rupN john-1.7.8/src/stdint.h john-1.7.8-jumbo-2/src/stdint.h
--- john-1.7.8/src/stdint.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/stdint.h	2011-07-02 02:00:00.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef _STDINT_H
+#ifdef __STDC_VERSION__
+#include <stdint.h>
+#else
+#define _STDINT_H 1
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned long long uint64_t;
+#endif
+#endif
diff -rupN john-1.7.8/src/symlink.c john-1.7.8-jumbo-2/src/symlink.c
--- john-1.7.8/src/symlink.c	2002-04-10 16:13:25.000000000 +0200
+++ john-1.7.8-jumbo-2/src/symlink.c	2011-05-17 18:13:03.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-98 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for MSC, by JimF.
  */
 
 /*
@@ -14,7 +16,13 @@
 
 int main(int argc, char **argv)
 {
+#if !defined (_MSC_VER)
 	char path[strlen(argv[0] ? argv[0] : "") + sizeof(MAIN_NAME)];
+#else
+#pragma warning ( disable : 4996 )
+    char path[4096];
+#endif
+
 	char *name;
 
 	if (!argv[0])
diff -rupN john-1.7.8/src/tgtsnarf.c john-1.7.8-jumbo-2/src/tgtsnarf.c
--- john-1.7.8/src/tgtsnarf.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/tgtsnarf.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,278 @@
+/*
+  tgtsnarf
+
+  Collect AFS/Kerberos TGTs for later offline dictionary attack.
+
+  Copyright (c) 1999 Dug Song <dugsong@monkey.org>
+  All rights reserved, all wrongs reversed.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+  2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+  3. The name of author may not be used to endorse or promote products
+     derived from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
+  INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+  AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+  THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <sys/types.h>
+#include <sys/time.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <netdb.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <ctype.h>
+
+#define VERSION		"1.2"
+#define TGT_LENGTH	16
+
+#ifndef MIN
+#define MIN(a,b)	(((a)<(b))?(a):(b))
+#endif
+
+typedef struct ktext_st {
+  unsigned int length;
+  unsigned char dat[1250];
+} KTEXT_ST;
+
+int AFS = 0;
+
+void
+usage(void)
+{
+  fprintf(stderr, "Usage: tgtsnarf [-A] realm host [users...]\n");
+  exit(1);
+}
+
+unsigned long
+resolve_host(char *host)
+{
+  unsigned long addr;
+  struct hostent *hp;
+
+  if ((addr = inet_addr(host)) == -1) {
+    if ((hp = gethostbyname(host)) == NULL)
+      return (-1);
+    memcpy((char *)&addr, hp->h_addr, sizeof(addr));
+  }
+  return (addr);
+}
+
+int
+krb_put_int(unsigned long from, void *to, int size)
+{
+  int i;
+  unsigned char *p = (unsigned char *)to;
+
+  for (i = size - 1; i >= 0; i--) {
+    p[i] = from & 0xff;
+    from >>= 8;
+  }
+  return (size);
+}
+
+int
+krb_put_string(char *from, void *to)
+{
+  strcpy((char *)to, from);
+  return (strlen(from) + 1);
+}
+
+int
+make_req(unsigned char *dst, char *user, char *realm)
+{
+  char *pname, *pinst;
+  struct timeval tv;
+  unsigned char *p;
+
+  if ((pname = strdup(user)) == NULL)
+    return (-1);
+
+  if ((pinst = strchr(pname, '.')) != NULL)
+    *pinst++ = '\0';
+  else pinst = pname + strlen(pname);
+
+  gettimeofday(&tv, NULL);
+
+  p = dst;
+  p += krb_put_int(4, p, 1);			/* protocol version */
+  p += krb_put_int((1 << 1), p, 1);		/* msg type (KDC_REQUEST) */
+  p += krb_put_string(pname, p);		/* principal name */
+  p += krb_put_string(pinst, p);		/* principal instance */
+  p += krb_put_string(realm, p);		/* realm */
+  p += krb_put_int(tv.tv_sec, p, 4);		/* time */
+  p += krb_put_int(120, p, 1);			/* lifetime (120) */
+  p += krb_put_string("krbtgt", p);		/* service name (krbtgt)*/
+  p += krb_put_string(realm, p);		/* service instance (realm) */
+
+  free(pname);
+
+  return (p - dst);
+}
+
+int
+find_tkt(KTEXT_ST *ktext, unsigned char *dst, int size)
+{
+  unsigned char *p;
+  int type, len;
+
+  p = ktext->dat;
+  p += 1;			/* version */
+  type = *p++;
+  type &= ~1;			/* msg type */
+
+  if (type != (2 << 1))		/* KDC_REPLY */
+    return (-1);
+
+  p += strlen((char*)p) + 1;	/* name */
+  p += strlen((char*)p) + 1;	/* instance */
+  p += strlen((char*)p) + 1;	/* realm */
+  p += 4;			/* time */
+  p += 1;			/* # tickets */
+  p += 4;			/* exp date */
+  p += 1;			/* master kvno */
+  p += 2;			/* length */
+
+  len = MIN(ktext->length - (p - ktext->dat), size);
+  memcpy(dst, p, len);
+
+  return (len);
+}
+
+int
+fetch_tgt(char *host, char *user, char *realm, unsigned char *dst, int size)
+{
+  struct sockaddr_in from, to;
+  KTEXT_ST ktext;
+  int sock;
+  socklen_t alen;
+
+  /* Fill in dest addr. */
+  memset(&to, 0, sizeof(to));
+  if ((to.sin_addr.s_addr = resolve_host(host)) == -1) {
+    fprintf(stderr, "bad host: %s\n", host);
+    return (-1);
+  }
+  to.sin_family = AF_INET;
+  to.sin_port = htons(750);
+
+  /* Fill in our TGT request. */
+  ktext.length = make_req(ktext.dat, user, realm);
+
+  /* Send it to KDC. */
+  if ((sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+    perror("socket");
+    return (-1);
+  }
+  alen = sizeof(to);
+  if (sendto(sock, ktext.dat, ktext.length, 0, (struct sockaddr *)&to, alen)
+      < 0) {
+    perror("send");
+    close(sock);
+    return (-1);
+  }
+  /* Read reply. */
+  if ((ktext.length = recvfrom(sock, ktext.dat, sizeof(ktext.dat), 0,
+			       (struct sockaddr *)&from, &alen)) <= 0) {
+    perror("recv");
+    close(sock);
+    return (-1);
+  }
+  close(sock);
+
+  /* Extract TGT. */
+  return (find_tkt(&ktext, dst, size));
+}
+
+void
+print_tgt(char *host, char *user, char *realm)
+{
+  unsigned char tgt[TGT_LENGTH];
+  int i, len;
+
+  if ((len = fetch_tgt(host, user, realm, tgt, sizeof(tgt))) == -1) {
+    fprintf(stderr, "==> couldn't get tgt for %s@%s\n", user, realm);
+  }
+  else {
+    printf("%s:$%s$%s$", user, AFS ? "af" : "k4", realm);
+
+    for (i = 0; i < len; i++)
+      printf("%.2x", tgt[i]);
+
+    printf("\n");
+  }
+}
+
+char *
+upcase(char *string)
+{
+  char *p;
+
+  for (p = string; *p != '\0'; p++)
+    *p = toupper(*p);
+
+  return (string);
+}
+
+int
+main(int argc, char *argv[])
+{
+  char c, *p, *host, *realm, user[128];
+  int i;
+
+  host = realm = NULL;
+
+  while ((c = getopt(argc, argv, "h?AV")) != EOF) {
+    switch (c) {
+    case 'A':
+      AFS = 1;
+      break;
+    case 'V':
+      fprintf(stderr, "Version: %s\n", VERSION);
+      usage();
+      break;
+    default:
+      usage();
+    }
+  }
+  argc -= optind;
+  argv += optind;
+
+  if (argc < 2)
+    usage();
+
+  realm = upcase(argv[0]);
+  host = argv[1];
+
+  if (argc == 2) {
+    while (fgets(user, sizeof(user), stdin) != NULL) {
+      if ((p = strrchr(user, '\n')) != NULL)
+	*p = '\0';
+      print_tgt(host, user, realm);
+    }
+  }
+  else {
+    for (i = 2; i < argc; i++)
+      print_tgt(host, argv[i], realm);
+  }
+  exit(0);
+}
diff -rupN john-1.7.8/src/timer.c john-1.7.8-jumbo-2/src/timer.c
--- john-1.7.8/src/timer.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/timer.c	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,127 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Portable hi-res timer.  Was a nice C++ class.
+ * Downgraded to C for project john
+ *
+ */
+
+#include "timer.h"
+#include <stdio.h>
+
+double sm_HRTicksPerSec=0.0;	// HR Ticks per second
+int sm_fGotHRTicksPerSec=0;	// Set if we have got the above
+double sm_hrPrecision=0.0;
+double sm_cPrecision=0.0;
+
+void sTimer_sTimer (sTimer *t)
+{
+	t->m_fRunning=0;
+	t->m_cStartTime=0;
+	t->m_cEndTime=0;
+	t->m_dAccumSeconds=0;
+	HRZERO(t->m_hrStartTime);
+	HRZERO(t->m_hrEndTime);
+	if (!sm_fGotHRTicksPerSec)
+	{
+        // What's the lowest digit set non-zero in a clock() call
+		// That's a fair indication what the precision is likely to be.
+		// Note - this isn't actually used
+		clock_t heuristicTimeTest=clock();
+		sm_fGotHRTicksPerSec = 1;
+		if(heuristicTimeTest%10) sm_cPrecision = 1.0/CLOCKS_PER_SEC;
+		else if(heuristicTimeTest%100) sm_cPrecision = 10.0/CLOCKS_PER_SEC;
+		else if(heuristicTimeTest%1000) sm_cPrecision = 100.0/CLOCKS_PER_SEC;
+		else if(heuristicTimeTest%10000) sm_cPrecision = 1000.0/CLOCKS_PER_SEC;
+		else sm_cPrecision = 10000.0/CLOCKS_PER_SEC;
+
+        // Find the claimed resolution of the high res timer
+		// Then find the most likely real rate by waiting for it to change.
+		// Note - I've frequently seen missed beats, and therefore a
+		// 0.000001 reality gets reported as a 0.000002.
+		// Note - this also isn't actually used, all that matters is
+		// whether HRTicksPerSec has a non-zero value or not.
+		HRGETTICKS_PER_SEC (sm_HRTicksPerSec);
+
+		if (sm_HRTicksPerSec != 0.0)
+		{
+			hr_timer start, end;
+			HRSETCURRENT (start);
+			do
+			{
+				HRSETCURRENT (end);
+			}	while (HRGETTICKS (end) == HRGETTICKS (start));
+
+			sm_hrPrecision = (HRGETTICKS (end)-HRGETTICKS (start))/sm_HRTicksPerSec;
+		}
+	}
+}
+
+
+void sTimer_Stop (sTimer *t)
+{
+	if (t->m_fRunning)
+	{
+		if (sm_HRTicksPerSec != 0.0) { HRSETCURRENT (t->m_hrEndTime); }
+		else { t->m_cEndTime = clock (); }
+	}
+	else
+		HRZERO (t->m_hrEndTime);
+	t->m_fRunning = 0;
+}
+
+void sTimer_Start (sTimer *t, int bClear)
+{
+	if (bClear)
+		sTimer_ClearTime(t);
+	if (sm_HRTicksPerSec != 0.0) { HRSETCURRENT (t->m_hrStartTime); }
+	else { t->m_cStartTime = clock (); }
+	t->m_fRunning = 1;
+}
+
+void sTimer_ClearTime(sTimer *t)
+{
+	t->m_dAccumSeconds = 0;
+	HRZERO (t->m_hrStartTime);
+	HRZERO (t->m_hrEndTime);
+	t->m_fRunning=0;
+}
+
+double sTimer_GetSecs (sTimer *t)
+{
+	double retval;
+	if (t->m_fRunning)
+	{
+		if (sm_HRTicksPerSec != 0.0) { HRSETCURRENT(t->m_hrEndTime); }
+		else { t->m_cEndTime = clock (); }
+	}
+	if (sm_HRTicksPerSec == 0.0)
+	{
+		// This is process time
+		double d = (t->m_cEndTime-t->m_cStartTime)*1.0;
+		if (d > 0)
+			retval = d/CLOCKS_PER_SEC;
+		else
+			retval = 0;
+	}
+	else
+	{
+		// This is wall-clock time
+		double d = (HRGETTICKS (t->m_hrEndTime) - HRGETTICKS (t->m_hrStartTime));
+		retval = 0;
+		if (d > 0)
+			retval = d/sm_HRTicksPerSec;
+		else
+			retval = 0;
+	}
+	return retval+t->m_dAccumSeconds;
+}
diff -rupN john-1.7.8/src/timer.h john-1.7.8-jumbo-2/src/timer.h
--- john-1.7.8/src/timer.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/timer.h	2011-06-02 17:19:49.000000000 +0200
@@ -0,0 +1,116 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Portable hi-res timer.  Was a nice C++ class.
+ * Downgraded to C for project john
+ *
+ */
+
+#ifndef GOT_TIMER_H
+#define GOT_TIMER_H
+
+#include <time.h>
+#include <sys/timeb.h>
+
+#if defined (_MSC_VER) || defined (__MINGW32__)
+#undef MEM_FREE
+#include <windows.h>
+#undef MEM_FREE
+typedef LARGE_INTEGER hr_timer;
+#if defined (_MSC_VER)
+#define inline _inline
+#endif
+#define HRZERO(X)				(X).HighPart = (X).LowPart = 0
+#define HRSETCURRENT(X)			QueryPerformanceCounter (&(X));
+#define HRGETTICKS(X)			((double)(X).HighPart*4294967296.0+(double)(X).LowPart)
+#define HRGETTICKS_PER_SEC(X)	{LARGE_INTEGER large;														\
+								   if (QueryPerformanceFrequency (&large))									\
+								      (X) = (double)large.HighPart*4294967296.0 +	(double)large.LowPart;	\
+								   else																		\
+								      (X) = 0.0;															\
+								}
+#else
+#include <sys/time.h>
+typedef struct timeval hr_timer;
+#define HRZERO(X)				(X).tv_sec = (X).tv_usec = 0
+#define HRSETCURRENT(X)			{struct timezone tz; gettimeofday (&(X), &tz);}
+#define HRGETTICKS(X)			((double)(X).tv_sec*1000000.0+(double)(X).tv_usec)
+#define HRGETTICKS_PER_SEC(X)	(X) = 1000000.0
+#endif
+
+typedef struct _sTimer
+{
+	int m_fRunning;				// true if we are running
+	clock_t m_cStartTime;
+	clock_t m_cEndTime;
+	hr_timer m_hrStartTime;
+	hr_timer m_hrEndTime;
+	double m_dAccumSeconds;
+} sTimer;
+
+void sTimer_sTimer(sTimer *t);
+void sTimer_Start (sTimer *t, int bClear/*=true*/);	// Start the timer
+//inline void sTimer_Start_noclear (sTimer *t);	// Start the timer
+void sTimer_Stop (sTimer *t);			// Stop the timer
+//inline void sTimer_Pause(sTimer *t);			// Pause the timer
+//inline void sTimer_Resume(sTimer *t);			// Resume the timer.
+void sTimer_ClearTime(sTimer *t);		// Clears out the time to 0
+double sTimer_GetSecs (sTimer *t);		// If timer is running returns elapsed;
+										// if stopped returns timed interval;
+										// if not started returns 0.0.
+
+extern double sm_HRTicksPerSec;	// HR Ticks per second
+extern int sm_fGotHRTicksPerSec;	// Set if we have got the above
+extern double sm_hrPrecision;
+extern double sm_cPrecision;
+
+//inline void sTimer_Start_noclear (sTimer *t)
+//{
+//	if (sm_HRTicksPerSec != 0.0) { HRSETCURRENT (t->m_hrStartTime); }
+//	else { t->m_cStartTime = clock (); }
+//	t->m_fRunning = 1;
+//}
+#define sTimer_Start_noclear(t) \
+	do { \
+	if (sm_HRTicksPerSec != 0.0) { HRSETCURRENT ((t)->m_hrStartTime); } \
+	else { (t)->m_cStartTime = clock (); } \
+	(t)->m_fRunning = 1; \
+	} while (0)
+
+//inline void sTimer_Pause (sTimer *t)
+//{
+//	t->m_dAccumSeconds = sTimer_GetSecs(t);
+//	HRZERO (t->m_hrStartTime);
+//	HRZERO (t->m_hrEndTime);
+//	t->m_fRunning=0;
+//}
+#define sTimer_Pause(t) \
+	do { \
+	(t)->m_dAccumSeconds = sTimer_GetSecs(t); \
+	(t)->m_fRunning=0; \
+	} while (0)
+
+
+//inline void sTimer_Resume (sTimer *t)
+//{
+	//HRZERO (t->m_hrEndTime);
+//	if (!t->m_fRunning)
+//		sTimer_Start_noclear(t);
+//}
+
+#define sTimer_Resume(t) \
+	do { \
+	if (!(t)->m_fRunning) \
+		sTimer_Start_noclear(t); \
+	} while (0)
+
+#endif
diff -rupN john-1.7.8/src/tty.c john-1.7.8-jumbo-2/src/tty.c
--- john-1.7.8/src/tty.c	2010-07-12 04:56:36.000000000 +0200
+++ john-1.7.8-jumbo-2/src/tty.c	2011-05-17 18:13:03.000000000 +0200
@@ -1,14 +1,21 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003,2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC, by JimF.
  */
 
+#if defined (__MINGW32__) || defined (_MSC_VER)
+#include <conio.h>
+#else
 #ifndef __DJGPP__
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
+#if !defined (_MSC_VER)
 #include <termios.h>
 #include <unistd.h>
+#endif
 #include <stdlib.h>
 #else
 #include <bios.h>
@@ -26,17 +33,18 @@ extern int tcgetattr(int fd, struct term
 extern int tcsetattr(int fd, int actions, struct termios *termios_p);
 #endif
 #endif
+#endif /* !defined __MINGW32__ */
 
 #include "tty.h"
 
-#ifndef __DJGPP__
+#if !defined(__DJGPP__) && !defined(__MINGW32__) && !defined (_MSC_VER)
 static int tty_fd = -1;
 static struct termios saved_ti;
 #endif
 
 void tty_init(int stdin_mode)
 {
-#ifndef __DJGPP__
+#if !defined(__DJGPP__) && !defined(__MINGW32__) && !defined (_MSC_VER)
 	int fd;
 	struct termios ti;
 
@@ -74,7 +82,7 @@ void tty_init(int stdin_mode)
 
 int tty_getchar(void)
 {
-#ifndef __DJGPP__
+#if !defined(__DJGPP__) && !defined(__MINGW32__) && !defined (_MSC_VER)
 	int c;
 #ifdef __CYGWIN32__
 	fd_set set;
@@ -91,9 +99,12 @@ int tty_getchar(void)
 		c = 0;
 		if (read(tty_fd, &c, 1) > 0) return c;
 	}
-#else
+#elif defined(__DJGPP__)
 	if (_bios_keybrd(_KEYBRD_READY))
 		return _bios_keybrd(_KEYBRD_READ);
+#else /* defined(__MINGW32__) or _MSC_VER */
+	if (_kbhit())
+		return _getch();
 #endif
 
 	return -1;
@@ -101,7 +112,7 @@ int tty_getchar(void)
 
 void tty_done(void)
 {
-#ifndef __DJGPP__
+#if !defined(__DJGPP__) && !defined(__MINGW32__) && !defined (_MSC_VER)
 	int fd;
 
 	if (tty_fd < 0) return;
diff -rupN john-1.7.8/src/undrop.c john-1.7.8-jumbo-2/src/undrop.c
--- john-1.7.8/src/undrop.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/undrop.c	2011-06-02 17:20:34.000000000 +0200
@@ -0,0 +1,75 @@
+/*
+ * Eggdrop userfile converter
+ * Copyright (c) 2002 by Sun-Zero <sun-zero at freemail.hu>
+ * This is a free software distributable under terms of the GNU GPL.
+ * See the file COPYING for details.
+ *
+ * 2003-04-21
+*/
+
+#include <stdio.h>
+#include <string.h>
+#if !defined (_MSC_VER)
+#include <unistd.h>
+#endif
+
+
+#define USERFILE_HEADER "#4v:"
+#define USERNAME_LENGTH 11
+#define PASSWORD_LENGTH 13
+#define MAX_FLAGS_LENGTH 32
+#define BUFSIZE 512
+
+int undrop(int argc, char *argv[]) {
+
+    FILE *userfile;
+    char username[USERNAME_LENGTH];
+    char password[PASSWORD_LENGTH];
+    char flags[MAX_FLAGS_LENGTH];
+    char t_username[BUFSIZE];
+    char t_flags[BUFSIZE];
+    char t_line[BUFSIZE];
+
+    if (argc != 2) {
+	userfile = stdin;
+	printf("# userfile reading from stdin\n");
+    } else {
+        if ((userfile = fopen(argv[1], "rt")) == NULL) {
+    	        fprintf(stderr, "opening userfile\n");
+	        userfile = stdin;
+        }
+    }
+
+
+    if (fgets(t_line, sizeof(t_line) - 1, userfile) == NULL)
+	return 1;
+
+    if (strncmp(t_line, USERFILE_HEADER, strlen(USERFILE_HEADER)) != 0) {
+	fprintf(stderr, "usefile format is wrong\n");
+	return 1;
+    } else {
+	printf("# userfile format OK\n\n");
+    }
+
+    while (fgets(t_line, sizeof(t_line) - 1, userfile) != NULL) {
+	if (sscanf(t_line, "%10s - %24s\n", t_username, t_flags)  == 2) {
+	    if (strncmp(t_username, "! ", 2) != 0 &&
+		strncmp(t_username, "--", 2) != 0 &&
+		strncmp(t_username, "&&", 2) != 0 &&
+		strncmp(t_username, "::", 2) != 0 &&
+		strncmp(t_username, "$$", 2) != 0
+	    ) {
+		strncpy(username, t_username, USERNAME_LENGTH);
+	        strncpy(flags, t_flags, MAX_FLAGS_LENGTH);
+	    }
+	}
+
+	if (strncmp(t_line, "--PASS +", 8) == 0) {
+	    sscanf(t_line, "--PASS %s", password);
+	    printf("%s:%s:::%s:\n", username, password, flags);
+	}
+	fflush(stdout);
+    }
+    fclose(userfile);
+    return 0;
+}
diff -rupN john-1.7.8/src/unicode.c john-1.7.8-jumbo-2/src/unicode.c
--- john-1.7.8/src/unicode.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unicode.c	2011-06-06 10:15:05.000000000 +0200
@@ -0,0 +1,442 @@
+/*
+    Conversion from UTF-8 to UTF-16.  Source code file.
+
+	Stripped and modified for John the Ripper ; see ConvertUTF.[ch].original
+	for the original content. magnum, 2009, 2010, 2011
+
+	What was left in smbencrypt.c is now moved to these files too.
+*/
+/*
+   (from smbencrypt.c)
+
+   Unix SMB/Netbios implementation.
+   Version 1.9.
+   SMB parameters and setup
+   Copyright (C) Andrew Tridgell 1992-1998
+   Modified by Jeremy Allison 1995.
+   (and hacked further by others)
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+/*
+ * (from ConvertUTF.c)
+ *
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+    Sept 2001: fixed const & error conditions per
+	mods suggested by S. Parent & A. Lillich.
+    June 2002: Tim Dodd added detection and handling of incomplete
+	source sequences, enhanced error detection, added casts
+	to eliminate compiler warnings.
+    July 2003: slight mods to back out aggressive FFFE detection.
+    Jan 2004: updated switches in from-UTF8 conversions.
+    Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.
+
+    See the header file "ConvertUTF.h" for complete documentation.
+
+
+------------------------------------------------------------------------ */
+
+#include "unicode.h"
+#include "md4.h"
+#if !defined(uint16) && !defined(HAVE_UINT16_FROM_RPC_RPC_H)
+#if (SIZEOF_SHORT == 4)
+#define uint16 __ERROR___CANNOT_DETERMINE_TYPE_FOR_INT16;
+#else /* SIZEOF_SHORT != 4 */
+#define uint16 unsigned short
+#endif /* SIZEOF_SHORT != 4 */
+#endif
+
+#if !defined(int16) && !defined(HAVE_INT16_FROM_RPC_RPC_H)
+#if (SIZEOF_SHORT == 4)
+#define int16 __ERROR___CANNOT_DETERMINE_TYPE_FOR_INT16;
+#else /* SIZEOF_SHORT != 4 */
+#define int16 short
+#endif /* SIZEOF_SHORT != 4 */
+#endif
+
+#include <string.h>
+#include "common.h"
+#include "arch.h"
+#include "byteorder.h"
+#if !defined (NOT_JOHN)
+#include "options.h"
+#else
+struct opts { int flags; };
+#define FLG_UTF8 1
+struct opts options;
+#endif
+
+//Init values for NT hashing
+#define INIT_A 0x67452301
+#define INIT_B 0xefcdab89
+#define INIT_C 0x98badcfe
+#define INIT_D 0x10325476
+
+#define SQRT_2 0x5a827999
+#define SQRT_3 0x6ed9eba1
+
+/*
+ * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
+ * into the first byte, depending on how many bytes follow.  There are
+ * as many entries in this table as there are UTF-8 sequence types.
+ * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
+ * for *legal* UTF-8 will be 4 or fewer bytes total.
+ */
+static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+/*
+ * Magic values subtracted from a buffer value during UTF8 conversion.
+ * This table contains as many values as there might be trailing bytes
+ * in a UTF-8 sequence. (Cut-down version, 4 and 5 are illegal).
+ */
+const UTF32 offsetsFromUTF8[] = { 0x00000000UL, 0x00003080UL,
+    0x000E2080UL, 0x03C82080UL };
+
+/*
+ * Index into the table below with the first byte of a UTF-8 sequence to
+ * get the number of trailing bytes that are supposed to follow it.
+ * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
+ * left as-is for anyone who may want to do such conversion, which was
+ * allowed in earlier algorithms.
+ *
+ * Cut-down version for speed. Use with [c & 0x3f]
+ */
+const char opt_trailingBytesUTF8[64] = {
+	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+// Convert UTF-8 to NT UNICODE (UCS-2) string. Note that regardless of
+// processor type this must be in intel (little-endian) format.
+// This code is optimised for speed. Errors result in truncation.
+//
+// Normally returns number of UTF16 characters converted. If truncated,
+// the number of UTF8 characters that was successfully read is returned
+// instead, so we can truncate our saved_plain or whatever accordingly.
+//
+// The original function in ConvertUTF.c is called ConvertUTF8toUTF16()
+inline int utf8towcs(UTF16 * target, unsigned int len, const UTF8 * source,
+                     unsigned int sourceLen)
+{
+	const UTF16 *targetStart = target;
+	const UTF16 *targetEnd = target + len;
+	const UTF8 *sourceStart = source;
+	const UTF8 *sourceEnd = source + sourceLen;
+	UTF32 ch;
+	unsigned int extraBytesToRead;
+
+	while (source < sourceEnd) {
+		if (*source < 0xC0) {
+#if (ARCH_LITTLE_ENDIAN==1)
+			*target++ = (UTF16) * source++;
+#else
+			UTF8 val = *source++;
+			SSVAL(target, 0, val);
+			++target;
+#endif
+			if (*source == 0)
+				break;
+			if (target >= targetEnd) {
+				*target = 0;
+				return -1 * (source - sourceStart);
+			}
+			continue;
+		}
+		ch = *source;
+		// The original code in ConvertUTF.c has a much larger (slower)
+		// lookup table including zeros. This point must not be reached
+		// with *source < 0xC0
+		extraBytesToRead =
+		    opt_trailingBytesUTF8[ch & 0x3f];
+		if (source + extraBytesToRead >= sourceEnd) {
+			*target = 0;
+			return -1 * (source - sourceStart);
+		}
+		switch (extraBytesToRead) {
+		case 2:
+			ch <<= 6;
+			ch += *++source;
+		case 1:
+			ch <<= 6;
+			ch += *++source;
+		case 0:
+			++source;
+			break;
+		default:
+			*target = 0;
+			return -1 * (source - sourceStart);
+		}
+		ch -= offsetsFromUTF8[extraBytesToRead];
+#if (ARCH_LITTLE_ENDIAN==1)
+		*target++ = (UTF16) ch;
+#else
+		SSVAL(target, 0, ch);
+		++target;
+#endif
+		if (*source == 0)
+			break;
+		if (target >= targetEnd) {
+			*target = 0;
+			return -1 * (source - sourceStart);
+		}
+	}
+	*target = 0;		// Null-terminate
+	return (target - targetStart);
+}
+
+// Convert a string into an NT UNICODE string. Note that regardless of
+// processor type this must be in intel (little-endian) format.
+//
+// This version converts from UTF-8 if the --utf8 option was given to John
+// and from ISO-8859-1 otherwise. The latter is a little faster.
+//
+inline int plaintowcs(UTF16 * dst, unsigned int maxdstlen, const UTF8 * src,
+                      unsigned int srclen)
+{
+	if (!(options.flags & FLG_UTF8)) {	// Convert from ISO-8859-1
+		unsigned int i, trunclen = srclen;
+		if (trunclen > maxdstlen)
+			trunclen = maxdstlen;
+		for (i = 0; i < trunclen; i++) {
+#if (ARCH_LITTLE_ENDIAN==1)
+			*dst++ = (UTF16) * src++;
+#else
+			UTF8 val = *src++;
+			SSVAL(dst, 0, val);
+			++dst;
+#endif
+		}
+		*dst = 0;
+		if (i < srclen)
+			return -i;
+		else
+			return i;
+	} else {		// Convert from UTF-8
+		return utf8towcs(dst, maxdstlen, src, srclen);
+	}
+}
+
+// strlen of UTF16 (in characters, not bytes)
+inline unsigned int strlen16(const UTF16 * str)
+{
+	unsigned int len = 0;
+	while (*str++ != 0)
+		len++;
+	return len;
+}
+
+/*
+ * Creates an MD4 Hash of the user's password in NT UNICODE.
+ * This version honours the --utf8 flag and makes a couple
+ * of formats utf8-aware with few further modifications.
+ *
+ * Now using Alain's fast NTLM up to 27 characters of plaintext (54 bytes
+ * of UTF-16) and a generic one (Solar's MD4) otherwise.
+ *
+ * MD4 compress function
+ * Written by Alain Espinosa <alainesp@gmail.com> in 2008
+ * and placed in the public domain.
+ *
+ */
+int E_md4hash(const UTF8 * passwd, unsigned int len, unsigned char *p16)
+{
+	int trunclen;
+	static UTF16 wpwd[PLAINTEXT_BUFFER_SIZE + 1];
+
+	// Quick work around. We may want to port the else{} into BE code,
+	// and do it without impacting LE speed. The boost is not huge though.
+#if ARCH_ALLOWS_UNALIGNED
+	if (len > 27) {
+#endif
+		static MD4_CTX ctx;
+
+		/* Password is converted to UTF-16LE (UCS-2) */
+		trunclen = plaintowcs(wpwd, PLAINTEXT_BUFFER_SIZE, passwd, len);
+		if(trunclen < 0)
+			len = strlen16(wpwd); // From UTF-8 you can't know
+		else
+			len = trunclen;
+
+		MD4_Init(&ctx);
+		MD4_Update(&ctx, (unsigned char *)wpwd, len * sizeof(UTF16));
+		MD4_Final(p16, &ctx);
+#if ARCH_ALLOWS_UNALIGNED
+	} else {
+		static unsigned int nt_buffer[16];
+		static unsigned int lastlen = 16;
+		unsigned int a = INIT_A;
+		unsigned int b = INIT_B;
+		unsigned int c = INIT_C;
+		unsigned int d = INIT_D;
+		unsigned int i = 0, md4_size = 0;
+
+		/* Password is converted to UTF-16LE (UCS-2) */
+		trunclen = plaintowcs(wpwd, 27, passwd, len);
+		// We need to check this because it's not just a matter of truncating
+		// length, it can be malformed UTF-8
+		if (trunclen < 0)
+			len = strlen16(wpwd);	/* From UTF-8 you can't know */
+		else
+			len = trunclen;
+
+		/* Key setup */
+		for (; md4_size + 1 < len; i++, md4_size += 2)
+			nt_buffer[i] = wpwd[md4_size] | (wpwd[md4_size + 1] << 16);
+		if (md4_size < len)
+			nt_buffer[i] = wpwd[md4_size++] | 0x800000;
+		else
+			nt_buffer[i] = 0x80;
+
+		/* Key cleaning */
+		for (i++; i <= lastlen; i++)
+			nt_buffer[i] = 0;
+
+		lastlen = md4_size >> 1;
+		nt_buffer[14] = md4_size << 4;
+
+		/* Round 1 */
+		a += (d ^ (b & (c ^ d)))  +  nt_buffer[0]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  +  nt_buffer[1]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  +  nt_buffer[2]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))  +  nt_buffer[3]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d)))  +  nt_buffer[4]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  +  nt_buffer[5]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  +  nt_buffer[6]  ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))  +  nt_buffer[7]  ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d)))  +  nt_buffer[8]  ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  +  nt_buffer[9]  ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  +  nt_buffer[10] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a)))  +  nt_buffer[11] ;b = (b << 19) | (b >> 13);
+
+		a += (d ^ (b & (c ^ d)))  +  nt_buffer[12] ;a = (a << 3 ) | (a >> 29);
+		d += (c ^ (a & (b ^ c)))  +  nt_buffer[13] ;d = (d << 7 ) | (d >> 25);
+		c += (b ^ (d & (a ^ b)))  +  nt_buffer[14] ;c = (c << 11) | (c >> 21);
+		b += (a ^ (c & (d ^ a))) ;b = (b << 19) | (b >> 13);
+
+		/* Round 2 */
+		a += ((b & (c | d)) | (c & d)) + nt_buffer[0] +SQRT_2; a = (a<<3 ) | (a>>29);
+		d += ((a & (b | c)) | (b & c)) + nt_buffer[4] +SQRT_2; d = (d<<5 ) | (d>>27);
+		c += ((d & (a | b)) | (a & b)) + nt_buffer[8] +SQRT_2; c = (c<<9 ) | (c>>23);
+		b += ((c & (d | a)) | (d & a)) + nt_buffer[12]+SQRT_2; b = (b<<13) | (b>>19);
+
+		a += ((b & (c | d)) | (c & d)) + nt_buffer[1] +SQRT_2; a = (a<<3 ) | (a>>29);
+		d += ((a & (b | c)) | (b & c)) + nt_buffer[5] +SQRT_2; d = (d<<5 ) | (d>>27);
+		c += ((d & (a | b)) | (a & b)) + nt_buffer[9] +SQRT_2; c = (c<<9 ) | (c>>23);
+		b += ((c & (d | a)) | (d & a)) + nt_buffer[13]+SQRT_2; b = (b<<13) | (b>>19);
+
+		a += ((b & (c | d)) | (c & d)) + nt_buffer[2] +SQRT_2; a = (a<<3 ) | (a>>29);
+		d += ((a & (b | c)) | (b & c)) + nt_buffer[6] +SQRT_2; d = (d<<5 ) | (d>>27);
+		c += ((d & (a | b)) | (a & b)) + nt_buffer[10]+SQRT_2; c = (c<<9 ) | (c>>23);
+		b += ((c & (d | a)) | (d & a)) + nt_buffer[14]+SQRT_2; b = (b<<13) | (b>>19);
+
+		a += ((b & (c | d)) | (c & d)) + nt_buffer[3] +SQRT_2; a = (a<<3 ) | (a>>29);
+		d += ((a & (b | c)) | (b & c)) + nt_buffer[7] +SQRT_2; d = (d<<5 ) | (d>>27);
+		c += ((d & (a | b)) | (a & b)) + nt_buffer[11]+SQRT_2; c = (c<<9 ) | (c>>23);
+		b += ((c & (d | a)) | (d & a)) +SQRT_2; b = (b<<13) | (b>>19);
+
+		/* Round 3 */
+		a += (d ^ c ^ b) + nt_buffer[0]  +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (c ^ b ^ a) + nt_buffer[8]  +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (b ^ a ^ d) + nt_buffer[4]  +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (a ^ d ^ c) + nt_buffer[12] +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (d ^ c ^ b) + nt_buffer[2]  +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (c ^ b ^ a) + nt_buffer[10] +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (b ^ a ^ d) + nt_buffer[6]  +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (a ^ d ^ c) + nt_buffer[14] +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (d ^ c ^ b) + nt_buffer[1]  +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (c ^ b ^ a) + nt_buffer[9]  +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (b ^ a ^ d) + nt_buffer[5]  +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (a ^ d ^ c) + nt_buffer[13] +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		a += (d ^ c ^ b) + nt_buffer[3]  +  SQRT_3; a = (a << 3 ) | (a >> 29);
+		d += (c ^ b ^ a) + nt_buffer[11] +  SQRT_3; d = (d << 9 ) | (d >> 23);
+		c += (b ^ a ^ d) + nt_buffer[7]  +  SQRT_3; c = (c << 11) | (c >> 21);
+		b += (a ^ d ^ c) +  SQRT_3; b = (b << 15) | (b >> 17);
+
+		((unsigned int *)p16)[0] = a + INIT_A;
+		((unsigned int *)p16)[1] = b + INIT_B;
+		((unsigned int *)p16)[2] = c + INIT_C;
+		((unsigned int *)p16)[3] = d + INIT_D;
+	}
+#endif
+	return trunclen;
+}
+
+// Convert UTF-16LE to UTF-8. This is not optimised as it's
+// only used in get_key() as of now.
+char * utf16toutf8 (const UTF16* source) {
+	static char target[PLAINTEXT_BUFFER_SIZE + 1];
+	UTF8 *tpt = (UTF8 *)target;
+	UTF8 *targetEnd = tpt + PLAINTEXT_BUFFER_SIZE;
+	while (*source) {
+		UTF32 ch;
+		unsigned short bytesToWrite = 0;
+		const UTF32 byteMask = 0xBF;
+		const UTF32 byteMark = 0x80;
+		const UTF16* oldSource = source; /* In case we have to back out */
+		ch = *source++;
+		/* Figure out how many bytes the result will require */
+		if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
+		} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+		} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+		} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
+		} else {			    bytesToWrite = 3;
+			ch = UNI_REPLACEMENT_CHAR;
+		}
+
+		tpt += bytesToWrite;
+		if (tpt > targetEnd) {
+			source = oldSource; /* Back up source pointer! */
+			tpt -= bytesToWrite; break;
+		}
+		switch (bytesToWrite) { /* note: everything falls through. */
+		case 4: *--tpt = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+		case 3: *--tpt = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+		case 2: *--tpt = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+		case 1: *--tpt =  (UTF8)(ch | firstByteMark[bytesToWrite]);
+		}
+		tpt += bytesToWrite;
+	}
+	*tpt = 0;
+	return target;
+}
diff -rupN john-1.7.8/src/unicode.h john-1.7.8-jumbo-2/src/unicode.h
--- john-1.7.8/src/unicode.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unicode.h	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Conversion from UTF-8 to UTF-16.  Header file.
+
+	Stripped and modified for John the Ripper ; see ConvertUTF.h.original
+	for the original content. magnum, 2009
+
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+		 Fixes & updates, Sept 2001.
+
+------------------------------------------------------------------------ */
+
+/* ---------------------------------------------------------------------
+    The following definitions are compiler-specific.
+    The C standard does not guarantee that wchar_t has at least
+    16 bits, so wchar_t is no less portable than unsigned short!
+    All should be unsigned values to avoid sign extension during
+    bit mask & shift operations.
+------------------------------------------------------------------------ */
+
+#ifndef _CONVERTUTF_H
+#define _CONVERTUTF_H
+
+typedef unsigned long UTF32;	/* at least 32 bits */
+typedef unsigned short UTF16;	/* at least 16 bits */
+typedef unsigned char UTF8;	/* typically 8 bits */
+
+/* Some fundamental constants */
+#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
+#define UNI_MAX_BMP (UTF32)0x0000FFFF
+#define UNI_MAX_UTF16 (UTF32)0x0010FFFF
+#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF
+#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF
+
+/* These are used in NT_fmt.c */
+extern const UTF32 offsetsFromUTF8[];
+extern const char opt_trailingBytesUTF8[64];
+
+/* Convert UTF-8 to UTF-16LE */
+extern int utf8towcs(UTF16 * target, unsigned int maxtargetlen,
+    const UTF8 * source, unsigned int sourcelen);
+
+/* Convert to UTF-16LE from UTF-8 or ISO-8859-1 depending on --utf8 flag */
+extern int plaintowcs(UTF16 * dst, unsigned int maxdstlen, const UTF8 * src,
+    unsigned int srclen);
+
+/* Convert back to UTF-8 (for get_key without a saved_plain) */
+extern char * utf16toutf8 (const UTF16* source);
+
+/* These were in smbencrypt.c before: */
+
+/* Return length (in characters) of a UTF16 string */
+/* Number of octets is the result * sizeof(UTF16)  */
+extern unsigned int strlen16(const UTF16 * str);
+
+/* Create an NT hash from a ISO-8859 or UTF-8 string (--utf8 aware) */
+extern int E_md4hash(const UTF8 * passwd, unsigned int len, unsigned char *p16);
+
+/* --------------------------------------------------------------------- */
+#endif				/* _CONVERTUTF_H */
diff -rupN john-1.7.8/src/unique.c john-1.7.8-jumbo-2/src/unique.c
--- john-1.7.8/src/unique.c	2011-03-20 15:54:16.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unique.c	2011-06-08 23:10:07.000000000 +0200
@@ -1,6 +1,26 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1998,1999,2002,2003,2005,2006,2011 by Solar Designer
+ * Copyright (c) 2011 by Jim Fougeron
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * -v  (some debugging output
+ * -inp=fname vs using stdin
+ * -ex_file=FNAME       also unique's against this external file
+ * -ex_file_only=FNAME  uniq against extern file, and assumes current file is
+ *                      already unique, so does not unique it.
+ * -cut=len  Trims each line to len, prior to unique. Also, any -ex_file=
+ *           file has it's lines trimmed (to properly compare).
+ * -cut=LM   Trim each line to 7 bytes, and grab the next (up to) 7 bytes
+ *           and upcase each.  Warning, if using -ex_file= make sure these
+ *           files are 'proper' LM format (7 char and upcase).  No auto
+ *           trimming/upcasing is done.
+ * -mem=num. A number that overrides the UNIQUE_HASH_LOG value from within
+ *           params.h.  The default is 21.  valid range from 13 to 25.  25
+ *           will use a 2GB memory buffer, and 33 entry million hash table
+ *           Each number doubles size.
  */
 
 #define _POSIX_SOURCE /* for fdopen(3) */
@@ -9,6 +29,11 @@
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <string.h>
+#ifdef _MSC_VER
+#include <io.h>
+#pragma warning ( disable : 4996 )
+#define fdopen _fdopen
+#endif
 
 #include "arch.h"
 #include "misc.h"
@@ -24,7 +49,16 @@ static struct {
 	char *data;
 } buffer;
 
+static FILE *fpInput;
 static FILE *output;
+static FILE *use_to_unique_but_not_add;
+static int do_not_unique_against_self=0;
+
+long long totLines=0,written_lines=0;
+int verbose=0, cut_len=0, LM=0;
+unsigned int vUNIQUE_HASH_LOG=UNIQUE_HASH_LOG, vUNIQUE_HASH_SIZE=UNIQUE_HASH_SIZE, vUNIQUE_BUFFER_SIZE=UNIQUE_BUFFER_SIZE;
+unsigned int vUNIQUE_HASH_MASK = UNIQUE_HASH_SIZE - 1;
+unsigned int vUNIQUE_HASH_LOG_HALF = UNIQUE_HASH_LOG / 2;
 
 #if ARCH_ALLOWS_UNALIGNED && !ARCH_INT_GT_32
 
@@ -76,11 +110,7 @@ static unsigned int line_hash(char *line
 		goto out;
 	extra = (unsigned char)line[1];
 	if (!extra)
-#if UNIQUE_HASH_SIZE >= 0x100
 		goto out;
-#else
-		goto out_and;
-#endif
 
 	while (*p) {
 		hash <<= 3; extra <<= 2;
@@ -89,21 +119,18 @@ static unsigned int line_hash(char *line
 		extra += (unsigned char)p[1];
 		p += 2;
 		if (hash & 0xe0000000) {
-			hash ^= hash >> UNIQUE_HASH_LOG;
-			extra ^= extra >> UNIQUE_HASH_LOG;
-			hash &= UNIQUE_HASH_SIZE - 1;
+			hash ^= hash >> vUNIQUE_HASH_LOG;
+			extra ^= extra >> vUNIQUE_HASH_LOG;
+			hash &= vUNIQUE_HASH_MASK;
 		}
 	}
 
 	hash -= extra;
-	hash ^= extra << (UNIQUE_HASH_LOG / 2);
+	hash ^= extra << vUNIQUE_HASH_LOG_HALF;
 
-	hash ^= hash >> UNIQUE_HASH_LOG;
+	hash ^= hash >> vUNIQUE_HASH_LOG;
 
-#if UNIQUE_HASH_SIZE < 0x100
-out_and:
-#endif
-	hash &= UNIQUE_HASH_SIZE - 1;
+	hash &= vUNIQUE_HASH_MASK;
 out:
 	return hash;
 }
@@ -113,14 +140,22 @@ static void init_hash(void)
 #if 0
 	int index;
 
-	for (index = 0; index < UNIQUE_HASH_SIZE; index++)
+	for (index = 0; index < vUNIQUE_HASH_SIZE; index++)
 		buffer.hash[index] = ENTRY_END_HASH;
 #else
 /* ENTRY_END_HASH is 0xFFFFFFFF */
-	memset(buffer.hash, 0xff, UNIQUE_HASH_SIZE * sizeof(unsigned int));
+	memset(buffer.hash, 0xff, vUNIQUE_HASH_SIZE * sizeof(unsigned int));
 #endif
 }
 
+static void upcase(char *cp) {
+	while (*cp) {
+		if (*cp >= 'a' && *cp <= 'z')
+			*cp -= 0x20;
+		++cp;
+	}
+}
+
 static void read_buffer(void)
 {
 	char line[LINE_BUFFER_SIZE];
@@ -129,7 +164,21 @@ static void read_buffer(void)
 	init_hash();
 
 	ptr = 0;
-	while (fgetl(line, sizeof(line), stdin)) {
+	while (fgetl(line, sizeof(line), fpInput)) {
+		char LM_Buf[8];
+		if (LM) {
+			if (strlen(line) > 7) {
+				strncpy(LM_Buf, &line[7], 7);
+				LM_Buf[7] = 0;
+				upcase(LM_Buf);
+				++totLines;
+			}
+			else
+				*LM_Buf = 0;
+			line[7] = 0;
+			upcase(line);
+		} else if (cut_len) line[cut_len] = 0;
+		++totLines;
 		last = &buffer.hash[line_hash(line)];
 #if ARCH_LITTLE_ENDIAN && !ARCH_INT_GT_32
 		current = *last;
@@ -141,7 +190,11 @@ static void read_buffer(void)
 			last = (unsigned int *)&buffer.data[current];
 			current = get_int(last);
 		}
-		if (current != ENTRY_END_HASH) continue;
+		if (current != ENTRY_END_HASH) {
+			if (LM && *LM_Buf)
+				goto DoExtraLM;
+			continue;
+		}
 
 		put_int(last, ptr);
 
@@ -151,10 +204,36 @@ static void read_buffer(void)
 		strcpy(&buffer.data[ptr], line);
 		ptr += strlen(line) + 1;
 
-		if (ptr > UNIQUE_BUFFER_SIZE - sizeof(line) - 8) break;
+		if (ptr > vUNIQUE_BUFFER_SIZE - sizeof(line) - 8) break;
+
+DoExtraLM:;
+		if (LM && *LM_Buf) {
+			last = &buffer.hash[line_hash(LM_Buf)];
+#if ARCH_LITTLE_ENDIAN && !ARCH_INT_GT_32
+			current = *last;
+#else
+			current = get_int(last);
+#endif
+			while (current != ENTRY_END_HASH) {
+				if (!strcmp(LM_Buf, &buffer.data[current + 4])) break;
+				last = (unsigned int *)&buffer.data[current];
+				current = get_int(last);
+			}
+			if (current != ENTRY_END_HASH) continue;
+
+			put_int(last, ptr);
+
+			put_data(ptr, ENTRY_END_HASH);
+			ptr += 4;
+
+			strcpy(&buffer.data[ptr], LM_Buf);
+			ptr += strlen(LM_Buf) + 1;
+
+			if (ptr > vUNIQUE_BUFFER_SIZE - sizeof(line) - 8) break;
+		}
 	}
 
-	if (ferror(stdin)) pexit("fgets");
+	if (ferror(fpInput)) pexit("fgets");
 
 	put_data(ptr, ENTRY_END_LIST);
 }
@@ -170,6 +249,7 @@ static void write_buffer(void)
 		length = strlen(&buffer.data[ptr]);
 		size = length + 1;
 		if (hash != ENTRY_DUPE) {
+			++written_lines;
 			buffer.data[ptr + length] = '\n';
 			if (fwrite(&buffer.data[ptr], size, 1, output) != 1)
 				pexit("fwrite");
@@ -183,9 +263,35 @@ static void clean_buffer(void)
 	char line[LINE_BUFFER_SIZE];
 	unsigned int current, *last;
 
+	if (use_to_unique_but_not_add) {
+		if (fseek(use_to_unique_but_not_add, 0, SEEK_SET) < 0) pexit("fseek");
+		while (fgetl(line, sizeof(line), use_to_unique_but_not_add)) {
+			if (cut_len) line[cut_len] = 0;
+			last = &buffer.hash[line_hash(line)];
+#if ARCH_LITTLE_ENDIAN && !ARCH_INT_GT_32
+			current = *last;
+#else
+			current = get_int(last);
+#endif
+			while (current != ENTRY_END_HASH) {
+				if (current != ENTRY_DUPE && !strcmp(line, &buffer.data[current + 4])) {
+					put_int(last, get_data(current));
+					put_data(current, ENTRY_DUPE);
+					break;
+				}
+				last = (unsigned int *)&buffer.data[current];
+				current = get_int(last);
+			}
+		}
+	}
+
+	if (do_not_unique_against_self)
+	  return;
+
 	if (fseek(output, 0, SEEK_SET) < 0) pexit("fseek");
 
 	while (fgetl(line, sizeof(line), output)) {
+		if (cut_len) line[cut_len] = 0;
 		last = &buffer.hash[line_hash(line)];
 #if ARCH_LITTLE_ENDIAN && !ARCH_INT_GT_32
 		current = *last;
@@ -213,23 +319,37 @@ static void unique_init(char *name)
 {
 	int fd;
 
-	buffer.hash = mem_alloc(UNIQUE_HASH_SIZE * sizeof(unsigned int));
-	buffer.data = mem_alloc(UNIQUE_BUFFER_SIZE);
+	buffer.hash = mem_alloc(vUNIQUE_HASH_SIZE * sizeof(unsigned int));
+	buffer.data = mem_alloc(vUNIQUE_BUFFER_SIZE);
 
-	if ((fd = open(name, O_RDWR | O_CREAT | O_EXCL, 0600)) < 0)
+#if defined (_MSC_VER) || defined(__MINGW32__)
+	fd = open(name, O_RDWR | O_CREAT | O_EXCL | O_BINARY, 0600);
+#else
+	fd = open(name, O_RDWR | O_CREAT | O_EXCL, 0600);
+#endif
+	if (fd < 0)
 		pexit("open: %s", name);
-	if (!(output = fdopen(fd, "w+"))) pexit("fdopen");
+	if (!(output = fdopen(fd, "wb+"))) pexit("fdopen");
 }
 
 static void unique_run(void)
 {
 	read_buffer();
+	if (use_to_unique_but_not_add)
+	  clean_buffer();
 	write_buffer();
 
-	while (!feof(stdin)) {
+	while (!feof(fpInput)) {
 		read_buffer();
 		clean_buffer();
 		write_buffer();
+
+		if (verbose)
+#ifdef __MINGW32__
+			printf ("\rTotal lines read %I64u Unique lines written %I64u\r", totLines, written_lines);
+#else
+			printf ("\rTotal lines read %llu Unique lines written %llu\r", totLines, written_lines);
+#endif
 	}
 }
 
@@ -240,8 +360,99 @@ static void unique_done(void)
 
 int unique(int argc, char **argv)
 {
+	while (argc > 2 && (!strcmp(argv[1], "-v") || !strncmp(argv[1], "-inp=", 5) || !strncmp(argv[1], "-cut=", 5) || !strncmp(argv[1], "-mem=", 5))) {
+		int i;
+		if (!strcmp(argv[1], "-v"))
+		{
+			verbose = 1;
+			--argc;
+			for (i = 1; i < argc; ++i)
+				argv[i] = argv[i+1];
+		}
+		else if (!strncmp(argv[1], "-inp=", 5))
+		{
+			fpInput = fopen(&argv[1][5], "rb");
+			if (!fpInput)
+				exit(fprintf(stderr, "Error, could not open input file %s\n", &argv[1][5]));
+			--argc;
+			for (i = 1; i < argc; ++i)
+				argv[i] = argv[i+1];
+		}
+		else if (!strncmp(argv[1], "-cut=", 5))
+		{
+			if (!strcmp(argv[1], "-cut=LM")) {
+				cut_len = 7;
+				LM = 1;
+			}
+			else
+				sscanf(argv[1], "-cut=%d", &cut_len);
+			if (cut_len < 0 || cut_len >= LINE_BUFFER_SIZE)
+				exit(fprintf(stderr, "Error, invalid length in the -cut= param\n"));
+			--argc;
+			for (i = 1; i < argc; ++i)
+				argv[i] = argv[i+1];
+		}
+		else if (!strncmp(argv[1], "-mem=", 5))
+		{
+			int len;
+			sscanf(argv[1], "-mem=%d", &len);
+			if (len > 25) {
+				fprintf (stderr, "Warning, max memory usages reduced to 25\n");
+				len = 25;
+			}
+			if (len < 13) {
+				fprintf (stderr, "Warning the min memory usage allowed is 13\n");
+				len = 13;
+			}
+			--argc;
+			for (i = 1; i < argc; ++i)
+				argv[i] = argv[i+1];
+
+// Original from params.h in john-1.7.7
+//#define UNIQUE_HASH_LOG			20
+//#define UNIQUE_HASH_SIZE		(1 << UNIQUE_HASH_LOG)
+//#define UNIQUE_BUFFER_SIZE		0x4000000
+
+			vUNIQUE_HASH_LOG = len;
+			vUNIQUE_HASH_SIZE = (1 << vUNIQUE_HASH_LOG);
+			vUNIQUE_BUFFER_SIZE = 64 * vUNIQUE_HASH_SIZE;
+			vUNIQUE_HASH_MASK = vUNIQUE_HASH_SIZE - 1;
+			vUNIQUE_HASH_LOG_HALF = vUNIQUE_HASH_LOG / 2;
+		}
+	}
+	if (argc == 3 && !strncmp(argv[2], "-ex_file=", 9)) {
+		use_to_unique_but_not_add = fopen(&argv[2][9], "rb");
+		argc = 2;
+		if (use_to_unique_but_not_add)
+		  printf("Not outputting any lines found in file %s\n", &argv[2][9]);
+	}
+	if (argc == 3 && !strncmp(argv[2], "-ex_file_only=", 14)) {
+		use_to_unique_but_not_add = fopen(&argv[2][14], "rb");
+		argc = 2;
+		if (use_to_unique_but_not_add)
+		  printf("Expecting file to be unique, and not outputting any lines found in file %s\n", &argv[2][14]);
+		else
+		  exit(printf("Error, in this mode, we MUST have a file to test against\n"));
+		do_not_unique_against_self = 1;
+	}
 	if (argc != 2) {
-		puts("Usage: unique OUTPUT-FILE");
+#if defined (__MINGW32__)
+	    puts("");
+#endif
+		puts("Usage: unique [-v] [-inp=fname] [-cut=len] [-mem=num] OUTPUT-FILE [-ex_file=FNAME2] [-ex_file_only=FNAME2]\n\n"
+			 "       reads from stdin 'normally', but can be overridden by optional -inp=\n"
+			 "       If -ex_file=XX is used, then data from file XX is also used to\n"
+			 "       unique the data, but nothing is ever written to XX. Thus, any data in\n"
+			 "       XX, will NOT output into OUTPUT-FILE (for making iterative dictionaries)\n"
+			 "       -ex_file_only=XX assumes the file is 'unique', and only checks against XX\n"
+			 "       -cut=len  Will trim each input lines to 'len' bytes long, prior to running\n"
+			 "       the unique algorithm. The 'trimming' is done on any -ex_file[_only] file\n"
+			 "       -mem=num.  A number that overrides the UNIQUE_HASH_LOG value from within\n"
+			 "       params.h.  The default is 21.  This can be raised, up to 25 (memory usage\n"
+			 "       doubles each number).  If you go TOO large, unique will swap and thrash and\n"
+			 "       work VERY slow\n"
+			 "\n"
+			 "       -v is for 'verbose' mode, outputs line counts during the run");
 
 		if (argc <= 1)
 			return 0;
@@ -249,9 +460,16 @@ int unique(int argc, char **argv)
 			error();
 	}
 
+	if (!fpInput)
+		fpInput = stdin;
 	unique_init(argv[1]);
 	unique_run();
 	unique_done();
+#ifdef __MINGW32__
+    printf ("Total lines read %I64u Unique lines written %I64u\n", totLines, written_lines);
+#else
+    printf ("Total lines read %llu Unique lines written %llu\n", totLines, written_lines);
+#endif
 
 	return 0;
 }
diff -rupN john-1.7.8/src/unused/ConvertUTF.c.original john-1.7.8-jumbo-2/src/unused/ConvertUTF.c.original
--- john-1.7.8/src/unused/ConvertUTF.c.original	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/ConvertUTF.c.original	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,539 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Conversions between UTF32, UTF-16, and UTF-8. Source code file.
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+    Sept 2001: fixed const & error conditions per
+	mods suggested by S. Parent & A. Lillich.
+    June 2002: Tim Dodd added detection and handling of incomplete
+	source sequences, enhanced error detection, added casts
+	to eliminate compiler warnings.
+    July 2003: slight mods to back out aggressive FFFE detection.
+    Jan 2004: updated switches in from-UTF8 conversions.
+    Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.
+
+    See the header file "ConvertUTF.h" for complete documentation.
+
+------------------------------------------------------------------------ */
+
+
+#include "ConvertUTF.h"
+#ifdef CVTUTF_DEBUG
+#include <stdio.h>
+#endif
+
+static const int halfShift  = 10; /* used for shifting by 10 bits */
+
+static const UTF32 halfBase = 0x0010000UL;
+static const UTF32 halfMask = 0x3FFUL;
+
+#define UNI_SUR_HIGH_START  (UTF32)0xD800
+#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
+#define UNI_SUR_LOW_START   (UTF32)0xDC00
+#define UNI_SUR_LOW_END     (UTF32)0xDFFF
+#define false	   0
+#define true	    1
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF16 (
+	const UTF32** sourceStart, const UTF32* sourceEnd,
+	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF32* source = *sourceStart;
+    UTF16* target = *targetStart;
+    while (source < sourceEnd) {
+	UTF32 ch;
+	if (target >= targetEnd) {
+	    result = targetExhausted; break;
+	}
+	ch = *source++;
+	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
+	    /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+		if (flags == strictConversion) {
+		    --source; /* return to the illegal value itself */
+		    result = sourceIllegal;
+		    break;
+		} else {
+		    *target++ = UNI_REPLACEMENT_CHAR;
+		}
+	    } else {
+		*target++ = (UTF16)ch; /* normal case */
+	    }
+	} else if (ch > UNI_MAX_LEGAL_UTF32) {
+	    if (flags == strictConversion) {
+		result = sourceIllegal;
+	    } else {
+		*target++ = UNI_REPLACEMENT_CHAR;
+	    }
+	} else {
+	    /* target is a character in range 0xFFFF - 0x10FFFF. */
+	    if (target + 1 >= targetEnd) {
+		--source; /* Back up source pointer! */
+		result = targetExhausted; break;
+	    }
+	    ch -= halfBase;
+	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+	}
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF32 (
+	const UTF16** sourceStart, const UTF16* sourceEnd,
+	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF16* source = *sourceStart;
+    UTF32* target = *targetStart;
+    UTF32 ch, ch2;
+    while (source < sourceEnd) {
+	const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
+	ch = *source++;
+	/* If we have a surrogate pair, convert to UTF32 first. */
+	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+	    /* If the 16 bits following the high surrogate are in the source buffer... */
+	    if (source < sourceEnd) {
+		ch2 = *source;
+		/* If it's a low surrogate, convert to UTF32. */
+		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
+		    ++source;
+		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+		    --source; /* return to the illegal value itself */
+		    result = sourceIllegal;
+		    break;
+		}
+	    } else { /* We don't have the 16 bits following the high surrogate. */
+		--source; /* return to the high surrogate */
+		result = sourceExhausted;
+		break;
+	    }
+	} else if (flags == strictConversion) {
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+		--source; /* return to the illegal value itself */
+		result = sourceIllegal;
+		break;
+	    }
+	}
+	if (target >= targetEnd) {
+	    source = oldSource; /* Back up source pointer! */
+	    result = targetExhausted; break;
+	}
+	*target++ = ch;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+#ifdef CVTUTF_DEBUG
+if (result == sourceIllegal) {
+    fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
+    fflush(stderr);
+}
+#endif
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Index into the table below with the first byte of a UTF-8 sequence to
+ * get the number of trailing bytes that are supposed to follow it.
+ * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
+ * left as-is for anyone who may want to do such conversion, which was
+ * allowed in earlier algorithms.
+ */
+static const char trailingBytesForUTF8[256] = {
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
+};
+
+/*
+ * Magic values subtracted from a buffer value during UTF8 conversion.
+ * This table contains as many values as there might be trailing bytes
+ * in a UTF-8 sequence.
+ */
+static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL,
+		     0x03C82080UL, 0xFA082080UL, 0x82082080UL };
+
+/*
+ * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
+ * into the first byte, depending on how many bytes follow.  There are
+ * as many entries in this table as there are UTF-8 sequence types.
+ * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
+ * for *legal* UTF-8 will be 4 or fewer bytes total.
+ */
+static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };
+
+/* --------------------------------------------------------------------- */
+
+/* The interface converts a whole buffer to avoid function-call overhead.
+ * Constants have been gathered. Loops & conditionals have been removed as
+ * much as possible for efficiency, in favor of drop-through switches.
+ * (See "Note A" at the bottom of the file for equivalent code.)
+ * If your compiler supports it, the "isLegalUTF8" call can be turned
+ * into an inline function.
+ */
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF16toUTF8 (
+	const UTF16** sourceStart, const UTF16* sourceEnd,
+	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF16* source = *sourceStart;
+    UTF8* target = *targetStart;
+    while (source < sourceEnd) {
+	UTF32 ch;
+	unsigned short bytesToWrite = 0;
+	const UTF32 byteMask = 0xBF;
+	const UTF32 byteMark = 0x80;
+	const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
+	ch = *source++;
+	/* If we have a surrogate pair, convert to UTF32 first. */
+	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
+	    /* If the 16 bits following the high surrogate are in the source buffer... */
+	    if (source < sourceEnd) {
+		UTF32 ch2 = *source;
+		/* If it's a low surrogate, convert to UTF32. */
+		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
+		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
+			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
+		    ++source;
+		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */
+		    --source; /* return to the illegal value itself */
+		    result = sourceIllegal;
+		    break;
+		}
+	    } else { /* We don't have the 16 bits following the high surrogate. */
+		--source; /* return to the high surrogate */
+		result = sourceExhausted;
+		break;
+	    }
+	} else if (flags == strictConversion) {
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
+		--source; /* return to the illegal value itself */
+		result = sourceIllegal;
+		break;
+	    }
+	}
+	/* Figure out how many bytes the result will require */
+	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
+	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+	} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
+	} else {			    bytesToWrite = 3;
+					    ch = UNI_REPLACEMENT_CHAR;
+	}
+
+	target += bytesToWrite;
+	if (target > targetEnd) {
+	    source = oldSource; /* Back up source pointer! */
+	    target -= bytesToWrite; result = targetExhausted; break;
+	}
+	switch (bytesToWrite) { /* note: everything falls through. */
+	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+	    case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
+	}
+	target += bytesToWrite;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Utility routine to tell whether a sequence of bytes is legal UTF-8.
+ * This must be called with the length pre-determined by the first byte.
+ * If not calling this from ConvertUTF8to*, then the length can be set by:
+ *  length = trailingBytesForUTF8[*source]+1;
+ * and the sequence is illegal right away if there aren't that many bytes
+ * available.
+ * If presented with a length > 4, this returns false.  The Unicode
+ * definition of UTF-8 goes up to 4-byte sequences.
+ */
+
+static Boolean isLegalUTF8(const UTF8 *source, int length) {
+    UTF8 a;
+    const UTF8 *srcptr = source+length;
+    switch (length) {
+    default: return false;
+	/* Everything else falls through when "true"... */
+    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
+    case 2: if ((a = (*--srcptr)) > 0xBF) return false;
+
+	switch (*source) {
+	    /* no fall-through in this inner switch */
+	    case 0xE0: if (a < 0xA0) return false; break;
+	    case 0xED: if (a > 0x9F) return false; break;
+	    case 0xF0: if (a < 0x90) return false; break;
+	    case 0xF4: if (a > 0x8F) return false; break;
+	    default:   if (a < 0x80) return false;
+	}
+
+    case 1: if (*source >= 0x80 && *source < 0xC2) return false;
+    }
+    if (*source > 0xF4) return false;
+    return true;
+}
+
+/* --------------------------------------------------------------------- */
+
+/*
+ * Exported function to return whether a UTF-8 sequence is legal or not.
+ * This is not used here; it's just exported.
+ */
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
+    int length = trailingBytesForUTF8[*source]+1;
+    if (source+length > sourceEnd) {
+	return false;
+    }
+    return isLegalUTF8(source, length);
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF16 (
+	const UTF8** sourceStart, const UTF8* sourceEnd,
+	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF8* source = *sourceStart;
+    UTF16* target = *targetStart;
+    while (source < sourceEnd) {
+	UTF32 ch = 0;
+	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+	if (source + extraBytesToRead >= sourceEnd) {
+	    result = sourceExhausted; break;
+	}
+	/* Do this check whether lenient or strict */
+	if (! isLegalUTF8(source, extraBytesToRead+1)) {
+	    result = sourceIllegal;
+	    break;
+	}
+	/*
+	 * The cases all fall through. See "Note A" below.
+	 */
+	switch (extraBytesToRead) {
+	    case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+	    case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
+	    case 3: ch += *source++; ch <<= 6;
+	    case 2: ch += *source++; ch <<= 6;
+	    case 1: ch += *source++; ch <<= 6;
+	    case 0: ch += *source++;
+	}
+	ch -= offsetsFromUTF8[extraBytesToRead];
+
+	if (target >= targetEnd) {
+	    source -= (extraBytesToRead+1); /* Back up source pointer! */
+	    result = targetExhausted; break;
+	}
+	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+		if (flags == strictConversion) {
+		    source -= (extraBytesToRead+1); /* return to the illegal value itself */
+		    result = sourceIllegal;
+		    break;
+		} else {
+		    *target++ = UNI_REPLACEMENT_CHAR;
+		}
+	    } else {
+		*target++ = (UTF16)ch; /* normal case */
+	    }
+	} else if (ch > UNI_MAX_UTF16) {
+	    if (flags == strictConversion) {
+		result = sourceIllegal;
+		source -= (extraBytesToRead+1); /* return to the start */
+		break; /* Bail out; shouldn't continue */
+	    } else {
+		*target++ = UNI_REPLACEMENT_CHAR;
+	    }
+	} else {
+	    /* target is a character in range 0xFFFF - 0x10FFFF. */
+	    if (target + 1 >= targetEnd) {
+		source -= (extraBytesToRead+1); /* Back up source pointer! */
+		result = targetExhausted; break;
+	    }
+	    ch -= halfBase;
+	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
+	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
+	}
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF32toUTF8 (
+	const UTF32** sourceStart, const UTF32* sourceEnd,
+	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF32* source = *sourceStart;
+    UTF8* target = *targetStart;
+    while (source < sourceEnd) {
+	UTF32 ch;
+	unsigned short bytesToWrite = 0;
+	const UTF32 byteMask = 0xBF;
+	const UTF32 byteMark = 0x80;
+	ch = *source++;
+	if (flags == strictConversion ) {
+	    /* UTF-16 surrogate values are illegal in UTF-32 */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+		--source; /* return to the illegal value itself */
+		result = sourceIllegal;
+		break;
+	    }
+	}
+	/*
+	 * Figure out how many bytes the result will require. Turn any
+	 * illegally large UTF32 things (> Plane 17) into replacement chars.
+	 */
+	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
+	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
+	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
+	} else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
+	} else {			    bytesToWrite = 3;
+					    ch = UNI_REPLACEMENT_CHAR;
+					    result = sourceIllegal;
+	}
+	
+	target += bytesToWrite;
+	if (target > targetEnd) {
+	    --source; /* Back up source pointer! */
+	    target -= bytesToWrite; result = targetExhausted; break;
+	}
+	switch (bytesToWrite) { /* note: everything falls through. */
+	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
+	    case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
+	}
+	target += bytesToWrite;
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* --------------------------------------------------------------------- */
+
+ConversionResult ConvertUTF8toUTF32 (
+	const UTF8** sourceStart, const UTF8* sourceEnd,
+	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
+    ConversionResult result = conversionOK;
+    const UTF8* source = *sourceStart;
+    UTF32* target = *targetStart;
+    while (source < sourceEnd) {
+	UTF32 ch = 0;
+	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
+	if (source + extraBytesToRead >= sourceEnd) {
+	    result = sourceExhausted; break;
+	}
+	/* Do this check whether lenient or strict */
+	if (! isLegalUTF8(source, extraBytesToRead+1)) {
+	    result = sourceIllegal;
+	    break;
+	}
+	/*
+	 * The cases all fall through. See "Note A" below.
+	 */
+	switch (extraBytesToRead) {
+	    case 5: ch += *source++; ch <<= 6;
+	    case 4: ch += *source++; ch <<= 6;
+	    case 3: ch += *source++; ch <<= 6;
+	    case 2: ch += *source++; ch <<= 6;
+	    case 1: ch += *source++; ch <<= 6;
+	    case 0: ch += *source++;
+	}
+	ch -= offsetsFromUTF8[extraBytesToRead];
+
+	if (target >= targetEnd) {
+	    source -= (extraBytesToRead+1); /* Back up the source pointer! */
+	    result = targetExhausted; break;
+	}
+	if (ch <= UNI_MAX_LEGAL_UTF32) {
+	    /*
+	     * UTF-16 surrogate values are illegal in UTF-32, and anything
+	     * over Plane 17 (> 0x10FFFF) is illegal.
+	     */
+	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
+		if (flags == strictConversion) {
+		    source -= (extraBytesToRead+1); /* return to the illegal value itself */
+		    result = sourceIllegal;
+		    break;
+		} else {
+		    *target++ = UNI_REPLACEMENT_CHAR;
+		}
+	    } else {
+		*target++ = ch;
+	    }
+	} else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
+	    result = sourceIllegal;
+	    *target++ = UNI_REPLACEMENT_CHAR;
+	}
+    }
+    *sourceStart = source;
+    *targetStart = target;
+    return result;
+}
+
+/* ---------------------------------------------------------------------
+
+    Note A.
+    The fall-through switches in UTF-8 reading code save a
+    temp variable, some decrements & conditionals.  The switches
+    are equivalent to the following loop:
+	{
+	    int tmpBytesToRead = extraBytesToRead+1;
+	    do {
+		ch += *source++;
+		--tmpBytesToRead;
+		if (tmpBytesToRead) ch <<= 6;
+	    } while (tmpBytesToRead > 0);
+	}
+    In UTF-8 writing code, the switches on "bytesToWrite" are
+    similarly unrolled loops.
+
+   --------------------------------------------------------------------- */
diff -rupN john-1.7.8/src/unused/ConvertUTF.h.original john-1.7.8-jumbo-2/src/unused/ConvertUTF.h.original
--- john-1.7.8/src/unused/ConvertUTF.h.original	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/ConvertUTF.h.original	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2001-2004 Unicode, Inc.
+ *
+ * Disclaimer
+ *
+ * This source code is provided as is by Unicode, Inc. No claims are
+ * made as to fitness for any particular purpose. No warranties of any
+ * kind are expressed or implied. The recipient agrees to determine
+ * applicability of information provided. If this file has been
+ * purchased on magnetic or optical media from Unicode, Inc., the
+ * sole remedy for any claim will be exchange of defective media
+ * within 90 days of receipt.
+ *
+ * Limitations on Rights to Redistribute This Code
+ *
+ * Unicode, Inc. hereby grants the right to freely use the information
+ * supplied in this file in the creation of products supporting the
+ * Unicode Standard, and to make copies of this file in any form
+ * for internal or external distribution as long as this notice
+ * remains attached.
+ */
+
+/* ---------------------------------------------------------------------
+
+    Conversions between UTF32, UTF-16, and UTF-8.  Header file.
+
+    Several funtions are included here, forming a complete set of
+    conversions between the three formats.  UTF-7 is not included
+    here, but is handled in a separate source file.
+
+    Each of these routines takes pointers to input buffers and output
+    buffers.  The input buffers are const.
+
+    Each routine converts the text between *sourceStart and sourceEnd,
+    putting the result into the buffer between *targetStart and
+    targetEnd. Note: the end pointers are *after* the last item: e.g.
+    *(sourceEnd - 1) is the last item.
+
+    The return result indicates whether the conversion was successful,
+    and if not, whether the problem was in the source or target buffers.
+    (Only the first encountered problem is indicated.)
+
+    After the conversion, *sourceStart and *targetStart are both
+    updated to point to the end of last text successfully converted in
+    the respective buffers.
+
+    Input parameters:
+	sourceStart - pointer to a pointer to the source buffer.
+		The contents of this are modified on return so that
+		it points at the next thing to be converted.
+	targetStart - similarly, pointer to pointer to the target buffer.
+	sourceEnd, targetEnd - respectively pointers to the ends of the
+		two buffers, for overflow checking only.
+
+    These conversion functions take a ConversionFlags argument. When this
+    flag is set to strict, both irregular sequences and isolated surrogates
+    will cause an error.  When the flag is set to lenient, both irregular
+    sequences and isolated surrogates are converted.
+
+    Whether the flag is strict or lenient, all illegal sequences will cause
+    an error return. This includes sequences such as: <F4 90 80 80>, <C0 80>,
+    or <A0> in UTF-8, and values above 0x10FFFF in UTF-32. Conformant code
+    must check for illegal sequences.
+
+    When the flag is set to lenient, characters over 0x10FFFF are converted
+    to the replacement character; otherwise (when the flag is set to strict)
+    they constitute an error.
+
+    Output parameters:
+	The value "sourceIllegal" is returned from some routines if the input
+	sequence is malformed.  When "sourceIllegal" is returned, the source
+	value will point to the illegal value that caused the problem. E.g.,
+	in UTF-8 when a sequence is malformed, it points to the start of the
+	malformed sequence.
+
+    Author: Mark E. Davis, 1994.
+    Rev History: Rick McGowan, fixes & updates May 2001.
+		 Fixes & updates, Sept 2001.
+
+------------------------------------------------------------------------ */
+
+/* ---------------------------------------------------------------------
+    The following 4 definitions are compiler-specific.
+    The C standard does not guarantee that wchar_t has at least
+    16 bits, so wchar_t is no less portable than unsigned short!
+    All should be unsigned values to avoid sign extension during
+    bit mask & shift operations.
+------------------------------------------------------------------------ */
+
+typedef unsigned long	UTF32;	/* at least 32 bits */
+typedef unsigned short	UTF16;	/* at least 16 bits */
+typedef unsigned char	UTF8;	/* typically 8 bits */
+typedef unsigned char	Boolean; /* 0 or 1 */
+
+/* Some fundamental constants */
+#define UNI_REPLACEMENT_CHAR (UTF32)0x0000FFFD
+#define UNI_MAX_BMP (UTF32)0x0000FFFF
+#define UNI_MAX_UTF16 (UTF32)0x0010FFFF
+#define UNI_MAX_UTF32 (UTF32)0x7FFFFFFF
+#define UNI_MAX_LEGAL_UTF32 (UTF32)0x0010FFFF
+
+typedef enum {
+	conversionOK, 		/* conversion successful */
+	sourceExhausted,	/* partial character in source, but hit end */
+	targetExhausted,	/* insuff. room in target for conversion */
+	sourceIllegal		/* source sequence is illegal/malformed */
+} ConversionResult;
+
+typedef enum {
+	strictConversion = 0,
+	lenientConversion
+} ConversionFlags;
+
+/* This is for C++ and does no harm in C */
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+ConversionResult ConvertUTF8toUTF16 (
+		const UTF8** sourceStart, const UTF8* sourceEnd,
+		UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF16toUTF8 (
+		const UTF16** sourceStart, const UTF16* sourceEnd,
+		UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+		
+ConversionResult ConvertUTF8toUTF32 (
+		const UTF8** sourceStart, const UTF8* sourceEnd,
+		UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF8 (
+		const UTF32** sourceStart, const UTF32* sourceEnd,
+		UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags);
+		
+ConversionResult ConvertUTF16toUTF32 (
+		const UTF16** sourceStart, const UTF16* sourceEnd,
+		UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags);
+
+ConversionResult ConvertUTF32toUTF16 (
+		const UTF32** sourceStart, const UTF32* sourceEnd,
+		UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags);
+
+Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd);
+
+#ifdef __cplusplus
+}
+#endif
+
+/* --------------------------------------------------------------------- */
diff -rupN john-1.7.8/src/unused/PHPS_fmt_orig.c john-1.7.8-jumbo-2/src/unused/PHPS_fmt_orig.c
--- john-1.7.8/src/unused/PHPS_fmt_orig.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/PHPS_fmt_orig.c	2011-05-17 18:13:01.000000000 +0200
@@ -0,0 +1,268 @@
+/*
+ * PHPS_fmt.c
+ *
+ * Salted PHP on the form (php-code): $hash = MD5(MD5($pass).$salt);
+ * Based on salted IPB2 mode (by regenrecht at o2.pl).
+ *
+ * albert veli gmail com, 2007
+ *
+ * Convert hashes to the form username:$PHPS$salt$hash
+ * For instance, if the pw file has the form
+ * 1234<::>luser<::>luser@hotmail.com<::><::>1ea46bf1f5167b63d12bd47c8873050e<::>C9%
+ * it can be converted to the wanted form with the following perl script:
+ *
+ * #!/usr/bin/perl -w
+ * while (<>) {
+ *    my @fields = split(/<::>/, $_);
+ *    my $a =  substr $fields[5], 0, 1;
+ *    my $b =  substr $fields[5], 1, 1;
+ *    my $c =  substr $fields[5], 2, 1;
+ *    printf "%s:\$IPB2\$%02x%02x%02x\$%s\n", $fields[1], ord($a), ord($b), ord($c), $fields[4];
+ * }
+ *
+ * BUGS: Can't handle usernames with ':' in them.
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "md5.h"
+#include "common.h"
+#include "formats.h"
+
+#define FORMAT_LABEL		"phps"
+#define FORMAT_NAME		"PHPS MD5"
+#define ALGORITHM_NAME		"MD5(MD5($pass).$salt)"
+
+#define BENCHMARK_COMMENT	""
+#define BENCHMARK_LENGTH	0
+
+#define MD5_BINARY_SIZE		16
+#define MD5_HEX_SIZE		(MD5_BINARY_SIZE * 2)
+
+#define BINARY_SIZE		MD5_BINARY_SIZE
+
+#define SALT_SIZE		3
+#define PROCESSED_SALT_SIZE	SALT_SIZE
+
+#define PLAINTEXT_LENGTH	32
+#define CIPHERTEXT_LENGTH	(1 + 4 + 1 + SALT_SIZE * 2 + 1 + MD5_HEX_SIZE)
+
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+
+static struct fmt_tests phps_tests[] = {
+	{"$PHPS$433925$5d756853cd63acee76e6dcd6d3728447", "welcome"},
+	{NULL}
+};
+
+static char itoa16_shr_04[] =
+	"0000000000000000"
+	"1111111111111111"
+	"2222222222222222"
+	"3333333333333333"
+	"4444444444444444"
+	"5555555555555555"
+	"6666666666666666"
+	"7777777777777777"
+	"8888888888888888"
+	"9999999999999999"
+	"aaaaaaaaaaaaaaaa"
+	"bbbbbbbbbbbbbbbb"
+	"cccccccccccccccc"
+	"dddddddddddddddd"
+	"eeeeeeeeeeeeeeee"
+	"ffffffffffffffff";
+
+static char itoa16_and_0f[] =
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef"
+	"0123456789abcdef";
+
+static MD5_CTX ctx;
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static int saved_key_len;
+static char workspace[MD5_HEX_SIZE * 2];
+static char output[MD5_BINARY_SIZE];
+
+static int phps_valid(char *ciphertext, struct fmt_main *pFmt)
+{
+	if (!ciphertext)
+		return 0;
+
+	if (strlen(ciphertext) != CIPHERTEXT_LENGTH)
+		return 0;
+
+	if (strncmp(ciphertext, "$PHPS$", 6) != 0)
+		return 0;
+
+ 	if (ciphertext[12] != '$')
+		return 0;
+
+ 	if (strspn(ciphertext+6, itoa16) != SALT_SIZE * 2)
+		return 0;
+
+ 	if (strspn(ciphertext+13, itoa16) != MD5_HEX_SIZE)
+		return 0;
+
+	return 1;
+}
+
+static void *phps_binary(char *ciphertext)
+{
+	static unsigned char binary_cipher[BINARY_SIZE];
+	int i;
+
+	ciphertext += 13;
+	for (i = 0; i < MD5_HEX_SIZE; ++i)
+		binary_cipher[i] =
+			(atoi16[ARCH_INDEX(ciphertext[i*2])] << 4)
+			+ atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+	return (void *)binary_cipher;
+}
+
+static void *phps_salt(char *ciphertext)
+{
+	static unsigned char binary_salt[SALT_SIZE];
+	int i;
+
+	ciphertext += 6;
+	for (i = 0; i < SALT_SIZE; ++i)
+		binary_salt[i] =
+			(atoi16[ARCH_INDEX(ciphertext[i*2])] << 4)
+			+ atoi16[ARCH_INDEX(ciphertext[i*2+1])];
+
+	return (void*)binary_salt;
+}
+
+static void phps_set_salt(void *salt)
+{
+	memcpy((char*)(workspace + MD5_HEX_SIZE), (char*)salt, PROCESSED_SALT_SIZE);
+}
+
+static int strnfcpy_count(char *dst, char *src, int size)
+{
+	char *dptr = dst, *sptr = src;
+	int count = size;
+
+	while (count--)
+		if (!(*dptr++ = *sptr++)) break;
+
+	return size-count-1;
+}
+
+static void phps_set_key(char *key, int index)
+{
+	static unsigned char key_hash[MD5_BINARY_SIZE];
+	unsigned char *kh = key_hash;
+	unsigned char *workspace_ptr = (unsigned char *) workspace;
+	unsigned char v;
+	int i;
+
+	saved_key_len = strnfcpy_count(saved_key, key, PLAINTEXT_LENGTH);
+
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, saved_key, saved_key_len);
+	MD5_Final(key_hash, &ctx);
+
+	for (i = 0; i < MD5_BINARY_SIZE; ++i) {
+		v = *kh++;
+		*workspace_ptr++ = itoa16_shr_04[ARCH_INDEX(v)];
+		*workspace_ptr++ = itoa16_and_0f[ARCH_INDEX(v)];
+	}
+}
+
+static char *phps_get_key(int index)
+{
+	return saved_key;
+}
+
+static void phps_crypt_all(int count)
+{
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, workspace, MD5_HEX_SIZE + SALT_SIZE);
+	MD5_Final((unsigned char *) output, &ctx);
+}
+
+static int phps_cmp_all(void *binary, int index)
+{
+	return !memcmp(binary, output, MD5_BINARY_SIZE);
+}
+
+static int phps_cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main fmt_PHPS = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		PROCESSED_SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		phps_tests
+	},
+	{
+		fmt_default_init,
+		fmt_default_prepare,
+		phps_valid,
+		fmt_default_split,
+		phps_binary,
+		phps_salt,
+		{
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash,
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		phps_set_salt,
+		phps_set_key,
+		phps_get_key,
+		fmt_default_clear_keys,
+		phps_crypt_all,
+		{
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash,
+			fmt_default_get_hash
+		},
+		phps_cmp_all,
+		phps_cmp_all,
+		phps_cmp_exact
+	}
+};
+
+
+/**
+ * GNU Emacs settings: K&R with 1 tab indent.
+ * Local Variables:
+ * c-file-style: "k&r"
+ * c-basic-offset: 8
+ * indent-tabs-mode: t
+ * End:
+ */
diff -rupN john-1.7.8/src/unused/crc32-calculator.c john-1.7.8-jumbo-2/src/unused/crc32-calculator.c
--- john-1.7.8/src/unused/crc32-calculator.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/crc32-calculator.c	2011-06-08 02:37:56.000000000 +0200
@@ -0,0 +1,53 @@
+/* gcc -Wall crc32-calculator.c crc32.c memory.c -o crc32-calculator */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <assert.h>
+
+#include "crc32.h"
+
+static void process_file(const char *filename)
+{
+	int i;
+	FILE *fp;
+	if (!(fp = fopen(filename, "rb"))) {
+		fprintf(stderr, "! %s : %s\n", filename, strerror(errno));
+		return;
+	}
+	fseek(fp, 0, SEEK_END);
+	long size = ftell(fp);
+	rewind(fp);
+
+	printf("file name : %s, file size : %ld, CRC32: ", filename, size);
+	unsigned char *buf = (unsigned char *) malloc(size);
+	long count = fread(buf, 1, size, fp);
+	assert(count == size);
+
+	CRC32_t crc;
+	CRC32_Init(&crc);
+	CRC32_Update(&crc, buf, count);
+	unsigned char crc_out[4];
+	CRC32_Final(crc_out, crc);
+	for (i = 0; i < 4; i++) {
+		printf("%02x ", crc_out[i]);
+	}
+	printf("\n");
+	fclose(fp);
+}
+
+int main(int argc, char **argv)
+{
+	int i;
+
+	if (argc < 2) {
+		printf("Usage: %s [files]\n", argv[0]);
+		return 0;
+	}
+	for (i = 1; i < argc; i++)
+		process_file(argv[i]);
+
+	return 0;
+}
diff -rupN john-1.7.8/src/unused/dsa_test.key john-1.7.8-jumbo-2/src/unused/dsa_test.key
--- john-1.7.8/src/unused/dsa_test.key	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/dsa_test.key	2011-06-02 23:31:42.000000000 +0200
@@ -0,0 +1,15 @@
+-----BEGIN DSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: AES-128-CBC,5A8068279C0F46E98207150A3C2EC614
+
+/uiTinJ4RUjoZv0+pY1iMv1ciVarCi4z/b6ZiLAaVYpyJ1hXT2tci+Y2f3LaaExc
+o5wr1aAFM47xmRmGo82I/vCHGA9Rxg5waGC9pWOGZVuUQrDsU6tcUkCMB+2Z4GS9
+5ODGCdDK2gNetDnb2JvHsqATsm4Cc63GdhiZ0sCFYLqym+We1wCYalxsO21W+Ogo
+B3ogFFIw2r2F+qJzqM7AUCyLFhi5zGmu6SNeXvU4GzxGPFJNG0mAOUIwaaN1aDjc
+N2k4bCrfybq3z6nCe3DBs8K22iN+8uRnSAbCOqzZXEdYqUYY5Kkj2neCTRTXINdg
+Q+aSSYg3y5Y7boKkjIOrvPUWHeOyduQ+tersAEw7nCVJzr9N8tRg2qV4PUv1CKfp
+OIFwB7/9somjYIjqWoaSzjxK0c8Rwz0S1pmr+uqrbwy+Peou5M3semHlBkGiU27f
+wohKy+MUNHbsNjysSZSElNKsMIPqTIVzZE1mVFA/0uMGqdpQ3bzBOjX2Zo6edFCO
+mJ4wYavW5wM+jmuVKPVVNy99Zxyep0FEdLP5Kb2c4Zl0S9f14/b6h6APixVe7zuv
+VbSkByfJnyzhIOYBIyT7Mdw14r4AXJV6+ZoEw09wiwM=
+-----END DSA PRIVATE KEY-----
diff -rupN john-1.7.8/src/unused/pdfdump john-1.7.8-jumbo-2/src/unused/pdfdump
--- john-1.7.8/src/unused/pdfdump	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/pdfdump	2011-06-02 23:12:33.000000000 +0200
@@ -0,0 +1,4 @@
+PDF-Example-Password.pdf:$pdf$Standard*badad1e86442699427116d3e5d5271bc80a27814fc5e80f815efeef839354c5f*289ece9b5ce451a5d7064693dab3badf101112131415161718191a1b1c1d1e1f*16*34b1b6e593787af681a9b63fa8bf563b*1*1*0*1*4*128*-4*3*2
+test-3-RC4-40-open-testpassword.pdf:$pdf$Standard*9a1156c38ab8177598d1608df7d7e340ae639679bd66bc4cda9bc9a4eedeb170*1f300cd939dd5cf0920c787f12d16be22205e55a5bec5c9c6d563ab4fd0770d7*16*c015cff8dbf99345ac91c84a45667784*1*1*0*1*6*40*-4*2*1
+test-3-RC4-40-open-test.pdf:$pdf$Standard*7303809eaf677bdb5ca64b9d8cb0ccdd47d09a7b28ad5aa522c62685c6d9e499*bf38d7a59daaf38365a338e1fc07976102f1dfd6bdb52072032f57920109b43a*16*c56bbc4145d25b468a873618cd71c2d3*1*1*0*1*6*40*-4*2*1
+test-5-RC4-128-open-testpassword.pdf:$pdf$Standard*137ad7063db5114a66ce1900d47e5cab9c5d7053487d92ac978f54db86eca393*0231a4c9cae29b53892874e168cfae9600000000000000000000000000000000*16*c015cff8dbf99345ac91c84a45667784*1*1*0*1*6*128*-1028*3*2
diff -rupN john-1.7.8/src/unused/phpassMD5_fmt_orig.c john-1.7.8-jumbo-2/src/unused/phpassMD5_fmt_orig.c
--- john-1.7.8/src/unused/phpassMD5_fmt_orig.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/phpassMD5_fmt_orig.c	2011-06-02 17:19:13.000000000 +0200
@@ -0,0 +1,486 @@
+/*
+ * This software was written by Jim Fougeron jfoug AT cox dot net
+ * in 2009. No copyright is claimed, and the software is hereby
+ * placed in the public domain. In case this attempt to disclaim
+ * copyright and place the software in the public domain is deemed
+ * null and void, then the software is Copyright  2009 Jim Fougeron
+ * and it is hereby released to the general public under the following
+ * terms:
+ *
+ * This software may be modified, redistributed, and used for any
+ * purpose, in source and binary forms, with or without modification.
+ *
+ * Cracks phpass 'portable' hashes, and phpBBv3 hashes, which
+ * are simply phpass portable, with a slightly different signature.
+ * These are 8 byte salted hashes, with a 1 byte 'salt' that
+ * defines the number of loops to compute.  Internally we work
+ * with 8 byte salt (the 'real' salt), but let john track it as
+ * 9 byte salts (the loop count byte is appended to the 'real'
+ * 8 byte salt value.
+ *
+ * code should be pretty fast, and pretty well debugged.  Works
+ * even if there are multiple loop count values in the set of
+ * hashes. PHPv5 kicked up the default loop number, but it is
+ * programatically allowed to have different looping counts.
+ * This format should handle all valid loop values.
+ *
+ * uses openSSL's MD5 and SSE2/MMX MD5 found in md5-mmx.S
+ *
+ */
+
+#include <string.h>
+
+#include "arch.h"
+#include "misc.h"
+#include "common.h"
+#include "formats.h"
+#include "md5.h"
+
+#define FORMAT_LABEL			"phpass-md5"
+#define FORMAT_NAME				"PHPass MD5"
+#ifdef MMX_COEF
+#if (MMX_COEF == 2)
+#define ALGORITHM_NAME			"phpass-MD5 MMX"
+#else
+#define ALGORITHM_NAME			"phpass-MD5 SSE2"
+#endif
+#else
+#define ALGORITHM_NAME			"phpass-md5"
+#endif
+
+#ifdef MMX_TYPE
+#define BENCHMARK_COMMENT		MMX_TYPE
+#else
+#define BENCHMARK_COMMENT		""
+#endif
+#define BENCHMARK_LENGTH		-1
+
+#define PLAINTEXT_LENGTH		64
+#define CIPHERTEXT_LENGTH		34
+
+#define BINARY_SIZE					16
+#define SALT_SIZE						8
+// NOTE salts are only 8 bytes, but we tell john they are 9.
+// We then take the 8 bytes of salt, and append the 1 byte of
+// loop count data, making it 9.  However, internal to this
+// code, we only use the 8 bytes of salt. We do 'use' the loop
+// count data to set our counters, whenever we set the salt, but
+// it is NOT part of the rest of the salt 'usage'.
+// So, $H$9PE8jEklg.... would have a salt of PE8jEklg9 but only
+// the PE8jEklg is the 'actual' salt, and we use the '9' to figure
+// out the looping.
+
+#ifdef MMX_COEF
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	MMX_COEF
+#define GETPOS(i, index)		( (index)*4 + ((i)& (0xffffffff-3) )*MMX_COEF + ((i)&3) )
+#else
+#define MIN_KEYS_PER_CRYPT	1
+#define MAX_KEYS_PER_CRYPT	1
+#endif
+
+static struct fmt_tests phpassmd5_tests[] = {
+		{"$H$9aaaaaSXBjgypwqm.JsMssPLiS8YQ00","test1"},
+		{"$H$9PE8jEklgZhgLmZl5.HYJAzfGCQtzi1", "123456"},
+		{"$H$9pdx7dbOW3Nnt32sikrjAxYFjX8XoK1", "123456"},
+		{"$P$912345678LIjjb6PhecupozNBmDndU0", "thisisalongertestPW"},
+		{"$H$9A5she.OeEiU583vYsRXZ5m2XIpI68/", "123456"},
+		{"$P$917UOZtDi6ksoFt.y2wUYvgUI6ZXIK/", "test1"},
+		{"$P$91234567AQwVI09JXzrV1hEC6MSQ8I0", "thisisalongertest"},
+		{"$P$9234560A8hN6sXs5ir0NfozijdqT6f0", "test2"},
+		{"$P$9234560A86ySwM77n2VA/Ey35fwkfP0", "test3"},
+		{"$P$9234560A8RZBZDBzO5ygETHXeUZX5b1", "test4"},
+		{"$P$91234567xogA.H64Lkk8Cx8vlWBVzH0", "thisisalongertst"},
+		{"$P$612345678si5M0DDyPpmRCmcltU/YW/", "JohnRipper"}, // note smaller loop count
+		{"$H$712345678WhEyvy1YWzT4647jzeOmo0", "JohnRipper"}, // note smaller loop count (phpbb w/older PHP version)
+		{"$P$B12345678L6Lpt4BxNotVIMILOa9u81", "JohnRipper"}, // note larber loop count  (Wordpress)
+		{NULL}
+};
+
+#ifdef MMX_COEF
+/* Cygwin would not guarantee the alignment if these were declared static */
+#define crypt_key phpassmd5_crypt_key
+#define cursalt phpassmd5_cursalt
+#define dump phpassmd5_dump
+char crypt_key[PLAINTEXT_LENGTH*MMX_COEF+1] __attribute__ ((aligned(16)));
+unsigned char cursalt[PLAINTEXT_LENGTH*MMX_COEF+1] __attribute__ ((aligned(16)));
+unsigned char dump[BINARY_SIZE*MMX_COEF] __attribute__((aligned(16)));
+static unsigned keylen[MMX_COEF];
+static unsigned maxkeylen, bNewKeys;
+static ARCH_WORD_32 total_len;
+static unsigned tot_keys;
+static unsigned char EncKey[MMX_COEF][PLAINTEXT_LENGTH + 1];
+#else
+static MD5_CTX ctx;
+static unsigned char cursalt[SALT_SIZE];
+static char crypt_key[PLAINTEXT_LENGTH+1+BINARY_SIZE];
+static unsigned char EncKey[PLAINTEXT_LENGTH + 1];
+static unsigned EncKeyLen;
+#endif
+static unsigned loopCnt;
+static char out[PLAINTEXT_LENGTH+1];
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+		int i;
+		unsigned count_log2;
+
+		if (strlen(ciphertext) != 34)
+				return 0;
+		// Handle both the phpass signature, and the phpBB v3 signature (same formula)
+		// NOTE we are only dealing with the 'portable' encryption method
+		if (strncmp(ciphertext, "$P$", 3) != 0 && strncmp(ciphertext, "$H$", 3) != 0)
+				return 0;
+		for (i = 3; i < 34; ++i)
+				if (atoi64[ARCH_INDEX(ciphertext[i])] == 0x7F)
+						return 0;
+
+		count_log2 = atoi64[ARCH_INDEX(ciphertext[3])];
+		if (count_log2 < 7 || count_log2 > 31)
+				return 0;
+
+		return 1;
+}
+
+static void phpassmd5_init(struct fmt_main *pFmt) {
+#ifdef MMX_COEF
+		memset(cursalt, 0, sizeof(cursalt));
+		memset(crypt_key, 0, sizeof(crypt_key));
+#endif
+}
+static void phpassmd5_set_salt(void *salt)
+{
+		// compute the loop count for this salt
+		loopCnt = (1 << (atoi64[ARCH_INDEX(((char*)salt)[8])]));
+
+		// Now, deal with the 8 byte salt 'value'
+#ifdef MMX_COEF
+#if (MMX_COEF == 4)
+		// since salt is 8 bytes long, we can use 2 32 bit assignments to
+		// handle the setting (replicated 4 times), vs 32 8 bit character
+		// assignments.  Same end result, but faster.
+		((ARCH_WORD_32 *)cursalt)[0] = ((ARCH_WORD_32 *)salt)[0];
+		((ARCH_WORD_32 *)cursalt)[1] = ((ARCH_WORD_32 *)salt)[0];
+		((ARCH_WORD_32 *)cursalt)[2] = ((ARCH_WORD_32 *)salt)[0];
+		((ARCH_WORD_32 *)cursalt)[3] = ((ARCH_WORD_32 *)salt)[0];
+		((ARCH_WORD_32 *)cursalt)[4] = ((ARCH_WORD_32 *)salt)[1];
+		((ARCH_WORD_32 *)cursalt)[5] = ((ARCH_WORD_32 *)salt)[1];
+		((ARCH_WORD_32 *)cursalt)[6] = ((ARCH_WORD_32 *)salt)[1];
+		((ARCH_WORD_32 *)cursalt)[7] = ((ARCH_WORD_32 *)salt)[1];
+#else
+		((ARCH_WORD_32 *)cursalt)[0] = ((ARCH_WORD_32 *)salt)[0];
+		((ARCH_WORD_32 *)cursalt)[1] = ((ARCH_WORD_32 *)salt)[0];
+		((ARCH_WORD_32 *)cursalt)[2] = ((ARCH_WORD_32 *)salt)[1];
+		((ARCH_WORD_32 *)cursalt)[3] = ((ARCH_WORD_32 *)salt)[1];
+#endif  // MMX_COEF != 4
+#else	// !MMX_COEF
+		((ARCH_WORD_32 *)cursalt)[0] = ((ARCH_WORD_32 *)salt)[0];
+		((ARCH_WORD_32 *)cursalt)[1] = ((ARCH_WORD_32 *)salt)[1];
+#endif
+}
+
+static void phpassmd5_set_key(char *key, int index) {
+		int len;
+		len = strlen(key);
+#ifdef MMX_COEF
+		int i;
+
+		// the SSE code works up to 55 chars, but we have append PW to 16 byte prior
+		// md5 hashes, so 39 is max PW size we can do with this SSE phpass code.
+		if(len > (55-16) )
+				len = (55-16);
+		if (index == 0)
+		{
+				tot_keys = total_len = 0;
+				memset(&cursalt[SALT_SIZE*MMX_COEF], 0, (maxkeylen+4)*MMX_COEF);
+				memset(&crypt_key[BINARY_SIZE*MMX_COEF], 0, (maxkeylen+4)*MMX_COEF);
+				maxkeylen = len;
+		}
+		else if (len > maxkeylen)
+			maxkeylen = len;
+		bNewKeys = 1;
+		keylen[index] = len;
+		strncpy(((char*)(EncKey[index])), key, len);
+		EncKey[index][len] = 0;
+		i = SALT_SIZE;
+		int j, wordcnt = (len >> 2);
+		if (wordcnt)
+		{
+				i += (wordcnt << 2);
+				for (j = 0; j < wordcnt; ++j)
+						((ARCH_WORD_32 *)cursalt)[((SALT_SIZE>>2)+j)*MMX_COEF+index] = ((ARCH_WORD_32 *)key)[j];
+		}
+		for(; i < len+SALT_SIZE; ++i)
+				cursalt[GETPOS(i, index)] = ((unsigned char *)key)[i-SALT_SIZE];
+		cursalt[GETPOS(i, index)] = 0x80;
+		total_len += ( len << ( ( (32/MMX_COEF) * index ) ));
+		++tot_keys;
+#else
+		if(len>PLAINTEXT_LENGTH)
+				len = PLAINTEXT_LENGTH;
+		EncKeyLen=len;
+		strcpy(((char*)EncKey), key);
+#endif
+}
+
+static char *phpassmd5_get_key(int index) {
+#ifdef MMX_COEF
+		strcpy(out, ((char*)(EncKey[index])));
+#else
+		strcpy(out, ((char*)EncKey));
+#endif
+		return (char *) out;
+}
+
+static int phpassmd5_cmp_all(void *binary, int index) {
+
+#ifdef MMX_COEF
+#if (MMX_COEF > 3)
+		unsigned int i=0;
+		while(i< (BINARY_SIZE/4) )
+		{
+				if((((ARCH_WORD_32 *)binary)[i] != ((ARCH_WORD_32 *)crypt_key)[i*MMX_COEF]) &&
+					 (((ARCH_WORD_32 *)binary)[i] != ((ARCH_WORD_32 *)crypt_key)[i*MMX_COEF+1])
+#if (MMX_COEF > 3)
+					 &&
+					 (((ARCH_WORD_32 *)binary)[i] != ((ARCH_WORD_32 *)crypt_key)[i*MMX_COEF+2]) &&
+					 (((ARCH_WORD_32 *)binary)[i] != ((ARCH_WORD_32 *)crypt_key)[i*MMX_COEF+3])
+#endif
+						)
+						return 0;
+				i++;
+		}
+		return 1;
+#endif
+#else
+		int i=0;
+		while(i<BINARY_SIZE/4)
+		{
+				if(((ARCH_WORD_32 *)binary)[i]!=((ARCH_WORD_32 *)crypt_key)[i])
+						return 0;
+				i++;
+		}
+#endif
+		return 1;
+}
+
+static int phpassmd5_cmp_exact(char *source, int count)
+{
+		return (1);
+}
+
+#ifdef MMX_COEF
+static int phpassmd5_cmp_one(void * binary, int index)
+{
+		return((((ARCH_WORD_32 *)binary)[0] == ((ARCH_WORD_32 *)crypt_key)[0*MMX_COEF+index]) &&
+				   (((ARCH_WORD_32 *)binary)[1] == ((ARCH_WORD_32 *)crypt_key)[1*MMX_COEF+index])
+#if (MMX_COEF > 3)
+				   &&
+				   (((ARCH_WORD_32 *)binary)[2] == ((ARCH_WORD_32 *)crypt_key)[2*MMX_COEF+index]) &&
+				   (((ARCH_WORD_32 *)binary)[3] == ((ARCH_WORD_32 *)crypt_key)[3*MMX_COEF+index])
+#endif
+				);
+}
+#else
+#define phpassmd5_cmp_one phpassmd5_cmp_all
+#endif
+
+#ifdef MMX_COEF
+static void appendOneKey(int index) {
+		int i=0;
+
+		int j, wordcnt = (keylen[index] >> 2);
+		if (wordcnt)
+		{
+				ARCH_WORD_32 *dwKey = ((ARCH_WORD_32*)EncKey[index]);
+				i += (wordcnt << 2);
+				for (j = 0; j < wordcnt; ++j)
+						((ARCH_WORD_32 *)crypt_key)[((BINARY_SIZE>>2)+j)*MMX_COEF+index] = dwKey[j];
+		}
+		for (; i < keylen[index]; ++i)
+				crypt_key[GETPOS(i+BINARY_SIZE, index)] = EncKey[index][i];
+		crypt_key[GETPOS(keylen[index]+BINARY_SIZE, index)] = 0x80;
+}
+#endif
+
+static void phpassmd5_crypt_all(int count) {
+		unsigned Lcount;
+
+#ifdef MMX_COEF
+		int i, cur_working_lengths;
+
+		// The first call, is to encrypt the seeds (8 bytes long) with the password
+		// appened.  Thus, we need total_len + 0x08080808  (for sse2), since the
+		// 8 byte fixed length of the seeds (0x00080008 for MMX, for the 2 seeds)
+#if (MMX_COEF > 2)
+		cur_working_lengths = 0x08080808 + total_len;
+#else
+		cur_working_lengths = 0x80008 + total_len;
+#endif
+
+		// Now, encrypt the seed+pw data
+		mdfivemmx(crypt_key, cursalt, cur_working_lengths);
+
+		// Now setup length for md5hash+password.  The md5hash will be overwrittnen
+		// again and again, within our loop, but the password (and length info) will
+		// stay static.  Huge improvement over doing 2 MD5 calls.  Again, add 0x10
+		// to the length of the passwords (0x10101010 for SSE2, 0x00100010 for MMX)
+#if (MMX_COEF > 2)
+		cur_working_lengths = 0x10101010 + total_len;
+#else
+		cur_working_lengths = 0x100010 + total_len;
+#endif
+		if (bNewKeys)
+		{
+				bNewKeys = 0;
+				for (i = 0; i < tot_keys; ++i)
+						appendOneKey(i);
+		}
+
+		Lcount = loopCnt;
+		// Now, encrypt the hash+pw data (again and again)  NOTE crypt_key is both input
+		// and output. the md5 hashes will be at the 'base' of this, followed by the
+		// already stored passwords.
+
+		mdfivemmx( crypt_key, crypt_key, cur_working_lengths);
+		--Lcount;
+		do
+		{
+				//mdfivemmx( crypt_key, crypt_key, cur_working_lengths);
+				mdfivemmx_nosizeupdate( crypt_key, crypt_key, cur_working_lengths);
+		} while (--Lcount);
+
+#else
+		MD5_Init( &ctx );
+		MD5_Update( &ctx, cursalt, 8 );
+		MD5_Update( &ctx, EncKey, EncKeyLen );
+		MD5_Final( (unsigned char *) crypt_key, &ctx);
+
+		strcpy(&crypt_key[BINARY_SIZE], ((char*)EncKey));
+		Lcount = loopCnt;
+
+		do {
+				MD5_Init( &ctx );
+				MD5_Update( &ctx, crypt_key,  BINARY_SIZE+EncKeyLen);
+				MD5_Final( (unsigned char *) crypt_key, &ctx);
+		} while (--Lcount);
+
+#endif
+}
+
+static void * phpassmd5_binary(char *ciphertext)
+{
+		int i;
+		unsigned sixbits;
+		static unsigned char b[16];
+		int bidx=0;
+		char *pos;
+
+		// ugly code, but only called one time (at program load,
+		// once for each candidate pass hash).
+
+		pos = &ciphertext[3+1+8];
+		for (i = 0; i < 5; ++i)
+		{
+				sixbits = atoi64[ARCH_INDEX(*pos++)];
+				b[bidx] = sixbits;
+				sixbits = atoi64[ARCH_INDEX(*pos++)];
+				b[bidx++] |= (sixbits<<6);
+				sixbits >>= 2;
+				b[bidx] = sixbits;
+				sixbits = atoi64[ARCH_INDEX(*pos++)];
+				b[bidx++] |= (sixbits<<4);
+				sixbits >>= 4;
+				b[bidx] = sixbits;
+				sixbits = atoi64[ARCH_INDEX(*pos++)];
+				b[bidx++] |= (sixbits<<2);
+		}
+		sixbits = atoi64[ARCH_INDEX(*pos++)];
+		b[bidx] = sixbits;
+		sixbits = atoi64[ARCH_INDEX(*pos++)];
+		b[bidx] |= (sixbits<<6);
+		return b;
+}
+
+static void * phpassmd5_salt(char *ciphertext)
+{
+		static unsigned char salt[SALT_SIZE+2];
+		// store off the 'real' 8 bytes of salt
+		memcpy(salt, &ciphertext[4], 8);
+		// append the 1 byte of loop count information.
+		salt[8] = ciphertext[3];
+		salt[9]=0;
+		return salt;
+}
+
+static int phpassmd5_binary_hash_0(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xf; }
+static int phpassmd5_binary_hash_1(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xff; }
+static int phpassmd5_binary_hash_2(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfff; }
+static int phpassmd5_binary_hash_3(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xffff; }
+static int phpassmd5_binary_hash_4(void * binary) { return ((ARCH_WORD_32 *)binary)[0] & 0xfffff; }
+
+/* Note, even though in non MMX/SSE code, there is only 1 crypt_key, using   */
+/* the typecast and dereference of element [index] works fine, since indes   */
+/* will always be 0 (the program knows only 1 element at most is used. Thus  */
+/* the same 'simple' function(s) work for SSE and non-SSE get_hash_x() funcs */
+static int phpassmd5_get_hash_0(int index) { return ((ARCH_WORD_32 *)crypt_key)[index] & 0xf; }
+static int phpassmd5_get_hash_1(int index) { return ((ARCH_WORD_32 *)crypt_key)[index] & 0xff; }
+static int phpassmd5_get_hash_2(int index) { return ((ARCH_WORD_32 *)crypt_key)[index] & 0xfff; }
+static int phpassmd5_get_hash_3(int index) { return ((ARCH_WORD_32 *)crypt_key)[index] & 0xffff; }
+static int phpassmd5_get_hash_4(int index) { return ((ARCH_WORD_32 *)crypt_key)[index] & 0xfffff; }
+
+static int phpassmd5_salt_hash(void *salt)
+{
+	return *((ARCH_WORD *)salt) & 0x3FF;
+}
+
+struct fmt_main fmt_phpassmd5 = {
+		{
+				FORMAT_LABEL,
+				FORMAT_NAME,
+				ALGORITHM_NAME,
+				BENCHMARK_COMMENT,
+				BENCHMARK_LENGTH,
+				PLAINTEXT_LENGTH,
+				BINARY_SIZE,
+				// only true salt of SALT_SIZE (8), but we store on 'extra' byte
+				// as a salt, since we need it AND it does act as a different salt
+				// byte.  However, when we use the salt in our crypting, we only
+				// use the SALT_SIZE bytes.
+				SALT_SIZE+1,
+				MIN_KEYS_PER_CRYPT,
+				MAX_KEYS_PER_CRYPT,
+				FMT_CASE | FMT_8_BIT,
+				phpassmd5_tests
+		}, {
+				phpassmd5_init,
+				fmt_default_prepare,
+				valid,
+				fmt_default_split,
+				phpassmd5_binary,
+				phpassmd5_salt,
+				{
+					phpassmd5_binary_hash_0,
+					phpassmd5_binary_hash_1,
+					phpassmd5_binary_hash_2,
+					phpassmd5_binary_hash_3,
+					phpassmd5_binary_hash_4
+				},
+				phpassmd5_salt_hash,
+				phpassmd5_set_salt,
+				phpassmd5_set_key,
+				phpassmd5_get_key,
+				fmt_default_clear_keys,
+				phpassmd5_crypt_all,
+				{
+					phpassmd5_get_hash_0,
+					phpassmd5_get_hash_1,
+					phpassmd5_get_hash_2,
+					phpassmd5_get_hash_3,
+					phpassmd5_get_hash_4
+				},
+				phpassmd5_cmp_all,
+				phpassmd5_cmp_one,
+				phpassmd5_cmp_exact
+		}
+};
diff -rupN john-1.7.8/src/unused/rardump john-1.7.8-jumbo-2/src/unused/rardump
--- john-1.7.8/src/unused/rardump	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/rardump	2011-06-07 21:58:23.000000000 +0200
@@ -0,0 +1 @@
+p0.rar:$rar3$*1*2367145ebcf1e5df*6367b6f5*32*9*p0.rar*70
diff -rupN john-1.7.8/src/unused/rarinfo.c john-1.7.8-jumbo-2/src/unused/rarinfo.c
--- john-1.7.8/src/unused/rarinfo.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/rarinfo.c	2011-06-08 02:40:43.000000000 +0200
@@ -0,0 +1,168 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <limits.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+ 
+#include "misc.h"
+#include "common.h"
+#include "arch.h"
+#include "params.h"
+#include "crc32.h"
+ 
+static void process_file(const char *filename)
+{
+	FILE *fp;
+	unsigned char marker_block[7];
+	unsigned char archive_header_block[13];
+	unsigned char file_header_block[40];
+	int i, count, type;
+
+	if (!(fp = fopen(filename, "rb"))) {
+		fprintf(stderr, "! %s : %s\n", filename, strerror(errno));
+		return;
+	}
+	/* marker block */
+	memset(marker_block, 0, 7);
+	count = fread(marker_block, 1, 7, fp);
+	if (memcmp(marker_block, "\x52\x61\x72\x21\x1a\x07\x00", 7)) {
+		fprintf(stderr, "! %s : Not a RAR file\n", filename);
+		fclose(fp);
+		return;
+	}
+	/* archive header block */
+	count = fread(archive_header_block, 1, 13, fp);
+	assert(count == 13);
+	assert(archive_header_block[2] == 0x73);
+	/* find encryption mode used (called type in output line format) */
+	uint16_t archive_header_head_flags =
+	    archive_header_block[4] << 8 | archive_header_block[3];
+	if (archive_header_head_flags & 0x0080) {	/* file header block is encrypted */
+		type = 0;	/* RAR file was created using -hp flag */
+	} else
+		type = 1;
+	/* file header block */
+	count = fread(file_header_block, 1, 32, fp);
+	assert(count == 32);
+	if (type == 1)
+		assert(file_header_block[2] == 0x74);
+	uint16_t file_header_head_flags =
+	    file_header_block[4] << 8 | file_header_block[3];
+	/* if type = 1, check if encryption is being used? */
+	int is_encrypted;
+	if (type == 1 && !(file_header_head_flags & 0x04)) {
+		fprintf(stderr, "! %s : RAR file is not encrypted\n",
+		    filename);
+		is_encrypted = 0;
+
+	}
+
+	/* process -hp mode files */
+	if (type == 0) {	/* use Marc's end-of-archive block decrypt trick */
+		printf("%s:$rar3$*%d*", filename, type);
+		fseek(fp, -24, SEEK_END);
+		unsigned char buf[24];
+		count = fread(buf, 1, 24, fp);
+		for (i = 0; i < 8; i++) {
+			printf("%c%c", itoa16[ARCH_INDEX(buf[i] >> 4)],
+			    itoa16[ARCH_INDEX(buf[i] & 0x0f)]);
+		}
+		printf("*");
+		for (i = 8; i < 24; i++) {
+			printf("%c%c", itoa16[ARCH_INDEX(buf[i] >> 4)],
+			    itoa16[ARCH_INDEX(buf[i] & 0x0f)]);
+		}
+		printf("\n");
+	} else {    /* TODO: process -p mode files */
+		if (!(file_header_head_flags & 0x8000)) {
+			fprintf(stderr, "bailing out ...\n");
+		}
+		uint16_t file_header_head_size =
+		    file_header_block[6] << 8 | file_header_block[5];
+		int file_header_pack_size;
+		memcpy(&file_header_pack_size, file_header_block + 7, 4);
+		int file_header_unp_size;
+		memcpy(&file_header_unp_size, file_header_block + 11, 4);
+		fprintf(stderr, "HEAD_SIZE : %d, PACK_SIZE : %d, UNP_SIZE : %d\n",
+		    file_header_head_size, file_header_pack_size,
+		    file_header_unp_size);
+
+		/* calculate EXT_TIME size */
+		int EXT_TIME_SIZE = file_header_head_size - 32;
+
+		unsigned char rejbuf[32];
+		if (file_header_head_flags & 0x100) {
+			fprintf(stderr, "! HIGH_PACK_SIZE present\n");
+			fread(rejbuf, 1, 4, fp);
+			EXT_TIME_SIZE -= 4;
+		}
+		if (file_header_head_flags & 0x100) {
+			fprintf(stderr, "! HIGH_UNP_SIZE present\n");
+			fread(rejbuf, 1, 4, fp);
+			EXT_TIME_SIZE -= 4;
+		}
+		/* file name processing */
+		uint16_t file_name_size =
+		    file_header_block[27] << 8 | file_header_block[26];
+		fprintf(stderr, "file name size : %d bytes\n", file_name_size);
+		unsigned char file_name[128];
+		fread(file_name, 1, file_name_size, fp);
+		file_name[file_name_size] = 0;
+		fprintf(stderr, "file name : %s\n", file_name);
+		EXT_TIME_SIZE -= file_name_size;
+		/* SALT processing */
+		unsigned char SALT[8];
+		if (file_header_head_flags & 0x400) {
+			EXT_TIME_SIZE -= 8;
+			fread(SALT, 1, 8, fp);
+		}
+		/* EXT_TIME processing */
+		if (file_header_head_flags & 0x1000) {
+			fprintf(stderr, "! EXT_TIME present with size %d\n",
+			    EXT_TIME_SIZE);
+			fread(rejbuf, 1, EXT_TIME_SIZE, fp);
+		}
+		/* process encrypted data of size "file_header_pack_size" */
+		if (file_header_head_flags & 0x400) {
+    		printf("%s:$rar3$*%d*", filename, type);
+	    	for (i = 0; i < 8; i++) { /* encode SALT */
+		    	printf("%c%c", itoa16[ARCH_INDEX(SALT[i] >> 4)],
+			        itoa16[ARCH_INDEX(SALT[i] & 0x0f)]);
+    		}
+        }
+		printf("*");
+		unsigned char FILE_CRC[4];
+		memcpy(FILE_CRC, file_header_block + 16, 4);
+		for (i = 0; i < 4; i++) { /* encode FILE_CRC */
+			printf("%c%c", itoa16[ARCH_INDEX(FILE_CRC[i] >> 4)],
+			    itoa16[ARCH_INDEX(FILE_CRC[i] & 0x0f)]);
+		}
+		/* fp is at compressed plaintext or ciphertext location */
+		long pos = ftell(fp); 
+		printf("*%d*%d*%s*%ld\n",file_header_pack_size, file_header_unp_size, filename, pos);
+		printf("dumping data at %ld\n", pos);
+		fread(rejbuf, 1, 16, fp);
+		for (i = 0; i < 16; i++) {
+			printf("%x ", rejbuf[i]);
+		}
+		printf("\n");
+ 
+	}
+	fclose(fp);
+}
+
+int main(int argc, char **argv)
+{
+	int i;
+
+	if (argc < 2) {
+		printf("Usage: %s [rar files]", argv[0]);
+		return 0;
+	}
+	for (i = 1; i < argc; i++)
+		process_file(argv[i]);
+
+	return 0;
+}
diff -rupN john-1.7.8/src/unused/rsa_test.key john-1.7.8-jumbo-2/src/unused/rsa_test.key
--- john-1.7.8/src/unused/rsa_test.key	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/rsa_test.key	2011-06-02 23:31:42.000000000 +0200
@@ -0,0 +1,30 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: AES-128-CBC,BBF774D1DEFFA4F438F316AAF1FF35F6
+
+XlPI1ipEFWSZt2TZ2yMNw6+YPxDKiJPUYcrilqmMP00P8p6FfIkgGTDZplB9M3JY
+rYZjccfMC2aL2ifnA+4hy+sTITeOj7DG1wX9OHeqXzF7SrJMpf+UyAUcwgMn5Zwh
+9CzH15Jmp500riCQIwWvkDsKdZh0ZBRiPltO0UOZMtBauAaaFsDa1X9B7xEctZYB
+n2u6aeDWADdzhTkQwPGwTEqfPO0bugoS4Ov1HPrLHskRnvSJVHbyDSt0v/n1QEaS
+xciYnIQOEKvjEoAz+xBzxIS9alLRbMqiOeljRo0rwHTdhkrPk8wuv3yR2QINQQtM
+qSiZH2r6G072mDa/TKzKMm78pwj9VTuQK7dl8JzgMXIVZvg2/9bCDI5usR40Gml+
+EGUy11pb/EOWh+UJFzcXad+8nHSky3aqdiWpaX1f+UhIMYSXgkd+uwlvoeFfDCmi
+sL6GC3enH9J9RAbn61xH+e5R0synIpkEhPLLJY/bmy70nKKydMzyHgixdvNakPU1
+xgL9lZ6+pe7TucMIyAFIpUgw+Vkq0Hu7s0ak/u6u2+g63zo0EN5Bhc0XdM2jwcXj
+SMj9OSrnn8FMviuzP8s5E+KR/4mvEIWRCopbQGdn16vHP/1XtwVcwf/i767FCYVm
+cNL+33S9sTR3qgo+pL6+9eSQc1QB0L+dkjpJHwgPcXsq1kwY86kzFVLqAjTUzMFh
+dUw7eUYPMT09nolA1fAgED+4FLaDjvqETi3gyUafBmCxZD1AoRT+QzOa3mDeKfX6
+1f9sVyjEhQAwOAcvU5u9LETIrSNIIWSLo8wUbvovQk0RxuLjhJRYuTDsjWxccFqL
+baBO/4KGS2n2GkPVBuoDHY2bs5EZShhP/kZDPWwjkBp9iJ9S6Y0g7kMF7Q/92fHV
+fJLN5zI/AQww3jB00GZKBJ25s5iO9biGTAwLYWMfvwYfuo9dUGix4G6AfZa8HLlg
+ttiPl5yWyIoLzqRU8eJhdNPIhaPQx/FQkVFm/zju5ODAXGrorzlvx+tgyL4b+l/T
+/vD/O3Kl7Brn6AuYfChbc20RLRLato0e8OFD8H+MkmrWkl/NYzF1u/m3V/5BqDJz
+OV8tOib1IEKRZZdxESKOAUQYK5MjrjQwQ4hpLlYSfd2uEX+pWAvXUk6oYoM1pTPF
+BSGL/hlrtLeedWhN6toLcY/hQDqGLcXC8NwHs6VOc5WKUqjpRMgbmSodIhmxqwP4
+rlzsMwkyCYbEX4oXGpNCtQnLLP4bxRiYe5hQC+GZ3xlciSk5hvOLducInwomNxr+
+EQBJBT/8va8de5lyoL2bh6lF7E1mEYaqks8VAH8aGnpm28cOBhv/vtBddkw3WJvE
+SF4OREOGkPq43jUtEe6A1rHfKep4vl0m051a53ixGVB1/qOlKk5mSLK2CCJ3I3I8
+N3BaHPWE3eBlVcRn0O3yppfsLctiMUy02oXg+iFOSvrkD7MkgchDAQH0U9rLtxmu
+wuqfAHWHEPXAkNT2YPtapRv4/qGGQ/zyH1sS6TAd1loHzbUer0VvM4ySozKFZtml
+7UYObt4eZFx7JU/2U1TM4YEtdGDMRSZ3jzS3TpQnhDog4wT3LF+zVzFI6KKy/iKF
+-----END RSA PRIVATE KEY-----
diff -rupN john-1.7.8/src/unused/sshdump john-1.7.8-jumbo-2/src/unused/sshdump
--- john-1.7.8/src/unused/sshdump	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/sshdump	2011-06-02 23:31:42.000000000 +0200
@@ -0,0 +1,2 @@
+dsa_test.key:$ssh2$2d2d2d2d2d424547494e204453412050524956415445204b45592d2d2d2d2d0a50726f632d547970653a20342c454e435259505445440a44454b2d496e666f3a204145532d3132382d4342432c35413830363832373943304634364539383230373135304133433245433631340a0a2f756954696e4a3452556a6f5a76302b705931694d763163695661724369347a2f62365a694c4161565970794a31685854327463692b593266334c61614578630a6f357772316141464d3437786d526d476f3832492f76434847413952786735776147433970574f475a5675555172447355367463556b434d422b325a344753390a354f44474364444b32674e6574446e62324a764873714154736d3443633633476468695a30734346594c71796d2b576531774359616c78734f3231572b4f676f0a42336f6746464977327232462b714a7a714d37415543794c466869357a476d7536534e6558765534477a784750464a4e47306d414f55497761614e3161446a630a4e326b3462437266796271337a366e436533444273384b3232694e2b3875526e534162434f717a5a5845645971555959354b6b6a326e654354525458494e64670a512b61535359673379355937626f4b6b6a494f727650555748654f796475512b74657273414577376e43564a7a72394e387452673271563450557631434b66700a4f49467742372f39736f6d6a59496a71576f61537a6a784b30633852777a305331706d722b7571726277792b50656f75354d3373656d486c426b4769553237660a776f684b792b4d554e4862734e6a7973535a53456c4e4b734d4950715449567a5a45316d5646412f30754d477164705133627a424f6a58325a6f36656446434f0a6d4a34775961765735774d2b6a6d75564b5056564e7939395a78796570304645644c50354b623263345a6c3053396631342f62366836415069785665377a75760a5662536b4279664a6e797a68494f5942497954374d64773134723441584a56362b5a6f457730397769774d3d0a2d2d2d2d2d454e44204453412050524956415445204b45592d2d2d2d2d0a*771
+rsa_test.key:$ssh2$2d2d2d2d2d424547494e205253412050524956415445204b45592d2d2d2d2d0a50726f632d547970653a20342c454e435259505445440a44454b2d496e666f3a204145532d3132382d4342432c42424637373444314445464641344634333846333136414146314646333546360a0a586c5049316970454657535a7432545a32794d4e77362b595078444b694a5055596372696c716d4d503030503870364666496b674754445a706c42394d334a590a72595a6a6363664d4332614c3269666e412b3468792b73544954654f6a374447317758394f486571587a463753724a4d70662b557941556377674d6e355a77680a39437a4831354a6d7035303072694351497757766b44734b645a68305a425269506c744f30554f5a4d74426175416161467344613158394237784563745a59420a6e327536616544574144647a68546b517750477754457166504f306275676f53344f76314850724c48736b526e76534a5648627944537430762f6e31514561530a786369596e49514f454b766a456f417a2b78427a78495339616c4c52624d71694f656c6a526f307277485464686b72506b387775763379523251494e5151744d0a7153695a48327236473037326d44612f544b7a4b4d6d373870776a39565475514b37646c384a7a674d5849565a7667322f3962434449357573523430476d6c2b0a45475579313170622f454f57682b554a467a635861642b386e48536b7933617164695770615831662b5568494d595358676b642b75776c766f65466644436d690a734c36474333656e48394a395241626e363178482b6535523073796e49706b4568504c4c4a592f626d7937306e4b4b79644d7a794867697864764e616b5055310a78674c396c5a362b7065375475634d4979414649705567772b566b71304875377330616b2f753675322b6736337a6f30454e354268633058644d326a7763586a0a534d6a394f53726e6e38464d7669757a50387335452b4b522f346d7645495752436f70625147646e31367648502f31587477566377662f69373637464359566d0a634e4c2b333353397354523371676f2b704c362b3965535163315142304c2b646b6a704a4877675063587371316b775938366b7a46564c71416a54557a4d46680a64557737655559504d5430396e6f6c413166416745442b34464c61446a7671455469336779556166426d43785a4431416f52542b517a4f61336d44654b6658360a3166397356796a45685141774f416376553575394c45544972534e494957534c6f38775562766f76516b305278754c6a684a5259755444736a5778636346714c0a6261424f2f344b4753326e32476b505642756f44485932627335455a536868502f6b5a445057776a6b427039694a395336593067376b4d4637512f39326648560a664a4c4e357a492f41517777336a423030475a4b424a32357335694f396269475441774c59574d6676775966756f39645547697834473641665a6138484c6c670a747469506c35795779496f4c7a71525538654a68644e504968615051782f46516b56466d2f7a6a75354f44415847726f727a6c76782b7467794c34622b6c2f540a2f76442f4f334b6c3742726e3641755966436862633230524c524c61746f3065384f464438482b4d6b6d72576b6c2f4e597a4631752f6d33562f354271444a7a0a4f5638744f69623149454b525a5a647845534b4f415551594b354d6a726a5177513468704c6c59536664327545582b7057417658556b366f596f4d31705450460a4253474c2f686c72744c65656457684e36746f4c63592f68514471474c635843384e77487336564f6335574b55716a70524d67626d536f6449686d78717750340a726c7a734d776b794359624558346f5847704e4374516e4c4c5034627852695965356851432b475a33786c6369536b3568764f4c647563496e776f6d4e78722b0a4551424a42542f387661386465356c796f4c326268366c463745316d455961716b73385641483861476e706d3238634f4268762f76744264646b7733574a76450a5346344f52454f476b507134336a557445653641317248664b657034766c306d3035316135336978475642312f714f6c4b6b356d534c4b3243434a33493349380a4e334261485057453365426c5663526e304f3379707066734c6374694d557930326f58672b69464f5376726b44374d6b67636844415148305539724c74786d750a7775716641485748455058416b4e543259507461705276342f714747512f7a794831735336544164316c6f487a625565723056764d3479536f7a4b465a746d6c0a3755594f627434655a4678374a552f325531544d345945746447444d52535a336a7a53335470516e68446f67347754334c462b7a567a4649364b4b792f694b460a2d2d2d2d2d454e44205253412050524956415445204b45592d2d2d2d2d0a*1766
diff -rupN john-1.7.8/src/unused/x86-64.orig.S john-1.7.8-jumbo-2/src/unused/x86-64.orig.S
--- john-1.7.8/src/unused/x86-64.orig.S	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/x86-64.orig.S	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,1317 @@
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 2000-2001,2005,2006,2008 by Solar Designer and others:
+ *
+ * The optimized S-box expressions are based on work by Matthew Kwan (see
+ * nonstd.c and sboxes.c).  S1-S5 and S7 are based on nonstd.c, whereas S6
+ * and S8 are based on sboxes.c.
+ *
+ * ...with changes in the jumbo patch, by Alain Espinosa (starting with a
+ * comment further down this file).
+ */
+
+#include "arch.h"
+
+#ifdef ALIGN_LOG
+#define DO_ALIGN(log)			.align log
+#else
+#define DO_ALIGN(log)			.align 1 << log
+#endif
+
+#if DES_BS_ASM
+
+#ifdef UNDERSCORES
+#define DES_bs_all			_DES_bs_all
+#define DES_bs_init_asm			_DES_bs_init_asm
+#define DES_bs_crypt			_DES_bs_crypt
+#define DES_bs_crypt_25			_DES_bs_crypt_25
+#define DES_bs_crypt_LM			_DES_bs_crypt_LM
+#endif
+
+#ifdef __sun
+/* Sun's assembler doesn't recognize .space */
+#define DO_SPACE(size)			.zero size
+#else
+/* Mac OS X assembler doesn't recognize .zero */
+#define DO_SPACE(size)			.space size
+#endif
+
+/* Sun's assembler can't multiply, but at least it can add... */
+#define nptr(n)				n+n+n+n+n+n+n+n
+#define nvec(n)				n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n
+
+#ifdef BSD
+.data
+#else
+.bss
+#endif
+
+.globl DES_bs_all
+DO_ALIGN(6)
+DES_bs_all:
+DES_bs_all_KSp:
+DO_SPACE(nptr(0x300))
+DES_bs_all_KS_p:
+DES_bs_all_KS_v:
+DO_SPACE(nvec(0x300))
+DES_bs_all_E:
+DO_SPACE(nptr(96))
+DES_bs_all_K:
+DO_SPACE(nvec(56))
+DES_bs_all_B:
+DO_SPACE(nvec(64))
+DES_bs_all_tmp:
+DO_SPACE(nvec(16))
+DES_bs_all_fields_not_used_here:
+DO_SPACE(0x400 + 0x100 + 4 + 4 + 0x400)
+DES_bs_all_possible_alignment_gaps:
+DO_SPACE(0x100)
+
+#define E(i)				DES_bs_all_E+nptr(i)(%rip)
+#define B(i)				DES_bs_all_B+nvec(i)(%rip)
+#define tmp_at(i)			DES_bs_all_tmp+nvec(i)(%rip)
+
+#define pnot				tmp_at(0)
+
+#define a1				%xmm0
+#define a2				%xmm1
+#define a3				%xmm2
+#define a4				%xmm3
+#define a5				%xmm4
+#define a6				%xmm5
+
+#define S1(out1, out2, out3, out4) \
+	movdqa %xmm3,%xmm11; \
+	movdqa %xmm3,%xmm6; \
+	movdqa %xmm0,tmp_at(1); \
+	movdqa %xmm4,tmp_at(2); \
+	movdqa %xmm4,%xmm7; \
+	movdqa %xmm4,%xmm14; \
+	movdqa %xmm3,%xmm9; \
+	pandn %xmm2,%xmm11; \
+	pxor %xmm2,%xmm9; \
+	pandn %xmm2,%xmm4; \
+	movdqa %xmm9,%xmm12; \
+	pxor %xmm4,%xmm6; \
+	por %xmm11,%xmm14; \
+	movdqa %xmm14,%xmm10; \
+	pandn %xmm3,%xmm7; \
+	pandn %xmm5,%xmm12; \
+	movdqa %xmm12,%xmm0; \
+	pandn tmp_at(2),%xmm3; \
+	pand %xmm5,%xmm10; \
+	movdqa %xmm10,%xmm15; \
+	movdqa %xmm10,%xmm13; \
+	por %xmm10,%xmm4; \
+	pxor %xmm7,%xmm0; \
+	por %xmm1,%xmm0; \
+	pxor %xmm6,%xmm15; \
+	pxor %xmm15,%xmm0; \
+	pxor tmp_at(2),%xmm13; \
+	pand %xmm9,%xmm13; \
+	movdqa %xmm13,%xmm8; \
+	por %xmm15,%xmm7; \
+	pxor %xmm9,%xmm4; \
+	movdqa %xmm4,%xmm15; \
+	pxor %xmm11,%xmm8; \
+	por %xmm5,%xmm8; \
+	pxor %xmm3,%xmm8; \
+	movdqa %xmm8,%xmm3; \
+	pandn %xmm8,%xmm6; \
+	movdqa %xmm6,%xmm5; \
+	pxor %xmm7,%xmm6; \
+	pxor %xmm12,%xmm15; \
+	por %xmm1,%xmm3; \
+	pxor %xmm13,%xmm3; \
+	pand tmp_at(1),%xmm3; \
+	pxor %xmm0,%xmm3; \
+	pxor out2,%xmm3; \
+	pxor pnot,%xmm3; \
+	movdqa %xmm11,%xmm0; \
+	por %xmm1,%xmm0; \
+	pandn %xmm1,%xmm5; \
+	pxor %xmm4,%xmm5; \
+	pandn %xmm8,%xmm15; \
+	movdqa %xmm15,%xmm9; \
+	pand %xmm2,%xmm7; \
+	movdqa %xmm3,out2; \
+	por %xmm2,%xmm15; \
+	movdqa %xmm1,%xmm2; \
+	pand %xmm1,%xmm9; \
+	pxor %xmm9,%xmm6; \
+	movdqa %xmm6,%xmm9; \
+	pandn %xmm6,%xmm12; \
+	pand tmp_at(1),%xmm9; \
+	pxor %xmm5,%xmm9; \
+	movdqa %xmm7,%xmm5; \
+	pxor out4,%xmm9; \
+	movdqa %xmm9,out4; \
+	pxor %xmm14,%xmm7; \
+	pandn %xmm7,%xmm10; \
+	pandn %xmm8,%xmm5; \
+	pxor %xmm5,%xmm0; \
+	pandn %xmm4,%xmm5; \
+	por %xmm11,%xmm5; \
+	pandn %xmm5,%xmm2; \
+	pxor %xmm2,%xmm15; \
+	pandn tmp_at(1),%xmm15; \
+	pxor %xmm0,%xmm15; \
+	pxor pnot,%xmm15; \
+	pxor out1,%xmm15; \
+	movdqa %xmm15,out1; \
+	pxor %xmm12,%xmm0; \
+	por %xmm8,%xmm5; \
+	pxor tmp_at(2),%xmm5; \
+	pandn %xmm1,%xmm5; \
+	pxor %xmm10,%xmm5; \
+	por tmp_at(1),%xmm5; \
+	pxor %xmm0,%xmm5; \
+	pxor pnot,%xmm5; \
+	pxor out3,%xmm5; \
+	movdqa %xmm5,out3
+
+#define S2(out1, out2, out3, out4) \
+	movdqa %xmm3,tmp_at(1); \
+	movdqa %xmm5,%xmm7; \
+	movdqa %xmm4,%xmm9; \
+	movdqa %xmm4,%xmm10; \
+	movdqa %xmm1,%xmm11; \
+	movdqa %xmm1,%xmm12; \
+	pxor %xmm0,%xmm7; \
+	pxor %xmm7,%xmm9; \
+	pand %xmm5,%xmm10; \
+	movdqa %xmm10,%xmm8; \
+	pandn %xmm0,%xmm8; \
+	movdqa %xmm8,%xmm14; \
+	movdqa %xmm8,%xmm6; \
+	pandn %xmm1,%xmm14; \
+	movdqa %xmm14,%xmm15; \
+	por %xmm10,%xmm14; \
+	pandn %xmm14,%xmm7; \
+	movdqa %xmm7,%xmm14; \
+	pandn %xmm4,%xmm6; \
+	pxor %xmm1,%xmm4; \
+	pxor %xmm9,%xmm15; \
+	por %xmm6,%xmm11; \
+	por %xmm2,%xmm14; \
+	movdqa %xmm11,%xmm3; \
+	pxor %xmm15,%xmm14; \
+	pxor %xmm15,%xmm6; \
+	pand %xmm1,%xmm6; \
+	pandn %xmm4,%xmm7; \
+	pand tmp_at(1),%xmm3; \
+	pxor %xmm14,%xmm3; \
+	pxor pnot,%xmm3; \
+	movdqa %xmm3,%xmm13; \
+	pxor %xmm8,%xmm3; \
+	pandn %xmm3,%xmm12; \
+	pxor %xmm9,%xmm12; \
+	pandn %xmm5,%xmm8; \
+	movdqa %xmm6,%xmm5; \
+	pxor out1,%xmm13; \
+	movdqa %xmm13,out1; \
+	por %xmm0,%xmm15; \
+	pxor %xmm1,%xmm15; \
+	pxor %xmm8,%xmm5; \
+	movdqa %xmm15,%xmm0; \
+	pand %xmm2,%xmm5; \
+	pxor %xmm12,%xmm5; \
+	por %xmm6,%xmm15; \
+	pxor %xmm1,%xmm9; \
+	pandn %xmm2,%xmm0; \
+	pxor %xmm7,%xmm0; \
+	movdqa %xmm0,%xmm3; \
+	por %xmm8,%xmm7; \
+	por tmp_at(1),%xmm3; \
+	por %xmm10,%xmm6; \
+	pand %xmm2,%xmm10; \
+	pxor %xmm7,%xmm14; \
+	pxor %xmm5,%xmm3; \
+	movdqa %xmm15,%xmm5; \
+	pxor out3,%xmm3; \
+	pand %xmm2,%xmm5; \
+	pand %xmm4,%xmm15; \
+	pandn %xmm11,%xmm15; \
+	movdqa %xmm3,out3; \
+	pxor %xmm14,%xmm5; \
+	por tmp_at(1),%xmm15; \
+	pxor %xmm5,%xmm15; \
+	pxor pnot,%xmm15; \
+	pxor out4,%xmm15; \
+	movdqa %xmm15,out4; \
+	pandn %xmm9,%xmm14; \
+	pxor %xmm0,%xmm14; \
+	pandn %xmm2,%xmm14; \
+	pxor %xmm9,%xmm14; \
+	pxor %xmm10,%xmm6; \
+	pandn tmp_at(1),%xmm6; \
+	pxor %xmm6,%xmm14; \
+	pxor pnot,%xmm14; \
+	pxor out2,%xmm14; \
+	movdqa %xmm14,out2
+
+#define S3(out1, out2, out3, out4) \
+	movdqa %xmm0,tmp_at(1); \
+	movdqa %xmm4,%xmm0; \
+	movdqa %xmm5,tmp_at(3); \
+	movdqa %xmm2,%xmm7; \
+	movdqa %xmm4,%xmm13; \
+	pxor %xmm5,%xmm7; \
+	movdqa %xmm3,tmp_at(2); \
+	movdqa %xmm5,%xmm11; \
+	pxor %xmm1,%xmm7; \
+	movdqa %xmm7,%xmm5; \
+	pand %xmm1,%xmm5; \
+	movdqa %xmm5,%xmm6; \
+	movdqa %xmm5,%xmm14; \
+	movdqa %xmm5,%xmm15; \
+	pand %xmm2,%xmm11; \
+	por %xmm11,%xmm5; \
+	pxor %xmm5,%xmm4; \
+	movdqa %xmm4,tmp_at(4); \
+	pxor %xmm5,%xmm4; \
+	por %xmm4,%xmm6; \
+	pxor %xmm2,%xmm14; \
+	movdqa %xmm6,%xmm12; \
+	pandn %xmm14,%xmm13; \
+	movdqa %xmm13,%xmm10; \
+	pandn tmp_at(3),%xmm15; \
+	movdqa %xmm13,%xmm9; \
+	pxor %xmm7,%xmm12; \
+	movdqa %xmm13,%xmm3; \
+	pxor %xmm15,%xmm0; \
+	movdqa %xmm0,%xmm8; \
+	por tmp_at(1),%xmm10; \
+	pxor %xmm12,%xmm10; \
+	pandn %xmm7,%xmm9; \
+	pxor %xmm9,%xmm11; \
+	por tmp_at(1),%xmm11; \
+	pand tmp_at(1),%xmm8; \
+	pxor %xmm4,%xmm8; \
+	pand %xmm2,%xmm4; \
+	por tmp_at(2),%xmm8; \
+	pxor %xmm10,%xmm8; \
+	movdqa %xmm8,%xmm10; \
+	pxor tmp_at(4),%xmm11; \
+	por %xmm1,%xmm3; \
+	pxor %xmm3,%xmm6; \
+	pxor %xmm4,%xmm7; \
+	por %xmm9,%xmm0; \
+	pxor out4,%xmm10; \
+	pxor %xmm5,%xmm0; \
+	movdqa %xmm0,tmp_at(5); \
+	movdqa %xmm10,out4; \
+	por tmp_at(1),%xmm0; \
+	pandn %xmm13,%xmm2; \
+	por tmp_at(1),%xmm2; \
+	pxor %xmm0,%xmm6; \
+	pxor %xmm2,%xmm7; \
+	movdqa tmp_at(5),%xmm0; \
+	pandn tmp_at(2),%xmm6; \
+	pxor %xmm11,%xmm6; \
+	pxor pnot,%xmm6; \
+	pxor out3,%xmm6; \
+	por %xmm15,%xmm0; \
+	movdqa %xmm6,out3; \
+	pxor tmp_at(3),%xmm5; \
+	pandn %xmm5,%xmm12; \
+	pand tmp_at(1),%xmm12; \
+	pxor %xmm12,%xmm0; \
+	pand tmp_at(2),%xmm0; \
+	pxor %xmm7,%xmm0; \
+	movdqa %xmm0,%xmm2; \
+	por %xmm1,%xmm9; \
+	movdqa tmp_at(1),%xmm1; \
+	pxor tmp_at(4),%xmm9; \
+	pand tmp_at(3),%xmm8; \
+	pxor out2,%xmm2; \
+	movdqa %xmm2,out2; \
+	pxor %xmm14,%xmm8; \
+	pandn %xmm8,%xmm1; \
+	pxor %xmm1,%xmm9; \
+	pandn %xmm0,%xmm3; \
+	por tmp_at(1),%xmm3; \
+	pxor %xmm1,%xmm3; \
+	pand tmp_at(2),%xmm3; \
+	pxor %xmm9,%xmm3; \
+	pxor pnot,%xmm3; \
+	pxor out1,%xmm3; \
+	movdqa %xmm3,out1
+
+#define S4(out1, out2, out3, out4) \
+	movdqa %xmm2,%xmm7; \
+	movdqa %xmm2,%xmm9; \
+	por %xmm0,%xmm7; \
+	pand %xmm4,%xmm7; \
+	movdqa %xmm7,%xmm6; \
+	pxor %xmm2,%xmm7; \
+	por %xmm1,%xmm9; \
+	pxor %xmm0,%xmm6; \
+	pandn %xmm2,%xmm0; \
+	por %xmm6,%xmm0; \
+	pxor %xmm6,%xmm9; \
+	movdqa %xmm0,%xmm10; \
+	pand %xmm1,%xmm10; \
+	movdqa %xmm10,%xmm11; \
+	pxor %xmm2,%xmm10; \
+	pxor %xmm4,%xmm11; \
+	pxor %xmm2,%xmm4; \
+	movdqa %xmm11,%xmm8; \
+	pand %xmm1,%xmm11; \
+	pand %xmm3,%xmm8; \
+	pxor %xmm8,%xmm9; \
+	movdqa %xmm7,%xmm8; \
+	por %xmm6,%xmm7; \
+	pandn %xmm1,%xmm8; \
+	movdqa %xmm9,%xmm12; \
+	pxor %xmm0,%xmm8; \
+	movdqa %xmm1,%xmm0; \
+	pandn %xmm4,%xmm0; \
+	movdqa %xmm0,%xmm4; \
+	pxor %xmm10,%xmm0; \
+	pxor out2,%xmm12; \
+	pxor %xmm7,%xmm4; \
+	por %xmm3,%xmm4; \
+	pxor %xmm8,%xmm4; \
+	movdqa %xmm4,%xmm6; \
+	pand %xmm5,%xmm4; \
+	pxor %xmm4,%xmm12; \
+	pxor pnot,%xmm12; \
+	pandn %xmm3,%xmm0; \
+	por %xmm5,%xmm6; \
+	movdqa %xmm12,out2; \
+	pxor %xmm9,%xmm6; \
+	movdqa %xmm6,%xmm8; \
+	pxor %xmm11,%xmm7; \
+	pxor %xmm7,%xmm0; \
+	pxor %xmm0,%xmm9; \
+	movdqa %xmm9,%xmm2; \
+	pandn %xmm9,%xmm3; \
+	pxor out1,%xmm8; \
+	movdqa %xmm8,out1; \
+	pandn %xmm1,%xmm2; \
+	pxor %xmm2,%xmm6; \
+	pxor %xmm3,%xmm6; \
+	por %xmm6,%xmm5; \
+	pxor %xmm5,%xmm0; \
+	pxor pnot,%xmm0; \
+	movdqa %xmm0,%xmm1; \
+	pxor %xmm4,%xmm6; \
+	pxor %xmm6,%xmm0; \
+	pxor out4,%xmm0; \
+	movdqa %xmm0,out4; \
+	pxor out3,%xmm1; \
+	movdqa %xmm1,out3
+
+#define S5(out1, out2, out3, out4) \
+	movdqa %xmm3,%xmm7; \
+	movdqa %xmm4,tmp_at(2); \
+	movdqa %xmm1,tmp_at(1); \
+	movdqa %xmm0,%xmm6; \
+	movdqa %xmm2,%xmm4; \
+	movdqa %xmm0,%xmm10; \
+	movdqa %xmm5,%xmm12; \
+	movdqa %xmm1,%xmm13; \
+	pandn %xmm2,%xmm7; \
+	movdqa %xmm1,%xmm15; \
+	pxor %xmm7,%xmm6; \
+	pandn %xmm0,%xmm4; \
+	pxor %xmm3,%xmm10; \
+	movdqa %xmm4,%xmm8; \
+	movdqa %xmm4,%xmm1; \
+	por %xmm10,%xmm7; \
+	pandn %xmm7,%xmm12; \
+	por %xmm5,%xmm8; \
+	movdqa %xmm12,tmp_at(3); \
+	movdqa %xmm12,%xmm14; \
+	movdqa %xmm7,%xmm12; \
+	movdqa %xmm8,%xmm9; \
+	pxor %xmm3,%xmm4; \
+	pand %xmm2,%xmm12; \
+	pxor %xmm3,%xmm12; \
+	pxor %xmm2,%xmm14; \
+	pxor %xmm6,%xmm9; \
+	movdqa %xmm14,%xmm11; \
+	pandn %xmm12,%xmm1; \
+	por %xmm5,%xmm4; \
+	pxor %xmm4,%xmm1; \
+	movdqa %xmm1,%xmm5; \
+	pand %xmm3,%xmm8; \
+	por tmp_at(2),%xmm11; \
+	pxor %xmm9,%xmm11; \
+	pxor %xmm1,%xmm8; \
+	por tmp_at(2),%xmm5; \
+	pxor %xmm12,%xmm5; \
+	pandn %xmm5,%xmm13; \
+	pxor %xmm13,%xmm11; \
+	movdqa %xmm11,%xmm13; \
+	pxor %xmm14,%xmm0; \
+	pand %xmm0,%xmm6; \
+	pandn tmp_at(2),%xmm6; \
+	pxor %xmm8,%xmm6; \
+	movdqa %xmm0,%xmm8; \
+	pxor out4,%xmm13; \
+	movdqa %xmm13,out4; \
+	pand %xmm9,%xmm1; \
+	movdqa %xmm1,%xmm9; \
+	por %xmm12,%xmm4; \
+	por %xmm3,%xmm8; \
+	pandn %xmm8,%xmm15; \
+	pxor %xmm6,%xmm15; \
+	pxor out2,%xmm15; \
+	pandn %xmm7,%xmm9; \
+	movdqa %xmm15,out2; \
+	pandn tmp_at(3),%xmm3; \
+	pxor %xmm2,%xmm3; \
+	movdqa %xmm3,%xmm2; \
+	pxor %xmm14,%xmm1; \
+	movdqa %xmm1,%xmm7; \
+	pand tmp_at(2),%xmm2; \
+	pxor %xmm9,%xmm2; \
+	pandn %xmm5,%xmm9; \
+	pxor %xmm9,%xmm0; \
+	por tmp_at(2),%xmm7; \
+	pxor %xmm7,%xmm4; \
+	por tmp_at(1),%xmm4; \
+	pxor %xmm2,%xmm4; \
+	pxor pnot,%xmm4; \
+	pxor out3,%xmm4; \
+	movdqa %xmm4,out3; \
+	por %xmm9,%xmm6; \
+	pxor %xmm10,%xmm6; \
+	pandn tmp_at(2),%xmm6; \
+	pxor %xmm0,%xmm6; \
+	pand %xmm1,%xmm10; \
+	pxor %xmm10,%xmm3; \
+	pxor %xmm11,%xmm1; \
+	pandn %xmm8,%xmm1; \
+	pand tmp_at(2),%xmm1; \
+	pxor %xmm3,%xmm1; \
+	por tmp_at(1),%xmm1; \
+	pxor %xmm6,%xmm1; \
+	pxor out1,%xmm1; \
+	movdqa %xmm1,out1
+
+#define S6(out1, out2, out3, out4) \
+	movdqa %xmm1,%xmm12; \
+	movdqa %xmm2,tmp_at(1); \
+	movdqa %xmm4,%xmm2; \
+	movdqa %xmm5,%xmm8; \
+	movdqa %xmm4,%xmm7; \
+	movdqa %xmm5,%xmm14; \
+	movdqa %xmm5,%xmm10; \
+	pxor pnot,%xmm12; \
+	pxor pnot,%xmm2; \
+	movdqa %xmm12,%xmm15; \
+	pxor %xmm1,%xmm8; \
+	pxor %xmm2,%xmm8; \
+	pxor %xmm0,%xmm8; \
+	pand %xmm4,%xmm10; \
+	movdqa %xmm8,%xmm13; \
+	pand %xmm4,%xmm13; \
+	pand %xmm1,%xmm14; \
+	pxor %xmm14,%xmm7; \
+	movdqa %xmm7,%xmm9; \
+	por %xmm10,%xmm15; \
+	movdqa %xmm13,%xmm6; \
+	pand %xmm0,%xmm9; \
+	pxor %xmm9,%xmm2; \
+	movdqa %xmm2,%xmm11; \
+	pxor %xmm5,%xmm2; \
+	pand %xmm0,%xmm6; \
+	pxor %xmm15,%xmm6; \
+	movdqa %xmm6,%xmm15; \
+	pxor %xmm5,%xmm6; \
+	pand %xmm0,%xmm6; \
+	por %xmm3,%xmm11; \
+	pxor %xmm11,%xmm6; \
+	pand %xmm3,%xmm15; \
+	pxor %xmm8,%xmm15; \
+	pand tmp_at(1),%xmm6; \
+	pxor out2,%xmm6; \
+	pxor %xmm15,%xmm6; \
+	movdqa %xmm6,out2; \
+	pand %xmm2,%xmm0; \
+	movdqa %xmm0,%xmm15; \
+	pxor %xmm1,%xmm9; \
+	movdqa %xmm10,%xmm1; \
+	pand %xmm4,%xmm2; \
+	por %xmm0,%xmm7; \
+	pxor %xmm4,%xmm15; \
+	movdqa %xmm8,%xmm4; \
+	por %xmm9,%xmm1; \
+	pxor %xmm12,%xmm7; \
+	pand %xmm3,%xmm1; \
+	pxor %xmm1,%xmm15; \
+	pxor pnot,%xmm9; \
+	por %xmm15,%xmm5; \
+	movdqa %xmm5,%xmm1; \
+	pxor %xmm2,%xmm4; \
+	por %xmm3,%xmm4; \
+	pxor %xmm14,%xmm0; \
+	pxor %xmm5,%xmm0; \
+	pxor pnot,%xmm1; \
+	pand %xmm3,%xmm1; \
+	pxor %xmm9,%xmm1; \
+	movdqa %xmm1,%xmm11; \
+	pxor %xmm10,%xmm1; \
+	pxor %xmm4,%xmm1; \
+	por %xmm3,%xmm0; \
+	pxor %xmm7,%xmm0; \
+	pand tmp_at(1),%xmm11; \
+	pxor %xmm11,%xmm15; \
+	pxor out4,%xmm15; \
+	movdqa %xmm15,out4; \
+	por tmp_at(1),%xmm0; \
+	pxor %xmm0,%xmm1; \
+	pxor out1,%xmm1; \
+	movdqa %xmm1,out1; \
+	por %xmm8,%xmm2; \
+	pxor %xmm10,%xmm2; \
+	pand %xmm13,%xmm5; \
+	por %xmm3,%xmm5; \
+	pxor %xmm5,%xmm2; \
+	pand %xmm9,%xmm7; \
+	por tmp_at(1),%xmm7; \
+	pxor %xmm7,%xmm2; \
+	pxor out3,%xmm2; \
+	movdqa %xmm2,out3
+
+#define S7(out1, out2, out3, out4) \
+	movdqa %xmm3,%xmm14; \
+	movdqa %xmm1,%xmm8; \
+	movdqa %xmm3,%xmm11; \
+	movdqa %xmm1,%xmm7; \
+	movdqa %xmm2,%xmm10; \
+	pand %xmm1,%xmm14; \
+	pxor %xmm4,%xmm14; \
+	movdqa %xmm14,%xmm12; \
+	por %xmm1,%xmm11; \
+	por %xmm4,%xmm11; \
+	pandn %xmm4,%xmm7; \
+	por %xmm2,%xmm7; \
+	pand %xmm3,%xmm12; \
+	pxor %xmm12,%xmm8; \
+	movdqa %xmm8,%xmm13; \
+	pxor %xmm11,%xmm7; \
+	pandn %xmm3,%xmm10; \
+	movdqa %xmm10,%xmm9; \
+	pxor %xmm3,%xmm8; \
+	movdqa %xmm12,%xmm3; \
+	pandn %xmm2,%xmm13; \
+	pxor %xmm13,%xmm14; \
+	pxor %xmm2,%xmm13; \
+	movdqa %xmm13,%xmm6; \
+	pandn %xmm1,%xmm9; \
+	por %xmm2,%xmm3; \
+	pand %xmm5,%xmm9; \
+	pxor %xmm8,%xmm3; \
+	pandn %xmm5,%xmm6; \
+	pxor %xmm14,%xmm6; \
+	pxor %xmm12,%xmm14; \
+	movdqa %xmm14,%xmm11; \
+	pxor %xmm2,%xmm12; \
+	pand %xmm1,%xmm12; \
+	pandn %xmm5,%xmm12; \
+	pxor %xmm3,%xmm12; \
+	por %xmm5,%xmm11; \
+	movdqa %xmm12,%xmm15; \
+	pxor %xmm7,%xmm11; \
+	pand %xmm0,%xmm11; \
+	pxor %xmm6,%xmm11; \
+	movdqa %xmm11,%xmm7; \
+	pxor %xmm9,%xmm6; \
+	por %xmm0,%xmm15; \
+	pxor %xmm15,%xmm6; \
+	movdqa %xmm8,%xmm15; \
+	pxor pnot,%xmm6; \
+	pxor out1,%xmm7; \
+	movdqa %xmm7,out1; \
+	pxor out2,%xmm6; \
+	movdqa %xmm6,out2; \
+	pxor %xmm12,%xmm13; \
+	por %xmm1,%xmm15; \
+	pxor %xmm15,%xmm11; \
+	movdqa %xmm5,%xmm15; \
+	por %xmm4,%xmm10; \
+	pxor %xmm1,%xmm14; \
+	pandn %xmm8,%xmm14; \
+	pand %xmm5,%xmm14; \
+	pandn %xmm11,%xmm15; \
+	movdqa %xmm2,%xmm11; \
+	pxor %xmm13,%xmm15; \
+	pxor %xmm10,%xmm13; \
+	pxor %xmm14,%xmm13; \
+	pand %xmm2,%xmm9; \
+	pandn %xmm3,%xmm11; \
+	movdqa %xmm0,%xmm3; \
+	por %xmm12,%xmm11; \
+	pxor %xmm9,%xmm14; \
+	por %xmm0,%xmm14; \
+	pxor %xmm13,%xmm14; \
+	pandn %xmm11,%xmm3; \
+	pxor %xmm3,%xmm15; \
+	pxor out3,%xmm15; \
+	movdqa %xmm15,out3; \
+	pxor out4,%xmm14; \
+	movdqa %xmm14,out4
+
+#define S8(out1, out2, out3, out4) \
+	movdqa %xmm3,tmp_at(1); \
+	movdqa %xmm5,tmp_at(2); \
+	movdqa %xmm0,%xmm15; \
+	pxor pnot,%xmm15; \
+	movdqa %xmm3,%xmm13; \
+	pxor pnot,%xmm13; \
+	movdqa %xmm15,%xmm3; \
+	movdqa %xmm15,%xmm7; \
+	movdqa %xmm13,%xmm10; \
+	pxor %xmm2,%xmm7; \
+	por %xmm2,%xmm3; \
+	pxor pnot,%xmm2; \
+	pxor %xmm3,%xmm10; \
+	movdqa %xmm10,%xmm14; \
+	por %xmm10,%xmm15; \
+	movdqa %xmm15,%xmm5; \
+	movdqa %xmm15,%xmm12; \
+	pand %xmm15,%xmm2; \
+	por %xmm4,%xmm14; \
+	movdqa %xmm14,%xmm9; \
+	pand %xmm4,%xmm3; \
+	pxor %xmm13,%xmm5; \
+	movdqa %xmm5,%xmm11; \
+	movdqa %xmm5,%xmm8; \
+	pand %xmm7,%xmm5; \
+	pxor %xmm7,%xmm9; \
+	pand %xmm4,%xmm12; \
+	pand %xmm4,%xmm11; \
+	movdqa %xmm11,%xmm6; \
+	pxor %xmm12,%xmm5; \
+	pxor %xmm14,%xmm8; \
+	por %xmm1,%xmm5; \
+	pxor %xmm8,%xmm5; \
+	pxor %xmm15,%xmm6; \
+	movdqa %xmm5,%xmm8; \
+	pand %xmm1,%xmm6; \
+	pxor %xmm9,%xmm6; \
+	por %xmm4,%xmm7; \
+	pand %xmm7,%xmm13; \
+	por tmp_at(2),%xmm8; \
+	pxor %xmm6,%xmm8; \
+	pxor out1,%xmm8; \
+	movdqa %xmm8,out1; \
+	pxor %xmm2,%xmm3; \
+	por %xmm1,%xmm3; \
+	pxor %xmm13,%xmm3; \
+	movdqa %xmm3,%xmm2; \
+	pxor %xmm10,%xmm14; \
+	pxor %xmm7,%xmm14; \
+	pxor %xmm0,%xmm13; \
+	pand %xmm9,%xmm13; \
+	pand tmp_at(2),%xmm2; \
+	pxor %xmm6,%xmm2; \
+	pxor out4,%xmm2; \
+	movdqa %xmm2,out4; \
+	por tmp_at(1),%xmm6; \
+	pand %xmm1,%xmm6; \
+	pxor %xmm14,%xmm6; \
+	pand %xmm0,%xmm14; \
+	pxor %xmm15,%xmm14; \
+	pand %xmm1,%xmm13; \
+	pxor %xmm14,%xmm13; \
+	por tmp_at(2),%xmm13; \
+	pxor %xmm6,%xmm13; \
+	pxor out3,%xmm13; \
+	movdqa %xmm13,out3; \
+	pxor %xmm0,%xmm11; \
+	pxor %xmm11,%xmm7; \
+	pxor pnot,%xmm9; \
+	pand %xmm9,%xmm15; \
+	por %xmm1,%xmm15; \
+	pxor %xmm7,%xmm15; \
+	pxor %xmm5,%xmm3; \
+	por %xmm14,%xmm3; \
+	pand tmp_at(2),%xmm3; \
+	pxor %xmm15,%xmm3; \
+	pxor out2,%xmm3; \
+	movdqa %xmm3,out2
+
+#define zero				%xmm0
+
+#define DES_bs_clear_block_8(i) \
+	movdqa zero,B(i); \
+	movdqa zero,B(i + 1); \
+	movdqa zero,B(i + 2); \
+	movdqa zero,B(i + 3); \
+	movdqa zero,B(i + 4); \
+	movdqa zero,B(i + 5); \
+	movdqa zero,B(i + 6); \
+	movdqa zero,B(i + 7)
+
+#define DES_bs_clear_block \
+	DES_bs_clear_block_8(0); \
+	DES_bs_clear_block_8(8); \
+	DES_bs_clear_block_8(16); \
+	DES_bs_clear_block_8(24); \
+	DES_bs_clear_block_8(32); \
+	DES_bs_clear_block_8(40); \
+	DES_bs_clear_block_8(48); \
+	DES_bs_clear_block_8(56)
+
+#define k_ptr				%rdx
+#define K(i)				nvec(i)(k_ptr)
+#define k(i)				nptr(i)(k_ptr)
+
+#define tmp1				%rcx
+#define tmp2				%rsi
+
+#define xor_E(i) \
+	movq E(i),tmp1; \
+	movdqa K(i),a1; \
+	movq E(i + 1),tmp2; \
+	movdqa K(i + 1),a2; \
+	pxor (tmp1),a1; \
+	pxor (tmp2),a2; \
+	movq E(i + 2),tmp1; \
+	movdqa K(i + 2),a3; \
+	movq E(i + 3),tmp2; \
+	movdqa K(i + 3),a4; \
+	pxor (tmp1),a3; \
+	pxor (tmp2),a4; \
+	movq E(i + 4),tmp1; \
+	movdqa K(i + 4),a5; \
+	movq E(i + 5),tmp2; \
+	movdqa K(i + 5),a6; \
+	pxor (tmp1),a5; \
+	pxor (tmp2),a6
+
+#define xor_B(b1, k1, b2, k2, b3, k3, b4, k4, b5, k5, b6, k6) \
+	movdqa B(b1),a1; \
+	movdqa B(b2),a2; \
+	pxor K(k1),a1; \
+	movdqa B(b3),a3; \
+	pxor K(k2),a2; \
+	movdqa B(b4),a4; \
+	pxor K(k3),a3; \
+	movdqa B(b5),a5; \
+	pxor K(k4),a4; \
+	movdqa B(b6),a6; \
+	pxor K(k5),a5; \
+	pxor K(k6),a6
+
+#define xor_B_KS_p(b1, k1, b2, k2, b3, k3, b4, k4, b5, k5, b6, k6) \
+	movq k(k1),tmp1; \
+	movq k(k2),tmp2; \
+	movdqa B(b1),a1; \
+	movdqa B(b2),a2; \
+	pxor (tmp1),a1; \
+	movq k(k3),tmp1; \
+	pxor (tmp2),a2; \
+	movq k(k4),tmp2; \
+	movdqa B(b3),a3; \
+	movdqa B(b4),a4; \
+	pxor (tmp1),a3; \
+	movq k(k5),tmp1; \
+	pxor (tmp2),a4; \
+	movdqa B(b5),a5; \
+	movq k(k6),tmp2; \
+	movdqa B(b6),a6; \
+	pxor (tmp1),a5; \
+	pxor (tmp2),a6
+
+.text
+
+DO_ALIGN(6)
+.globl DES_bs_init_asm
+DES_bs_init_asm:
+	pcmpeqd %xmm0,%xmm0
+	movdqa %xmm0,pnot
+	ret
+
+#define iterations			%edi
+#define rounds_and_swapped		%eax
+
+DO_ALIGN(6)
+.globl DES_bs_crypt
+DES_bs_crypt:
+	pxor zero,zero
+	leaq DES_bs_all_KS_v(%rip),k_ptr
+	DES_bs_clear_block
+	movl $8,rounds_and_swapped
+DES_bs_crypt_start:
+	xor_E(0)
+	S1(B(40), B(48), B(54), B(62))
+	xor_E(6)
+	S2(B(44), B(59), B(33), B(49))
+	xor_E(12)
+	S3(B(55), B(47), B(61), B(37))
+	xor_E(18)
+	S4(B(57), B(51), B(41), B(32))
+	xor_E(24)
+	S5(B(39), B(45), B(56), B(34))
+	xor_E(30)
+	S6(B(35), B(60), B(42), B(50))
+	xor_E(36)
+	S7(B(63), B(43), B(53), B(38))
+	xor_E(42)
+	S8(B(36), B(58), B(46), B(52))
+	cmpl $0x100,rounds_and_swapped
+	je DES_bs_crypt_next
+DES_bs_crypt_swap:
+	xor_E(48)
+	S1(B(8), B(16), B(22), B(30))
+	xor_E(54)
+	S2(B(12), B(27), B(1), B(17))
+	xor_E(60)
+	S3(B(23), B(15), B(29), B(5))
+	xor_E(66)
+	S4(B(25), B(19), B(9), B(0))
+	xor_E(72)
+	S5(B(7), B(13), B(24), B(2))
+	xor_E(78)
+	S6(B(3), B(28), B(10), B(18))
+	xor_E(84)
+	S7(B(31), B(11), B(21), B(6))
+	xor_E(90)
+	addq $nvec(96),k_ptr
+	S8(B(4), B(26), B(14), B(20))
+	subl $1,rounds_and_swapped
+	jnz DES_bs_crypt_start
+	subq $nvec(0x300+48),k_ptr
+	movl $0x108,rounds_and_swapped
+	subl $1,iterations
+	jnz DES_bs_crypt_swap
+	ret
+DES_bs_crypt_next:
+	subq $nvec(0x300-48),k_ptr
+	movl $8,rounds_and_swapped
+	subl $1,iterations
+	jnz DES_bs_crypt_start
+	ret
+
+DO_ALIGN(6)
+.globl DES_bs_crypt_25
+DES_bs_crypt_25:
+	pxor zero,zero
+	leaq DES_bs_all_KS_v(%rip),k_ptr
+	DES_bs_clear_block
+	movl $8,rounds_and_swapped
+	movl $25,iterations
+DES_bs_crypt_25_start:
+	xor_E(0)
+	S1(B(40), B(48), B(54), B(62))
+	xor_E(6)
+	S2(B(44), B(59), B(33), B(49))
+	xor_B(7, 12, 8, 13, 9, 14, 10, 15, 11, 16, 12, 17)
+	S3(B(55), B(47), B(61), B(37))
+	xor_B(11, 18, 12, 19, 13, 20, 14, 21, 15, 22, 16, 23)
+	S4(B(57), B(51), B(41), B(32))
+	xor_E(24)
+	S5(B(39), B(45), B(56), B(34))
+	xor_E(30)
+	S6(B(35), B(60), B(42), B(50))
+	xor_B(23, 36, 24, 37, 25, 38, 26, 39, 27, 40, 28, 41)
+	S7(B(63), B(43), B(53), B(38))
+	xor_B(27, 42, 28, 43, 29, 44, 30, 45, 31, 46, 0, 47)
+	S8(B(36), B(58), B(46), B(52))
+	cmpl $0x100,rounds_and_swapped
+	je DES_bs_crypt_25_next
+DES_bs_crypt_25_swap:
+	xor_E(48)
+	S1(B(8), B(16), B(22), B(30))
+	xor_E(54)
+	S2(B(12), B(27), B(1), B(17))
+	xor_B(39, 60, 40, 61, 41, 62, 42, 63, 43, 64, 44, 65)
+	S3(B(23), B(15), B(29), B(5))
+	xor_B(43, 66, 44, 67, 45, 68, 46, 69, 47, 70, 48, 71)
+	S4(B(25), B(19), B(9), B(0))
+	xor_E(72)
+	S5(B(7), B(13), B(24), B(2))
+	xor_E(78)
+	S6(B(3), B(28), B(10), B(18))
+	xor_B(55, 84, 56, 85, 57, 86, 58, 87, 59, 88, 60, 89)
+	S7(B(31), B(11), B(21), B(6))
+	xor_B(59, 90, 60, 91, 61, 92, 62, 93, 63, 94, 32, 95)
+	S8(B(4), B(26), B(14), B(20))
+	addq $nvec(96),k_ptr
+	subl $1,rounds_and_swapped
+	jnz DES_bs_crypt_25_start
+	subq $nvec(0x300+48),k_ptr
+	movl $0x108,rounds_and_swapped
+	subl $1,iterations
+	jnz DES_bs_crypt_25_swap
+	ret
+DES_bs_crypt_25_next:
+	subq $nvec(0x300-48),k_ptr
+	movl $8,rounds_and_swapped
+	subl $1,iterations
+	jmp DES_bs_crypt_25_start
+
+#define ones				%xmm1
+
+#define rounds				%eax
+
+DO_ALIGN(6)
+.globl DES_bs_crypt_LM
+DES_bs_crypt_LM:
+	pxor zero,zero
+	pcmpeqd ones,ones
+	leaq DES_bs_all_KS_p(%rip),k_ptr
+	movdqa zero,B(0)
+	movdqa zero,B(1)
+	movdqa zero,B(2)
+	movdqa zero,B(3)
+	movdqa zero,B(4)
+	movdqa zero,B(5)
+	movdqa zero,B(6)
+	movdqa zero,B(7)
+	movdqa ones,B(8)
+	movdqa ones,B(9)
+	movdqa ones,B(10)
+	movdqa zero,B(11)
+	movdqa ones,B(12)
+	movdqa zero,B(13)
+	movdqa zero,B(14)
+	movdqa zero,B(15)
+	movdqa zero,B(16)
+	movdqa zero,B(17)
+	movdqa zero,B(18)
+	movdqa zero,B(19)
+	movdqa zero,B(20)
+	movdqa zero,B(21)
+	movdqa zero,B(22)
+	movdqa ones,B(23)
+	movdqa zero,B(24)
+	movdqa zero,B(25)
+	movdqa ones,B(26)
+	movdqa zero,B(27)
+	movdqa zero,B(28)
+	movdqa ones,B(29)
+	movdqa ones,B(30)
+	movdqa ones,B(31)
+	movdqa zero,B(32)
+	movdqa zero,B(33)
+	movdqa zero,B(34)
+	movdqa ones,B(35)
+	movdqa zero,B(36)
+	movdqa ones,B(37)
+	movdqa ones,B(38)
+	movdqa ones,B(39)
+	movdqa zero,B(40)
+	movdqa zero,B(41)
+	movdqa zero,B(42)
+	movdqa zero,B(43)
+	movdqa zero,B(44)
+	movdqa ones,B(45)
+	movdqa zero,B(46)
+	movdqa zero,B(47)
+	movdqa ones,B(48)
+	movdqa ones,B(49)
+	movdqa zero,B(50)
+	movdqa zero,B(51)
+	movdqa zero,B(52)
+	movdqa zero,B(53)
+	movdqa ones,B(54)
+	movdqa zero,B(55)
+	movdqa ones,B(56)
+	movdqa zero,B(57)
+	movdqa ones,B(58)
+	movdqa zero,B(59)
+	movdqa ones,B(60)
+	movdqa ones,B(61)
+	movdqa ones,B(62)
+	movdqa ones,B(63)
+	movl $8,rounds
+DES_bs_crypt_LM_loop:
+	xor_B_KS_p(31, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5)
+	S1(B(40), B(48), B(54), B(62))
+	xor_B_KS_p(3, 6, 4, 7, 5, 8, 6, 9, 7, 10, 8, 11)
+	S2(B(44), B(59), B(33), B(49))
+	xor_B_KS_p(7, 12, 8, 13, 9, 14, 10, 15, 11, 16, 12, 17)
+	S3(B(55), B(47), B(61), B(37))
+	xor_B_KS_p(11, 18, 12, 19, 13, 20, 14, 21, 15, 22, 16, 23)
+	S4(B(57), B(51), B(41), B(32))
+	xor_B_KS_p(15, 24, 16, 25, 17, 26, 18, 27, 19, 28, 20, 29)
+	S5(B(39), B(45), B(56), B(34))
+	xor_B_KS_p(19, 30, 20, 31, 21, 32, 22, 33, 23, 34, 24, 35)
+	S6(B(35), B(60), B(42), B(50))
+	xor_B_KS_p(23, 36, 24, 37, 25, 38, 26, 39, 27, 40, 28, 41)
+	S7(B(63), B(43), B(53), B(38))
+	xor_B_KS_p(27, 42, 28, 43, 29, 44, 30, 45, 31, 46, 0, 47)
+	S8(B(36), B(58), B(46), B(52))
+	xor_B_KS_p(63, 48, 32, 49, 33, 50, 34, 51, 35, 52, 36, 53)
+	S1(B(8), B(16), B(22), B(30))
+	xor_B_KS_p(35, 54, 36, 55, 37, 56, 38, 57, 39, 58, 40, 59)
+	S2(B(12), B(27), B(1), B(17))
+	xor_B_KS_p(39, 60, 40, 61, 41, 62, 42, 63, 43, 64, 44, 65)
+	S3(B(23), B(15), B(29), B(5))
+	xor_B_KS_p(43, 66, 44, 67, 45, 68, 46, 69, 47, 70, 48, 71)
+	S4(B(25), B(19), B(9), B(0))
+	xor_B_KS_p(47, 72, 48, 73, 49, 74, 50, 75, 51, 76, 52, 77)
+	S5(B(7), B(13), B(24), B(2))
+	xor_B_KS_p(51, 78, 52, 79, 53, 80, 54, 81, 55, 82, 56, 83)
+	S6(B(3), B(28), B(10), B(18))
+	xor_B_KS_p(55, 84, 56, 85, 57, 86, 58, 87, 59, 88, 60, 89)
+	S7(B(31), B(11), B(21), B(6))
+	xor_B_KS_p(59, 90, 60, 91, 61, 92, 62, 93, 63, 94, 32, 95)
+	addq $nptr(96),k_ptr
+	S8(B(4), B(26), B(14), B(20))
+	subl $1,rounds
+	jnz DES_bs_crypt_LM_loop
+	ret
+
+#endif
+
+/* The following was written by Alain Espinosa <alainesp at gmail.com> in 2007.
+ * No copyright is claimed, and the software is hereby placed in the public domain.
+ * In case this attempt to disclaim copyright and place the software in the
+ * public domain is deemed null and void, then the software is
+ * Copyright (c) 2007 Alain Espinosa and it is hereby released to the
+ * general public under the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * There's ABSOLUTELY NO WARRANTY, express or implied.
+ *
+ * (This is a heavily cut-down "BSD license".)
+ */
+/* ...converted to use %rip-relative addressing, still public domain */
+
+/*
+ * FIXME: this depends on the assembler being able to multiply, which won't
+ * work on Solaris (unless the use of GNU assembler is forced).
+ */
+
+#ifdef UNDERSCORES
+#define nt_crypt_all_x86_64 _nt_crypt_all_x86_64
+#define nt_buffer8x _nt_buffer8x
+#define output8x _output8x
+#endif
+
+/*
+extern nt_crypt_all_x86_64(int count);
+*/
+
+.globl nt_crypt_all_x86_64
+
+.data
+DO_ALIGN(6)
+const_init_a:
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+const_init_b:
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+const_init_c:
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+const_init_d:
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+
+const_stage2:
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+const_stage3:
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+
+#define a  %xmm0
+#define b  %xmm1
+#define c  %xmm2
+#define d  %xmm3
+#define t1 %xmm4
+#define t2 %xmm5
+#define t3 %xmm6
+#define t4 %xmm7
+
+#undef a3
+#define a3  %xmm8
+#define b3  %xmm9
+#define c3  %xmm10
+#define d3  %xmm11
+#define t13 %xmm12
+#define t23 %xmm13
+
+#define STEP1(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (512*base)+(x*32)+nt_buffer8x(%rip), aa;		\
+	paddd (512*base)+(x*32)+16+nt_buffer8x(%rip), aa3;	\
+	movdqa cc, t1;						\
+	movdqa cc3, t13;					\
+	pxor dd, t1;						\
+	pxor dd3, t13;						\
+	pand bb, t1;						\
+	pand bb3, t13;						\
+	pxor dd, t1;						\
+	pxor dd3, t13;						\
+	paddd t1, aa;						\
+	paddd t13, aa3;						\
+	movdqa aa, t2;						\
+	movdqa aa3, t23;					\
+	pslld $s, aa;						\
+	pslld $s, aa3;						\
+	psrld $(32-s), t2;					\
+	psrld $(32-s), t23;					\
+	por t2, aa;						\
+	por t23, aa3;
+
+#define STEP2(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (512*base)+(x*32)+nt_buffer8x(%rip), aa;		\
+	paddd (512*base)+(x*32)+16+nt_buffer8x(%rip), aa3;	\
+	movdqa cc, t1;						\
+	movdqa cc3, t13;					\
+	movdqa cc, t2;						\
+	movdqa cc3, t23;					\
+	por dd, t1;						\
+	por dd3, t13;						\
+	pand dd, t2;						\
+	pand dd3, t23;						\
+	pand bb, t1;						\
+	pand bb3, t13;						\
+	paddd t3, aa;						\
+	paddd t3, aa3;						\
+	por t2, t1;						\
+	por t23, t13;						\
+	paddd t1, aa;						\
+	paddd t13, aa3;						\
+	movdqa aa, t1;						\
+	movdqa aa3, t13;					\
+	pslld $s, aa;						\
+	pslld $s, aa3;						\
+	psrld $(32-s), t1;					\
+	psrld $(32-s), t13;					\
+	por t1, aa;						\
+	por t13, aa3;
+
+#define STEP3(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (512*base)+(x*32)+nt_buffer8x(%rip), aa;		\
+	paddd (512*base)+(x*32)+16+nt_buffer8x(%rip), aa3;	\
+	movdqa dd, t1;						\
+	movdqa dd3, t13;					\
+	pxor cc, t1;						\
+	pxor cc3, t13;						\
+	paddd t4, aa;						\
+	paddd t4, aa3;						\
+	pxor bb, t1;						\
+	pxor bb3, t13;						\
+	paddd t1, aa;						\
+	paddd t13, aa3;						\
+	movdqa aa, t1;						\
+	movdqa aa3, t13;					\
+	pslld $s, aa;						\
+	pslld $s, aa3;						\
+	psrld $(32-s), t1;					\
+	psrld $(32-s), t13;					\
+	por t1, aa;						\
+	por t13, aa3;
+
+#define NT_CRYPT_BODY(base)					\
+	movdqa const_init_a(%rip), a;				\
+	movdqa const_init_a(%rip), a3;				\
+	movdqa const_init_b(%rip), b;				\
+	movdqa const_init_b(%rip), b3;				\
+	movdqa const_init_c(%rip), c;				\
+	movdqa const_init_c(%rip), c3;				\
+	movdqa const_init_d(%rip), d;				\
+	movdqa const_init_d(%rip), d3;				\
+								\
+	paddd (512*base)+nt_buffer8x(%rip), a;			\
+	paddd (512*base)+16+nt_buffer8x(%rip), a3;		\
+	pslld $3, a;						\
+	pslld $3, a3;						\
+								\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 1 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 2 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 3 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 4 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 5 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 7 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 8 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 9 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 10, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 11, 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 12, 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 13, 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 14, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 15, 19, base)		\
+								\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 4 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 8 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 12, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 5 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 9 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 13, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 6 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 10, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 14, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 3 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 7 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 11, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 15, 13, base)		\
+								\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 8 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 4 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 12, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 10, 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 14, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 9 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 5 , 11, base)		\
+	movdqa a, t1;						\
+	movdqa a3, t13;						\
+	paddd (512*base)+416+nt_buffer8x(%rip), b;		\
+	paddd (512*base)+416+16+nt_buffer8x(%rip), b3;		\
+	pxor d, t1;						\
+	pxor d3,t13;						\
+	pxor c, t1;						\
+	pxor c3,t13;						\
+	paddd t1, b;						\
+	paddd t13,b3;						\
+								\
+	movdqa a,  (128*base)+output8x(%rip);			\
+	movdqa a3,  (128*base)+16+output8x(%rip);		\
+	movdqa b, (128*base)+32+output8x(%rip);			\
+	movdqa b3, (128*base)+32+16+output8x(%rip);		\
+	movdqa c, (128*base)+64+output8x(%rip);			\
+	movdqa c3, (128*base)+64+16+output8x(%rip);		\
+	movdqa d, (128*base)+96+output8x(%rip);			\
+	movdqa d3, (128*base)+96+16+output8x(%rip);
+	
+.text
+
+DO_ALIGN(6)
+
+nt_crypt_all_x86_64:
+	movdqa const_stage2(%rip), t3
+	movdqa const_stage3(%rip), t4
+
+	NT_CRYPT_BODY(0)
+	NT_CRYPT_BODY(1)
+	NT_CRYPT_BODY(2)
+	NT_CRYPT_BODY(3)
+
+	ret
+
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",@progbits
+#endif
diff -rupN john-1.7.8/src/unused/x86-sse.orig.S john-1.7.8-jumbo-2/src/unused/x86-sse.orig.S
--- john-1.7.8/src/unused/x86-sse.orig.S	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/x86-sse.orig.S	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,1569 @@
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 2000-2001,2005,2006,2008 by Solar Designer and others:
+ *
+ * The MMX DES S-box code that this SSE2 DES S-box code is derived from
+ * is by Bruce Ford and Rmi Guyomarch, originally for use in the
+ * distributed.net clients, included here with permission.  Only minor
+ * modifications have been made to their S-box code.  The optimized S-box
+ * expressions are based on work by Matthew Kwan (see nonstd.c).
+ *
+ * ...with changes in the jumbo patch, by Alain Espinosa (starting with a
+ * comment further down this file).
+ */
+
+#include "arch.h"
+
+/*
+ * Some broken systems don't offer section alignments larger than 4 bytes,
+ * while for the SSE code we need at least a 16 byte alignment.  ALIGN_FIX
+ * is here to work around this issue when we happen to get bad addresses.
+ */
+#ifndef ALIGN_FIX
+#ifdef ALIGN_LOG
+#define DO_ALIGN(log)			.align log
+#else
+#define DO_ALIGN(log)			.align 1 << log
+#endif
+#else
+#ifdef ALIGN_LOG
+#define DO_ALIGN(log)			.align log; .space ALIGN_FIX
+#else
+#define DO_ALIGN(log)			.align 1 << log; .space ALIGN_FIX
+#endif
+#endif
+
+#if DES_BS_ASM
+
+#ifdef UNDERSCORES
+#define DES_bs_all			_DES_bs_all
+#define DES_bs_init_asm			_DES_bs_init_asm
+#define DES_bs_crypt			_DES_bs_crypt
+#define DES_bs_crypt_25			_DES_bs_crypt_25
+#define DES_bs_crypt_LM			_DES_bs_crypt_LM
+#endif
+
+#ifdef __sun
+/* Sun's assembler doesn't recognize .space */
+#define DO_SPACE(size)			.zero size
+#else
+/* Mac OS X assembler doesn't recognize .zero */
+#define DO_SPACE(size)			.space size
+#endif
+
+/* Sun's assembler can't multiply, but at least it can add... */
+#define nptr(n)				n+n+n+n
+#define nvec(n)				n+n+n+n+n+n+n+n+n+n+n+n+n+n+n+n
+
+#ifdef BSD
+.data
+#else
+.bss
+#endif
+
+.globl DES_bs_all
+DO_ALIGN(5)
+DES_bs_all:
+DES_bs_all_KSp:
+DO_SPACE(nptr(0x300))
+DES_bs_all_KS_p:
+DES_bs_all_KS_v:
+DO_SPACE(nvec(0x300))
+DES_bs_all_E:
+DO_SPACE(nptr(96))
+DES_bs_all_K:
+DO_SPACE(nvec(56))
+DES_bs_all_B:
+DO_SPACE(nvec(64))
+DES_bs_all_tmp:
+DO_SPACE(nvec(16))
+DES_bs_all_fields_not_used_here:
+DO_SPACE(0x400 + 0x100 + 4 + 4 + 0x400)
+DES_bs_all_possible_alignment_gaps:
+DO_SPACE(0x100)
+
+#define E(i)				DES_bs_all_E+nptr(i)
+#define B(i)				DES_bs_all_B+nvec(i)
+#define tmp_at(i)			DES_bs_all_tmp+nvec(i)
+
+#define pnot				tmp_at(0)
+
+#define a1				%xmm0
+#define a2				%xmm1
+#define a3				%xmm2
+#define a4				%xmm3
+#define a5				%xmm4
+#define a6				%xmm5
+
+#define S1_out1				%xmm5
+#define S1_out2				%xmm7
+#define S1_out3				%xmm2
+#define S1_out4				%xmm0
+
+#define S1_a1				tmp_at(1)
+#define S1_a3				tmp_at(2)
+#define S1_a5				tmp_at(3)
+#define S1_x1				tmp_at(4)
+#define S1_x3				tmp_at(5)
+#define S1_x4				tmp_at(6)
+#define S1_x5				tmp_at(7)
+#define S1_x6				tmp_at(8)
+#define S1_x13				tmp_at(9)
+#define S1_x14				tmp_at(10)
+#define S1_x25				tmp_at(11)
+#define S1_x26				tmp_at(12)
+#define S1_x38				tmp_at(13)
+#define S1_x55				tmp_at(14)
+#define S1_x58				tmp_at(15)
+
+#define S1(out1, out2, out3, out4, extra) \
+	movdqa %xmm0,S1_a1; \
+	movdqa %xmm3,%xmm6; \
+	pxor pnot,%xmm0; \
+	pxor %xmm2,%xmm3; \
+	pxor pnot,%xmm6; \
+	movdqa %xmm0,%xmm7; \
+	extra; \
+	movdqa %xmm4,S1_a5; \
+	por %xmm2,%xmm7; \
+	movdqa %xmm3,S1_x3; \
+	movdqa %xmm5,%xmm4; \
+	movdqa %xmm6,S1_x1; \
+	pxor %xmm0,%xmm3; \
+	movdqa %xmm7,S1_x5; \
+	por %xmm6,%xmm0; \
+	movdqa %xmm2,S1_a3; \
+	pand %xmm6,%xmm7; \
+	movdqa %xmm3,S1_x4; \
+	por %xmm3,%xmm2; \
+	pxor pnot,%xmm2; \
+	pand %xmm0,%xmm4; \
+	movdqa %xmm7,%xmm6; \
+	por %xmm5,%xmm2; \
+	movdqa %xmm7,S1_x6; \
+	por %xmm5,%xmm6; \
+	pxor %xmm2,%xmm7; \
+	pxor %xmm6,%xmm3; \
+	movdqa %xmm2,S1_x25; \
+	pxor %xmm4,%xmm6; \
+	pand S1_a3,%xmm4; \
+	movdqa %xmm6,%xmm2; \
+	pxor S1_a3,%xmm6; \
+	por %xmm1,%xmm2; \
+	pand S1_x5,%xmm6; \
+	pxor %xmm3,%xmm2; \
+	movdqa %xmm4,S1_x38; \
+	pxor %xmm2,%xmm0; \
+	movdqa %xmm7,S1_x26; \
+	movdqa %xmm5,%xmm4; \
+	movdqa %xmm2,S1_x13; \
+	por %xmm0,%xmm4; \
+	movdqa S1_x1,%xmm7; \
+	por %xmm1,%xmm6; \
+	movdqa %xmm0,S1_x14; \
+	movdqa %xmm3,%xmm2; \
+	pandn S1_x3,%xmm0; \
+	pxor %xmm7,%xmm4; \
+	por S1_x4,%xmm5; \
+	por %xmm1,%xmm0; \
+	pxor S1_x38,%xmm5; \
+	pxor %xmm0,%xmm4; \
+	movdqa S1_a5,%xmm0; \
+	pand %xmm7,%xmm2; \
+	movdqa %xmm6,S1_x55; \
+	por %xmm1,%xmm2; \
+	movdqa S1_x14,%xmm6; \
+	por %xmm4,%xmm0; \
+	pand S1_x5,%xmm6; \
+	por %xmm3,%xmm7; \
+	movdqa %xmm5,S1_x58; \
+	pxor %xmm3,%xmm6; \
+	pxor S1_x6,%xmm7; \
+	movdqa %xmm1,%xmm5; \
+	pxor S1_x26,%xmm2; \
+	pand %xmm6,%xmm5; \
+	pand S1_a3,%xmm6; \
+	pxor %xmm7,%xmm5; \
+	por S1_a5,%xmm5; \
+	movdqa S1_a1,%xmm7; \
+	pxor %xmm2,%xmm5; \
+	movdqa S1_x4,%xmm2; \
+	por %xmm3,%xmm7; \
+	por S1_x38,%xmm2; \
+	pxor %xmm6,%xmm3; \
+	pxor S1_x25,%xmm6; \
+	pxor %xmm4,%xmm7; \
+	movdqa S1_a3,%xmm4; \
+	por %xmm1,%xmm7; \
+	por S1_x26,%xmm4; \
+	por %xmm1,%xmm6; \
+	pxor S1_x14,%xmm4; \
+	pxor %xmm2,%xmm6; \
+	movdqa S1_x13,%xmm2; \
+	pxor %xmm4,%xmm7; \
+	pxor S1_x55,%xmm3; \
+	pxor %xmm2,%xmm0; \
+	pxor out1,%xmm5; \
+	pand %xmm3,%xmm2; \
+	movdqa S1_a5,%xmm4; \
+	pand %xmm1,%xmm2; \
+	movdqa %xmm5,out1; \
+	pxor S1_x58,%xmm2; \
+	pand %xmm4,%xmm7; \
+	pxor out4,%xmm0; \
+	pand %xmm4,%xmm2; \
+	pxor out2,%xmm7; \
+	movdqa %xmm0,out4; \
+	pxor out3,%xmm2; \
+	pxor %xmm6,%xmm7; \
+	pxor %xmm3,%xmm2; \
+	movdqa %xmm7,out2; \
+	movdqa %xmm2,out3
+
+#define S2_out1				%xmm1
+#undef S2_out2
+#define S2_out3				%xmm7
+#define S2_out4				%xmm2
+
+#define S2_a1				tmp_at(1)
+#define S2_a2				tmp_at(2)
+#define S2_a3				tmp_at(3)
+#define S2_a4				tmp_at(4)
+#define S2_x3				tmp_at(5)
+#define S2_x4				tmp_at(6)
+#define S2_x5				tmp_at(7)
+#define S2_x13				tmp_at(8)
+#define S2_x18				tmp_at(9)
+#define S2_x25				tmp_at(10)
+
+#define S2(out1, out2, out3, out4, extra) \
+	movdqa %xmm3,S2_a4; \
+	movdqa %xmm4,%xmm6; \
+	extra; \
+	movdqa %xmm0,S2_a1; \
+	movdqa %xmm4,%xmm7; \
+	pxor pnot,%xmm0; \
+	pxor %xmm5,%xmm6; \
+	pxor pnot,%xmm7; \
+	movdqa %xmm0,%xmm3; \
+	movdqa %xmm2,S2_a3; \
+	por %xmm5,%xmm7; \
+	movdqa %xmm6,S2_x3; \
+	por %xmm7,%xmm3; \
+	pxor %xmm4,%xmm7; \
+	pxor %xmm0,%xmm6; \
+	pand %xmm1,%xmm3; \
+	por %xmm7,%xmm2; \
+	movdqa %xmm1,S2_a2; \
+	pxor %xmm5,%xmm3; \
+	movdqa %xmm6,S2_x4; \
+	pxor %xmm1,%xmm6; \
+	movdqa %xmm7,S2_x13; \
+	pand %xmm3,%xmm1; \
+	pand S2_a3,%xmm3; \
+	pxor %xmm2,%xmm1; \
+	movdqa S2_x4,%xmm7; \
+	movdqa %xmm1,%xmm2; \
+	pand S2_a4,%xmm2; \
+	pxor %xmm6,%xmm3; \
+	movdqa %xmm6,S2_x5; \
+	pxor %xmm2,%xmm3; \
+	movdqa S2_a1,%xmm2; \
+	por %xmm5,%xmm7; \
+	por %xmm2,%xmm1; \
+	pand %xmm3,%xmm7; \
+	pxor out2,%xmm3; \
+	por %xmm4,%xmm2; \
+	por S2_a3,%xmm7; \
+	movdqa %xmm2,%xmm6; \
+	pxor S2_x13,%xmm1; \
+	por %xmm5,%xmm6; \
+	movdqa %xmm3,out2; \
+	pand %xmm0,%xmm4; \
+	movdqa S2_x13,%xmm3; \
+	por %xmm0,%xmm5; \
+	movdqa %xmm2,S2_x18; \
+	pxor %xmm6,%xmm3; \
+	movdqa S2_a2,%xmm2; \
+	pxor %xmm6,%xmm0; \
+	pxor %xmm2,%xmm3; \
+	pand %xmm2,%xmm0; \
+	pxor %xmm3,%xmm7; \
+	por %xmm4,%xmm2; \
+	pxor S2_x3,%xmm4; \
+	pand %xmm3,%xmm6; \
+	pxor %xmm0,%xmm4; \
+	pxor %xmm5,%xmm6; \
+	movdqa %xmm7,S2_x25; \
+	pand %xmm3,%xmm0; \
+	movdqa S2_a3,%xmm7; \
+	pxor %xmm2,%xmm5; \
+	pxor S2_x5,%xmm0; \
+	pand %xmm4,%xmm7; \
+	pand S2_a2,%xmm4; \
+	pxor %xmm5,%xmm7; \
+	por S2_a4,%xmm7; \
+	movdqa %xmm1,%xmm5; \
+	por S2_a3,%xmm5; \
+	por %xmm2,%xmm1; \
+	pand S2_x18,%xmm2; \
+	pxor %xmm3,%xmm4; \
+	movdqa S2_a4,%xmm3; \
+	pand %xmm4,%xmm2; \
+	pand S2_a3,%xmm4; \
+	pxor %xmm5,%xmm0; \
+	pxor S2_x25,%xmm7; \
+	pxor %xmm6,%xmm4; \
+	pxor out3,%xmm7; \
+	pand %xmm3,%xmm1; \
+	por %xmm3,%xmm2; \
+	pxor out1,%xmm1; \
+	pxor %xmm4,%xmm2; \
+	pxor %xmm0,%xmm1; \
+	pxor out4,%xmm2; \
+	movdqa %xmm1,out1; \
+	movdqa %xmm7,out3; \
+	movdqa %xmm2,out4
+
+#define S3_out1				%xmm2
+#define S3_out2				%xmm6
+#define S3_out3				%xmm3
+#define S3_out4				%xmm7
+
+#define S3_a1				tmp_at(1)
+#define S3_x2				tmp_at(2)
+#define S3_x9				tmp_at(3)
+#define S3_a5				tmp_at(4)
+#define S3_x4				tmp_at(5)
+#define S3_a6				tmp_at(6)
+#define S3_x6				tmp_at(7)
+#define S3_x5				tmp_at(8)
+#define S3_x11				tmp_at(9)
+#define S3_x12				tmp_at(10)
+#define S3_x13				tmp_at(11)
+#define S3_x54				tmp_at(12)
+#define S3_x7				tmp_at(13)
+#define S3_a4				tmp_at(14)
+#define S3_a3				S3_a5
+#define S3_x38				S3_x4
+
+#define S3(out1, out2, out3, out4, extra) \
+	movdqa %xmm0,S3_a1; \
+	extra; \
+	movdqa %xmm4,%xmm0; \
+	movdqa %xmm5,%xmm6; \
+	pxor pnot,%xmm6; \
+	movdqa %xmm4,%xmm7; \
+	pxor %xmm6,%xmm7; \
+	movdqa %xmm6,S3_x2; \
+	pand %xmm2,%xmm0; \
+	movdqa %xmm7,S3_x9; \
+	pxor %xmm5,%xmm0; \
+	movdqa %xmm4,S3_a5; \
+	pandn %xmm3,%xmm4; \
+	movdqa %xmm0,S3_x4; \
+	por %xmm3,%xmm7; \
+	movdqa S3_a5,%xmm6; \
+	pxor %xmm4,%xmm0; \
+	movdqa %xmm5,S3_a6; \
+	pandn %xmm2,%xmm6; \
+	movdqa %xmm0,S3_x6; \
+	pxor %xmm6,%xmm7; \
+	movdqa S3_x2,%xmm5; \
+	pxor %xmm1,%xmm0; \
+	movdqa %xmm4,S3_x5; \
+	movdqa %xmm7,%xmm4; \
+	por S3_x4,%xmm5; \
+	pand %xmm0,%xmm4; \
+	movdqa %xmm7,S3_x11; \
+	pxor %xmm5,%xmm6; \
+	pxor S3_a5,%xmm7; \
+	por %xmm1,%xmm6; \
+	movdqa %xmm4,S3_x12; \
+	pand %xmm5,%xmm4; \
+	movdqa %xmm7,S3_x13; \
+	por %xmm0,%xmm7; \
+	movdqa %xmm4,S3_x54; \
+	movdqa %xmm2,%xmm4; \
+	pxor S3_x9,%xmm4; \
+	pand %xmm3,%xmm7; \
+	movdqa %xmm0,S3_x7; \
+	pxor %xmm3,%xmm4; \
+	pxor S3_a6,%xmm5; \
+	pxor %xmm4,%xmm6; \
+	movdqa %xmm3,S3_a4; \
+	por %xmm5,%xmm3; \
+	movdqa %xmm2,S3_a3; \
+	pxor %xmm3,%xmm5; \
+	por %xmm1,%xmm5; \
+	pxor %xmm7,%xmm2; \
+	pxor S3_x12,%xmm7; \
+	movdqa %xmm2,%xmm4; \
+	por S3_x5,%xmm2; \
+	pand %xmm1,%xmm7; \
+	por S3_x4,%xmm4; \
+	por %xmm1,%xmm2; \
+	pxor S3_x11,%xmm7; \
+	pxor %xmm3,%xmm2; \
+	movdqa S3_a1,%xmm3; \
+	pxor S3_a4,%xmm4; \
+	pand %xmm3,%xmm7; \
+	pxor S3_x7,%xmm7; \
+	por %xmm3,%xmm2; \
+	movdqa %xmm4,S3_x38; \
+	pxor %xmm6,%xmm2; \
+	pxor out4,%xmm7; \
+	por %xmm1,%xmm4; \
+	movdqa S3_a3,%xmm6; \
+	movdqa %xmm2,%xmm3; \
+	pxor S3_x9,%xmm6; \
+	por S3_x5,%xmm6; \
+	pxor S3_x38,%xmm3; \
+	pxor %xmm6,%xmm4; \
+	movdqa S3_a6,%xmm6; \
+	pand S3_x11,%xmm6; \
+	movdqa %xmm7,out4; \
+	movdqa S3_x2,%xmm0; \
+	pxor %xmm6,%xmm3; \
+	por S3_x6,%xmm6; \
+	pand %xmm1,%xmm3; \
+	por S3_x38,%xmm0; \
+	pxor %xmm6,%xmm3; \
+	pxor S3_x13,%xmm0; \
+	movdqa %xmm5,%xmm6; \
+	por S3_a1,%xmm3; \
+	pxor %xmm5,%xmm0; \
+	pand S3_x54,%xmm6; \
+	pxor %xmm4,%xmm3; \
+	por S3_a1,%xmm6; \
+	pxor out3,%xmm3; \
+	pxor %xmm0,%xmm6; \
+	pxor out1,%xmm2; \
+	movdqa %xmm3,out3; \
+	pxor out2,%xmm6; \
+	movdqa %xmm2,out1; \
+	movdqa %xmm6,out2
+
+#define S4_out1				%xmm1
+#define S4_out2				%xmm0
+#define S4_out3				%xmm6
+#define S4_out4				%xmm5
+
+#define S4_a2				tmp_at(1)
+#define S4_a3				tmp_at(2)
+#define S4_a4				tmp_at(3)
+#define S4_a6				tmp_at(4)
+
+#define S4(out1, out2, out3, out4, extra) \
+	movdqa %xmm2,%xmm6; \
+	movdqa %xmm3,S4_a4; \
+	movdqa %xmm0,%xmm7; \
+	movdqa %xmm1,S4_a2; \
+	por %xmm0,%xmm6; \
+	extra; \
+	pand %xmm4,%xmm7; \
+	movdqa %xmm1,%xmm3; \
+	movdqa %xmm5,S4_a6; \
+	movdqa %xmm2,S4_a3; \
+	movdqa %xmm4,%xmm5; \
+	pand %xmm6,%xmm5; \
+	por %xmm2,%xmm3; \
+	pxor pnot,%xmm2; \
+	pxor %xmm5,%xmm0; \
+	pxor pnot,%xmm0; \
+	pxor %xmm7,%xmm6; \
+	pxor %xmm0,%xmm3; \
+	movdqa %xmm1,%xmm7; \
+	pand %xmm6,%xmm7; \
+	pxor %xmm2,%xmm5; \
+	pxor %xmm4,%xmm2; \
+	pand %xmm5,%xmm0; \
+	pxor %xmm7,%xmm4; \
+	pand %xmm1,%xmm5; \
+	por %xmm1,%xmm2; \
+	pxor %xmm6,%xmm5; \
+	movdqa S4_a4,%xmm1; \
+	movdqa %xmm0,%xmm6; \
+	pand %xmm4,%xmm1; \
+	pxor %xmm2,%xmm6; \
+	por S4_a4,%xmm6; \
+	pxor %xmm3,%xmm1; \
+	pand S4_a2,%xmm4; \
+	pxor %xmm5,%xmm6; \
+	movdqa S4_a6,%xmm3; \
+	pxor %xmm0,%xmm4; \
+	pxor S4_a3,%xmm7; \
+	movdqa %xmm3,%xmm0; \
+	pxor %xmm2,%xmm7; \
+	pand %xmm6,%xmm0; \
+	movdqa S4_a4,%xmm2; \
+	por %xmm3,%xmm6; \
+	pxor %xmm1,%xmm0; \
+	pand %xmm2,%xmm7; \
+	pxor pnot,%xmm1; \
+	pxor %xmm7,%xmm4; \
+	movdqa %xmm4,%xmm5; \
+	pxor %xmm1,%xmm4; \
+	pxor out1,%xmm1; \
+	por %xmm4,%xmm2; \
+	pand S4_a2,%xmm4; \
+	pxor %xmm6,%xmm1; \
+	pxor %xmm0,%xmm4; \
+	pxor out3,%xmm6; \
+	pxor %xmm4,%xmm2; \
+	pxor out2,%xmm0; \
+	pand %xmm2,%xmm3; \
+	pxor %xmm2,%xmm6; \
+	pxor %xmm3,%xmm5; \
+	movdqa %xmm1,out1; \
+	pxor %xmm5,%xmm6; \
+	movdqa %xmm0,out2; \
+	pxor out4,%xmm5; \
+	movdqa %xmm6,out3; \
+	movdqa %xmm5,out4
+
+#define S5_out1				%xmm5
+#define S5_out2				%xmm7
+#define S5_out3				%xmm6
+#define S5_out4				%xmm4
+
+#define S5_a1				tmp_at(1)
+#define S5_a2				tmp_at(2)
+#define S5_a6				tmp_at(3)
+#define S5_x2				tmp_at(4)
+#define S5_x4				tmp_at(5)
+#define S5_x5				tmp_at(6)
+#define S5_x6				tmp_at(7)
+#define S5_x7				tmp_at(8)
+#define S5_x8				tmp_at(9)
+#define S5_x9				tmp_at(10)
+#define S5_x13				tmp_at(11)
+#define S5_x16				tmp_at(12)
+#define S5_x17				S5_a6
+#define S5_x21				S5_x7
+#define S5_x24				S5_x8
+#define S5_x28				S5_x17
+#define S5_x38				S5_x9
+
+#define S5(out1, out2, out3, out4, extra) \
+	movdqa %xmm1,S5_a2; \
+	movdqa %xmm3,%xmm6; \
+	movdqa %xmm2,%xmm7; \
+	pandn %xmm2,%xmm6; \
+	pandn %xmm0,%xmm7; \
+	movdqa %xmm6,%xmm1; \
+	movdqa %xmm0,S5_a1; \
+	pxor %xmm0,%xmm1; \
+	extra; \
+	pxor %xmm3,%xmm0; \
+	movdqa %xmm1,S5_x2; \
+	movdqa %xmm5,S5_a6; \
+	por %xmm0,%xmm6; \
+	por %xmm7,%xmm5; \
+	movdqa %xmm6,S5_x7; \
+	pxor %xmm5,%xmm1; \
+	movdqa %xmm5,S5_x4; \
+	pand %xmm2,%xmm6; \
+	movdqa S5_a6,%xmm5; \
+	pxor %xmm3,%xmm6; \
+	pandn S5_x7,%xmm5; \
+	movdqa %xmm0,S5_x6; \
+	movdqa %xmm7,%xmm0; \
+	movdqa %xmm5,S5_x8; \
+	pxor %xmm2,%xmm5; \
+	movdqa %xmm1,S5_x5; \
+	pxor %xmm3,%xmm0; \
+	movdqa %xmm5,S5_x9; \
+	pandn %xmm6,%xmm7; \
+	por S5_a6,%xmm0; \
+	por %xmm4,%xmm5; \
+	movdqa %xmm6,S5_x13; \
+	pxor %xmm1,%xmm5; \
+	movdqa %xmm0,S5_x16; \
+	pxor %xmm0,%xmm7; \
+	movdqa S5_a2,%xmm0; \
+	movdqa %xmm4,%xmm1; \
+	movdqa %xmm7,S5_x17; \
+	por %xmm7,%xmm1; \
+	pand S5_x5,%xmm7; \
+	pxor %xmm6,%xmm1; \
+	pandn %xmm1,%xmm0; \
+	movdqa %xmm7,%xmm6; \
+	pandn S5_x7,%xmm6; \
+	pxor %xmm0,%xmm5; \
+	pxor S5_x9,%xmm7; \
+	movdqa %xmm3,%xmm0; \
+	movdqa %xmm5,S5_x21; \
+	movdqa %xmm6,%xmm5; \
+	pandn S5_x8,%xmm0; \
+	pandn %xmm1,%xmm5; \
+	pxor out3,%xmm6; \
+	pxor %xmm2,%xmm0; \
+	movdqa S5_a1,%xmm2; \
+	movdqa %xmm0,%xmm1; \
+	pxor S5_x9,%xmm2; \
+	pand %xmm4,%xmm1; \
+	movdqa %xmm7,S5_x38; \
+	pxor %xmm1,%xmm6; \
+	movdqa S5_x4,%xmm1; \
+	movdqa %xmm2,%xmm7; \
+	pand S5_x2,%xmm7; \
+	pand %xmm3,%xmm1; \
+	pxor S5_x17,%xmm1; \
+	pandn %xmm4,%xmm7; \
+	movdqa %xmm2,S5_x24; \
+	pxor %xmm7,%xmm1; \
+	movdqa out2,%xmm7; \
+	por %xmm2,%xmm3; \
+	movdqa S5_a2,%xmm2; \
+	pxor %xmm1,%xmm7; \
+	movdqa %xmm3,S5_x28; \
+	pandn %xmm3,%xmm2; \
+	movdqa S5_x38,%xmm3; \
+	pxor %xmm2,%xmm7; \
+	movdqa S5_x16,%xmm2; \
+	por %xmm4,%xmm3; \
+	por S5_x13,%xmm2; \
+	por %xmm5,%xmm1; \
+	pxor out1,%xmm5; \
+	pxor %xmm3,%xmm2; \
+	por S5_a2,%xmm2; \
+	movdqa %xmm7,out2; \
+	pxor S5_x6,%xmm1; \
+	pxor %xmm2,%xmm6; \
+	pandn %xmm4,%xmm1; \
+	movdqa S5_x38,%xmm2; \
+	pxor S5_x24,%xmm1; \
+	movdqa %xmm2,%xmm3; \
+	pxor S5_x21,%xmm2; \
+	pxor %xmm1,%xmm5; \
+	pand S5_x6,%xmm3; \
+	pandn %xmm4,%xmm2; \
+	pand S5_x28,%xmm2; \
+	pxor %xmm0,%xmm3; \
+	pxor pnot,%xmm6; \
+	pxor %xmm2,%xmm3; \
+	movdqa S5_x21,%xmm4; \
+	por S5_a2,%xmm3; \
+	movdqa %xmm6,out3; \
+	pxor out4,%xmm4; \
+	pxor %xmm3,%xmm5; \
+	movdqa %xmm4,out4; \
+	movdqa %xmm5,out1
+
+#define S6_out1				%xmm0
+#undef S6_out2
+#define S6_out3				%xmm2
+#define S6_out4				%xmm4
+
+#define S6_a1				tmp_at(1)
+#define S6_a2				tmp_at(2)
+#define S6_a3				tmp_at(3)
+#define S6_a4				tmp_at(4)
+#define S6_x1				tmp_at(5)
+#define S6_x2				tmp_at(6)
+#define S6_x5				tmp_at(7)
+#define S6_x6				tmp_at(8)
+#define S6_x8				tmp_at(9)
+#define S6_x15				tmp_at(10)
+#define S6_x16				tmp_at(11)
+
+#define S6(out1, out2, out3, out4, extra) \
+	movdqa %xmm2,S6_a3; \
+	extra; \
+	movdqa %xmm4,%xmm6; \
+	pxor pnot,%xmm6; \
+	movdqa %xmm5,%xmm7; \
+	movdqa %xmm1,S6_a2; \
+	movdqa %xmm4,%xmm2; \
+	movdqa %xmm3,S6_a4; \
+	pxor %xmm1,%xmm7; \
+	pxor pnot,%xmm1; \
+	pxor %xmm6,%xmm7; \
+	movdqa %xmm6,S6_x2; \
+	pxor %xmm0,%xmm7; \
+	pand %xmm5,%xmm2; \
+	movdqa %xmm4,%xmm6; \
+	movdqa %xmm1,S6_x1; \
+	movdqa %xmm5,%xmm3; \
+	pand S6_a2,%xmm3; \
+	pand %xmm7,%xmm6; \
+	movdqa %xmm0,S6_a1; \
+	por %xmm2,%xmm1; \
+	movdqa %xmm2,S6_x6; \
+	pand %xmm6,%xmm0; \
+	movdqa %xmm3,S6_x15; \
+	pxor %xmm0,%xmm1; \
+	movdqa S6_a4,%xmm0; \
+	movdqa %xmm4,%xmm2; \
+	movdqa %xmm6,S6_x8; \
+	pand %xmm1,%xmm0; \
+	movdqa %xmm7,S6_x5; \
+	pxor %xmm3,%xmm2; \
+	movdqa S6_x2,%xmm6; \
+	pxor %xmm7,%xmm0; \
+	movdqa S6_a1,%xmm7; \
+	pxor %xmm5,%xmm1; \
+	movdqa %xmm2,S6_x16; \
+	pand %xmm7,%xmm2; \
+	movdqa S6_a4,%xmm3; \
+	pxor %xmm2,%xmm6; \
+	pxor S6_a2,%xmm2; \
+	pand %xmm7,%xmm1; \
+	por %xmm6,%xmm3; \
+	pxor %xmm5,%xmm6; \
+	pxor %xmm3,%xmm1; \
+	pand %xmm6,%xmm7; \
+	pand S6_a3,%xmm1; \
+	pand %xmm4,%xmm6; \
+	movdqa S6_x6,%xmm3; \
+	pxor %xmm1,%xmm0; \
+	pxor out2,%xmm0; \
+	por %xmm2,%xmm3; \
+	pand S6_a4,%xmm3; \
+	pxor %xmm7,%xmm4; \
+	movdqa S6_x5,%xmm1; \
+	pxor %xmm3,%xmm4; \
+	pxor pnot,%xmm2; \
+	por %xmm4,%xmm5; \
+	movdqa %xmm0,out2; \
+	movdqa %xmm5,%xmm3; \
+	pandn S6_a4,%xmm3; \
+	pxor %xmm6,%xmm1; \
+	movdqa S6_x6,%xmm0; \
+	pxor %xmm2,%xmm3; \
+	por S6_a4,%xmm1; \
+	pxor %xmm3,%xmm0; \
+	pand S6_a3,%xmm3; \
+	pxor %xmm1,%xmm0; \
+	por S6_x5,%xmm6; \
+	movdqa %xmm7,%xmm1; \
+	pxor S6_x15,%xmm7; \
+	pxor %xmm3,%xmm4; \
+	movdqa S6_a4,%xmm3; \
+	pxor %xmm5,%xmm7; \
+	pand S6_x8,%xmm5; \
+	por %xmm3,%xmm7; \
+	pxor S6_x6,%xmm6; \
+	por %xmm3,%xmm5; \
+	por S6_x16,%xmm1; \
+	pxor %xmm6,%xmm5; \
+	pxor S6_x1,%xmm1; \
+	movdqa S6_a3,%xmm3; \
+	pxor %xmm1,%xmm7; \
+	pxor out4,%xmm4; \
+	por %xmm3,%xmm7; \
+	pand %xmm1,%xmm2; \
+	pxor out1,%xmm0; \
+	por %xmm3,%xmm2; \
+	pxor %xmm7,%xmm0; \
+	pxor %xmm5,%xmm2; \
+	movdqa %xmm4,out4; \
+	pxor out3,%xmm2; \
+	movdqa %xmm0,out1; \
+	movdqa %xmm2,out3
+
+#define S7_out1				%xmm7
+#define S7_out2				%xmm1
+#define S7_out3				%xmm3
+#define S7_out4				%xmm0
+
+#define S7_a1				tmp_at(1)
+#define S7_a2				tmp_at(2)
+#define S7_a4				tmp_at(3)
+#define S7_a6				tmp_at(4)
+#define S7_x6				tmp_at(5)
+#define S7_x7				tmp_at(6)
+#define S7_x8				tmp_at(7)
+#define S7_x11				tmp_at(8)
+#define S7_x13				tmp_at(9)
+#define S7_x15				tmp_at(10)
+#define S7_x25				tmp_at(11)
+#define S7_x26				tmp_at(12)
+
+#define S7(out1, out2, out3, out4, extra) \
+	movdqa %xmm0,S7_a1; \
+	movdqa %xmm1,%xmm6; \
+	extra; \
+	movdqa %xmm1,S7_a2; \
+	movdqa %xmm3,%xmm7; \
+	movdqa %xmm5,S7_a6; \
+	pand %xmm3,%xmm6; \
+	movdqa %xmm3,S7_a4; \
+	pxor %xmm4,%xmm6; \
+	pxor pnot,%xmm4; \
+	pand %xmm6,%xmm7; \
+	pand %xmm4,%xmm3; \
+	movdqa %xmm1,%xmm5; \
+	pxor %xmm2,%xmm6; \
+	pxor %xmm7,%xmm5; \
+	movdqa %xmm7,S7_x6; \
+	por %xmm1,%xmm4; \
+	por %xmm3,%xmm1; \
+	pxor %xmm6,%xmm7; \
+	movdqa %xmm5,S7_x7; \
+	pand %xmm2,%xmm4; \
+	pand %xmm2,%xmm5; \
+	por %xmm7,%xmm3; \
+	movdqa %xmm1,S7_x13; \
+	pxor %xmm5,%xmm0; \
+	por S7_a6,%xmm0; \
+	pxor %xmm4,%xmm1; \
+	movdqa %xmm4,S7_x15; \
+	pxor %xmm6,%xmm0; \
+	movdqa %xmm5,S7_x8; \
+	movdqa %xmm3,%xmm4; \
+	movdqa S7_a6,%xmm6; \
+	movdqa %xmm0,%xmm5; \
+	pxor S7_x6,%xmm5; \
+	por %xmm6,%xmm4; \
+	movdqa %xmm7,S7_x25; \
+	por %xmm6,%xmm5; \
+	movdqa S7_a1,%xmm7; \
+	pxor %xmm1,%xmm5; \
+	movdqa %xmm3,S7_x26; \
+	pand %xmm5,%xmm7; \
+	movdqa %xmm0,S7_x11; \
+	pxor %xmm0,%xmm7; \
+	movdqa S7_a4,%xmm3; \
+	movdqa %xmm7,%xmm0; \
+	por S7_a2,%xmm0; \
+	pand %xmm3,%xmm1; \
+	pand S7_x13,%xmm3; \
+	por S7_x7,%xmm2; \
+	pxor S7_x6,%xmm0; \
+	pxor %xmm3,%xmm2; \
+	movdqa S7_a2,%xmm3; \
+	movdqa %xmm0,%xmm6; \
+	pxor pnot,%xmm3; \
+	pxor S7_x15,%xmm6; \
+	por %xmm3,%xmm1; \
+	pand S7_x26,%xmm0; \
+	pxor %xmm6,%xmm4; \
+	pand S7_a6,%xmm0; \
+	por %xmm3,%xmm6; \
+	por S7_a6,%xmm6; \
+	pand %xmm5,%xmm3; \
+	pand S7_a6,%xmm1; \
+	pxor %xmm3,%xmm0; \
+	por S7_a1,%xmm0; \
+	pxor %xmm6,%xmm2; \
+	pxor S7_x11,%xmm1; \
+	pxor %xmm4,%xmm0; \
+	movdqa S7_a1,%xmm4; \
+	pxor %xmm2,%xmm5; \
+	movdqa S7_a4,%xmm6; \
+	por %xmm2,%xmm4; \
+	pxor S7_x25,%xmm6; \
+	pxor %xmm4,%xmm1; \
+	movdqa S7_a6,%xmm4; \
+	pand %xmm1,%xmm6; \
+	movdqa S7_x6,%xmm3; \
+	pand %xmm4,%xmm6; \
+	pxor S7_x15,%xmm3; \
+	pxor %xmm5,%xmm6; \
+	pxor S7_x8,%xmm2; \
+	por %xmm4,%xmm3; \
+	por S7_a1,%xmm6; \
+	pxor %xmm2,%xmm3; \
+	pxor out1,%xmm7; \
+	pxor %xmm6,%xmm3; \
+	pxor out2,%xmm1; \
+	movdqa %xmm7,out1; \
+	pxor out3,%xmm3; \
+	movdqa %xmm1,out2; \
+	pxor out4,%xmm0; \
+	movdqa %xmm3,out3; \
+	movdqa %xmm0,out4
+
+#define S8_out1				%xmm6
+#define S8_out2				%xmm2
+#define S8_out3				%xmm5
+#define S8_out4				%xmm1
+
+#define S8_a1				tmp_at(1)
+#define S8_a2				tmp_at(2)
+#define S8_a4				tmp_at(3)
+#define S8_a5				tmp_at(4)
+#define S8_a6				tmp_at(5)
+#define S8_x14				tmp_at(6)
+#define S8_x22				tmp_at(7)
+#define S8_x33				tmp_at(8)
+
+#define S8(out1, out2, out3, out4, extra) \
+	movdqa %xmm0,S8_a1; \
+	extra; \
+	movdqa %xmm2,%xmm6; \
+	pxor pnot,%xmm0; \
+	movdqa %xmm2,%xmm7; \
+	movdqa %xmm3,S8_a4; \
+	por %xmm0,%xmm7; \
+	pxor pnot,%xmm3; \
+	pxor %xmm0,%xmm6; \
+	movdqa %xmm5,S8_a6; \
+	movdqa %xmm4,%xmm5; \
+	movdqa %xmm1,S8_a2; \
+	movdqa %xmm7,%xmm1; \
+	movdqa %xmm4,S8_a5; \
+	pxor %xmm3,%xmm7; \
+	por %xmm6,%xmm5; \
+	por %xmm7,%xmm0; \
+	pand %xmm4,%xmm1; \
+	pandn %xmm0,%xmm2; \
+	por %xmm7,%xmm4; \
+	pxor %xmm1,%xmm2; \
+	movdqa %xmm5,S8_x22; \
+	pand %xmm3,%xmm5; \
+	por S8_a2,%xmm2; \
+	pxor %xmm4,%xmm7; \
+	pxor %xmm0,%xmm3; \
+	movdqa %xmm4,%xmm1; \
+	pxor S8_x22,%xmm7; \
+	pxor %xmm3,%xmm1; \
+	pxor %xmm6,%xmm4; \
+	pxor %xmm5,%xmm2; \
+	pxor S8_a1,%xmm5; \
+	pand %xmm3,%xmm6; \
+	movdqa %xmm1,S8_x14; \
+	pand %xmm4,%xmm5; \
+	movdqa %xmm7,S8_x33; \
+	movdqa %xmm0,%xmm1; \
+	pand S8_a5,%xmm3; \
+	movdqa %xmm0,%xmm7; \
+	pand S8_a5,%xmm1; \
+	pxor %xmm3,%xmm7; \
+	pand S8_a2,%xmm7; \
+	pxor %xmm1,%xmm6; \
+	movdqa S8_a6,%xmm1; \
+	pxor %xmm4,%xmm7; \
+	por S8_a2,%xmm6; \
+	pandn %xmm0,%xmm4; \
+	pxor S8_x14,%xmm6; \
+	pand %xmm2,%xmm1; \
+	pxor S8_a1,%xmm3; \
+	pxor %xmm6,%xmm2; \
+	por S8_a6,%xmm6; \
+	pxor %xmm7,%xmm1; \
+	pxor S8_x22,%xmm3; \
+	pxor %xmm7,%xmm6; \
+	por S8_a2,%xmm4; \
+	pand S8_a2,%xmm5; \
+	pxor %xmm4,%xmm3; \
+	movdqa S8_a1,%xmm4; \
+	pand S8_x33,%xmm4; \
+	por S8_a4,%xmm7; \
+	pxor %xmm4,%xmm0; \
+	pand S8_a2,%xmm7; \
+	pxor %xmm0,%xmm5; \
+	movdqa S8_a6,%xmm4; \
+	por %xmm0,%xmm2; \
+	pxor S8_x33,%xmm7; \
+	por %xmm4,%xmm5; \
+	pxor out1,%xmm6; \
+	pand %xmm4,%xmm2; \
+	pxor out4,%xmm1; \
+	pxor %xmm7,%xmm5; \
+	pxor %xmm3,%xmm2; \
+	pxor out3,%xmm5; \
+	movdqa %xmm6,out1; \
+	pxor out2,%xmm2; \
+	movdqa %xmm1,out4; \
+	movdqa %xmm5,out3; \
+	movdqa %xmm2,out2
+
+#define zero				%xmm0
+
+#define DES_bs_clear_block_8(i) \
+	movdqa zero,B(i); \
+	movdqa zero,B(i + 1); \
+	movdqa zero,B(i + 2); \
+	movdqa zero,B(i + 3); \
+	movdqa zero,B(i + 4); \
+	movdqa zero,B(i + 5); \
+	movdqa zero,B(i + 6); \
+	movdqa zero,B(i + 7)
+
+#define DES_bs_clear_block \
+	DES_bs_clear_block_8(0); \
+	DES_bs_clear_block_8(8); \
+	DES_bs_clear_block_8(16); \
+	DES_bs_clear_block_8(24); \
+	DES_bs_clear_block_8(32); \
+	DES_bs_clear_block_8(40); \
+	DES_bs_clear_block_8(48); \
+	DES_bs_clear_block_8(56)
+
+#define k_ptr				%edx
+#define K(i)				nvec(i)(k_ptr)
+#define k(i)				nptr(i)(k_ptr)
+
+#define a6_xor_ptr			%esi
+#define a6_p				pxor (a6_xor_ptr),a6
+#define a6_v(i)				pxor K(i),a6
+
+#define tmp1				%ecx
+#define tmp2				a6_xor_ptr
+
+#define xor_E(i) \
+	movl E(i),tmp1; \
+	movdqa K(i),a1; \
+	movl E(i + 1),tmp2; \
+	movdqa K(i + 1),a2; \
+	pxor (tmp1),a1; \
+	pxor (tmp2),a2; \
+	movl E(i + 2),tmp1; \
+	movdqa K(i + 2),a3; \
+	movl E(i + 3),tmp2; \
+	movdqa K(i + 3),a4; \
+	pxor (tmp1),a3; \
+	pxor (tmp2),a4; \
+	movl E(i + 4),tmp1; \
+	movdqa K(i + 4),a5; \
+	movl E(i + 5),a6_xor_ptr; \
+	movdqa K(i + 5),a6; \
+	pxor (tmp1),a5
+
+#define xor_B(b1, k1, b2, k2, b3, k3, b4, k4, b5, k5, b6) \
+	movdqa B(b1),a1; \
+	movdqa B(b2),a2; \
+	pxor K(k1),a1; \
+	movdqa B(b3),a3; \
+	pxor K(k2),a2; \
+	movdqa B(b4),a4; \
+	pxor K(k3),a3; \
+	movdqa B(b5),a5; \
+	pxor K(k4),a4; \
+	movdqa B(b6),a6; \
+	pxor K(k5),a5
+
+#define xor_B_KS_p(b1, k1, b2, k2, b3, k3, b4, k4, b5, k5, b6, k6) \
+	movl k(k1),tmp1; \
+	movl k(k2),tmp2; \
+	movdqa B(b1),a1; \
+	movdqa B(b2),a2; \
+	pxor (tmp1),a1; \
+	movl k(k3),tmp1; \
+	pxor (tmp2),a2; \
+	movl k(k4),tmp2; \
+	movdqa B(b3),a3; \
+	movdqa B(b4),a4; \
+	pxor (tmp1),a3; \
+	movl k(k5),tmp1; \
+	pxor (tmp2),a4; \
+	movdqa B(b5),a5; \
+	movl k(k6),a6_xor_ptr; \
+	movdqa B(b6),a6; \
+	pxor (tmp1),a5
+
+.text
+
+DO_ALIGN(5)
+.globl DES_bs_init_asm
+DES_bs_init_asm:
+	pcmpeqd %xmm0,%xmm0
+	movdqa %xmm0,pnot
+	ret
+
+#define rounds_and_swapped		%ebp
+#define iterations			%eax
+
+DO_ALIGN(5)
+.globl DES_bs_crypt
+DES_bs_crypt:
+	movl 4(%esp),iterations
+	pxor zero,zero
+	pushl %ebp
+	pushl %esi
+	movl $DES_bs_all_KS_v,k_ptr
+	DES_bs_clear_block
+	movl $8,rounds_and_swapped
+DES_bs_crypt_start:
+	xor_E(0)
+	S1(B(40), B(48), B(54), B(62), a6_p)
+	xor_E(6)
+	S2(B(44), B(59), B(33), B(49), a6_p)
+	xor_E(12)
+	S3(B(55), B(47), B(61), B(37), a6_p)
+	xor_E(18)
+	S4(B(57), B(51), B(41), B(32), a6_p)
+	xor_E(24)
+	S5(B(39), B(45), B(56), B(34), a6_p)
+	xor_E(30)
+	S6(B(35), B(60), B(42), B(50), a6_p)
+	xor_E(36)
+	S7(B(63), B(43), B(53), B(38), a6_p)
+	xor_E(42)
+	S8(B(36), B(58), B(46), B(52), a6_p)
+	cmpl $0x100,rounds_and_swapped
+	je DES_bs_crypt_next
+DES_bs_crypt_swap:
+	xor_E(48)
+	S1(B(8), B(16), B(22), B(30), a6_p)
+	xor_E(54)
+	S2(B(12), B(27), B(1), B(17), a6_p)
+	xor_E(60)
+	S3(B(23), B(15), B(29), B(5), a6_p)
+	xor_E(66)
+	S4(B(25), B(19), B(9), B(0), a6_p)
+	xor_E(72)
+	S5(B(7), B(13), B(24), B(2), a6_p)
+	xor_E(78)
+	S6(B(3), B(28), B(10), B(18), a6_p)
+	xor_E(84)
+	S7(B(31), B(11), B(21), B(6), a6_p)
+	xor_E(90)
+	addl $nvec(96),k_ptr
+	S8(B(4), B(26), B(14), B(20), a6_p)
+	decl rounds_and_swapped
+	jnz DES_bs_crypt_start
+	subl $nvec(0x300+48),k_ptr
+	movl $0x108,rounds_and_swapped
+	decl iterations
+	jnz DES_bs_crypt_swap
+	popl %esi
+	popl %ebp
+	ret
+DES_bs_crypt_next:
+	subl $nvec(0x300-48),k_ptr
+	movl $8,rounds_and_swapped
+	decl iterations
+	jnz DES_bs_crypt_start
+	popl %esi
+	popl %ebp
+	ret
+
+DO_ALIGN(5)
+.globl DES_bs_crypt_25
+DES_bs_crypt_25:
+	pxor zero,zero
+	pushl %ebp
+	pushl %esi
+	movl $DES_bs_all_KS_v,k_ptr
+	DES_bs_clear_block
+	movl $8,rounds_and_swapped
+	movl $25,iterations
+DES_bs_crypt_25_start:
+	xor_E(0)
+	S1(B(40), B(48), B(54), B(62), a6_p)
+	xor_E(6)
+	S2(B(44), B(59), B(33), B(49), a6_p)
+	xor_B(7, 12, 8, 13, 9, 14, 10, 15, 11, 16, 12)
+	S3(B(55), B(47), B(61), B(37), a6_v(17))
+	xor_B(11, 18, 12, 19, 13, 20, 14, 21, 15, 22, 16)
+	S4(B(57), B(51), B(41), B(32), a6_v(23))
+	xor_E(24)
+	S5(B(39), B(45), B(56), B(34), a6_p)
+	xor_E(30)
+	S6(B(35), B(60), B(42), B(50), a6_p)
+	xor_B(23, 36, 24, 37, 25, 38, 26, 39, 27, 40, 28)
+	S7(B(63), B(43), B(53), B(38), a6_v(41))
+	xor_B(27, 42, 28, 43, 29, 44, 30, 45, 31, 46, 0)
+	S8(B(36), B(58), B(46), B(52), a6_v(47))
+	cmpl $0x100,rounds_and_swapped
+	je DES_bs_crypt_25_next
+DES_bs_crypt_25_swap:
+	xor_E(48)
+	S1(B(8), B(16), B(22), B(30), a6_p)
+	xor_E(54)
+	S2(B(12), B(27), B(1), B(17), a6_p)
+	xor_B(39, 60, 40, 61, 41, 62, 42, 63, 43, 64, 44)
+	S3(B(23), B(15), B(29), B(5), a6_v(65))
+	xor_B(43, 66, 44, 67, 45, 68, 46, 69, 47, 70, 48)
+	S4(B(25), B(19), B(9), B(0), a6_v(71))
+	xor_E(72)
+	S5(B(7), B(13), B(24), B(2), a6_p)
+	xor_E(78)
+	S6(B(3), B(28), B(10), B(18), a6_p)
+	xor_B(55, 84, 56, 85, 57, 86, 58, 87, 59, 88, 60)
+	S7(B(31), B(11), B(21), B(6), a6_v(89))
+	xor_B(59, 90, 60, 91, 61, 92, 62, 93, 63, 94, 32)
+	S8(B(4), B(26), B(14), B(20), a6_v(95))
+	addl $nvec(96),k_ptr
+	decl rounds_and_swapped
+	jnz DES_bs_crypt_25_start
+	subl $nvec(0x300+48),k_ptr
+	movl $0x108,rounds_and_swapped
+	decl iterations
+	jnz DES_bs_crypt_25_swap
+	popl %esi
+	popl %ebp
+	ret
+DES_bs_crypt_25_next:
+	subl $nvec(0x300-48),k_ptr
+	movl $8,rounds_and_swapped
+	decl iterations
+	jmp DES_bs_crypt_25_start
+
+#define ones				%xmm1
+
+#define rounds				%eax
+
+DO_ALIGN(5)
+.globl DES_bs_crypt_LM
+DES_bs_crypt_LM:
+	pxor zero,zero
+	pushl %esi
+	pcmpeqd ones,ones
+	movl $DES_bs_all_KS_p,k_ptr
+	movdqa zero,B(0)
+	movdqa zero,B(1)
+	movdqa zero,B(2)
+	movdqa zero,B(3)
+	movdqa zero,B(4)
+	movdqa zero,B(5)
+	movdqa zero,B(6)
+	movdqa zero,B(7)
+	movdqa ones,B(8)
+	movdqa ones,B(9)
+	movdqa ones,B(10)
+	movdqa zero,B(11)
+	movdqa ones,B(12)
+	movdqa zero,B(13)
+	movdqa zero,B(14)
+	movdqa zero,B(15)
+	movdqa zero,B(16)
+	movdqa zero,B(17)
+	movdqa zero,B(18)
+	movdqa zero,B(19)
+	movdqa zero,B(20)
+	movdqa zero,B(21)
+	movdqa zero,B(22)
+	movdqa ones,B(23)
+	movdqa zero,B(24)
+	movdqa zero,B(25)
+	movdqa ones,B(26)
+	movdqa zero,B(27)
+	movdqa zero,B(28)
+	movdqa ones,B(29)
+	movdqa ones,B(30)
+	movdqa ones,B(31)
+	movdqa zero,B(32)
+	movdqa zero,B(33)
+	movdqa zero,B(34)
+	movdqa ones,B(35)
+	movdqa zero,B(36)
+	movdqa ones,B(37)
+	movdqa ones,B(38)
+	movdqa ones,B(39)
+	movdqa zero,B(40)
+	movdqa zero,B(41)
+	movdqa zero,B(42)
+	movdqa zero,B(43)
+	movdqa zero,B(44)
+	movdqa ones,B(45)
+	movdqa zero,B(46)
+	movdqa zero,B(47)
+	movdqa ones,B(48)
+	movdqa ones,B(49)
+	movdqa zero,B(50)
+	movdqa zero,B(51)
+	movdqa zero,B(52)
+	movdqa zero,B(53)
+	movdqa ones,B(54)
+	movdqa zero,B(55)
+	movdqa ones,B(56)
+	movdqa zero,B(57)
+	movdqa ones,B(58)
+	movdqa zero,B(59)
+	movdqa ones,B(60)
+	movdqa ones,B(61)
+	movdqa ones,B(62)
+	movdqa ones,B(63)
+	movl $8,rounds
+DES_bs_crypt_LM_loop:
+	xor_B_KS_p(31, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5)
+	S1(B(40), B(48), B(54), B(62), a6_p)
+	xor_B_KS_p(3, 6, 4, 7, 5, 8, 6, 9, 7, 10, 8, 11)
+	S2(B(44), B(59), B(33), B(49), a6_p)
+	xor_B_KS_p(7, 12, 8, 13, 9, 14, 10, 15, 11, 16, 12, 17)
+	S3(B(55), B(47), B(61), B(37), a6_p)
+	xor_B_KS_p(11, 18, 12, 19, 13, 20, 14, 21, 15, 22, 16, 23)
+	S4(B(57), B(51), B(41), B(32), a6_p)
+	xor_B_KS_p(15, 24, 16, 25, 17, 26, 18, 27, 19, 28, 20, 29)
+	S5(B(39), B(45), B(56), B(34), a6_p)
+	xor_B_KS_p(19, 30, 20, 31, 21, 32, 22, 33, 23, 34, 24, 35)
+	S6(B(35), B(60), B(42), B(50), a6_p)
+	xor_B_KS_p(23, 36, 24, 37, 25, 38, 26, 39, 27, 40, 28, 41)
+	S7(B(63), B(43), B(53), B(38), a6_p)
+	xor_B_KS_p(27, 42, 28, 43, 29, 44, 30, 45, 31, 46, 0, 47)
+	S8(B(36), B(58), B(46), B(52), a6_p)
+	xor_B_KS_p(63, 48, 32, 49, 33, 50, 34, 51, 35, 52, 36, 53)
+	S1(B(8), B(16), B(22), B(30), a6_p)
+	xor_B_KS_p(35, 54, 36, 55, 37, 56, 38, 57, 39, 58, 40, 59)
+	S2(B(12), B(27), B(1), B(17), a6_p)
+	xor_B_KS_p(39, 60, 40, 61, 41, 62, 42, 63, 43, 64, 44, 65)
+	S3(B(23), B(15), B(29), B(5), a6_p)
+	xor_B_KS_p(43, 66, 44, 67, 45, 68, 46, 69, 47, 70, 48, 71)
+	S4(B(25), B(19), B(9), B(0), a6_p)
+	xor_B_KS_p(47, 72, 48, 73, 49, 74, 50, 75, 51, 76, 52, 77)
+	S5(B(7), B(13), B(24), B(2), a6_p)
+	xor_B_KS_p(51, 78, 52, 79, 53, 80, 54, 81, 55, 82, 56, 83)
+	S6(B(3), B(28), B(10), B(18), a6_p)
+	xor_B_KS_p(55, 84, 56, 85, 57, 86, 58, 87, 59, 88, 60, 89)
+	S7(B(31), B(11), B(21), B(6), a6_p)
+	xor_B_KS_p(59, 90, 60, 91, 61, 92, 62, 93, 63, 94, 32, 95)
+	addl $nptr(96),k_ptr
+	S8(B(4), B(26), B(14), B(20), a6_p)
+	decl rounds
+	jnz DES_bs_crypt_LM_loop
+	popl %esi
+	ret
+
+#endif
+
+
+/* The following was written by Alain Espinosa <alainesp at gmail.com> in 2007.
+ * No copyright is claimed, and the software is hereby placed in the public domain.
+ * In case this attempt to disclaim copyright and place the software in the
+ * public domain is deemed null and void, then the software is
+ * Copyright (c) 2007 Alain Espinosa and it is hereby released to the
+ * general public under the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * There's ABSOLUTELY NO WARRANTY, express or implied.
+ *
+ * (This is a heavily cut-down "BSD license".)
+ */
+
+/*
+ * FIXME: this depends on the assembler being able to multiply, which won't
+ * work on Solaris (unless the use of GNU assembler is forced).
+ */
+
+#ifdef UNDERSCORES
+#define nt_crypt_all_sse2 _nt_crypt_all_sse2
+#define nt_buffer1x _nt_buffer1x
+#define nt_buffer4x _nt_buffer4x
+#define output1x _output1x
+#define output4x _output4x
+#endif
+
+/*
+extern nt_crypt_all_sse2(int count);
+*/
+
+.globl nt_crypt_all_sse2
+
+.data
+DO_ALIGN(6)
+const_init_a:
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+const_init_b:
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+const_init_c:
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+const_init_d:
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+
+const_stage2:
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+const_stage3:
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+
+#define a  %xmm0
+#define b  %xmm1
+#define c  %xmm2
+#define d  %xmm3
+#define t1 %xmm4
+#define t2 %xmm5
+#define t3 %xmm6
+#define t4 %xmm7
+
+#undef a3
+#define a3  %eax
+#define b3  %ebx
+#define c3  %ecx
+#define d3  %edx
+#define t13 %esi
+#define t23 %edi
+#define Q2 $0x5a827999
+#define Q3 $0x6ed9eba1
+
+#define STEP1(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (256*base)+(x*16)+nt_buffer4x, aa;		\
+	addl (64*base)+(x*4)+nt_buffer1x, aa3;			\
+	movdqa cc, t1;						\
+	movl cc3, t13;						\
+	pxor dd, t1;						\
+	xorl dd3, t13;						\
+	pand bb, t1;						\
+	andl bb3, t13;						\
+	pxor dd, t1;						\
+	xorl dd3, t13;						\
+	paddd t1, aa;						\
+	addl t13, aa3;						\
+	movdqa aa, t2;						\
+	roll $s, aa3;						\
+	pslld $s, aa;						\
+	psrld $(32-s), t2;					\
+	por t2, aa;
+
+#define STEP2(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (256*base)+(x*16)+nt_buffer4x, aa;		\
+	addl (64*base)+(x*4)+nt_buffer1x, aa3;			\
+	movdqa cc, t1;						\
+	movl cc3, t13;						\
+	movdqa cc, t2;						\
+	movl cc3, t23;						\
+	por dd, t1;						\
+	orl dd3, t13;						\
+	pand dd, t2;						\
+	andl dd3, t23;						\
+	pand bb, t1;						\
+	andl bb3, t13;						\
+	paddd t3, aa;						\
+	addl Q2, aa3;						\
+	por t2, t1;						\
+	orl t23, t13;						\
+	paddd t1, aa;						\
+	addl t13, aa3;						\
+	movdqa aa, t1;						\
+	roll $s, aa3;						\
+	pslld $s, aa;						\
+	psrld $(32-s), t1;					\
+	por t1, aa;
+
+#define STEP3(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (256*base)+(x*16)+nt_buffer4x, aa;		\
+	addl (64*base)+(x*4)+nt_buffer1x, aa3;			\
+	movdqa dd, t1;						\
+	movl dd3, t13;						\
+	pxor cc, t1;						\
+	xorl cc3, t13;						\
+	paddd t4, aa;						\
+	addl Q3, aa3;						\
+	pxor bb, t1;						\
+	xorl bb3, t13;						\
+	paddd t1, aa;						\
+	addl t13, aa3;						\
+	movdqa aa, t1;						\
+	roll $s, aa3;						\
+	pslld $s, aa;						\
+	psrld $(32-s), t1;					\
+	por t1, aa;
+
+#define NT_CRYPT_BODY(base)					\
+	movdqa const_init_a, a;					\
+	movl const_init_a, a3;					\
+	movdqa const_init_b, b;					\
+	movl const_init_b, b3;					\
+	movdqa const_init_c, c;					\
+	movl const_init_c, c3;					\
+	movdqa const_init_d, d;					\
+	movl const_init_d, d3;					\
+								\
+	paddd (256*base)+nt_buffer4x, a;			\
+	addl (64*base)+nt_buffer1x, a3;				\
+	pslld $3, a;						\
+	roll $3, a3;						\
+								\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 1 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 2 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 3 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 4 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 5 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 7 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 8 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 9 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 10, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 11, 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 12, 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 13, 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 14, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 15, 19, base)		\
+								\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 4 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 8 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 12, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 5 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 9 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 13, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 6 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 10, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 14, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 3 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 7 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 11, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 15, 13, base)		\
+								\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 8 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 4 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 12, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 10, 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 14, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 9 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 5 , 11, base)		\
+	movdqa a, t1;						\
+	movl a3, t13;						\
+	paddd (256*base)+208+nt_buffer4x, b;			\
+	addl (64*base)+52+nt_buffer1x, b3;			\
+	pxor d, t1;						\
+	xorl d3,t13;						\
+	pxor c, t1;						\
+	xorl c3,t13;						\
+	paddd t1, b;						\
+	addl t13,b3;						\
+								\
+	movdqa a,  (64*base)+output4x;				\
+	movl a3,  (16*base)+output1x;				\
+	movdqa b, (64*base)+16+output4x;			\
+	movl b3,  (16*base)+4+output1x;				\
+	movdqa c, (64*base)+32+output4x;			\
+	movl c3,  (16*base)+8+output1x;				\
+	movdqa d, (64*base)+48+output4x;			\
+	movl d3,  (16*base)+12+output1x;
+	
+.text
+
+DO_ALIGN(6)
+
+nt_crypt_all_sse2:
+	pusha
+		
+	movdqa const_stage2, t3
+	movdqa const_stage3, t4
+
+	NT_CRYPT_BODY(0)
+	NT_CRYPT_BODY(1)
+	NT_CRYPT_BODY(2)
+	NT_CRYPT_BODY(3)
+	NT_CRYPT_BODY(4)
+	NT_CRYPT_BODY(5)
+	NT_CRYPT_BODY(6)
+	NT_CRYPT_BODY(7)
+
+	popa
+
+	ret
+
+#if defined(__ELF__) && defined(__linux__)
+.section .note.GNU-stack,"",@progbits
+#endif
diff -rupN john-1.7.8/src/unused/zipdump john-1.7.8-jumbo-2/src/unused/zipdump
--- john-1.7.8/src/unused/zipdump	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/unused/zipdump	2011-06-17 01:30:00.000000000 +0200
@@ -0,0 +1,2 @@
+winzip-AES-128-testpassword#.zip:$zip$*0*1*8005b1b7d077708d*dee4
+winzip-AES-256-testpassword#.zip:$zip$*0*3*e3bd6c1a4c4950d0c35c1b0ca2bd5e84*061f
diff -rupN john-1.7.8/src/wordlist.c john-1.7.8-jumbo-2/src/wordlist.c
--- john-1.7.8/src/wordlist.c	2011-03-20 15:49:28.000000000 +0100
+++ john-1.7.8-jumbo-2/src/wordlist.c	2011-05-22 01:36:41.000000000 +0200
@@ -1,14 +1,22 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-99,2003,2004,2006,2009 by Solar Designer
+ *
+ * Heavily modified by JimF and maybe by others.
  */
 
 #define _POSIX_SOURCE /* for fileno(3) */
+
 #include <stdio.h>
 #include <sys/stat.h>
+#ifndef _MSC_VER
 #include <unistd.h>
+#else
+#pragma warning ( disable : 4996 )
+#endif
 #include <string.h>
 
+#include "arch.h"
 #include "misc.h"
 #include "math.h"
 #include "params.h"
@@ -23,9 +31,16 @@
 #include "rules.h"
 #include "external.h"
 #include "cracker.h"
+#include "memory.h"
+
+#ifdef HAVE_MPI
+#include "john-mpi.h"
+
+static int distributeWords, distributeRules, myrulecount;
+#endif
 
 static FILE *word_file = NULL;
-static int progress = 0;
+static int progress = 0, hund_progress = 0;
 
 static int rec_rule;
 static long rec_pos;
@@ -34,6 +49,17 @@ static int rule_number, rule_count, line
 static int length;
 static struct rpp_context *rule_ctx;
 
+// used for file in 'memory map' mode
+static char *word_file_str, **words;
+
+#ifdef HAVE_MPI
+static unsigned int nWordFileLines;
+#else
+static unsigned int nWordFileLines = 0, nCurLine;
+#endif
+
+static struct db_main *_db;
+
 static void save_state(FILE *file)
 {
 	fprintf(file, "%d\n%ld\n", rec_rule, rec_pos);
@@ -71,14 +97,50 @@ static int restore_state(FILE *file)
 
 	if (word_file == stdin)
 		restore_line_number();
-	else
-		if (fseek(word_file, rec_pos, SEEK_SET)) pexit("fseek");
+	else {
+		if (nWordFileLines) {
+#ifdef HAVE_MPI
+			for (line_number = 0; line_number < nWordFileLines; ++line_number) {
+				if (words[line_number] - words[0] >= rec_pos)
+#else
+			for (nCurLine = 0; nCurLine < nWordFileLines; ++nCurLine) {
+				if (words[nCurLine] - words[0] >= rec_pos)
+#endif
+					break;
+			}
+		}
+#ifdef HAVE_MPI
+		else {
+			if (fseek(word_file, rec_pos, SEEK_SET)) pexit("fseek");
+			line_number = rec_pos ? mpi_id : 0;    // we just need the correct modulus
+		}
+#else
+		else
+			if (fseek(word_file, rec_pos, SEEK_SET)) pexit("fseek");
+#endif
+	}
 
 	return 0;
 }
 
+static int fix_state_delay;
+
 static void fix_state(void)
 {
+	if (nWordFileLines) {
+		rec_rule = rule_number;
+#ifdef HAVE_MPI
+		rec_pos = words[line_number] - words[0];
+#else
+		rec_pos = words[nCurLine] - words[0];
+#endif
+		return;
+	}
+
+	if (++fix_state_delay < _db->options->max_fix_state_delay)
+		return;
+	fix_state_delay=0;
+
 	rec_rule = rule_number;
 
 	if (word_file == stdin)
@@ -94,31 +156,58 @@ static void fix_state(void)
 	}
 }
 
-static int get_progress(void)
+static int get_progress(int *hundth_perc)
 {
 	struct stat file_stat;
 	long pos;
-	int64 x100;
+	int hundredXpercent, percent;
+#ifndef HAVE_MPI
+	double x100, tmp;
+#endif
 
-	if (!word_file) return progress;
+	if (!word_file) {
+		*hundth_perc = hund_progress;
+		return progress;
+	}
 
-	if (word_file == stdin) return -1;
+	if (word_file == stdin) {
+		*hundth_perc = 0;
+		return -1;
+	}
 
 	if (fstat(fileno(word_file), &file_stat)) pexit("fstat");
-
-	if ((pos = ftell(word_file)) < 0) {
+	if (nWordFileLines) {
+		pos = rec_pos;
+	}
+	else {
+		if ((pos = ftell(word_file)) < 0) {
 #ifdef __DJGPP__
-		if (pos != -1)
-			pos = 0;
-		else
+			if (pos != -1)
+				pos = 0;
+			else
 #endif
-			pexit("ftell");
+				pexit("ftell");
+		}
 	}
 
-	mul32by32(&x100, pos, 100);
-	return
-		(rule_number * 100 +
-		div64by32lo(&x100, file_stat.st_size + 1)) / rule_count;
+#ifdef HAVE_MPI
+	if (distributeRules)
+		hundredXpercent = (int)((long long)(10000 * (rule_number / mpi_p * file_stat.st_size + pos)) /
+		                        (long long)(myrulecount * file_stat.st_size));
+	else
+		hundredXpercent = (int)((long long)(10000 * (rule_number * file_stat.st_size + pos)) /
+		                        (long long)(rule_count * file_stat.st_size));
+#else
+	x100 = ((double)pos) * 10000.;
+	// a double 'tmp' var is required, as I have seen the compiler
+	// optimize away the next statement if assigned to an int
+	tmp = (((double)rule_number)*10000. + x100/(file_stat.st_size+1)) / rule_count;
+	// safe int assignment.  tmp will be from 0 to 10000.00
+	hundredXpercent = (int)tmp;
+#endif
+	percent = hundredXpercent / 100;
+	*hundth_perc = hundredXpercent - (percent*100);
+	return percent;
 }
 
 static char *dummy_rules_apply(char *word, char *rule, int split, char *last)
@@ -139,13 +228,156 @@ void do_wordlist_crack(struct db_main *d
 	struct rpp_context ctx;
 	char *prerule, *rule, *word;
 	char *(*apply)(char *word, char *rule, int split, char *last);
+	long file_len;
+	int i;
+#ifdef HAVE_MPI
+	char file_line[LINE_BUFFER_SIZE];
+	long my_size = 0;
+	unsigned int myWordFileLines = 0;
+#endif
 
 	log_event("Proceeding with wordlist mode");
 
+	_db = db;
+
 	if (name) {
-		if (!(word_file = fopen(path_expand(name), "r")))
+		char *cp, csearch;
+
+		if (!(word_file = fopen(path_expand(name), "rb")))
 			pexit("fopen: %s", path_expand(name));
 		log_event("- Wordlist file: %.100s", path_expand(name));
+
+		/* this will both get us the file length, and tell us
+		   of 'invalid' files (i.e. too big in Win32 or other
+		   32 bit OS's.  A file between 2gb and 4gb returns
+		   a negative number.  NOTE john craps out on files
+		   this big.  The file needs cut before running through
+		   through john */
+		fseek(word_file, 0, SEEK_END);
+		file_len = ftell(word_file);
+		fseek(word_file, 0, SEEK_SET);
+		if (file_len < 0)
+		{
+			fprintf(stderr, "Error, dictionary file is too large for john to read (probably a 32 bit OS issue)\n");
+			error();
+		}
+		/* If the file is < max_wordfile_memory, then we work from a memory map of the file */
+#ifdef HAVE_MPI
+		if ((mpi_p > 1 && file_len > mpi_p * 100 && file_len / mpi_p < db->options->max_wordfile_memory) ||
+		    (file_len < db->options->max_wordfile_memory || db->options->max_wordfile_memory == 0)) {
+			// Load only this node's share of words to memory
+			char *aep;
+
+			if (mpi_p > 1 && (file_len > mpi_p * 100 || db->options->max_wordfile_memory == 0)) {
+				// Check size for our share. This depends on line
+				// lengths so we can't just split file_len
+				for (nWordFileLines = 0;; ++nWordFileLines) {
+					if (!fgets(file_line, sizeof(file_line), word_file)) {
+						if (ferror(word_file))
+							pexit("fgets");
+						else
+							break;
+					}
+					if (nWordFileLines % mpi_p == mpi_id) {
+						my_size += strlen(file_line);
+					}
+				}
+				fseek(word_file, 0, SEEK_SET);
+
+				// Now copy just our share to memory
+				word_file_str = mem_alloc(my_size + 1);
+				i = 0;
+				for (myWordFileLines = 0;; ++myWordFileLines) {
+					if (!fgets(file_line, sizeof(file_line), word_file)) {
+						if (ferror(word_file))
+							pexit("fgets");
+						else
+							break;
+					}
+					if (myWordFileLines % mpi_p == mpi_id) {
+						strcpy(&word_file_str[i], file_line);
+						i += (int)strlen(&word_file_str[i]);
+					}
+				}
+				log_event("- loaded this node's share of wordfile %s into memory "
+				          "(%lu bytes of %lu, max_size=%u avg/node)",
+				          name, my_size, file_len, db->options->max_wordfile_memory);
+				if (mpi_id == 0)
+					fprintf(stderr,"MPI: each node loaded 1/%d of wordfile to memory (about %lu %s/node)\n",
+					        mpi_p,
+					        my_size > 1<<23 ? my_size >> 20 : my_size >> 10,
+					        my_size > 1<<23 ? "MB" : "KB");
+				aep = word_file_str + my_size;
+				file_len = my_size;
+			}
+			else {
+				log_event("- loading wordfile %s into memory (%lu bytes, max_size=%u)",
+				          name, file_len, db->options->max_wordfile_memory);
+				if (mpi_p > 1 && mpi_id == 0)
+					fprintf(stderr,"MPI: each node loaded the whole wordfile to memory\n");
+				word_file_str = mem_alloc(file_len + 1);
+				if (fread(word_file_str, 1, file_len, word_file) != file_len) {
+					if (ferror(word_file))
+						pexit("fread");
+					fprintf(stderr, "fread: Unexpected EOF\n");
+					error();
+				}
+				aep = word_file_str + file_len;
+#else
+		if (file_len < db->options->max_wordfile_memory ||
+		    db->options->max_wordfile_memory == 0)
+		{
+			char *aep;
+
+			/* probably should only be debug message, but I left it in */
+			log_event("loading wordfile %s into memory (%lu bytes, max_size=%u)\n", name, file_len, db->options->max_wordfile_memory);
+/* XXX: would need to alloc more for dummy_rules_apply()'s "blind truncation" */
+			word_file_str = mem_alloc(file_len+1);
+			if (fread(word_file_str, 1, file_len, word_file) != file_len) {
+				if (ferror(word_file))
+					pexit("fread");
+				fprintf(stderr, "fread: Unexpected EOF\n");
+				error();
+#endif
+			}
+			aep = word_file_str + file_len;
+			*aep = 0;
+			csearch = '\n';
+			cp = memchr(word_file_str, csearch, file_len);
+			if (!cp)
+			{
+				csearch = '\r';
+				cp = memchr(word_file_str, csearch, file_len);
+			}
+			for (nWordFileLines = 1; cp; ++nWordFileLines)
+				cp = memchr(&cp[1], csearch, file_len - (cp - word_file_str) - 1);
+			words = mem_alloc(nWordFileLines * sizeof(char*));
+			log_event("wordfile had %u lines and required %lu bytes for index.\n", nWordFileLines, (unsigned long)(nWordFileLines * sizeof(char*)));
+
+			i = 0;
+			cp = word_file_str;
+			do
+			{
+				char *ep = cp, ec;
+				while ((ep < aep) && *ep && *ep != '\n' && *ep != '\r') ep++;
+				ec = *ep;
+				*ep = 0;
+				if (ep - cp >= LINE_BUFFER_SIZE)
+					cp[LINE_BUFFER_SIZE-1] = 0;
+				if (strncmp(cp, "#!comment", 9))
+					words[i++] = cp;
+				if (i == nWordFileLines)
+					break;
+				cp = ep + 1;
+				if (ec == '\r' && *cp == '\n') cp++;
+			} while (cp < aep);
+			nWordFileLines = i;
+#ifdef HAVE_MPI
+			line_number = 0;
+#else
+			nCurLine=0;
+#endif
+		}
 	} else {
 		word_file = stdin;
 		log_event("- Reading candidate passwords from stdin");
@@ -154,8 +386,11 @@ void do_wordlist_crack(struct db_main *d
 	length = db->format->params.plaintext_length;
 
 	if (rules) {
-		if (rpp_init(rule_ctx = &ctx, SUBSECTION_WORDLIST)) {
+		if (rpp_init(rule_ctx = &ctx, db->options->activewordlistrules)) {
 			log_event("! No wordlist mode rules found");
+#ifdef HAVE_MPI
+			if (mpi_id == 0)
+#endif
 			fprintf(stderr, "No wordlist mode rules found in %s\n",
 				cfg_name);
 			error();
@@ -176,6 +411,46 @@ void do_wordlist_crack(struct db_main *d
 		apply = dummy_rules_apply;
 	}
 
+#ifdef HAVE_MPI
+	if (mpi_p > 1) {
+		// Leapfrogging rules is less overhead unless we have wordfile in memory
+
+		// Do not leapfrog at all if we have a split wordlist in memory
+		if (!myWordFileLines) {
+
+			// If less rules than nodes, leapfrog words
+			if (rule_count < mpi_p)
+				distributeWords = 1;
+			else
+				distributeRules = 1;
+
+			// Magic debug numbers (should be replaced by proper options)
+			// use --mem = 0 to force split wordlist (no leapfrogging)
+			// use --mem = 1 to force leapfrogging of words
+			// use --mem = 2 to force leapfrogging of rules
+			if (db->options->max_wordfile_memory == 1) {
+				distributeWords = 1;
+				distributeRules = 0;
+			}
+			if (rule_count >= mpi_p && db->options->max_wordfile_memory == 2) {
+				distributeWords = 0;
+				distributeRules = 1;
+			}
+		}
+
+		// Tell user what was chosen.
+		if (distributeWords) {
+			log_event("MPI hack active: will process 1/%u of words", mpi_p);
+			if (mpi_id == 0) fprintf(stderr,"MPI: each node processing 1/%u of words\n", mpi_p);
+		}
+		if (distributeRules) {
+			myrulecount = (int)(rule_count / mpi_p) + (rule_count % mpi_p > mpi_id ? 1 : 0);
+			log_event("MPI hack active: will process 1/%u of rules, total %d for this node", mpi_p, myrulecount);
+			if (mpi_id == 0) fprintf(stderr,"MPI: each node processing 1/%u of %d rules. (%seven split)\n",
+			                         mpi_p, rule_count, rule_count % mpi_p ? "un" : "");
+		}
+	}
+#endif
 	line_number = rule_number = 0;
 
 	status_init(get_progress, 0);
@@ -195,6 +470,12 @@ void do_wordlist_crack(struct db_main *d
 	if (prerule)
 	do {
 		if (rules) {
+#ifdef HAVE_MPI
+			// MPI distribution - leapfrog rules
+			if (distributeRules && rule_number % mpi_p != mpi_id)
+				rule = NULL;
+			else
+#endif
 			if ((rule = rules_reject(prerule, -1, last, db))) {
 				if (strcmp(prerule, rule))
 					log_event("- Rule #%d: '%.100s'"
@@ -210,8 +491,43 @@ void do_wordlist_crack(struct db_main *d
 		}
 
 		if (rule)
-		while (fgetl(line, LINE_BUFFER_SIZE, word_file)) {
+		while (1) {
+			if (nWordFileLines) {
+#ifdef HAVE_MPI
+				if (line_number == nWordFileLines)
+#else
+				if (nCurLine == nWordFileLines)
+#endif
+					break;
+#ifdef HAVE_MPI
+				if (!distributeWords || line_number % mpi_p == mpi_id)
+#endif
+#if 0 && ARCH_ALLOWS_UNALIGNED
+/* XXX: somehow this breaks things - why? */
+#ifdef HAVE_MPI
+					line = words[line_number];
+#else /* HAVE_MPI */
+				line = words[nCurLine++];
+#endif /* HAVE_MPI */
+#else /* 0 && ARCH_ALLOWS_UNALIGNED */
+#ifdef HAVE_MPI
+					strcpy(line, words[line_number]);
+#else /* HAVE_MPI */
+				strcpy(line, words[nCurLine++]);
+#endif /* HAVE_MPI */
+#endif /* 0 && ARCH_ALLOWS_UNALIGNED */
+			}
+			else {
+				if (!fgetl(line, LINE_BUFFER_SIZE, word_file))
+					break;
+			}
+#ifdef HAVE_MPI
+			// MPI distribution - leapfrog words
+			if (line_number++ % mpi_p != mpi_id && distributeWords)
+				continue;
+#else
 			line_number++;
+#endif
 
 			if (line[0] != '#') {
 not_comment:
@@ -236,7 +552,15 @@ not_comment:
 			rule_number++;
 
 			line_number = 0;
-			if (fseek(word_file, 0, SEEK_SET)) pexit("fseek");
+
+#ifdef HAVE_MPI
+			if (!nWordFileLines)
+#else
+			if (nWordFileLines)
+				nCurLine = 0;
+			else
+#endif
+				if (fseek(word_file, 0, SEEK_SET)) pexit("fseek");
 		}
 	} while (rules);
 
@@ -247,10 +571,12 @@ not_comment:
 
 	if (name) {
 		if (event_abort)
-			progress = get_progress();
+			progress = get_progress(&hund_progress);
 		else
 			progress = 100;
 
+		MEM_FREE(word_file_str);
+		MEM_FREE(words);
 		if (fclose(word_file)) pexit("fclose");
 		word_file = NULL;
 	}
diff -rupN john-1.7.8/src/x86-64.S john-1.7.8-jumbo-2/src/x86-64.S
--- john-1.7.8/src/x86-64.S	2011-06-22 10:42:37.000000000 +0200
+++ john-1.7.8-jumbo-2/src/x86-64.S	2011-07-02 21:17:06.000000000 +0200
@@ -22,10 +22,19 @@
  * pass by a loop in the Perl script).
  *
  * The effort has been sponsored by Rapid7: http://www.rapid7.com
+ *
+ * ...with changes in the jumbo patch, by Alain Espinosa (starting with a
+ * comment further down this file).
  */
 
 #include "arch.h"
 
+#ifdef ALIGN_LOG
+#define DO_ALIGN(log)			.align log
+#else
+#define DO_ALIGN(log)			.align 1 << log
+#endif
+
 #if DES_BS_ASM
 
 #ifdef UNDERSCORES
@@ -36,12 +45,6 @@
 #define DES_bs_crypt_LM			_DES_bs_crypt_LM
 #endif
 
-#ifdef ALIGN_LOG
-#define DO_ALIGN(log)			.align log
-#else
-#define DO_ALIGN(log)			.align 1 << log
-#endif
-
 #ifdef __sun
 /* Sun's assembler doesn't recognize .space */
 #define DO_SPACE(size)			.zero size
@@ -964,6 +967,262 @@ DES_bs_crypt_LM_loop:
 
 #endif
 
+/* The following was written by Alain Espinosa <alainesp at gmail.com> in 2007.
+ * No copyright is claimed, and the software is hereby placed in the public domain.
+ * In case this attempt to disclaim copyright and place the software in the
+ * public domain is deemed null and void, then the software is
+ * Copyright (c) 2007 Alain Espinosa and it is hereby released to the
+ * general public under the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * There's ABSOLUTELY NO WARRANTY, express or implied.
+ *
+ * (This is a heavily cut-down "BSD license".)
+ */
+/* ...converted to use %rip-relative addressing, still public domain */
+
+/*
+ * FIXME: this depends on the assembler being able to multiply, which won't
+ * work on Solaris (unless the use of GNU assembler is forced).
+ */
+
+#ifdef UNDERSCORES
+#define nt_crypt_all_x86_64 _nt_crypt_all_x86_64
+#define nt_buffer8x _nt_buffer8x
+#define output8x _output8x
+#endif
+
+/*
+extern nt_crypt_all_x86_64(int count);
+*/
+
+.globl nt_crypt_all_x86_64
+
+.data
+DO_ALIGN(6)
+const_init_a:
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+const_init_b:
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+const_init_c:
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+const_init_d:
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+
+const_stage2:
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+const_stage3:
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+
+#define a  %xmm0
+#define b  %xmm1
+#define c  %xmm2
+#define d  %xmm3
+#define t1 %xmm4
+#define t2 %xmm5
+#define t3 %xmm6
+#define t4 %xmm7
+
+#undef a3
+#define a3  %xmm8
+#define b3  %xmm9
+#define c3  %xmm10
+#define d3  %xmm11
+#define t13 %xmm12
+#define t23 %xmm13
+
+#define STEP1(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (512*base)+(x*32)+nt_buffer8x(%rip), aa;		\
+	paddd (512*base)+(x*32)+16+nt_buffer8x(%rip), aa3;	\
+	movdqa cc, t1;						\
+	movdqa cc3, t13;					\
+	pxor dd, t1;						\
+	pxor dd3, t13;						\
+	pand bb, t1;						\
+	pand bb3, t13;						\
+	pxor dd, t1;						\
+	pxor dd3, t13;						\
+	paddd t1, aa;						\
+	paddd t13, aa3;						\
+	movdqa aa, t2;						\
+	movdqa aa3, t23;					\
+	pslld $s, aa;						\
+	pslld $s, aa3;						\
+	psrld $(32-s), t2;					\
+	psrld $(32-s), t23;					\
+	por t2, aa;						\
+	por t23, aa3;
+
+#define STEP2(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (512*base)+(x*32)+nt_buffer8x(%rip), aa;		\
+	paddd (512*base)+(x*32)+16+nt_buffer8x(%rip), aa3;	\
+	movdqa cc, t1;						\
+	movdqa cc3, t13;					\
+	movdqa cc, t2;						\
+	movdqa cc3, t23;					\
+	por dd, t1;						\
+	por dd3, t13;						\
+	pand dd, t2;						\
+	pand dd3, t23;						\
+	pand bb, t1;						\
+	pand bb3, t13;						\
+	paddd t3, aa;						\
+	paddd t3, aa3;						\
+	por t2, t1;						\
+	por t23, t13;						\
+	paddd t1, aa;						\
+	paddd t13, aa3;						\
+	movdqa aa, t1;						\
+	movdqa aa3, t13;					\
+	pslld $s, aa;						\
+	pslld $s, aa3;						\
+	psrld $(32-s), t1;					\
+	psrld $(32-s), t13;					\
+	por t1, aa;						\
+	por t13, aa3;
+
+#define STEP3(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (512*base)+(x*32)+nt_buffer8x(%rip), aa;		\
+	paddd (512*base)+(x*32)+16+nt_buffer8x(%rip), aa3;	\
+	movdqa dd, t1;						\
+	movdqa dd3, t13;					\
+	pxor cc, t1;						\
+	pxor cc3, t13;						\
+	paddd t4, aa;						\
+	paddd t4, aa3;						\
+	pxor bb, t1;						\
+	pxor bb3, t13;						\
+	paddd t1, aa;						\
+	paddd t13, aa3;						\
+	movdqa aa, t1;						\
+	movdqa aa3, t13;					\
+	pslld $s, aa;						\
+	pslld $s, aa3;						\
+	psrld $(32-s), t1;					\
+	psrld $(32-s), t13;					\
+	por t1, aa;						\
+	por t13, aa3;
+
+#define NT_CRYPT_BODY(base)					\
+	movdqa const_init_a(%rip), a;				\
+	movdqa const_init_a(%rip), a3;				\
+	movdqa const_init_b(%rip), b;				\
+	movdqa const_init_b(%rip), b3;				\
+	movdqa const_init_c(%rip), c;				\
+	movdqa const_init_c(%rip), c3;				\
+	movdqa const_init_d(%rip), d;				\
+	movdqa const_init_d(%rip), d3;				\
+								\
+	paddd (512*base)+nt_buffer8x(%rip), a;			\
+	paddd (512*base)+16+nt_buffer8x(%rip), a3;		\
+	movdqa a, t1;						\
+	movdqa a3, t13;						\
+	pslld $3, a;						\
+	pslld $3, a3;						\
+	psrld $29, t1;						\
+	psrld $29, t13;						\
+	por t1, a;						\
+	por t13, a3;						\
+								\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 1 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 2 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 3 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 4 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 5 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 7 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 8 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 9 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 10, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 11, 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 12, 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 13, 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 14, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 15, 19, base)		\
+								\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 4 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 8 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 12, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 5 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 9 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 13, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 6 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 10, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 14, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 3 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 7 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 11, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 15, 13, base)		\
+								\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 8 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 4 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 12, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 10, 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 14, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 9 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 5 , 11, base)		\
+	movdqa a, t1;						\
+	movdqa a3, t13;						\
+	paddd (512*base)+416+nt_buffer8x(%rip), b;		\
+	paddd (512*base)+416+16+nt_buffer8x(%rip), b3;		\
+	pxor d, t1;						\
+	pxor d3,t13;						\
+	pxor c, t1;						\
+	pxor c3,t13;						\
+	paddd t1, b;						\
+	paddd t13,b3;						\
+								\
+	movdqa a,  (128*base)+output8x(%rip);			\
+	movdqa a3,  (128*base)+16+output8x(%rip);		\
+	movdqa b, (128*base)+32+output8x(%rip);			\
+	movdqa b3, (128*base)+32+16+output8x(%rip);		\
+	movdqa c, (128*base)+64+output8x(%rip);			\
+	movdqa c3, (128*base)+64+16+output8x(%rip);		\
+	movdqa d, (128*base)+96+output8x(%rip);			\
+	movdqa d3, (128*base)+96+16+output8x(%rip);
+
+.text
+
+DO_ALIGN(6)
+
+nt_crypt_all_x86_64:
+	movdqa const_stage2(%rip), t3
+	movdqa const_stage3(%rip), t4
+
+	NT_CRYPT_BODY(0)
+	NT_CRYPT_BODY(1)
+	NT_CRYPT_BODY(2)
+	NT_CRYPT_BODY(3)
+
+	ret
+
 #if defined(__ELF__) && defined(__linux__)
 .section .note.GNU-stack,"",@progbits
 #endif
diff -rupN john-1.7.8/src/x86-64.h john-1.7.8-jumbo-2/src/x86-64.h
--- john-1.7.8/src/x86-64.h	2011-05-04 21:07:58.000000000 +0200
+++ john-1.7.8-jumbo-2/src/x86-64.h	2011-07-02 20:42:27.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 2003,2006,2008,2010,2011 by Solar Designer
+ *
+ * ...with a trivial change in the jumbo patch, by Alain Espinosa.
  */
 
 /*
@@ -139,8 +141,34 @@
 #define MD5_X2				1
 #define MD5_IMM				1
 
+#ifdef __GNUC__
+#define MD5_SSE_PARA		2
+#define MD5_N_STR			"8x"
+#else
+#define MD5_SSE_PARA		3
+#define MD5_N_STR			"12x"
+#endif
+
+#ifdef __GNUC__
+#define MD4_SSE_PARA		2
+#define MD4_N_STR			"8x"
+#else
+#define MD4_SSE_PARA		3
+#define MD4_N_STR			"12x"
+#endif
+
+#ifdef __GNUC__
+#define SHA1_SSE_PARA		2
+#define SHA1_N_STR			"8x"
+#else
+#define SHA1_SSE_PARA		2
+#define SHA1_N_STR			"8x"
+#endif
+
 #define BF_ASM				0
 #define BF_SCALE			1
 #define BF_X2				1
 
+#define NT_X86_64
+
 #endif
diff -rupN john-1.7.8/src/x86-any.h john-1.7.8-jumbo-2/src/x86-any.h
--- john-1.7.8/src/x86-any.h	2010-05-09 22:51:48.000000000 +0200
+++ john-1.7.8-jumbo-2/src/x86-any.h	2011-05-17 18:13:03.000000000 +0200
@@ -1,6 +1,8 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2001,2008,2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC, by JimF.
  */
 
 /*
@@ -20,14 +22,18 @@
 #define ARCH_ALLOWS_UNALIGNED		1
 #define ARCH_INDEX(x)			((unsigned int)(unsigned char)(x))
 
-#if defined(__CYGWIN32__) || defined(__BEOS__)
+#if defined(__CYGWIN32__) || defined(__BEOS__) || defined(__MINGW32__) || defined(_MSC_VER)
 #define OS_TIMER			0
 #else
 #define OS_TIMER			1
 #endif
 #define OS_FLOCK			1
 
+#ifdef _MSC_VER
+#define CPU_DETECT			0
+#else
 #define CPU_DETECT			1
+#endif
 #define CPU_REQ				0
 
 #define DES_ASM				1
diff -rupN john-1.7.8/src/x86-mmx.h john-1.7.8-jumbo-2/src/x86-mmx.h
--- john-1.7.8/src/x86-mmx.h	2010-06-09 19:12:22.000000000 +0200
+++ john-1.7.8-jumbo-2/src/x86-mmx.h	2011-05-17 18:13:03.000000000 +0200
@@ -1,6 +1,9 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2002,2008,2010 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC, by JimF.
+ * ...and introduction of MMX_TYPE and MMX_COEF by Simon Marechal.
  */
 
 /*
@@ -20,14 +23,18 @@
 #define ARCH_ALLOWS_UNALIGNED		1
 #define ARCH_INDEX(x)			((unsigned int)(unsigned char)(x))
 
-#if defined(__CYGWIN32__) || defined(__BEOS__)
+#if defined(__CYGWIN32__) || defined(__BEOS__) || defined(__MINGW32__) || defined(_MSC_VER)
 #define OS_TIMER			0
 #else
 #define OS_TIMER			1
 #endif
 #define OS_FLOCK			1
 
+#ifdef _MSC_VER
+#define CPU_DETECT			0
+#else
 #define CPU_DETECT			1
+#endif
 #define CPU_REQ				1
 #define CPU_NAME			"MMX"
 #ifndef CPU_FALLBACK
@@ -76,4 +83,7 @@
 #endif
 #define BF_SCALE			1
 
+#define MMX_TYPE			" MMX"
+#define MMX_COEF			2
+
 #endif
diff -rupN john-1.7.8/src/x86-sse.S john-1.7.8-jumbo-2/src/x86-sse.S
--- john-1.7.8/src/x86-sse.S	2011-06-22 03:10:47.000000000 +0200
+++ john-1.7.8-jumbo-2/src/x86-sse.S	2011-07-02 21:22:41.000000000 +0200
@@ -20,20 +20,13 @@
  * doing so may provide further speedup.
  *
  * The effort has been sponsored by Rapid7: http://www.rapid7.com
+ *
+ * ...with changes in the jumbo patch, by Alain Espinosa (starting with a
+ * comment further down this file).
  */
 
 #include "arch.h"
 
-#if DES_BS_ASM
-
-#ifdef UNDERSCORES
-#define DES_bs_all			_DES_bs_all
-#define DES_bs_init_asm			_DES_bs_init_asm
-#define DES_bs_crypt			_DES_bs_crypt
-#define DES_bs_crypt_25			_DES_bs_crypt_25
-#define DES_bs_crypt_LM			_DES_bs_crypt_LM
-#endif
-
 /*
  * Some broken systems don't offer section alignments larger than 4 bytes,
  * while for the SSE code we need at least a 16 byte alignment.  ALIGN_FIX
@@ -53,6 +46,16 @@
 #endif
 #endif
 
+#if DES_BS_ASM
+
+#ifdef UNDERSCORES
+#define DES_bs_all			_DES_bs_all
+#define DES_bs_init_asm			_DES_bs_init_asm
+#define DES_bs_crypt			_DES_bs_crypt
+#define DES_bs_crypt_25			_DES_bs_crypt_25
+#define DES_bs_crypt_LM			_DES_bs_crypt_LM
+#endif
+
 #ifdef __sun
 /* Sun's assembler doesn't recognize .space */
 #define DO_SPACE(size)			.zero size
@@ -1039,6 +1042,262 @@ DES_bs_crypt_LM_loop:
 
 #endif
 
+
+/* The following was written by Alain Espinosa <alainesp at gmail.com> in 2007.
+ * No copyright is claimed, and the software is hereby placed in the public domain.
+ * In case this attempt to disclaim copyright and place the software in the
+ * public domain is deemed null and void, then the software is
+ * Copyright (c) 2007 Alain Espinosa and it is hereby released to the
+ * general public under the following terms:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted.
+ *
+ * There's ABSOLUTELY NO WARRANTY, express or implied.
+ *
+ * (This is a heavily cut-down "BSD license".)
+ */
+
+/*
+ * FIXME: this depends on the assembler being able to multiply, which won't
+ * work on Solaris (unless the use of GNU assembler is forced).
+ */
+
+#ifdef UNDERSCORES
+#define nt_crypt_all_sse2 _nt_crypt_all_sse2
+#define nt_buffer1x _nt_buffer1x
+#define nt_buffer4x _nt_buffer4x
+#define output1x _output1x
+#define output4x _output4x
+#endif
+
+/*
+extern nt_crypt_all_sse2(int count);
+*/
+
+.globl nt_crypt_all_sse2
+
+.data
+DO_ALIGN(6)
+const_init_a:
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+.long 0xFFFFFFFF
+const_init_b:
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+.long 0xefcdab89
+const_init_c:
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+.long 0x98badcfe
+const_init_d:
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+.long 0x10325476
+
+const_stage2:
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+.long 0x5a827999
+const_stage3:
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+.long 0x6ed9eba1
+
+#define a  %xmm0
+#define b  %xmm1
+#define c  %xmm2
+#define d  %xmm3
+#define t1 %xmm4
+#define t2 %xmm5
+#define t3 %xmm6
+#define t4 %xmm7
+
+#undef a3
+#define a3  %eax
+#define b3  %ebx
+#define c3  %ecx
+#define d3  %edx
+#define t13 %esi
+#define t23 %edi
+#define Q2 $0x5a827999
+#define Q3 $0x6ed9eba1
+
+#define STEP1(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (256*base)+(x*16)+nt_buffer4x, aa;		\
+	addl (64*base)+(x*4)+nt_buffer1x, aa3;			\
+	movdqa cc, t1;						\
+	movl cc3, t13;						\
+	pxor dd, t1;						\
+	xorl dd3, t13;						\
+	pand bb, t1;						\
+	andl bb3, t13;						\
+	pxor dd, t1;						\
+	xorl dd3, t13;						\
+	paddd t1, aa;						\
+	addl t13, aa3;						\
+	movdqa aa, t2;						\
+	roll $s, aa3;						\
+	pslld $s, aa;						\
+	psrld $(32-s), t2;					\
+	por t2, aa;
+
+#define STEP2(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (256*base)+(x*16)+nt_buffer4x, aa;		\
+	addl (64*base)+(x*4)+nt_buffer1x, aa3;			\
+	movdqa cc, t1;						\
+	movl cc3, t13;						\
+	movdqa cc, t2;						\
+	movl cc3, t23;						\
+	por dd, t1;						\
+	orl dd3, t13;						\
+	pand dd, t2;						\
+	andl dd3, t23;						\
+	pand bb, t1;						\
+	andl bb3, t13;						\
+	paddd t3, aa;						\
+	addl Q2, aa3;						\
+	por t2, t1;						\
+	orl t23, t13;						\
+	paddd t1, aa;						\
+	addl t13, aa3;						\
+	movdqa aa, t1;						\
+	roll $s, aa3;						\
+	pslld $s, aa;						\
+	psrld $(32-s), t1;					\
+	por t1, aa;
+
+#define STEP3(aa, bb, cc, dd, aa3, bb3, cc3, dd3, x, s, base)	\
+	paddd (256*base)+(x*16)+nt_buffer4x, aa;		\
+	addl (64*base)+(x*4)+nt_buffer1x, aa3;			\
+	movdqa dd, t1;						\
+	movl dd3, t13;						\
+	pxor cc, t1;						\
+	xorl cc3, t13;						\
+	paddd t4, aa;						\
+	addl Q3, aa3;						\
+	pxor bb, t1;						\
+	xorl bb3, t13;						\
+	paddd t1, aa;						\
+	addl t13, aa3;						\
+	movdqa aa, t1;						\
+	roll $s, aa3;						\
+	pslld $s, aa;						\
+	psrld $(32-s), t1;					\
+	por t1, aa;
+
+#define NT_CRYPT_BODY(base)					\
+	movdqa const_init_a, a;					\
+	movl const_init_a, a3;					\
+	movdqa const_init_b, b;					\
+	movl const_init_b, b3;					\
+	movdqa const_init_c, c;					\
+	movl const_init_c, c3;					\
+	movdqa const_init_d, d;					\
+	movl const_init_d, d3;					\
+								\
+	paddd (256*base)+nt_buffer4x, a;			\
+	addl (64*base)+nt_buffer1x, a3;				\
+	movdqa a, t1;						\
+	pslld $3, a;						\
+	roll $3, a3;						\
+	psrld $29, t1;						\
+	por t1, a;						\
+								\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 1 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 2 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 3 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 4 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 5 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 7 , 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 8 , 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 9 , 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 10, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 11, 19, base)		\
+	STEP1(a, b, c, d, a3, b3, c3, d3, 12, 3 , base)		\
+	STEP1(d, a, b, c, d3, a3, b3, c3, 13, 7 , base)		\
+	STEP1(c, d, a, b, c3, d3, a3, b3, 14, 11, base)		\
+	STEP1(b, c, d, a, b3, c3, d3, a3, 15, 19, base)		\
+								\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 4 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 8 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 12, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 5 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 9 , 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 13, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 6 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 10, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 14, 13, base)		\
+	STEP2(a, b, c, d, a3, b3, c3, d3, 3 , 3 , base)		\
+	STEP2(d, a, b, c, d3, a3, b3, c3, 7 , 5 , base)		\
+	STEP2(c, d, a, b, c3, d3, a3, b3, 11, 9 , base)		\
+	STEP2(b, c, d, a, b3, c3, d3, a3, 15, 13, base)		\
+								\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 0 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 8 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 4 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 12, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 2 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 10, 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 6 , 11, base)		\
+	STEP3(b, c, d, a, b3, c3, d3, a3, 14, 15, base)		\
+	STEP3(a, b, c, d, a3, b3, c3, d3, 1 , 3 , base)		\
+	STEP3(d, a, b, c, d3, a3, b3, c3, 9 , 9 , base)		\
+	STEP3(c, d, a, b, c3, d3, a3, b3, 5 , 11, base)		\
+	movdqa a, t1;						\
+	movl a3, t13;						\
+	paddd (256*base)+208+nt_buffer4x, b;			\
+	addl (64*base)+52+nt_buffer1x, b3;			\
+	pxor d, t1;						\
+	xorl d3,t13;						\
+	pxor c, t1;						\
+	xorl c3,t13;						\
+	paddd t1, b;						\
+	addl t13,b3;						\
+								\
+	movdqa a,  (64*base)+output4x;				\
+	movl a3,  (16*base)+output1x;				\
+	movdqa b, (64*base)+16+output4x;			\
+	movl b3,  (16*base)+4+output1x;				\
+	movdqa c, (64*base)+32+output4x;			\
+	movl c3,  (16*base)+8+output1x;				\
+	movdqa d, (64*base)+48+output4x;			\
+	movl d3,  (16*base)+12+output1x;
+
+.text
+
+DO_ALIGN(6)
+
+nt_crypt_all_sse2:
+	pusha
+
+	movdqa const_stage2, t3
+	movdqa const_stage3, t4
+
+	NT_CRYPT_BODY(0)
+	NT_CRYPT_BODY(1)
+	NT_CRYPT_BODY(2)
+	NT_CRYPT_BODY(3)
+	NT_CRYPT_BODY(4)
+	NT_CRYPT_BODY(5)
+	NT_CRYPT_BODY(6)
+	NT_CRYPT_BODY(7)
+
+	popa
+
+	ret
+
 #if defined(__ELF__) && defined(__linux__)
 .section .note.GNU-stack,"",@progbits
 #endif
diff -rupN john-1.7.8/src/x86-sse.h john-1.7.8-jumbo-2/src/x86-sse.h
--- john-1.7.8/src/x86-sse.h	2011-05-04 20:59:50.000000000 +0200
+++ john-1.7.8-jumbo-2/src/x86-sse.h	2011-07-02 20:42:27.000000000 +0200
@@ -1,6 +1,10 @@
 /*
  * This file is part of John the Ripper password cracker,
  * Copyright (c) 1996-2002,2005,2006,2008,2010,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC, by JimF.
+ * ...and introduction of MMX_TYPE and MMX_COEF by Simon Marechal.
+ * ...and NT_SSE2 by Alain Espinosa.
  */
 
 /*
@@ -20,14 +24,18 @@
 #define ARCH_ALLOWS_UNALIGNED		1
 #define ARCH_INDEX(x)			((unsigned int)(unsigned char)(x))
 
-#if defined(__CYGWIN32__) || defined(__BEOS__)
+#if defined(__CYGWIN32__) || defined(__BEOS__) || defined(__MINGW32__) || defined(_MSC_VER)
 #define OS_TIMER			0
 #else
 #define OS_TIMER			1
 #endif
 #define OS_FLOCK			1
 
+#ifdef _MSC_VER
+#define CPU_DETECT			0
+#else
 #define CPU_DETECT			1
+#endif
 #define CPU_REQ				1
 #define CPU_NAME			"SSE2"
 #ifndef CPU_FALLBACK
@@ -102,9 +110,18 @@
 #define BF_ASM				0
 #define BF_X2				1
 #else
+#ifdef _MSC_VER
+#define BF_ASM				0
+#else
 #define BF_ASM				1
+#endif
 #define BF_X2				0
 #endif
 #define BF_SCALE			1
 
+#define MMX_TYPE			" SSE2"
+#define MMX_COEF			4
+
+#define NT_SSE2
+
 #endif
diff -rupN john-1.7.8/src/x86-ssei.h john-1.7.8-jumbo-2/src/x86-ssei.h
--- john-1.7.8/src/x86-ssei.h	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/x86-ssei.h	2011-05-17 18:13:03.000000000 +0200
@@ -0,0 +1,160 @@
+/*
+ * This file is part of John the Ripper password cracker,
+ * Copyright (c) 1996-2002,2005,2006,2008,2010,2011 by Solar Designer
+ *
+ * ...with changes in the jumbo patch for mingw and MSC, by JimF.
+ * ...and introduction of MMX_TYPE and MMX_COEF by Simon Marechal.
+ * ...and NT_SSE2 by Alain Espinosa.
+ */
+
+/*
+ * Architecture specific parameters for x86 with SSE2.
+ */
+
+#ifndef _JOHN_ARCH_H
+#define _JOHN_ARCH_H
+
+#define ARCH_WORD			long
+#define ARCH_SIZE			4
+#define ARCH_BITS			32
+#define ARCH_BITS_LOG			5
+#define ARCH_BITS_STR			"32"
+#define ARCH_LITTLE_ENDIAN		1
+#define ARCH_INT_GT_32			0
+#define ARCH_ALLOWS_UNALIGNED		1
+#define ARCH_INDEX(x)			((unsigned int)(unsigned char)(x))
+
+#if defined(__CYGWIN32__) || defined(__BEOS__) || defined(__MINGW32__) || defined(_MSC_VER)
+#define OS_TIMER			0
+#else
+#define OS_TIMER			1
+#endif
+#define OS_FLOCK			1
+
+#ifdef _MSC_VER
+#define CPU_DETECT			0
+#else
+#define CPU_DETECT			1
+#endif
+#define CPU_REQ				1
+#define CPU_NAME			"SSE2"
+#ifndef CPU_FALLBACK
+#define CPU_FALLBACK			0
+#endif
+#if CPU_FALLBACK
+#define CPU_FALLBACK_BINARY		"john-non-sse"
+#endif
+
+#define DES_ASM				1
+#define DES_128K			0
+#define DES_X2				1
+#define DES_MASK			1
+#define DES_SCALE			0
+#define DES_EXTB			0
+#define DES_COPY			1
+#define DES_STD_ALGORITHM_NAME		"48/64 4K MMX"
+#define DES_BS				1
+#if defined(__AVX__) && defined(__GNUC__)
+/* Require gcc for AVX because DES_bs_all is aligned in a gcc-specific way */
+#define DES_BS_ASM			0
+#if 1
+#define DES_BS_VECTOR			8
+#if defined(__XOP__) && defined(__GNUC__)
+/* Require gcc for 256-bit XOP because of __builtin_ia32_vpcmov_v8sf256() */
+#undef DES_BS
+#define DES_BS				3
+#define DES_BS_ALGORITHM_NAME		"256/256 BS XOP"
+#else
+#define DES_BS_ALGORITHM_NAME		"256/256 BS AVX"
+#endif
+#else
+#define DES_BS_VECTOR			4
+#ifdef __XOP__
+#undef DES_BS
+#define DES_BS				3
+#define DES_BS_ALGORITHM_NAME		"128/256 BS XOP"
+#else
+#define DES_BS_ALGORITHM_NAME		"128/256 BS AVX"
+#endif
+#endif
+#elif defined(__SSE2__) && 0
+#define DES_BS_ASM			0
+#if 1
+#define DES_BS_VECTOR			4
+#define DES_BS_ALGORITHM_NAME		"128/128 BS SSE2"
+#elif 0
+#define DES_BS_VECTOR			6
+#define DES_BS_VECTOR_SIZE		8
+#define DES_BS_ALGORITHM_NAME		"128/128 BS SSE2 + 64/64 BS MMX"
+#elif 0
+#define DES_BS_VECTOR			5
+#define DES_BS_VECTOR_SIZE		8
+#define DES_BS_ALGORITHM_NAME		"128/128 BS SSE2 + 32/32 BS"
+#else
+#define DES_BS_VECTOR			7
+#define DES_BS_VECTOR_SIZE		8
+#define DES_BS_ALGORITHM_NAME		"128/128 BS SSE2 + 64/64 BS MMX + 32/32 BS"
+#endif
+#else
+#define DES_BS_ASM			1
+#define DES_BS_VECTOR			4
+#define DES_BS_ALGORITHM_NAME		"128/128 BS SSE2"
+#endif
+#define DES_BS_EXPAND			1
+
+#define MD5_ASM				1
+#define MD5_X2				0
+#define MD5_IMM				1
+
+#ifdef _OPENMP
+#define BF_ASM				0
+#define BF_X2				1
+#else
+#ifdef _MSC_VER
+#define BF_ASM				0
+#else
+#define BF_ASM				1
+#endif
+#define BF_X2				0
+#endif
+#define BF_SCALE			1
+
+//#define MMX_TYPE			" SSE2"
+//#define MMX_COEF			4
+
+#if defined (_MSC_VER)
+#define MD5_SSE_PARA		2
+#define MD5_N_STR			"8x"
+#elif defined(__GNUC__)
+#define MD5_SSE_PARA		2
+#define MD5_N_STR			"8x"
+#else
+#define MD5_SSE_PARA		3
+#define MD5_N_STR			"12x"
+#endif
+
+#if defined (_MSC_VER)
+#define MD4_SSE_PARA		2
+#define MD4_N_STR			"8x"
+#elif defined(__GNUC__)
+#define MD4_SSE_PARA		2
+#define MD4_N_STR			"8x"
+#else
+#define MD4_SSE_PARA		3
+#define MD4_N_STR			"12x"
+#endif
+
+#if defined (_MSC_VER)
+#define SHA1_SSE_PARA		2
+#define SHA1_N_STR			"8x"
+#elif defined(__GNUC__)
+#define SHA1_SSE_PARA		2
+#define SHA1_N_STR			"8x"
+#else
+#define SHA1_SSE_PARA		2
+#define SHA1_N_STR			"8x"
+#endif
+
+#define NT_SSE2
+
+#endif
diff -rupN john-1.7.8/src/x86.S john-1.7.8-jumbo-2/src/x86.S
--- john-1.7.8/src/x86.S	2010-06-09 21:48:26.000000000 +0200
+++ john-1.7.8-jumbo-2/src/x86.S	2011-05-17 18:13:03.000000000 +0200
@@ -23,6 +23,7 @@
 #define DES_xor_key2			_DES_xor_key2
 #define MD5_body			_MD5_body
 #define BF_body				_BF_body
+#define BF_body_generic     _BF_body_generic
 #define BF_current			_BF_current
 #define CPU_detect			_CPU_detect
 #endif
diff -rupN john-1.7.8/src/zip2john.c john-1.7.8-jumbo-2/src/zip2john.c
--- john-1.7.8/src/zip2john.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/zip2john.c	2011-07-02 23:01:00.000000000 +0200
@@ -0,0 +1,185 @@
+/* zip2john processes input ZIP files into a format suitable for use with JtR.
+ *
+ * This software is Copyright  2011, Dhiru Kholia <dhiru.kholia at gmail.com>,
+ * and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted.
+ *
+ * References:
+ *
+ * 1. http://www.winzip.com/aes_info.htm
+ * 2. http://www.winzip.com/aes_tips.htm
+ * 4. ftp://ftp.info-zip.org/pub/infozip/doc/appnote-iz-latest.zip
+ * 5. Nathan Moinvaziri's work in extending minizip to support AES.
+ * 6. http://oldhome.schmorp.de/marc/fcrackzip.html (coding hints)
+ * 7. http://www.pkware.com/documents/casestudies/APPNOTE.TXT
+ * 8. http://gladman.plushost.co.uk/oldsite/cryptography_technology/fileencrypt/index.php
+ *   (borrowed files have "gladman_" prepended to them)
+ *
+ * Usage:
+ *
+ * 1. Run zip2john on zip file(s) as "zip2john [zip files]".
+ *    Output is written to standard output.
+ * 2. Run JtR on the output generated by zip2john as "john [output file]".
+ *
+ * Output Line Format:
+ *
+ * For type = 0, for ZIP files encrypted using AES
+ * filename:$zip$*type*hex(CRC)*encryption_strength*hex(salt)*hex(password_verfication_value):hex(authentication_code)
+ *
+ * For type = 1, for ZIP files encrypted using old encryption (TODO)
+ * filename:$zip$*type*...  */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <limits.h>
+#include <errno.h>
+#include <string.h>
+#include <assert.h>
+#include "common.h"
+
+/* helper functions for byte order conversions, header values are stored
+ * in little-endian byte order */
+static uint32_t fget32(FILE * fp)
+{
+	uint32_t v = fgetc(fp);
+	v |= fgetc(fp) << 8;
+	v |= fgetc(fp) << 16;
+	v |= fgetc(fp) << 24;
+	return v;
+}
+
+static uint16_t fget16(FILE * fp)
+{
+	uint32_t v = fgetc(fp);
+	v |= fgetc(fp) << 8;
+	return v;
+}
+
+static void process_file(const char *fname)
+{
+	unsigned char filename[1024];
+	FILE *fp;
+	int i;
+
+	if (!(fp = fopen(fname, "rb"))) {
+		fprintf(stderr, "! %s : %s\n", fname, strerror(errno));
+		return;
+	}
+
+	while (!feof(fp)) {
+		uint32_t id = fget32(fp);
+
+		if (id == 0x04034b50UL) {	/* local header */
+			uint16_t version = fget16(fp);
+			uint16_t flags = fget16(fp);
+			uint16_t compression_method = fget16(fp);
+			uint16_t lastmod_time = fget16(fp);
+			uint16_t lastmod_date = fget16(fp);
+			uint32_t crc = fget32(fp);
+			uint32_t compressed_size = fget32(fp);
+			uint32_t uncompressed_size = fget32(fp);
+			uint16_t filename_length = fget16(fp);
+			uint16_t extrafield_length = fget16(fp);
+			/* unused variables */
+			(void) version;
+			(void) lastmod_time;
+			(void) lastmod_date;
+			(void) crc;
+			(void) uncompressed_size;
+
+			fread(filename, 1, filename_length, fp);
+			filename[filename_length] = 0;
+
+			if (compression_method == 99) {	/* AES encryption */
+				fprintf(stderr,
+				    "%s->%s is using AES encryption, extrafield_length is %d\n",
+				    fname, filename, extrafield_length);
+				uint16_t efh_id = fget16(fp);
+				uint16_t efh_datasize = fget16(fp);
+				uint16_t efh_vendor_version = fget16(fp);
+				uint16_t efh_vendor_id = fget16(fp);
+				char efh_aes_strength = fgetc(fp);
+				uint16_t actual_compression_method =
+				    fget16(fp);
+
+				/* unused variables */
+				(void) efh_id;
+				(void) efh_datasize;
+				(void) efh_vendor_version;
+				(void) efh_vendor_id;
+				(void) efh_aes_strength;
+				(void) actual_compression_method;
+
+				printf("%s:$zip$*0*%d*", fname,
+				    efh_aes_strength);
+				unsigned char salt[16];
+				int n = 0;
+				switch (efh_aes_strength) {
+				case 1:
+					n = 8;
+					fread(salt, 1, n, fp);
+					break;
+				case 2:
+					n = 12;
+					fread(salt, 1, n, fp);
+					break;
+				case 3:
+					n = 16;
+					fread(salt, 1, n, fp);
+					break;
+
+				}
+				for (i = 0; i < n; i++) {
+					printf("%c%c",
+					    itoa16[ARCH_INDEX(salt[i] >> 4)],
+					    itoa16[ARCH_INDEX(salt[i] &
+						    0x0f)]);
+				}
+				uint16_t password_verification_value =
+				    fget16(fp);
+				unsigned char *p = (unsigned char *)
+				    &password_verification_value;
+				printf("*");
+				for (i = 0; i < 2; i++) {
+					printf("%c%c",
+					    itoa16[ARCH_INDEX(p[i] >> 4)],
+					    itoa16[ARCH_INDEX(p[i] & 0x0f)]);
+				}
+				printf("\n");
+				fseek(fp, 10, SEEK_CUR);
+
+			} else if (flags & 1) {	/* old encryption */
+				printf("%s is using old encryption!\n",
+				    filename);
+			} else {
+				printf("%s->%s is not encrypted!\n", fname,
+				    filename);
+				fseek(fp, extrafield_length, SEEK_CUR);
+				fseek(fp, compressed_size, SEEK_CUR);
+			}
+		} else if (id == 0x08074b50UL) {	/* data descriptor */
+			fseek(fp, 12, SEEK_CUR);
+		} else if (id == 0x02014b50UL || id == 0x06054b50UL) {	/* central directory structures */
+			goto cleanup;
+		}
+	}
+
+cleanup:
+	fclose(fp);
+}
+
+int zip2john(int argc, char **argv)
+{
+	int i;
+
+	if (argc < 2) {
+		puts("Usage: zip2john [zip files]");
+		return 0;
+	}
+	for (i = 1; i < argc; i++)
+		process_file(argv[i]);
+
+	return 0;
+}
diff -rupN john-1.7.8/src/zip_fmt.c john-1.7.8-jumbo-2/src/zip_fmt.c
--- john-1.7.8/src/zip_fmt.c	1970-01-01 01:00:00.000000000 +0100
+++ john-1.7.8-jumbo-2/src/zip_fmt.c	2011-07-02 23:32:35.000000000 +0200
@@ -0,0 +1,190 @@
+/* ZIP cracker patch for JtR. Hacked together during June of 2011
+ * by Dhiru Kholia <dhiru.kholia at gmail.com> for GSoC.
+ *
+ * This software is Copyright  2011, Dhiru Kholia <dhiru.kholia at gmail.com>,
+ * and it is hereby released to the general public under the following terms:
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted.
+ *
+ * Files borrowed from http://www.gladman.me.uk/cryptography_technology/fileencrypt/
+ * have "gladman_" prepended to them.
+ *
+ * http://www.winzip.com/aes_info.htm (There is a 1 in 65,536 chance that an
+ * incorrect password will yield a matching verification value; therefore, a
+ * matching verification value cannot be absolutely relied on to indicate a
+ * correct password.). The alternative is to implement / use a full unzip engine. */
+
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+#include "arch.h"
+#include "crc32.h"
+#include "misc.h"
+#include "params.h"
+#include "common.h"
+#include "formats.h"
+#include "gladman_fileenc.h"
+#include <openssl/aes.h>
+#include <openssl/sha.h>
+#include <openssl/ssl.h>
+
+#define FORMAT_LABEL        "zip"
+#define FORMAT_NAME         "zip"
+#define ALGORITHM_NAME      "32/" ARCH_BITS_STR
+#define BENCHMARK_COMMENT   ""
+#define BENCHMARK_LENGTH    -1
+#define PLAINTEXT_LENGTH    32
+#define BINARY_SIZE         2
+#define SALT_SIZE           512
+#define MIN_KEYS_PER_CRYPT  1
+#define MAX_KEYS_PER_CRYPT  1
+
+static char saved_key[PLAINTEXT_LENGTH + 1];
+static int has_been_cracked = 0;
+static unsigned char *saved_salt;
+static unsigned char passverify[2];
+static int type;		/* type of zip file */
+static int mode;
+
+static struct fmt_tests zip_tests[] = {
+	{"$zip$*0*1*8005b1b7d077708d*dee4", "testpassword#"},
+	{NULL}
+};
+
+static void init(struct fmt_main *pFmt)
+{
+	/* OpenSSL init, cleanup part is left to OS */
+	SSL_load_error_strings();
+	OpenSSL_add_all_algorithms();
+}
+
+static int valid(char *ciphertext, struct fmt_main *pFmt)
+{
+//	printf("%s\n", ciphertext);
+	return !strncmp(ciphertext, "$zip$*", 6);
+}
+
+static void *get_salt(char *ciphertext)
+{
+	return ciphertext;
+}
+
+static void set_salt(void *salt)
+{
+	int i;
+	/* extract data from "salt" */
+	char *saltcopy_mem = strdup(salt);
+	char *saltcopy = saltcopy_mem + 6; /* skip over "$zip$*" */
+	type = atoi(strtok(saltcopy, "*"));
+	int strength = atoi(strtok(NULL, "*"));
+	mode = strength;
+	int n;
+	switch (strength) {
+	case 1:
+		n = 8;
+		break;
+	case 2:
+		n = 12;
+		break;
+	case 3:
+		n = 16;
+		break;
+	default:
+		fprintf(stderr, "ZIP: Unsupported strength %d\n", strength);
+		error();
+		n = 0; /* Not reached */
+	}
+	char *encoded_salt = strtok(NULL, "*");
+	free(saved_salt);
+	saved_salt = malloc(n);
+	for (i = 0; i < n; i++)
+		saved_salt[i] = atoi16[ARCH_INDEX(encoded_salt[i * 2])] * 16
+		    + atoi16[ARCH_INDEX(encoded_salt[i * 2 + 1])];
+	char *p = strtok(NULL, "*");
+	for (i = 0; i < 2; i++)
+		passverify[i] = atoi16[ARCH_INDEX(p[i * 2])] * 16 +
+		    atoi16[ARCH_INDEX(p[i * 2 + 1])];
+	has_been_cracked = 0;
+	free(saltcopy_mem);
+}
+
+static void zip_set_key(char *key, int index)
+{
+	int saved_key_length = strlen(key);
+	if (saved_key_length > PLAINTEXT_LENGTH)
+		saved_key_length = PLAINTEXT_LENGTH;
+	memcpy(saved_key, key, saved_key_length);
+	saved_key[saved_key_length] = 0;
+}
+
+static char *get_key(int index)
+{
+	return saved_key;
+}
+
+static void crypt_all(int count)
+{
+	unsigned char pwd_ver[2] = { 0 };
+	unsigned char kbuf[2 * MAX_KEY_LENGTH + PWD_VER_LENGTH];
+	/* derive the encryption and authetication keys and the password verifier   */
+	derive_key((unsigned char *)saved_key, strlen(saved_key),
+	    saved_salt, SALT_LENGTH(mode),
+	    KEYING_ITERATIONS, kbuf, 2 * KEY_LENGTH(mode) + PWD_VER_LENGTH);
+	memcpy(pwd_ver, kbuf + 2 * KEY_LENGTH(mode), PWD_VER_LENGTH);
+	has_been_cracked = !memcmp(pwd_ver, passverify, 2);
+
+}
+
+static int cmp_all(void *binary, int count)
+{
+	return has_been_cracked;
+}
+
+static int cmp_one(void *binary, int index)
+{
+	return 1;
+}
+
+static int cmp_exact(char *source, int index)
+{
+	return 1;
+}
+
+struct fmt_main zip_fmt = {
+	{
+		FORMAT_LABEL,
+		FORMAT_NAME,
+		ALGORITHM_NAME,
+		BENCHMARK_COMMENT,
+		BENCHMARK_LENGTH,
+		PLAINTEXT_LENGTH,
+		BINARY_SIZE,
+		SALT_SIZE,
+		MIN_KEYS_PER_CRYPT,
+		MAX_KEYS_PER_CRYPT,
+		FMT_CASE | FMT_8_BIT,
+		zip_tests
+	}, {
+		init,
+		fmt_default_prepare,
+		valid,
+		fmt_default_split,
+		fmt_default_binary,
+		get_salt,
+		{
+			fmt_default_binary_hash
+		},
+		fmt_default_salt_hash,
+		set_salt,
+		zip_set_key,
+		get_key,
+		fmt_default_clear_keys,
+		crypt_all,
+		{
+			fmt_default_get_hash
+		},
+		cmp_all,
+		cmp_one,
+		cmp_exact
+	}
+};
