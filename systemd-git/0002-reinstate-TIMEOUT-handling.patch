From 2c7d9d04ca960f0f788768144399a33d0a3407d1 Mon Sep 17 00:00:00 2001
From: Kevin Murphy <kemurphy@andrew.cmu.edu>
Date: Sun, 8 Apr 2012 11:47:26 -0400
Subject: [PATCH 2/2] reinstate TIMEOUT= handling

Without treating events with timeouts specially some drivers would cause a
30 seconds stall on boot: .

I also received reports of some drivers not working at all, even after the
timeout.

We will remove this patch when more drivers have been fixed in the kernel (3.4?).

This reverts 43d5c5f03645c4b842659f9b5bd0ae465e885e92 and
57c6f8ae5f52a6e8ffc66a54966346f733dded39.
---
 src/libudev/libudev-device.c  |   19 +++++++++++++++++++
 src/libudev/libudev-private.h |    1 +
 src/libudev/udevd.c           |   13 ++++++++++---
 3 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/src/libudev/libudev-device.c b/src/libudev/libudev-device.c
index 40b00ac..2a179e3 100644
--- a/src/libudev/libudev-device.c
+++ b/src/libudev/libudev-device.c
@@ -68,6 +68,7 @@ struct udev_device {
         struct udev_list tags_list;
         unsigned long long int seqnum;
         unsigned long long int usec_initialized;
+        int timeout;
         int devlink_priority;
         int refcount;
         dev_t devnum;
@@ -160,6 +161,21 @@ static int udev_device_set_devnum(struct udev_device *udev_device, dev_t devnum)
         return 0;
 }
 
+int udev_device_get_timeout(struct udev_device *udev_device)
+{
+        return udev_device->timeout;
+}
+
+static int udev_device_set_timeout(struct udev_device *udev_device, int timeout)
+{
+        char num[32];
+
+        udev_device->timeout = timeout;
+        snprintf(num, sizeof(num), "%u", timeout);
+        udev_device_add_property(udev_device, "TIMEOUT", num);
+        return 0;
+}
+
 const char *udev_device_get_devpath_old(struct udev_device *udev_device)
 {
         return udev_device->devpath_old;
@@ -414,6 +430,8 @@ void udev_device_add_property_from_string_parse(struct udev_device *udev_device,
                 udev_device_set_devpath_old(udev_device, &property[12]);
         } else if (strncmp(property, "SEQNUM=", 7) == 0) {
                 udev_device_set_seqnum(udev_device, strtoull(&property[7], NULL, 10));
+        } else if (strncmp(property, "TIMEOUT=", 8) == 0) {
+                udev_device_set_timeout(udev_device, strtoull(&property[8], NULL, 10));
         } else if (strncmp(property, "IFINDEX=", 8) == 0) {
                 udev_device_set_ifindex(udev_device, strtoull(&property[8], NULL, 10));
         } else if (strncmp(property, "DEVMODE=", 8) == 0) {
@@ -599,6 +617,7 @@ struct udev_device *udev_device_new(struct udev *udev)
         udev_list_init(udev, &udev_device->sysattr_value_list, true);
         udev_list_init(udev, &udev_device->sysattr_list, false);
         udev_list_init(udev, &udev_device->tags_list, true);
+        udev_device->timeout = -1;
         udev_device->watch_handle = -1;
         /* copy global properties */
         udev_list_entry_foreach(list_entry, udev_get_properties_list_entry(udev))
diff --git a/src/libudev/libudev-private.h b/src/libudev/libudev-private.h
index d914aa4..9514ffc 100644
--- a/src/libudev/libudev-private.h
+++ b/src/libudev/libudev-private.h
@@ -64,6 +64,7 @@ const char *udev_device_get_id_filename(struct udev_device *udev_device);
 void udev_device_set_is_initialized(struct udev_device *udev_device);
 int udev_device_add_tag(struct udev_device *udev_device, const char *tag);
 void udev_device_cleanup_tags_list(struct udev_device *udev_device);
+int udev_device_get_timeout(struct udev_device *udev_device);
 unsigned long long udev_device_get_usec_initialized(struct udev_device *udev_device);
 void udev_device_set_usec_initialized(struct udev_device *udev_device, unsigned long long usec_initialized);
 int udev_device_get_devlink_priority(struct udev_device *udev_device);
diff --git a/src/libudev/udevd.c b/src/libudev/udevd.c
index 589a8fe..b1cccb3 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -390,7 +390,7 @@ out:
         }
 }
 
-static void event_run(struct event *event)
+static void event_run(struct event *event, bool force)
 {
         struct udev_list_node *loop;
 
@@ -416,7 +416,7 @@ static void event_run(struct event *event)
                 return;
         }
 
-        if (children >= children_max) {
+        if (!force && children >= children_max) {
                 if (children_max > 1)
                         log_debug("maximum number (%i) of children reached\n", children);
                 return;
@@ -450,6 +450,13 @@ static int event_queue_insert(struct udev_device *dev)
 
         event->state = EVENT_QUEUED;
         udev_list_node_append(&event->node, &event_list);
+
+        /* run all events with a timeout set immediately */
+        if (udev_device_get_timeout(dev) > 0) {
+                event_run(event, true);
+                return 0;
+        }
+
         return 0;
 }
 
@@ -564,7 +571,7 @@ static void event_queue_start(struct udev *udev)
                 if (is_devpath_busy(event))
                         continue;
 
-                event_run(event);
+                event_run(event, false);
         }
 }
 
-- 
1.7.10

