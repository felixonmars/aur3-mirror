diff -urN dosbox.orig/include/glidedef.h dosbox/include/glidedef.h
--- dosbox.orig/include/glidedef.h	1969-12-31 21:00:00.000000000 -0300
+++ dosbox/include/glidedef.h	2012-09-29 02:18:02.909193312 -0300
@@ -0,0 +1,176 @@
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GLIDEDEF_H
+#define GLIDEDEF_H
+
+#ifdef DOSBOX_DOSBOX_H
+struct GLIDE_Block
+{
+    bool splash;
+    bool enabled;
+    bool * fullscreen;
+    Bit16u width, height;
+    class GLIDE_PageHandler * lfb_pagehandler;
+    GLIDE_Block():enabled(false),fullscreen(0),width(0),height(0),lfb_pagehandler((GLIDE_PageHandler*)0) { }
+};
+extern GLIDE_Block glide;
+extern void GLIDE_ResetScreen(bool update=false);
+#endif
+
+#define GLIDE_LFB		0x60000000
+#define GLIDE_PAGES		384	/* Should be enough for 1024x768x2 */
+
+#ifdef __3DFX_H__
+/* If you change these defines, don't forget to change the table in glide.h and compile a matching GLIDE2X.OVL */
+
+#define	_grAADrawLine8			0	// void grAADrawLine(GrVertex *va, GrVertex *vb)
+#define	_grAADrawPoint4			1	// void grAADrawPoint(GrVertex *p)
+#define	_grAADrawPolygon12		2	// void grAADrawPolygon(int nVerts, const int ilist[], const GrVertex vlist[])
+#define	_grAADrawPolygonVertexList8	3	// void grAADrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+#define	_grAADrawTriangle24		4	// void grAADrawTriangle(GrVertex *a, GrVertex *b, GrVertex *c, FxBool antialiasAB, FxBool antialiasBC, FxBool antialiasCA)
+#define	_grAlphaBlendFunction16		5	// void grAlphaBlendFunction(GrAlphaBlendFnc_t rgb_sf, GrAlphaBlendFnc_t rgb_df, GrAlphaBlendFnc_t alpha_sf, GrAlphaBlendFnc_t alpha_df)
+#define	_grAlphaCombine20		6	// void grAlphaCombine(GrCombineFunction_t func, GrCombineFactor_t factor, GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+#define	_grAlphaControlsITRGBLighting4	7	// void grAlphaControlsITRGBLighting(FxBool enable)
+#define	_grAlphaTestFunction4		8	// void grAlphaTestFunction(GrCmpFnc_t function)
+#define	_grAlphaTestReferenceValue4	9	// void grAlphaTestReferenceValue(GrAlpha_t value)
+#define	_grBufferClear12		10	// void grBufferClear(GrColor_t color, GrAlpha_t alpha, FxU16 depth)
+#define	_grBufferNumPending0		11	// int grBufferNumPending(void)
+#define	_grBufferSwap4			12	// void grBufferSwap(int swap_interval)
+#define	_grCheckForRoom4		13	// void grCheckForRoom(FxI32 n)
+#define	_grChromakeyMode4		14	// void grChromakeyMode(GrChromakeyMode_t mode)
+#define	_grChromakeyValue4		15	// void grChromakeyValue(GrColor_t value)
+#define	_grClipWindow16			16	// void grClipWindow(FxU32 minx, FxU32 miny, FxU32 maxx, FxU32 maxy)
+#define	_grColorCombine20		17	// void grColorCombine(GrCombineFunction_t func, GrCombineFactor_t factor, GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+#define	_grColorMask8			18	// void grColorMask(FxBool rgb, FxBool alpha)
+#define	_grConstantColorValue416	19	// void grConstantColorValue4(float a, float r, float g, float b)
+#define	_grConstantColorValue4		20	// void grConstantColorValue(GrColor_t color)
+#define	_grCullMode4			21	// void grCullMode(GrCullMode_t mode)
+#define	_grDepthBiasLevel4		22	// void grDepthBiasLevel(FxI16 level)
+#define	_grDepthBufferFunction4		23	// void grDepthBufferFunction(GrCmpFnc_t func)
+#define	_grDepthBufferMode4		24	// void grDepthBufferMode(GrDepthBufferMode_t mode)
+#define	_grDepthMask4			25	// void grDepthMask(FxBool enable)
+#define	_grDisableAllEffects0		26	// void grDisableAllEffects(void)
+#define	_grDitherMode4			27	// void grDitherMode(GrDitherMode_t mode)
+#define	_grDrawLine8			28	// void grDrawLine(const GrVertex *a, const GrVertex *b)
+#define	_grDrawPlanarPolygon12		29	// void grDrawPlanarPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+#define	_grDrawPlanarPolygonVertexList8 30	// void grDrawPlanarPolygonVertexList(int nVerts, const GrVertex vlist[])
+#define	_grDrawPoint4			31	// void grDrawPoint(const GrVertex *a)
+#define	_grDrawPolygon12		32	// void grDrawPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+#define	_grDrawPolygonVertexList8	33	// void grDrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+#define	_grDrawTriangle12		34	// void grDrawTriangle(const GrVertex *a, const GrVertex *b, const GrVertex *c)
+#define	_grErrorSetCallback4		35	// void grErrorSetCallback(void (*function)(const char *string, FxBool fatal))
+#define	_grFogColorValue4		36	// void grFogColorValue(GrColor_t value)
+#define	_grFogMode4			37	// void grFogMode(GrFogMode_t mode)
+#define	_grFogTable4			38	// void grFogTable(const GrFog_t table[GR_FOG_TABLE_SIZE])
+#define	_grGammaCorrectionValue4	39	// void grGammaCorrectionValue(float value)
+#define	_grGlideGetState4		40	// void grGlideGetState(GrState *state)
+#define	_grGlideGetVersion4		41	// void grGlideGetVersion(char version[80])
+#define	_grGlideInit0			42	// void grGlideInit(void)
+#define	_grGlideSetState4		43	// void grGlideSetState(const GrState *state)
+#define	_grGlideShamelessPlug4		44	// void grGlideShamelessPlug(const FxBool on)
+#define	_grGlideShutdown0		45	// void grGlideShutdown(void)
+#define	_grHints8			46	// void grHints(GrHint_t type, FxU32 hintMask)
+#define	_grLfbConstantAlpha4		47	// void grLfbConstantAlpha(GrAlpha_t alpha)
+#define	_grLfbConstantDepth4		48	// void grLfbConstantDepth(FxU16 depth)
+#define	_grLfbLock24			49	// FxBool grLfbLock(GrLock_t type, GrBuffer_t buffer, GrLfbWriteMode_t writeMode, GrOriginLocation_t origin, FxBool pixelPipeline, GrLfbInfo_t *info)
+#define	_grLfbReadRegion28		50	// FxBool grLfbReadRegion(GrBuffer_t src_buffer, FxU32 src_x, FxU32 src_y, FxU32 src_width, FxU32 src_height, FxU32 dst_stride, void *dst_data)
+#define	_grLfbUnlock8			51	// FxBool grLfbUnlock(GrLock_t type, GrBuffer_t buffer)
+#define	_grLfbWriteColorFormat4		52	// void grLfbWriteColorFormat(GrColorFormat_t colorFormat)
+#define	_grLfbWriteColorSwizzle8	53	// void grLfbWriteColorSwizzle(FxBool swizzleBytes, FxBool swapWords)
+#define	_grLfbWriteRegion32		54	// FxBool grLfbWriteRegion(GrBuffer_t dst_buffer, FxU32 dst_x, FxU32 dst_y, GrLfbSrcFmt_t src_format, FxU32 src_width, FxU32 src_height, FxU32 src_stride, void *src_data)
+#define	_grRenderBuffer4		55	// void grRenderBuffer(GrBuffer_t buffer)
+#define	_grResetTriStats0		56	// void grResetTriStats()
+#define	_grSplash20			57	// void grSplash(float x, float y, float width, float height, FxU32 frame)
+#define	_grSstConfigPipeline12		58	//
+#define	_grSstControl4			59	// FxBool grSstControl(FxU32 code)
+#define	_grSstIdle0			60	// void grSstIdle(void)
+#define	_grSstIsBusy0			61	// FxBool grSstIsBusy(void)
+#define	_grSstOrigin4			62	// void grSstOrigin(GrOriginLocation_t origin)
+#define	_grSstPerfStats4		63	// void grSstPerfStats(GrSstPerfStats_t *pStats)
+#define	_grSstQueryBoards4		64	// FxBool grSstQueryBoards(GrHwConfiguration *hwConfig)
+#define	_grSstQueryHardware4		65	// FxBool grSstQueryHardware(GrHwConfiguration *hwConfig)
+#define	_grSstResetPerfStats0		66	// void grSstResetPerfStats(void)
+#define	_grSstScreenHeight0		67	// FxU32 grSstScreenHeight(void)
+#define	_grSstScreenWidth0		68	// FxU32 grSstScreenWidth(void)
+#define	_grSstSelect4			69	// void grSstSelect(int which_sst)
+#define	_grSstStatus0			70	// FxU32 grSstStatus(void)
+#define	_grSstVRetraceOn0		71	// FxBool grSstVRetraceOn(void)
+#define	_grSstVidMode8			72	//
+#define	_grSstVideoLine0		73	// FxU32 grSstVideoLine(void)
+#define	_grSstWinClose0			74	// void grSstWinClose(void)
+#define	_grSstWinOpen28			75	// FxBool grSstWinOpen(FxU32 hwnd, GrScreenResolution_t res, GrScreenRefresh_t ref, GrColorFormat_t cformat, GrOriginLocation_t org_loc, int num_buffers, int num_aux_buffers)
+#define	_grTexCalcMemRequired16		76	// FxU32 grTexCalcMemRequired(GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspect, GrTextureFormat_t format)
+#define	_grTexClampMode12		77	// void grTexClampMode(GrChipID_t tmu, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode)
+#define	_grTexCombine28			78	// void grTexCombine(GrChipID_t tmu, GrCombineFunction_t rgb_function, GrCombineFactor_t rgb_factor, GrCombineFunction_t alpha_function, GrCombineFactor_t alpha_factor, FxBool rgb_invert, FxBool alpha_invert)
+#define	_grTexCombineFunction8		79	// void grTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t fnc)
+#define	_grTexDetailControl16		80	// void grTexDetailControl(GrChipID_t tmu, int lodBias, FxU8 detailScale, float detailMax)
+#define	_grTexDownloadMipMap16		81	// void grTexDownloadMipMap(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+#define	_grTexDownloadMipMapLevel32	82	// void grTexDownloadMipMapLevel(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd, void *data)
+#define	_grTexDownloadMipMapLevelPartial40 83	// void grTexDownloadMipMapLevelPartial(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd, void *data, int start, int end)
+#define	_grTexDownloadTable12		84	// void grTexDownloadTable(GrChipID_t tmu, GrTexTable_t type, void *data)
+#define	_grTexDownloadTablePartial20	85	// void grTexDownloadTablePartial(GrChipID_t tmu, GrTexTable_t type, void *data, int start, int end)
+#define	_grTexFilterMode12		86	// void grTexFilterMode(GrChipID_t tmu, GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode)
+#define	_grTexLodBiasValue8		87	// void grTexLodBiasValue(GrChipID_t tmu, float bias)
+#define	_grTexMaxAddress4		88	// FxU32 grTexMaxAddress(GrChipID_t tmu)
+#define	_grTexMinAddress4		89	// FxU32 grTexMinAddress(GrChipID_t tmu)
+#define	_grTexMipMapMode12		90	// void grTexMipMapMode(GrChipID_t tmu, GrMipMapMode_t mode, FxBool lodBlend)
+#define	_grTexMultibase8		91	// void grTexMultibase(GrChipID_t tmu, FxBool enable)
+#define	_grTexMultibaseAddress20	92	// void grTexMultibaseAddress(GrChipID_t tmu, GrTexBaseRange_t range, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+#define	_grTexNCCTable8			93	// void grTexNCCTable(GrChipID_t tmu, GrNCCTable_t table)
+#define	_grTexSource16			94	// void grTexSource(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+#define	_grTexTextureMemRequired8	95	// FxU32 grTexTextureMemRequired(FxU32 evenOdd, GrTexInfo *info)
+#define	_grTriStats8			96	// void grTriStats(FxU32 *trisProcessed, FxU32 *trisDrawn)
+#define	_gu3dfGetInfo8			97	// FxBool gu3dfGetInfo(const char *filename, Gu3dfInfo *info)
+#define	_gu3dfLoad8			98	// FxBool gu3dfLoad(const char *filename, Gu3dfInfo *info)
+#define	_guAADrawTriangleWithClip12	99	// void guAADrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+#define	_guAlphaSource4			100	// void guAlphaSource(GrAlphaSource_t mode)
+#define	_guColorCombineFunction4	101	// void guColorCombineFunction(GrColorCombineFnc_t func)
+#define	_guDrawPolygonVertexListWithClip8 102	// void guDrawPolygonVertexListWithClip(int nverts, const GrVertex vlist[])
+#define	_guDrawTriangleWithClip12	103	// void guDrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+#define	_guEncodeRLE1616		104	//
+#define	_guEndianSwapBytes4		105	//
+#define	_guEndianSwapWords4		106	//
+#define	_guFogGenerateExp28		107	// void guFogGenerateExp2(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+#define	_guFogGenerateExp8		108	// void guFogGenerateExp(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+#define	_guFogGenerateLinear12		109	// void guFogGenerateLinear(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float nearW, float farW)
+#define	_guFogTableIndexToW4		110	// float guFogTableIndexToW(int i)
+#define	_guMPDrawTriangle12		111	//
+#define	_guMPInit0			112	//
+#define	_guMPTexCombineFunction4	113	//
+#define	_guMPTexSource8			114	//
+#define	_guMovieSetName4		115	//
+#define	_guMovieStart0			116	//
+#define	_guMovieStop0			117	//
+#define	_guTexAllocateMemory60		118	// GrMipMapId_t guTexAllocateMemory(GrChipID_t tmu, FxU8 evenOddMask, int width, int height, GrTextureFormat_t format, GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode, GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode, float lodBias, FxBool lodBlend)
+#define	_guTexChangeAttributes48	119	// FxBool guTexChangeAttributes(GrMipMapID_t mmid, int width, int height, GrTextureFormat_t format, GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode, GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode)
+#define	_guTexCombineFunction8		120	// void guTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t func)
+#define	_guTexCreateColorMipMap0	121	//
+#define	_guTexDownloadMipMap12		122	// void guTexDownloadMipMap(GrMipMapId_t mmid, const void *src, const GuNccTable *nccTable)
+#define	_guTexDownloadMipMapLevel12	123	// void guTexDownloadMipMapLevel(GrMipMapId_t mmid, GrLOD_t lod, const void **src)
+#define	_guTexGetCurrentMipMap4		124	// GrMipMapId_t guTexGetCurrentMipMap (GrChipID_t tmu)
+#define	_guTexGetMipMapInfo4		125	// GrMipMapInfo *guTexGetMipMapInfo(GrMipMapId_t mmid)
+#define	_guTexMemQueryAvail4		126	// FxU32 guTexMemQueryAvail(GrChipID_t tmu)
+#define	_guTexMemReset0			127	// void guTexMemReset(void)
+#define	_guTexSource4			128	// void guTexSource(GrMipMapId_t mmid)
+#define _ConvertAndDownloadRle64	129	// void ConvertAndDownloadRle(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd, FxU8 *bm_data, long  bm_h, FxU32 u0, FxU32 v0, FxU32 width, FxU32 height, FxU32 dest_width, FxU32 dest_height, FxU16 *tlut)
+#define GLIDE_MAX			129
+
+#endif // __3DFX_H__
+
+#endif // GLIDEDEF_H
diff -urN dosbox.orig/include/glide.h dosbox/include/glide.h
--- dosbox.orig/include/glide.h	1969-12-31 21:00:00.000000000 -0300
+++ dosbox/include/glide.h	2012-09-29 02:18:02.909193312 -0300
@@ -0,0 +1,331 @@
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef DOSBOX_GLIDE_H
+#define DOSBOX_GLIDE_H
+
+#define __3DFX_H__
+
+/*
+** basic data types
+*/
+typedef Bit8u   FxU8;
+typedef Bit8s   FxI8;
+typedef Bit16u  FxU16;
+typedef Bit16s  FxI16;
+typedef Bit32u  FxU32;
+typedef Bit32s  FxI32;
+typedef Bit32s  FxBool;
+typedef float   FxFloat;
+typedef double  FxDouble;
+
+/*
+** color types
+*/
+typedef Bit32u                       FxColor_t;
+typedef struct { float r, g, b, a; } FxColor4;
+
+/*
+** fundamental types
+*/
+#define FXTRUE    1
+#define FXFALSE   0
+
+/*
+** helper macros
+*/
+#define FXUNUSED( a ) ((void)(a))
+#define FXBIT( i )    ( 1L << (i) )
+
+#define FX_ENTRY
+#define FX_GLIDE_NO_FUNC_PROTO
+
+#if defined (WIN32)
+#define FX_CALL __stdcall
+#else
+#define FX_CALL
+#endif
+
+#include <openglide/sdk2_glide.h>
+#include "glidedef.h"
+
+// Careful with structures containing pointers
+//
+// GrTexInfo; GrLfbInfo_t; Gu3dfInfo; GrMipMapInfo;
+//
+
+// Some glide structs might have different size in guest 32-bit DOS (pointers)
+typedef struct {
+    Bit32s		smallLod;
+    Bit32s		largeLod;
+    Bit32s		aspectRatio;
+    Bit32s		format;
+    PhysPt		data;
+} DBGrTexInfo;
+
+typedef struct {
+    Bit32s		size;
+    PhysPt		lfbPtr;
+    Bit32u		strideInBytes;
+    Bit32s		writeMode;
+    Bit32s		origin;
+} DBGrLfbInfo_t;
+
+typedef struct {
+    Gu3dfHeader 	header;
+    GuTexTable		table;
+    PhysPt		data;
+    Bit32u		mem_required;
+} DBGu3dfInfo;
+
+typedef struct {
+    const char * name;
+    const Bit8u parms;
+} GLIDE_TABLE;
+
+typedef void (FX_CALL *pfunc0)		(void);
+typedef void (FX_CALL *pfunc1i)		(FxU32);
+typedef void (FX_CALL *pfunc1p)		(void*);
+typedef void (FX_CALL *pfunc1f)		(float);
+typedef void (FX_CALL *pfunc2i)		(FxU32, FxU32);
+typedef void (FX_CALL *pfunc1i1p)	(FxU32, void*);
+typedef void (FX_CALL *pfunc2p)		(void*, void*);
+typedef void (FX_CALL *pfunc1i1f)	(FxU32, float);
+typedef void (FX_CALL *pfunc1p1f)	(void*, float);
+typedef void (FX_CALL *pfunc3i)		(FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc2i1p)	(FxU32, FxU32, void*);
+typedef void (FX_CALL *pfunc1i2p)	(FxU32, void*, void*);
+typedef void (FX_CALL *pfunc3p)		(void*, void*, void*);
+typedef void (FX_CALL *pfunc1p2f)	(void*, float, float);
+typedef void (FX_CALL *pfunc4i)		(FxU32, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc3i1p)	(FxU32, FxU32, FxU32, void*);
+typedef void (FX_CALL *pfunc3i1f)	(FxU32, FxU32, FxU32, float);
+typedef void (FX_CALL *pfunc4f)		(float, float, float, float);
+typedef void (FX_CALL *pfunc5i)		(FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc2i1p2i)	(FxU32, FxU32, void*, FxU32, FxU32);
+typedef void (FX_CALL *pfunc4f1i)	(float, float, float, float, FxU32);
+typedef void (FX_CALL *pfunc3p3i)	(void*, void*, void*, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc7i)		(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc7i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef void (FX_CALL *pfunc7i1p2i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*,
+					    FxU32, FxU32);
+typedef void (FX_CALL *pfunc7i1p7i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*,
+					    FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+
+typedef FxU32 (FX_CALL *prfunc0)		(void);
+typedef FxU32 (FX_CALL *prfunc1i)	(FxU32);
+typedef FxU32 (FX_CALL *prfunc1p)	(void*);
+typedef FxU32 (FX_CALL *prfunc2i)	(FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc1i1p)	(FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc2p)	(void*, void*);
+typedef FxU32 (FX_CALL *prfunc4i)	(FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc5i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc7i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc1p6i)	(void*, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc6i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc7i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc12i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32,
+					    FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc13i1f1i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32,
+					    FxU32, FxU32, FxU32, FxU32, FxU32, float, FxU32);
+
+typedef void* (FX_CALL *prptfunc1i)	(FxU32);
+typedef float (FX_CALL *pffunc1i)	(FxU32);
+
+typedef union {
+    pfunc0	grFunction0;
+    pfunc1i	grFunction1i;
+    pfunc1p	grFunction1p;
+    pfunc1f	grFunction1f;
+    pfunc2i	grFunction2i;
+    pfunc1i1p	grFunction1i1p;
+    pfunc2p	grFunction2p;
+    pfunc1i1f	grFunction1i1f;
+    pfunc1p1f	grFunction1p1f;
+    pfunc3i	grFunction3i;
+    pfunc2i1p	grFunction2i1p;
+    pfunc1i2p	grFunction1i2p;
+    pfunc3p	grFunction3p;
+    pfunc1p2f	grFunction1p2f;
+    pfunc4i	grFunction4i;
+    pfunc3i1p	grFunction3i1p;
+    pfunc3i1f	grFunction3i1f;
+    pfunc4f	grFunction4f;
+    pfunc5i	grFunction5i;
+    pfunc2i1p2i	grFunction2i1p2i;
+    pfunc4f1i	grFunction4f1i;
+    pfunc3p3i	grFunction3p3i;
+    pfunc7i	grFunction7i;
+    pfunc7i1p	grFunction7i1p;
+    pfunc7i1p2i	grFunction7i1p2i;
+    pfunc7i1p7i1p grFunction7i1p7i1p;
+
+    prfunc0	grRFunction0;
+    prfunc1i	grRFunction1i;
+    prfunc1p	grRFunction1p;
+    prfunc2i	grRFunction2i;
+    prfunc1i1p	grRFunction1i1p;
+    prfunc2p	grRFunction2p;
+    prfunc4i	grRFunction4i;
+    prfunc5i1p	grRFunction5i1p;
+    prfunc7i	grRFunction7i;
+    prfunc1p6i	grRFunction1p6i;
+    prfunc6i1p	grRFunction6i1p;
+    prfunc7i1p	grRFunction7i1p;
+    prfunc12i	grRFunction12i;
+    prfunc13i1f1i grRFunction13i1f1i;
+
+    prptfunc1i	grRPTFunction1i;
+
+    pffunc1i	grFFunction1i;
+} FncPointers;
+
+static const GLIDE_TABLE grTable[] = {
+    { "grAADrawLine", 8 },
+    { "grAADrawPoint", 4 },
+    { "grAADrawPolygon", 12 },
+    { "grAADrawPolygonVertexList", 8 },
+    { "grAADrawTriangle", 24 },
+    { "grAlphaBlendFunction", 16 },
+    { "grAlphaCombine", 20 },
+    { "grAlphaControlsITRGBLighting", 4 },
+    { "grAlphaTestFunction", 4 },
+    { "grAlphaTestReferenceValue", 4 },
+    { "grBufferClear", 12 },
+    { "grBufferNumPending", 0 },
+    { "grBufferSwap", 4 },
+    { "grCheckForRoom", 4 },
+    { "grChromakeyMode", 4 },
+    { "grChromakeyValue", 4 },
+    { "grClipWindow", 16 },
+    { "grColorCombine", 20 },
+    { "grColorMask", 8 },
+    { "grConstantColorValue4", 16 },
+    { "grConstantColorValue", 4 },
+    { "grCullMode", 4 },
+    { "grDepthBiasLevel", 4 },
+    { "grDepthBufferFunction", 4 },
+    { "grDepthBufferMode", 4 },
+    { "grDepthMask", 4 },
+    { "grDisableAllEffects", 0 },
+    { "grDitherMode", 4 },
+    { "grDrawLine", 8 },
+    { "grDrawPlanarPolygon", 12 },
+    { "grDrawPlanarPolygonVertexList", 8 },
+    { "grDrawPoint", 4 },
+    { "grDrawPolygon", 12 },
+    { "grDrawPolygonVertexList", 8 },
+    { "grDrawTriangle", 12 },
+    { "grErrorSetCallback", 4 },
+    { "grFogColorValue", 4 },
+    { "grFogMode", 4 },
+    { "grFogTable", 4 },
+    { "grGammaCorrectionValue", 4 },
+    { "grGlideGetState", 4 },
+    { "grGlideGetVersion", 4 },
+    { "grGlideInit", 0 },
+    { "grGlideSetState", 4 },
+    { "grGlideShamelessPlug", 4 },
+    { "grGlideShutdown", 0 },
+    { "grHints", 8 },
+    { "grLfbConstantAlpha", 4 },
+    { "grLfbConstantDepth", 4 },
+    { "grLfbLock", 24 },
+    { "grLfbReadRegion", 28 },
+    { "grLfbUnlock", 8 },
+    { "grLfbWriteColorFormat", 4 },
+    { "grLfbWriteColorSwizzle", 8 },
+    { "grLfbWriteRegion", 32 },
+    { "grRenderBuffer", 4 },
+    { "grResetTriStats", 0 },
+    { "grSplash", 20 },
+    { "grSstConfigPipeline", 12 },
+    { "grSstControl", 4 },
+    { "grSstIdle", 0 },
+    { "grSstIsBusy", 0 },
+    { "grSstOrigin", 4 },
+    { "grSstPerfStats", 4 },
+    { "grSstQueryBoards", 4 },
+    { "grSstQueryHardware", 4 },
+    { "grSstResetPerfStats", 0 },
+    { "grSstScreenHeight", 0 },
+    { "grSstScreenWidth", 0 },
+    { "grSstSelect", 4 },
+    { "grSstStatus", 0 },
+    { "grSstVRetraceOn", 0 },
+    { "grSstVidMode", 8 },
+    { "grSstVideoLine", 0 },
+    { "grSstWinClose", 0 },
+    { "grSstWinOpen", 28 },
+    { "grTexCalcMemRequired", 16 },
+    { "grTexClampMode", 12 },
+    { "grTexCombine", 28 },
+    { "grTexCombineFunction", 8 },
+    { "grTexDetailControl", 16 },
+    { "grTexDownloadMipMap", 16 },
+    { "grTexDownloadMipMapLevel", 32 },
+    { "grTexDownloadMipMapLevelPartial", 40 },
+    { "grTexDownloadTable", 12 },
+    { "grTexDownloadTablePartial", 20 },
+    { "grTexFilterMode", 12 },
+    { "grTexLodBiasValue", 8 },
+    { "grTexMaxAddress", 4 },
+    { "grTexMinAddress", 4 },
+    { "grTexMipMapMode", 12 },
+    { "grTexMultibase", 8 },
+    { "grTexMultibaseAddress", 20 },
+    { "grTexNCCTable", 8 },
+    { "grTexSource", 16 },
+    { "grTexTextureMemRequired", 8 },
+    { "grTriStats", 8 },
+    { "gu3dfGetInfo", 8 },
+    { "gu3dfLoad", 8 },
+    { "guAADrawTriangleWithClip", 12 },
+    { "guAlphaSource", 4 },
+    { "guColorCombineFunction", 4 },
+    { "guDrawPolygonVertexListWithClip", 8 },
+    { "guDrawTriangleWithClip", 12 },
+    { "guEncodeRLE16", 16 },
+    { "guEndianSwapBytes", 4 },
+    { "guEndianSwapWords", 4 },
+    { "guFogGenerateExp2", 8 },
+    { "guFogGenerateExp", 8 },
+    { "guFogGenerateLinear", 12 },
+    { "guFogTableIndexToW", 4 },
+    { "guMPDrawTriangle", 12 },
+    { "guMPInit", 0 },
+    { "guMPTexCombineFunction", 4 },
+    { "guMPTexSource", 8 },
+    { "guMovieSetName", 4 },
+    { "guMovieStart", 0 },
+    { "guMovieStop", 0 },
+    { "guTexAllocateMemory", 60 },
+    { "guTexChangeAttributes", 48 },
+    { "guTexCombineFunction", 8 },
+    { "guTexCreateColorMipMap", 0 },
+    { "guTexDownloadMipMap", 12 },
+    { "guTexDownloadMipMapLevel", 12 },
+    { "guTexGetCurrentMipMap", 4 },
+    { "guTexGetMipMapInfo", 4 },
+    { "guTexMemQueryAvail", 4 },
+    { "guTexMemReset", 0 },
+    { "guTexSource", 4 },
+    { "ConvertAndDownloadRle", 64 }
+};
+
+#endif // DOSBOX_GLIDE_H
diff -urN dosbox.orig/include/mem.h dosbox/include/mem.h
--- dosbox.orig/include/mem.h	2012-09-29 02:17:58.492715311 -0300
+++ dosbox/include/mem.h	2012-09-29 02:18:02.909193312 -0300
@@ -152,6 +152,8 @@
 
 void MEM_BlockWrite(PhysPt pt,void const * const data,Bitu size);
 void MEM_BlockRead(PhysPt pt,void * data,Bitu size);
+void MEM_BlockWrite32(PhysPt pt,void * data,Bitu size);
+void MEM_BlockRead32(PhysPt pt,void * data,Bitu size);
 void MEM_BlockCopy(PhysPt dest,PhysPt src,Bitu size);
 void MEM_StrCopy(PhysPt pt,char * data,Bitu size);
 
diff -urN dosbox.orig/include/vga.h dosbox/include/vga.h
--- dosbox.orig/include/vga.h	2012-09-29 02:17:58.496048502 -0300
+++ dosbox/include/vga.h	2012-09-29 02:18:02.909193312 -0300
@@ -448,6 +448,7 @@
 void VGA_SetCGA4Table(Bit8u val0,Bit8u val1,Bit8u val2,Bit8u val3);
 void VGA_ActivateHardwareCursor(void);
 void VGA_KillDrawing(void);
+void VGA_SetOverride(bool override);
 
 void VGA_SetOverride(bool vga_override);
 
diff -urN dosbox.orig/src/dosbox.cpp dosbox/src/dosbox.cpp
--- dosbox.orig/src/dosbox.cpp	2012-09-29 02:17:58.459383401 -0300
+++ dosbox/src/dosbox.cpp	2012-09-29 02:18:02.909193312 -0300
@@ -86,6 +86,7 @@
 
 void KEYBOARD_Init(Section*);	//TODO This should setup INT 16 too but ok ;)
 void JOYSTICK_Init(Section*);
+void GLIDE_Init(Section*);
 void MOUSE_Init(Section*);
 void SBLASTER_Init(Section*);
 void GUS_Init(Section*);
@@ -668,6 +669,14 @@
 	Pmulti_remain->Set_help("see serial1");
 
 
+	secprop=control->AddSection_prop("glide",&GLIDE_Init,true);
+	Pbool = secprop->Add_bool("glide",Property::Changeable::WhenIdle,false);
+	Pbool->Set_help("Enable glide emulation: true,false.");
+	Phex = secprop->Add_hex("grport",Property::Changeable::WhenIdle,0x600);
+	Phex->Set_help("I/O port to use for host communication.");
+	Pstring = secprop->Add_string("lfb",Property::Changeable::WhenIdle,"full");
+	Pstring->Set_help("LFB access: full,read,write,none.");
+
 	/* All the DOS Related stuff, which will eventually start up in the shell */
 	secprop=control->AddSection_prop("dos",&DOS_Init,false);//done
 	secprop->AddInitFunction(&XMS_Init,true);//done
diff -urN dosbox.orig/src/dosbox.cpp.orig dosbox/src/dosbox.cpp.orig
--- dosbox.orig/src/dosbox.cpp.orig	2012-09-29 02:17:58.459383401 -0300
+++ dosbox/src/dosbox.cpp.orig	1969-12-31 21:00:00.000000000 -0300
@@ -1,712 +0,0 @@
-/*
- *  Copyright (C) 2002-2011  The DOSBox Team
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-
-#include <stdlib.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <string.h>
-#include <unistd.h>
-#include "dosbox.h"
-#include "debug.h"
-#include "cpu.h"
-#include "video.h"
-#include "pic.h"
-#include "cpu.h"
-#include "callback.h"
-#include "inout.h"
-#include "mixer.h"
-#include "timer.h"
-#include "dos_inc.h"
-#include "setup.h"
-#include "control.h"
-#include "cross.h"
-#include "programs.h"
-#include "support.h"
-#include "mapper.h"
-#include "ints/int10.h"
-#include "render.h"
-#include "pci_bus.h"
-
-Config * control;
-MachineType machine;
-SVGACards svgaCard;
-
-/* The whole load of startups for all the subfunctions */
-void MSG_Init(Section_prop *);
-void LOG_StartUp(void);
-void MEM_Init(Section *);
-void PAGING_Init(Section *);
-void IO_Init(Section * );
-void CALLBACK_Init(Section*);
-void PROGRAMS_Init(Section*);
-//void CREDITS_Init(Section*);
-void RENDER_Init(Section*);
-void VGA_Init(Section*);
-
-void DOS_Init(Section*);
-
-
-void CPU_Init(Section*);
-
-#if C_FPU
-void FPU_Init(Section*);
-#endif
-
-void DMA_Init(Section*);
-
-void MIXER_Init(Section*);
-void MIDI_Init(Section*);
-void HARDWARE_Init(Section*);
-
-#if defined(PCI_FUNCTIONALITY_ENABLED)
-void PCI_Init(Section*);
-#endif
-
-
-void KEYBOARD_Init(Section*);	//TODO This should setup INT 16 too but ok ;)
-void JOYSTICK_Init(Section*);
-void MOUSE_Init(Section*);
-void SBLASTER_Init(Section*);
-void GUS_Init(Section*);
-void MPU401_Init(Section*);
-void PCSPEAKER_Init(Section*);
-void TANDYSOUND_Init(Section*);
-void DISNEY_Init(Section*);
-void SERIAL_Init(Section*); 
-
-
-#if C_IPX
-void IPX_Init(Section*);
-#endif
-
-void SID_Init(Section* sec);
-
-void PIC_Init(Section*);
-void TIMER_Init(Section*);
-void BIOS_Init(Section*);
-void DEBUG_Init(Section*);
-void CMOS_Init(Section*);
-
-void MSCDEX_Init(Section*);
-void DRIVES_Init(Section*);
-void CDROM_Image_Init(Section*);
-
-/* Dos Internal mostly */
-void EMS_Init(Section*);
-void XMS_Init(Section*);
-
-void DOS_KeyboardLayout_Init(Section*);
-
-void AUTOEXEC_Init(Section*);
-void SHELL_Init(void);
-
-void INT10_Init(Section*);
-
-static LoopHandler * loop;
-
-bool SDLNetInited;
-
-static Bit32u ticksRemain;
-static Bit32u ticksLast;
-static Bit32u ticksAdded;
-Bit32s ticksDone;
-Bit32u ticksScheduled;
-bool ticksLocked;
-
-static Bitu Normal_Loop(void) {
-	Bits ret;
-	while (1) {
-		if (PIC_RunQueue()) {
-			ret = (*cpudecoder)();
-			if (GCC_UNLIKELY(ret<0)) return 1;
-			if (ret>0) {
-				if (GCC_UNLIKELY(ret >= CB_MAX)) return 0;
-				Bitu blah = (*CallBack_Handlers[ret])();
-				if (GCC_UNLIKELY(blah)) return blah;
-			}
-#if C_DEBUG
-			if (DEBUG_ExitLoop()) return 0;
-#endif
-		} else {
-			GFX_Events();
-			if (ticksRemain>0) {
-				TIMER_AddTick();
-				ticksRemain--;
-			} else goto increaseticks;
-		}
-	}
-increaseticks:
-	if (GCC_UNLIKELY(ticksLocked)) {
-		ticksRemain=5;
-		/* Reset any auto cycle guessing for this frame */
-		ticksLast = GetTicks();
-		ticksAdded = 0;
-		ticksDone = 0;
-		ticksScheduled = 0;
-	} else {
-		Bit32u ticksNew;
-		ticksNew=GetTicks();
-		ticksScheduled += ticksAdded;
-		if (ticksNew > ticksLast) {
-			ticksRemain = ticksNew-ticksLast;
-			ticksLast = ticksNew;
-			ticksDone += ticksRemain;
-			if ( ticksRemain > 20 ) {
-				ticksRemain = 20;
-			}
-			ticksAdded = ticksRemain;
-			if (CPU_CycleAutoAdjust && !CPU_SkipCycleAutoAdjust) {
-				if (ticksScheduled >= 250 || ticksDone >= 250 || (ticksAdded > 15 && ticksScheduled >= 5) ) {
-					if(ticksDone < 1) ticksDone = 1; // Protect against div by zero
-					/* ratio we are aiming for is around 90% usage*/
-					Bit32s ratio = (ticksScheduled * (CPU_CyclePercUsed*90*1024/100/100)) / ticksDone;
-					Bit32s new_cmax = CPU_CycleMax;
-					Bit64s cproc = (Bit64s)CPU_CycleMax * (Bit64s)ticksScheduled;
-					if (cproc > 0) {
-						/* ignore the cycles added due to the io delay code in order
-						   to have smoother auto cycle adjustments */
-						double ratioremoved = (double) CPU_IODelayRemoved / (double) cproc;
-						if (ratioremoved < 1.0) {
-							ratio = (Bit32s)((double)ratio * (1 - ratioremoved));
-							/* Don't allow very high ratio which can cause us to lock as we don't scale down
-							 * for very low ratios. High ratio might result because of timing resolution */
-							if (ticksScheduled >= 250 && ticksDone < 10 && ratio > 20480) 
-								ratio = 20480;
-							Bit64s cmax_scaled = (Bit64s)CPU_CycleMax * (Bit64s)ratio;
-							if (ratio <= 1024) 
-								new_cmax = (Bit32s)(cmax_scaled / (Bit64s)1024);
-							else 
-								new_cmax = (Bit32s)(1 + (CPU_CycleMax >> 1) + cmax_scaled / (Bit64s)2048);
-						}
-					}
-
-					if (new_cmax<CPU_CYCLES_LOWER_LIMIT)
-						new_cmax=CPU_CYCLES_LOWER_LIMIT;
-
-					/* ratios below 1% are considered to be dropouts due to
-					   temporary load imbalance, the cycles adjusting is skipped */
-					if (ratio>10) {
-						/* ratios below 12% along with a large time since the last update
-						   has taken place are most likely caused by heavy load through a
-						   different application, the cycles adjusting is skipped as well */
-						if ((ratio>120) || (ticksDone<700)) {
-							CPU_CycleMax = new_cmax;
-							if (CPU_CycleLimit > 0) {
-								if (CPU_CycleMax>CPU_CycleLimit) CPU_CycleMax = CPU_CycleLimit;
-							}
-						}
-					}
-					CPU_IODelayRemoved = 0;
-					ticksDone = 0;
-					ticksScheduled = 0;
-				} else if (ticksAdded > 15) {
-					/* ticksAdded > 15 but ticksScheduled < 5, lower the cycles
-					   but do not reset the scheduled/done ticks to take them into
-					   account during the next auto cycle adjustment */
-					CPU_CycleMax /= 3;
-					if (CPU_CycleMax < CPU_CYCLES_LOWER_LIMIT)
-						CPU_CycleMax = CPU_CYCLES_LOWER_LIMIT;
-				}
-			}
-		} else {
-			ticksAdded = 0;
-			SDL_Delay(1);
-			ticksDone -= GetTicks() - ticksNew;
-			if (ticksDone < 0)
-				ticksDone = 0;
-		}
-	}
-	return 0;
-}
-
-void DOSBOX_SetLoop(LoopHandler * handler) {
-	loop=handler;
-}
-
-void DOSBOX_SetNormalLoop() {
-	loop=Normal_Loop;
-}
-
-void DOSBOX_RunMachine(void){
-	Bitu ret;
-	do {
-		ret=(*loop)();
-	} while (!ret);
-}
-
-static void DOSBOX_UnlockSpeed( bool pressed ) {
-	static bool autoadjust = false;
-	if (pressed) {
-		LOG_MSG("Fast Forward ON");
-		ticksLocked = true;
-		if (CPU_CycleAutoAdjust) {
-			autoadjust = true;
-			CPU_CycleAutoAdjust = false;
-			CPU_CycleMax /= 3;
-			if (CPU_CycleMax<1000) CPU_CycleMax=1000;
-		}
-	} else {
-		LOG_MSG("Fast Forward OFF");
-		ticksLocked = false;
-		if (autoadjust) {
-			autoadjust = false;
-			CPU_CycleAutoAdjust = true;
-		}
-	}
-}
-
-static void DOSBOX_RealInit(Section * sec) {
-	Section_prop * section=static_cast<Section_prop *>(sec);
-	/* Initialize some dosbox internals */
-
-	ticksRemain=0;
-	ticksLast=GetTicks();
-	ticksLocked = false;
-	DOSBOX_SetLoop(&Normal_Loop);
-	MSG_Init(section);
-
-	MAPPER_AddHandler(DOSBOX_UnlockSpeed, MK_f12, MMOD2,"speedlock","Speedlock");
-	std::string cmd_machine;
-	if (control->cmdline->FindString("-machine",cmd_machine,true)){
-		//update value in config (else no matching against suggested values
-		section->HandleInputline(std::string("machine=") + cmd_machine);
-	}
-
-	std::string mtype(section->Get_string("machine"));
-	svgaCard = SVGA_None; 
-	machine = MCH_VGA;
-	int10.vesa_nolfb = false;
-	int10.vesa_oldvbe = false;
-	if      (mtype == "cga")      { machine = MCH_CGA; }
-	else if (mtype == "tandy")    { machine = MCH_TANDY; }
-	else if (mtype == "pcjr")     { machine = MCH_PCJR; }
-	else if (mtype == "hercules") { machine = MCH_HERC; }
-	else if (mtype == "ega")      { machine = MCH_EGA; }
-//	else if (mtype == "vga")          { svgaCard = SVGA_S3Trio; }
-	else if (mtype == "svga_s3")       { svgaCard = SVGA_S3Trio; }
-	else if (mtype == "vesa_nolfb")   { svgaCard = SVGA_S3Trio; int10.vesa_nolfb = true;}
-	else if (mtype == "vesa_oldvbe")   { svgaCard = SVGA_S3Trio; int10.vesa_oldvbe = true;}
-	else if (mtype == "svga_et4000")   { svgaCard = SVGA_TsengET4K; }
-	else if (mtype == "svga_et3000")   { svgaCard = SVGA_TsengET3K; }
-//	else if (mtype == "vga_pvga1a")   { svgaCard = SVGA_ParadisePVGA1A; }
-	else if (mtype == "svga_paradise") { svgaCard = SVGA_ParadisePVGA1A; }
-	else if (mtype == "vgaonly")      { svgaCard = SVGA_None; }
-	else E_Exit("DOSBOX:Unknown machine type %s",mtype.c_str());
-}
-
-
-void DOSBOX_Init(void) {
-	Section_prop * secprop;
-	Section_line * secline;
-	Prop_int* Pint;
-	Prop_hex* Phex;
-	Prop_string* Pstring;
-	Prop_bool* Pbool;
-	Prop_multival* Pmulti;
-	Prop_multival_remain* Pmulti_remain;
-
-	SDLNetInited = false;
-
-	// Some frequently used option sets
-	const char *rates[] = {  "44100", "48000", "32000","22050", "16000", "11025", "8000", "49716", 0 };
-	const char *oplrates[] = {   "44100", "49716", "48000", "32000","22050", "16000", "11025", "8000", 0 };
-	const char *ios[] = { "220", "240", "260", "280", "2a0", "2c0", "2e0", "300", 0 };
-	const char *irqssb[] = { "7", "5", "3", "9", "10", "11", "12", 0 };
-	const char *dmassb[] = { "1", "5", "0", "3", "6", "7", 0 };
-	const char *iosgus[] = { "240", "220", "260", "280", "2a0", "2c0", "2e0", "300", 0 };
-	const char *irqsgus[] = { "5", "3", "7", "9", "10", "11", "12", 0 };
-	const char *dmasgus[] = { "3", "0", "1", "5", "6", "7", 0 };
-
-
-	/* Setup all the different modules making up DOSBox */
-	const char* machines[] = {
-		"hercules", "cga", "tandy", "pcjr", "ega",
-		"vgaonly", "svga_s3", "svga_et3000", "svga_et4000",
-		"svga_paradise", "vesa_nolfb", "vesa_oldvbe", 0 };
-	secprop=control->AddSection_prop("dosbox",&DOSBOX_RealInit);
-	Pstring = secprop->Add_path("language",Property::Changeable::Always,"");
-	Pstring->Set_help("Select another language file.");
-
-	Pstring = secprop->Add_string("machine",Property::Changeable::OnlyAtStart,"svga_s3");
-	Pstring->Set_values(machines);
-	Pstring->Set_help("The type of machine DOSBox tries to emulate.");
-
-	Pstring = secprop->Add_path("captures",Property::Changeable::Always,"capture");
-	Pstring->Set_help("Directory where things like wave, midi, screenshot get captured.");
-
-#if C_DEBUG	
-	LOG_StartUp();
-#endif
-	
-	secprop->AddInitFunction(&IO_Init);//done
-	secprop->AddInitFunction(&PAGING_Init);//done
-	secprop->AddInitFunction(&MEM_Init);//done
-	secprop->AddInitFunction(&HARDWARE_Init);//done
-	Pint = secprop->Add_int("memsize", Property::Changeable::WhenIdle,16);
-	Pint->SetMinMax(1,63);
-	Pint->Set_help(
-		"Amount of memory DOSBox has in megabytes.\n"
-		"  This value is best left at its default to avoid problems with some games,\n"
-		"  though few games might require a higher value.\n"
-		"  There is generally no speed advantage when raising this value.");
-	secprop->AddInitFunction(&CALLBACK_Init);
-	secprop->AddInitFunction(&PIC_Init);//done
-	secprop->AddInitFunction(&PROGRAMS_Init);
-	secprop->AddInitFunction(&TIMER_Init);//done
-	secprop->AddInitFunction(&CMOS_Init);//done
-
-	secprop=control->AddSection_prop("render",&RENDER_Init,true);
-	Pint = secprop->Add_int("frameskip",Property::Changeable::Always,0);
-	Pint->SetMinMax(0,10);
-	Pint->Set_help("How many frames DOSBox skips before drawing one.");
-
-	Pbool = secprop->Add_bool("aspect",Property::Changeable::Always,false);
-	Pbool->Set_help("Do aspect correction, if your output method doesn't support scaling this can slow things down!.");
-
-	Pmulti = secprop->Add_multi("scaler",Property::Changeable::Always," ");
-	Pmulti->SetValue("normal2x");
-	Pmulti->Set_help("Scaler used to enlarge/enhance low resolution modes. If 'forced' is appended,\n"
-	                 "then the scaler will be used even if the result might not be desired.");
-	Pstring = Pmulti->GetSection()->Add_string("type",Property::Changeable::Always,"normal2x");
-
-	const char *scalers[] = { 
-		"none", "normal2x", "normal3x",
-#if RENDER_USE_ADVANCED_SCALERS>2
-		"advmame2x", "advmame3x", "advinterp2x", "advinterp3x", "hq2x", "hq3x", "2xsai", "super2xsai", "supereagle",
-#endif
-#if RENDER_USE_ADVANCED_SCALERS>0
-		"tv2x", "tv3x", "rgb2x", "rgb3x", "scan2x", "scan3x",
-#endif
-		0 };
-	Pstring->Set_values(scalers);
-
-	const char* force[] = { "", "forced", 0 };
-	Pstring = Pmulti->GetSection()->Add_string("force",Property::Changeable::Always,"");
-	Pstring->Set_values(force);
-
-	secprop=control->AddSection_prop("cpu",&CPU_Init,true);//done
-	const char* cores[] = { "auto",
-#if (C_DYNAMIC_X86) || (C_DYNREC)
-		"dynamic",
-#endif
-		"normal", "simple",0 };
-	Pstring = secprop->Add_string("core",Property::Changeable::WhenIdle,"auto");
-	Pstring->Set_values(cores);
-	Pstring->Set_help("CPU Core used in emulation. auto will switch to dynamic if available and\n"
-		"appropriate.");
-
-	const char* cputype_values[] = { "auto", "386", "386_slow", "486_slow", "pentium_slow", "386_prefetch", 0};
-	Pstring = secprop->Add_string("cputype",Property::Changeable::Always,"auto");
-	Pstring->Set_values(cputype_values);
-	Pstring->Set_help("CPU Type used in emulation. auto is the fastest choice.");
-
-
-	Pmulti_remain = secprop->Add_multiremain("cycles",Property::Changeable::Always," ");
-	Pmulti_remain->Set_help(
-		"Amount of instructions DOSBox tries to emulate each millisecond.\n"
-		"Setting this value too high results in sound dropouts and lags.\n"
-		"Cycles can be set in 3 ways:\n"
-		"  'auto'          tries to guess what a game needs.\n"
-		"                  It usually works, but can fail for certain games.\n"
-		"  'fixed #number' will set a fixed amount of cycles. This is what you usually\n"
-		"                  need if 'auto' fails (Example: fixed 4000).\n"
-		"  'max'           will allocate as much cycles as your computer is able to\n"
-		"                  handle.");
-
-	const char* cyclest[] = { "auto","fixed","max","%u",0 };
-	Pstring = Pmulti_remain->GetSection()->Add_string("type",Property::Changeable::Always,"auto");
-	Pmulti_remain->SetValue("auto");
-	Pstring->Set_values(cyclest);
-
-	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::Always,"");
-	
-	Pint = secprop->Add_int("cycleup",Property::Changeable::Always,10);
-	Pint->SetMinMax(1,1000000);
-	Pint->Set_help("Amount of cycles to decrease/increase with keycombos.(CTRL-F11/CTRL-F12)");
-
-	Pint = secprop->Add_int("cycledown",Property::Changeable::Always,20);
-	Pint->SetMinMax(1,1000000);
-	Pint->Set_help("Setting it lower than 100 will be a percentage.");
-		
-#if C_FPU
-	secprop->AddInitFunction(&FPU_Init);
-#endif
-	secprop->AddInitFunction(&DMA_Init);//done
-	secprop->AddInitFunction(&VGA_Init);
-	secprop->AddInitFunction(&KEYBOARD_Init);
-
-
-#if defined(PCI_FUNCTIONALITY_ENABLED)
-	secprop=control->AddSection_prop("pci",&PCI_Init,false); //PCI bus
-#endif
-
-
-	secprop=control->AddSection_prop("mixer",&MIXER_Init);
-	Pbool = secprop->Add_bool("nosound",Property::Changeable::OnlyAtStart,false);
-	Pbool->Set_help("Enable silent mode, sound is still emulated though.");
-
-	Pint = secprop->Add_int("rate",Property::Changeable::OnlyAtStart,44100);
-	Pint->Set_values(rates);
-	Pint->Set_help("Mixer sample rate, setting any device's rate higher than this will probably lower their sound quality.");
-
-	const char *blocksizes[] = {
-		 "1024", "2048", "4096", "8192", "512", "256", 0};
-	Pint = secprop->Add_int("blocksize",Property::Changeable::OnlyAtStart,1024);
-	Pint->Set_values(blocksizes);
-	Pint->Set_help("Mixer block size, larger blocks might help sound stuttering but sound will also be more lagged.");
-
-	Pint = secprop->Add_int("prebuffer",Property::Changeable::OnlyAtStart,20);
-	Pint->SetMinMax(0,100);
-	Pint->Set_help("How many milliseconds of data to keep on top of the blocksize.");
-
-	secprop=control->AddSection_prop("midi",&MIDI_Init,true);//done
-	secprop->AddInitFunction(&MPU401_Init,true);//done
-	
-	const char* mputypes[] = { "intelligent", "uart", "none",0};
-	// FIXME: add some way to offer the actually available choices.
-	const char *devices[] = { "default", "win32", "alsa", "oss", "coreaudio", "coremidi","none", 0};
-	Pstring = secprop->Add_string("mpu401",Property::Changeable::WhenIdle,"intelligent");
-	Pstring->Set_values(mputypes);
-	Pstring->Set_help("Type of MPU-401 to emulate.");
-
-	Pstring = secprop->Add_string("mididevice",Property::Changeable::WhenIdle,"default");
-	Pstring->Set_values(devices);
-	Pstring->Set_help("Device that will receive the MIDI data from MPU-401.");
-
-	Pstring = secprop->Add_string("midiconfig",Property::Changeable::WhenIdle,"");
-	Pstring->Set_help("Special configuration options for the device driver. This is usually the id of the device you want to use.\n"
-	                  "  or in the case of coreaudio, you can specify a soundfont here.\n"
-	                  "  When using a Roland MT-32 rev. 0 as midi output device, some games may require a delay in order to prevent 'buffer overflow' issues.\n"
-	                  "  In that case, add 'delaysysex', for example: midiconfig=2 delaysysex\n"
-	                  "  See the README/Manual for more details.");
-
-#if C_DEBUG
-	secprop=control->AddSection_prop("debug",&DEBUG_Init);
-#endif
-
-	secprop=control->AddSection_prop("sblaster",&SBLASTER_Init,true);//done
-	
-	const char* sbtypes[] = { "sb1", "sb2", "sbpro1", "sbpro2", "sb16", "gb", "none", 0 };
-	Pstring = secprop->Add_string("sbtype",Property::Changeable::WhenIdle,"sb16");
-	Pstring->Set_values(sbtypes);
-	Pstring->Set_help("Type of Soundblaster to emulate. gb is Gameblaster.");
-
-	Phex = secprop->Add_hex("sbbase",Property::Changeable::WhenIdle,0x220);
-	Phex->Set_values(ios);
-	Phex->Set_help("The IO address of the soundblaster.");
-
-	Pint = secprop->Add_int("irq",Property::Changeable::WhenIdle,7);
-	Pint->Set_values(irqssb);
-	Pint->Set_help("The IRQ number of the soundblaster.");
-
-	Pint = secprop->Add_int("dma",Property::Changeable::WhenIdle,1);
-	Pint->Set_values(dmassb);
-	Pint->Set_help("The DMA number of the soundblaster.");
-
-	Pint = secprop->Add_int("hdma",Property::Changeable::WhenIdle,5);
-	Pint->Set_values(dmassb);
-	Pint->Set_help("The High DMA number of the soundblaster.");
-
-	Pbool = secprop->Add_bool("sbmixer",Property::Changeable::WhenIdle,true);
-	Pbool->Set_help("Allow the soundblaster mixer to modify the DOSBox mixer.");
-
-	const char* oplmodes[]={ "auto", "cms", "opl2", "dualopl2", "opl3", "none", 0};
-	Pstring = secprop->Add_string("oplmode",Property::Changeable::WhenIdle,"auto");
-	Pstring->Set_values(oplmodes);
-	Pstring->Set_help("Type of OPL emulation. On 'auto' the mode is determined by sblaster type. All OPL modes are Adlib-compatible, except for 'cms'.");
-
-	const char* oplemus[]={ "default", "compat", "fast", 0};
-	Pstring = secprop->Add_string("oplemu",Property::Changeable::WhenIdle,"default");
-	Pstring->Set_values(oplemus);
-	Pstring->Set_help("Provider for the OPL emulation. compat might provide better quality (see oplrate as well).");
-
-	Pint = secprop->Add_int("oplrate",Property::Changeable::WhenIdle,44100);
-	Pint->Set_values(oplrates);
-	Pint->Set_help("Sample rate of OPL music emulation. Use 49716 for highest quality (set the mixer rate accordingly).");
-
-
-	secprop=control->AddSection_prop("gus",&GUS_Init,true); //done
-	Pbool = secprop->Add_bool("gus",Property::Changeable::WhenIdle,false); 	
-	Pbool->Set_help("Enable the Gravis Ultrasound emulation.");
-
-	Pint = secprop->Add_int("gusrate",Property::Changeable::WhenIdle,44100);
-	Pint->Set_values(rates);
-	Pint->Set_help("Sample rate of Ultrasound emulation.");
-
-	Phex = secprop->Add_hex("gusbase",Property::Changeable::WhenIdle,0x240);
-	Phex->Set_values(iosgus);
-	Phex->Set_help("The IO base address of the Gravis Ultrasound.");
-
-	Pint = secprop->Add_int("gusirq",Property::Changeable::WhenIdle,5);
-	Pint->Set_values(irqsgus);
-	Pint->Set_help("The IRQ number of the Gravis Ultrasound.");
-
-	Pint = secprop->Add_int("gusdma",Property::Changeable::WhenIdle,3);
-	Pint->Set_values(dmasgus);
-	Pint->Set_help("The DMA channel of the Gravis Ultrasound.");
-
-	Pstring = secprop->Add_string("ultradir",Property::Changeable::WhenIdle,"C:\\ULTRASND");
-	Pstring->Set_help(
-		"Path to Ultrasound directory. In this directory\n"
-		"there should be a MIDI directory that contains\n"
-		"the patch files for GUS playback. Patch sets used\n"
-		"with Timidity should work fine.");
-
-	secprop = control->AddSection_prop("speaker",&PCSPEAKER_Init,true);//done
-	Pbool = secprop->Add_bool("pcspeaker",Property::Changeable::WhenIdle,true);
-	Pbool->Set_help("Enable PC-Speaker emulation.");
-
-	Pint = secprop->Add_int("pcrate",Property::Changeable::WhenIdle,44100);
-	Pint->Set_values(rates);
-	Pint->Set_help("Sample rate of the PC-Speaker sound generation.");
-
-	secprop->AddInitFunction(&TANDYSOUND_Init,true);//done
-	const char* tandys[] = { "auto", "on", "off", 0};
-	Pstring = secprop->Add_string("tandy",Property::Changeable::WhenIdle,"auto");
-	Pstring->Set_values(tandys);
-	Pstring->Set_help("Enable Tandy Sound System emulation. For 'auto', emulation is present only if machine is set to 'tandy'.");
-	
-	Pint = secprop->Add_int("tandyrate",Property::Changeable::WhenIdle,44100);
-	Pint->Set_values(rates);
-	Pint->Set_help("Sample rate of the Tandy 3-Voice generation.");
-
-	secprop->AddInitFunction(&DISNEY_Init,true);//done
-	
-	Pbool = secprop->Add_bool("disney",Property::Changeable::WhenIdle,true);
-	Pbool->Set_help("Enable Disney Sound Source emulation. (Covox Voice Master and Speech Thing compatible).");
-
-	secprop=control->AddSection_prop("joystick",&BIOS_Init,false);//done
-	secprop->AddInitFunction(&INT10_Init);
-	secprop->AddInitFunction(&MOUSE_Init); //Must be after int10 as it uses CurMode
-	secprop->AddInitFunction(&JOYSTICK_Init);
-	const char* joytypes[] = { "auto", "2axis", "4axis", "4axis_2", "fcs", "ch", "none",0};
-	Pstring = secprop->Add_string("joysticktype",Property::Changeable::WhenIdle,"auto");
-	Pstring->Set_values(joytypes);
-	Pstring->Set_help(
-		"Type of joystick to emulate: auto (default), none,\n"
-		"2axis (supports two joysticks),\n"
-		"4axis (supports one joystick, first joystick used),\n"
-		"4axis_2 (supports one joystick, second joystick used),\n"
-		"fcs (Thrustmaster), ch (CH Flightstick).\n"
-		"none disables joystick emulation.\n"
-		"auto chooses emulation depending on real joystick(s).\n"
-		"(Remember to reset dosbox's mapperfile if you saved it earlier)");
-
-	Pbool = secprop->Add_bool("timed",Property::Changeable::WhenIdle,true);
-	Pbool->Set_help("enable timed intervals for axis. Experiment with this option, if your joystick drifts (away).");
-
-	Pbool = secprop->Add_bool("autofire",Property::Changeable::WhenIdle,false);
-	Pbool->Set_help("continuously fires as long as you keep the button pressed.");
-	
-	Pbool = secprop->Add_bool("swap34",Property::Changeable::WhenIdle,false);
-	Pbool->Set_help("swap the 3rd and the 4th axis. can be useful for certain joysticks.");
-
-	Pbool = secprop->Add_bool("buttonwrap",Property::Changeable::WhenIdle,false);
-	Pbool->Set_help("enable button wrapping at the number of emulated buttons.");
-
-	secprop=control->AddSection_prop("serial",&SERIAL_Init,true);
-	const char* serials[] = { "dummy", "disabled", "modem", "nullmodem",
-	                          "directserial",0 };
-   
-	Pmulti_remain = secprop->Add_multiremain("serial1",Property::Changeable::WhenIdle," ");
-	Pstring = Pmulti_remain->GetSection()->Add_string("type",Property::Changeable::WhenIdle,"dummy");
-	Pmulti_remain->SetValue("dummy");
-	Pstring->Set_values(serials);
-	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::WhenIdle,"");
-	Pmulti_remain->Set_help(
-		"set type of device connected to com port.\n"
-		"Can be disabled, dummy, modem, nullmodem, directserial.\n"
-		"Additional parameters must be in the same line in the form of\n"
-		"parameter:value. Parameter for all types is irq (optional).\n"
-		"for directserial: realport (required), rxdelay (optional).\n"
-		"                 (realport:COM1 realport:ttyS0).\n"
-		"for modem: listenport (optional).\n"
-		"for nullmodem: server, rxdelay, txdelay, telnet, usedtr,\n"
-		"               transparent, port, inhsocket (all optional).\n"
-		"Example: serial1=modem listenport:5000");
-
-	Pmulti_remain = secprop->Add_multiremain("serial2",Property::Changeable::WhenIdle," ");
-	Pstring = Pmulti_remain->GetSection()->Add_string("type",Property::Changeable::WhenIdle,"dummy");
-	Pmulti_remain->SetValue("dummy");
-	Pstring->Set_values(serials);
-	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::WhenIdle,"");
-	Pmulti_remain->Set_help("see serial1");
-
-	Pmulti_remain = secprop->Add_multiremain("serial3",Property::Changeable::WhenIdle," ");
-	Pstring = Pmulti_remain->GetSection()->Add_string("type",Property::Changeable::WhenIdle,"disabled");
-	Pmulti_remain->SetValue("disabled");
-	Pstring->Set_values(serials);
-	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::WhenIdle,"");
-	Pmulti_remain->Set_help("see serial1");
-
-	Pmulti_remain = secprop->Add_multiremain("serial4",Property::Changeable::WhenIdle," ");
-	Pstring = Pmulti_remain->GetSection()->Add_string("type",Property::Changeable::WhenIdle,"disabled");
-	Pmulti_remain->SetValue("disabled");
-	Pstring->Set_values(serials);
-	Pstring = Pmulti_remain->GetSection()->Add_string("parameters",Property::Changeable::WhenIdle,"");
-	Pmulti_remain->Set_help("see serial1");
-
-
-	/* All the DOS Related stuff, which will eventually start up in the shell */
-	secprop=control->AddSection_prop("dos",&DOS_Init,false);//done
-	secprop->AddInitFunction(&XMS_Init,true);//done
-	Pbool = secprop->Add_bool("xms",Property::Changeable::WhenIdle,true);
-	Pbool->Set_help("Enable XMS support.");
-
-	secprop->AddInitFunction(&EMS_Init,true);//done
-	const char* ems_settings[] = { "true", "emsboard", "emm386", "false", 0};
-	Pstring = secprop->Add_string("ems",Property::Changeable::WhenIdle,"true");
-	Pstring->Set_values(ems_settings);
-	Pstring->Set_help("Enable EMS support. The default (=true) provides the best\n"
-		"compatibility but certain applications may run better with\n"
-		"other choices, or require EMS support to be disabled (=false)\n"
-		"to work at all.");
-
-	Pbool = secprop->Add_bool("umb",Property::Changeable::WhenIdle,true);
-	Pbool->Set_help("Enable UMB support.");
-
-	secprop->AddInitFunction(&DOS_KeyboardLayout_Init,true);
-	Pstring = secprop->Add_string("keyboardlayout",Property::Changeable::WhenIdle, "auto");
-	Pstring->Set_help("Language code of the keyboard layout (or none).");
-
-	// Mscdex
-	secprop->AddInitFunction(&MSCDEX_Init);
-	secprop->AddInitFunction(&DRIVES_Init);
-	secprop->AddInitFunction(&CDROM_Image_Init);
-#if C_IPX
-	secprop=control->AddSection_prop("ipx",&IPX_Init,true);
-	Pbool = secprop->Add_bool("ipx",Property::Changeable::WhenIdle, false);
-	Pbool->Set_help("Enable ipx over UDP/IP emulation.");
-#endif
-//	secprop->AddInitFunction(&CREDITS_Init);
-
-	//TODO ?
-	secline=control->AddSection_line("autoexec",&AUTOEXEC_Init);
-	MSG_Add("AUTOEXEC_CONFIGFILE_HELP",
-		"Lines in this section will be run at startup.\n"
-		"You can put your MOUNT lines here.\n"
-	);
-	MSG_Add("CONFIGFILE_INTRO",
-	        "# This is the configuration file for DOSBox %s. (Please use the latest version of DOSBox)\n"
-	        "# Lines starting with a # are comment lines and are ignored by DOSBox.\n"
-	        "# They are used to (briefly) document the effect of each option.\n");
-	MSG_Add("CONFIG_SUGGESTED_VALUES", "Possible values");
-
-	control->SetStartUp(&SHELL_Init);
-}
diff -urN dosbox.orig/src/gui/sdlmain.cpp dosbox/src/gui/sdlmain.cpp
--- dosbox.orig/src/gui/sdlmain.cpp	2012-09-29 02:17:58.462716592 -0300
+++ dosbox/src/gui/sdlmain.cpp	2012-09-29 02:18:02.909193312 -0300
@@ -49,6 +49,7 @@
 #include "cpu.h"
 #include "cross.h"
 #include "control.h"
+#include "glidedef.h"
 
 #define MAPPERFILE "mapper-" VERSION ".map"
 //#define DISABLE_JOYSTICK
@@ -380,6 +381,10 @@
 
 
 void GFX_ResetScreen(void) {
+	if(glide.enabled) {
+		GLIDE_ResetScreen(true);
+		return;
+	}
 	GFX_Stop();
 	if (sdl.draw.callback)
 		(sdl.draw.callback)( GFX_CallBackReset );
@@ -780,7 +785,10 @@
 		sticky_keys(true); //restore sticky keys to default state in windowed mode.
 #endif
 	}
-	GFX_ResetScreen();
+	if (glide.enabled)
+		GLIDE_ResetScreen();
+	else
+		GFX_ResetScreen();
 }
 
 static void SwitchFullScreen(bool pressed) {
@@ -1519,7 +1527,7 @@
 			throw(0);
 			break;
 		case SDL_VIDEOEXPOSE:
-			if (sdl.draw.callback) sdl.draw.callback( GFX_CallBackRedraw );
+			if ((sdl.draw.callback) && (!glide.enabled)) sdl.draw.callback( GFX_CallBackRedraw );
 			break;
 #ifdef WIN32
 		case SDL_KEYDOWN:
@@ -1936,6 +1944,7 @@
 			if (strcmp(sdl_drv_name,"windib")==0) LOG_MSG("SDL_Init: Starting up with SDL windib video driver.\n          Try to update your video card and directx drivers!");
 		}
 #endif
+	glide.fullscreen = &sdl.desktop.fullscreen;
 	sdl.num_joysticks=SDL_NumJoysticks();
 
 	/* Parse configuration files */
diff -urN dosbox.orig/src/hardware/glide.cpp dosbox/src/hardware/glide.cpp
--- dosbox.orig/src/hardware/glide.cpp	1969-12-31 21:00:00.000000000 -0300
+++ dosbox/src/hardware/glide.cpp	2012-09-29 02:18:02.912526503 -0300
@@ -0,0 +1,1805 @@
+/*
+ *  Copyright (C) 2002-2009  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "dosbox.h"
+#include "inout.h"
+#include "mem.h"
+#include "paging.h"
+#include "glide.h"
+#include "setup.h"
+#include "vga.h"
+#include "dos_inc.h" 		/* for Drives[] */
+#include "../dos/drives.h"
+
+#include <iomanip>
+#include <sstream>
+using namespace std;
+
+#include "SDL.h"
+
+#if defined (WIN32)
+#include "SDL_syswm.h"
+#include <windows.h>
+
+#else // *nix
+#include <dlfcn.h>
+
+#include <dirent.h>
+#include <errno.h>
+
+#endif
+
+extern void GFX_Stop(void);
+extern void GFX_ResetScreen(void);
+extern const char* RunningProgram;
+
+// Macro to properly pass floating point values
+#define F(a)		*((float*)&a)
+
+#define SAFE_DELETE(p)	{ if(p) { delete p; p = NULL; } }
+#define ALIGN(x, a) (((x)+(a)-1)&~((a)-1))
+
+#define G_OK 	1
+#define G_FAIL	0
+
+// Print debug messages
+#define LOG_GLIDE 0
+
+void VFILE_Remove(const char *name);
+static void process_msg(Bitu);
+
+/** Global Variables **/
+GLIDE_Block glide;
+
+//  Pointers to loaded routines
+static FncPointers FP;
+static void ** fn_pt=NULL;
+
+// Shared memory address
+static Bit16u glsegment=0;
+static Bit32u param[20];
+
+// Pointer to return value
+static PhysPt ret;
+static Bit16u ret_value;
+
+// Temporary texture buffer
+static Bit32u texsize=0;
+static void* texmem=NULL;
+
+static HostPt hwnd=NULL;
+static char lfbacc=0;
+
+// Tomb Rider shadow hack
+static Bit8u tomb = 0;
+static FxI32 GrOriginLocation = 0;
+
+#if defined (WIN32)
+static HINSTANCE hdll=NULL;	//  Handle to glide2x lib file
+#else
+static void * hdll=NULL;
+#endif
+
+#if LOG_GLIDE
+static int GLIDE_count[GLIDE_MAX+2];
+#endif
+
+static Bitu read_gl(Bitu port,Bitu iolen)
+{
+    Bitu r=ret_value;
+#if LOG_GLIDE
+    if(ret_value == G_OK)
+	LOG_MSG("Glide:Port read. Return address: 0x%x, value: %d", ret, mem_readd(ret));
+    else if(ret_value == G_FAIL)
+	LOG_MSG("Glide:Port read. Return address: 0x%x, value: %d. Writing G_FAIL to port", ret, mem_readd(ret));
+    else
+	LOG_MSG("Glide:Port read. Returning %hu", ret_value);
+#endif
+
+    ret_value = ret_value >> 8;
+
+    return r;
+}
+
+static void write_gl(Bitu port,Bitu val,Bitu iolen)
+{
+    ret = 0;
+    ret_value = G_FAIL;
+    FP.grFunction0 = NULL;
+
+    // Allocate shared memory (80 bytes)
+    if(val > GLIDE_MAX) {
+	if(glsegment==0) {
+	    glsegment=DOS_GetMemory(5);
+#if LOG_GLIDE
+	    LOG_MSG("Glide:Memory allocated at 0x%x (segment: %hu)", glsegment<<4, glsegment);
+#endif
+	}
+	ret_value=glsegment;
+	LOG_MSG("Glide:Activated");
+	return;
+    }
+
+    // Process function parameters (80 bytes)
+    MEM_BlockRead32(PhysMake(glsegment,0), param, 80);
+    process_msg(val);
+
+//  LOG_MSG("Glide:Function %s executed OK", grTable[val].name);
+}
+
+class GLIDE_PageHandler : public PageHandler {
+private:
+    PhysPt base_addr;	// LFB physical address
+    HostPt lfb_addr;
+
+public:
+
+    FxU32 locked;
+    GLIDE_PageHandler(HostPt addr, PhysPt phyaddr = GLIDE_LFB):base_addr(phyaddr),locked(0) {
+
+	lfb_addr = addr-base_addr;
+	if(addr == NULL) {
+	    LOG_MSG("Glide:NULL address passed!");
+	    lfb_addr = NULL;
+	}
+	flags=PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE;
+	PAGING_UnlinkPages(base_addr>>12, GLIDE_PAGES);
+	LOG_MSG("Glide:GLIDE_PageHandler installed at 0x%x (%d pages)", base_addr, GLIDE_PAGES);
+    }
+
+    ~GLIDE_PageHandler() {
+	LOG_MSG("Glide:Resetting page handler at 0x%x", base_addr);
+	PAGING_UnlinkPages(base_addr>>12, GLIDE_PAGES);
+    }
+
+    void SetLFBAddr(HostPt addr) {
+	if(addr-base_addr != lfb_addr) {
+	    lfb_addr=addr-base_addr;
+#if LOG_GLIDE
+	    LOG_MSG("Glide:LFB addr set to 0x%x (0x%x), clear TLB", lfb_addr, addr);
+#endif
+	    PAGING_UnlinkPages(base_addr>>12, GLIDE_PAGES);
+	}
+    }
+
+    PhysPt GetPhysPt(void) {
+	return base_addr;
+    }
+
+    Bitu readb(PhysPt addr) {
+//	LOG_MSG("Glide:Read from 0x%p", lfb_addr+addr);
+	return *(Bit8u *)(lfb_addr+addr);
+    }
+
+    Bitu readw(PhysPt addr) {
+//	LOG_MSG("Glide:Read from 0x%p", lfb_addr+addr);
+	return *(Bit16u *)(lfb_addr+addr);
+    }
+
+    Bitu readd(PhysPt addr) {
+//	LOG_MSG("Glide:Read from 0x%p", lfb_addr+addr);
+	return *(Bit32u *)(lfb_addr+addr);
+    }
+
+    void writeb(PhysPt addr,Bitu val) {
+//	LOG_MSG("Glide:Write to 0x%p", lfb_addr+addr);
+	*(Bit8u *)(lfb_addr+addr)=(Bit8u)val;
+    }
+
+    void writew(PhysPt addr,Bitu val) {
+//	LOG_MSG("Glide:Write to 0x%p", lfb_addr+addr);
+	*(Bit16u *)(lfb_addr+addr)=(Bit16u)val;
+    }
+
+    void writed(PhysPt addr,Bitu val) {
+//	LOG_MSG("Glide:Write to 0x%p", lfb_addr+addr);
+	*(Bit32u *)(lfb_addr+addr)=(Bit32u)val;
+    }
+
+    HostPt GetHostReadPt(Bitu phys_page) {
+//	LOG_MSG("Glide:GetHostReadPt called with %d, returning 0x%x", phys_page, lfb_addr+(phys_page*MEM_PAGESIZE));
+	return lfb_addr+(phys_page*MEM_PAGESIZE);
+    }
+
+    HostPt GetHostWritePt(Bitu phys_page) {
+//	LOG_MSG("Glide:GetHostWritePt called with %d, returning 0x%x", phys_page, lfb_addr+(phys_page*MEM_PAGESIZE));
+	return lfb_addr+(phys_page*MEM_PAGESIZE);
+    }
+
+};
+
+class GLIDE: public Module_base {
+private:
+    AutoexecObject autoexecline;
+    // Glide port
+    Bitu glide_base;
+    Bit8u *ovl_data;
+public:
+    GLIDE(Section* configuration):Module_base(configuration),glide_base(0),ovl_data(NULL) {
+	Section_prop * section=static_cast<Section_prop *>(configuration);
+
+	if(!section->Get_bool("glide")) return;
+	std::string str = section->Get_string("lfb");
+	lowcase(str);
+	if(str == "none") {
+	    LOG_MSG("Glide:Disabled LFB access");
+	    lfbacc=0;
+	} else if(str == "read") {
+	    LOG_MSG("Glide:LFB access: read-only");
+	    lfbacc=1;
+	} else if(str == "write") {
+	    LOG_MSG("Glide:LFB access: write-only");
+	    lfbacc=2;
+	} else {
+	    LOG_MSG("Glide:LFB access: read-write");
+	    lfbacc=3;
+	}
+
+	// Load glide2x.dll
+#if defined(WIN32)
+	hdll = LoadLibrary("glide2x.dll");
+#elif defined(MACOSX)
+	hdll = dlopen("libglide2x.dylib", RTLD_NOW);
+#else
+	hdll = dlopen("libglide2x.so", RTLD_NOW);
+#endif
+
+	if(!hdll) {
+	    LOG_MSG("Glide:Unable to load glide2x library, glide emulation disabled");
+	    return;
+	}
+
+	// Allocate some temporary space
+	texmem = (void*)malloc(1024*768*2);
+	if(texmem == NULL) {
+	    LOG_MSG("Glide:Unable to allocate texture memory, glide disabled");
+	    return;
+	}
+
+	// Load glide2x.ovl if possible, so it is available on the Z: drive
+#if defined (WIN32)
+	// Windows is simple, either glide2x.ovl is in current directory or in path and the search is case insensitive
+	FILE * ovl = fopen("glide2x.ovl", "rb");
+#else
+	// Try a bit harder in *nix, perform case insensitive search and check /usr/share/dosbox as well
+	DIR * pdir; struct dirent * pfile;
+	FILE * ovl = NULL;
+
+	if((pdir = opendir("./"))) {
+	    while(pfile = readdir(pdir)) {
+		if(!strcasecmp(pfile->d_name, "glide2x.ovl")) {
+		    strcpy((char*)texmem, "./"); strcat((char*)texmem, pfile->d_name);
+		    FILE * ovl = fopen((char*)texmem, "rb");
+		}
+	    }
+	    closedir(pdir);
+	}
+
+	if((ovl == NULL) && ((pdir = opendir("/usr/share/dosbox/")))) {
+	    while(pfile = readdir(pdir)) {
+		if(!strcasecmp(pfile->d_name, "glide2x.ovl")) {
+		    strcpy((char*)texmem, "/usr/share/dosbox/"); strcat((char*)texmem, pfile->d_name);
+		    FILE * ovl = fopen((char*)texmem, "rb");
+		}
+	    }
+	    closedir(pdir);
+	}
+#endif
+
+	long ovl_size;
+
+	if(ovl != NULL) {
+	    fseek(ovl, 0, SEEK_END);
+	    ovl_size=ftell(ovl);
+	    ovl_data=(Bit8u*)malloc(ovl_size);
+	    fseek(ovl, 0, SEEK_SET);
+	    fread(ovl_data, sizeof(char), ovl_size, ovl);
+	    fclose(ovl);
+	}
+
+#if LOG_GLIDE
+	SDL_memset(GLIDE_count, 0, sizeof(GLIDE_count));
+#endif
+
+	// Allocate memory for dll pointers
+	fn_pt = (void**)malloc(sizeof(void*)*(GLIDE_MAX+1));
+	if(fn_pt == NULL) {
+	    LOG_MSG("Glide:Unable to allocate memory, glide disabled");
+	    free(texmem); texmem = NULL;
+	    return;
+	}
+	for(int i=0; i<(GLIDE_MAX+1); i++) {
+#if defined(WIN32)
+	    ostringstream temp;
+	    temp << "_" << grTable[i].name << "@" << (Bitu)grTable[i].parms;
+	    fn_pt[i] = (void*)(GetProcAddress(hdll, temp.str().c_str()));
+#else
+	    fn_pt[i] = (void*)(dlsym(hdll, grTable[i].name));
+#endif
+#if LOG_GLIDE
+	    if(fn_pt[i] == NULL) {
+		LOG_MSG("Glide:Warning, unable to load %s from glide2x", grTable[i].name);
+	    }
+#endif
+	}
+
+	glide.lfb_pagehandler = new GLIDE_PageHandler((HostPt)texmem);
+	glide_base=section->Get_hex("grport");
+
+	IO_RegisterReadHandler(glide_base,read_gl,IO_MB);
+	IO_RegisterWriteHandler(glide_base,write_gl,IO_MB);
+
+	ostringstream temp;
+	temp << "SET GLIDE=" << hex << glide_base << ends;
+
+    	autoexecline.Install(temp.str());
+	glide.splash = true;
+
+#if defined (WIN32)
+	// Get hwnd information
+	SDL_SysWMinfo wmi;
+	SDL_VERSION(&wmi.version);
+	if(SDL_GetWMInfo(&wmi)) {
+	    hwnd = (HostPt)wmi.window;
+	} else {
+	    LOG_MSG("SDL:Error retrieving window information");
+	}
+#endif
+
+	if(ovl_data)
+	    VFILE_Register("GLIDE2X.OVL", ovl_data, ovl_size);
+    }
+
+    ~GLIDE() {
+	if(glide.enabled) {
+	    // void grGlideShutdown(void)
+	    FP.grFunction0 = (pfunc0)fn_pt[_grGlideShutdown0];
+	    if(FP.grFunction0) FP.grFunction0();
+	    glide.enabled = false;
+	}
+
+	SAFE_DELETE(glide.lfb_pagehandler);
+	if(fn_pt)
+	    free(fn_pt); fn_pt = NULL;
+	if(texmem)
+	    free(texmem); texmem = NULL;
+
+	if(glide_base) {
+	    IO_FreeReadHandler(glide_base,IO_MB);
+	    IO_FreeWriteHandler(glide_base,IO_MB);
+	}
+
+	if(hdll) {
+#if defined (WIN32)
+	    FreeLibrary(hdll);
+#else
+	    dlclose(hdll);
+#endif
+	    hdll = NULL;
+	}
+
+	VFILE_Remove("GLIDE2X.OVL");
+	if(ovl_data) free(ovl_data);
+    }
+};
+
+static GLIDE* test;
+void GLIDE_ShutDown(Section* sec) {
+    delete test;
+}
+
+void GLIDE_Init(Section* sec) {
+    test = new GLIDE(sec);
+    sec->AddDestroyFunction(&GLIDE_ShutDown,true);
+}
+
+void GLIDE_ResetScreen(bool update)
+{
+#if LOG_GLIDE
+	LOG_MSG("Glide:ResetScreen");
+#endif
+	VGA_SetOverride(true);
+	GFX_Stop();
+
+	// OpenGlide will resize the window on it's own (using SDL)
+	if(
+#ifdef WIN32
+	// dgVoodoo needs a little help :)
+	// Most other wrappers render fullscreen by default
+	  (GetProcAddress(hdll, "DispatchDosNT") != NULL) ||
+#endif
+	// and resize when mapper and/or GUI finish
+	  update) {
+	    SDL_SetVideoMode(glide.width,glide.height,0,
+		(glide.fullscreen[0]?SDL_FULLSCREEN:0)|SDL_ANYFORMAT|SDL_SWSURFACE);
+	}
+}
+
+static bool GetFileName(char * filename)
+{
+    localDrive  *ldp;
+    Bit8u 	drive;
+    char 	fullname[DOS_PATHLENGTH];
+
+    // Get full path
+    if(!DOS_MakeName(filename,fullname,&drive)) return false;
+
+#if LOG_GLIDE
+    LOG_MSG("Glide:Fullname: %s", fullname);
+#endif
+
+    // Get real system path
+    ldp = dynamic_cast<localDrive*>(Drives[drive]);
+    if(ldp == NULL) return false;
+
+    ldp->GetSystemFilename(filename,fullname);
+#if LOG_GLIDE
+    LOG_MSG("Glide:System path: %s", filename);
+#endif
+    return true;
+}
+
+typedef FxBool (FX_CALL *pfxSplashInit)(FxU32 hWnd, FxU32 screenWidth, FxU32 screenHeight,
+					FxU32 numColBuf, FxU32 numAuxBuf, GrColorFormat_t colorFormat);
+typedef void (FX_CALL *pfxSplash)(float x, float y, float w, float h, FxU32 frameNumber);
+
+static void grSplash(void)
+{
+#ifdef WIN32
+    HINSTANCE dll = LoadLibrary("3dfxSpl2.dll");
+    if(dll == NULL) {
+	return;
+    }
+
+    pfxSplashInit fxSplashInit = (pfxSplashInit)GetProcAddress(dll, "_fxSplashInit@24");
+    pfxSplash fxSplash = (pfxSplash)GetProcAddress(dll, "_fxSplash@20");
+
+    if((fxSplashInit == NULL) || (fxSplash == NULL)) {
+	FreeLibrary(dll);
+	return;
+    }
+
+    fxSplashInit(0, glide.width, glide.height, 2, 1, GR_COLORFORMAT_ABGR);
+    fxSplash(0, 0, glide.width, glide.height, 0);
+
+    // Openglide does not restore this state
+    FP.grFunction1i = (pfunc1i)fn_pt[_grSstOrigin4];
+    if(FP.grFunction1i) {
+	FP.grFunction1i(GrOriginLocation);
+    }
+
+    FreeLibrary(dll);
+#endif
+}
+
+static void process_msg(Bitu value)
+{
+    GrLfbInfo_t   lfbinfo;
+    DBGrLfbInfo_t dblfbinfo;
+
+    GrTexInfo     texinfo;
+    DBGrTexInfo   dbtexinfo;
+
+    Gu3dfInfo     guinfo;
+    DBGu3dfInfo   dbguinfo;
+
+    GrVertex	  vertex[3];
+
+    GrMipMapInfo * mipmap;
+
+    // Temporary memory used in functions
+    FxI32	* ilist = (FxI32*)texmem;
+    FxU16	* ptr16 = (FxU16*)texmem;
+
+    // Filename translation
+    char	  filename[512];
+
+    // Return value address
+    ret = param[0];
+    Bitu i = value;
+    FxU32 j, k;
+
+    if((i > GLIDE_MAX) || (fn_pt[i] == NULL)) {
+	LOG_MSG("Glide:Invalid function pointer for call %s", (i > GLIDE_MAX) ? "(invalid)" : grTable[i].name);
+	return;
+    }
+
+#if LOG_GLIDE
+    LOG_MSG("Glide:Processing call %s (%d), return address: 0x%x", grTable[i].name, value, ret);
+    GLIDE_count[i]++;
+#endif
+
+    switch (value) {
+
+    case _grAADrawLine8:
+	// void grAADrawLine(GrVertex *va, GrVertex *vb)
+	FP.grFunction2p = (pfunc2p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	FP.grFunction2p(&vertex[0], &vertex[1]);
+	break;
+    case _grAADrawPoint4:
+	// void grAADrawPoint(GrVertex *p)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	FP.grFunction1p(&vertex[0]);
+	break;
+    case _grAADrawPolygon12:
+	// void grAADrawPolygon(int nVerts, const int ilist[], const GrVertex vlist[])
+	FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	i = sizeof(FxI32)*param[1];
+	MEM_BlockRead32(param[2], ilist, i);
+
+	// Find the number of vertices (?)
+	k = 0;
+	for(j = 0; j < param[1]; j++) {
+	    if(ilist[j] > k)
+		k = ilist[j];
+	}
+	k++;
+
+	MEM_BlockRead32(param[3], ilist+i, sizeof(GrVertex)*k);
+	FP.grFunction1i2p(param[1], ilist, ilist+i);
+	break;
+    case _grAADrawPolygonVertexList8:
+	// void grAADrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _grAADrawTriangle24:
+	// void grAADrawTriangle(GrVertex *a, GrVertex *b, GrVertex *c,
+	//	FxBool antialiasAB, FxBool antialiasBC, FxBool antialiasCA)
+	FP.grFunction3p3i = (pfunc3p3i)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p3i(&vertex[0], &vertex[1], &vertex[2], param[4], param[5], param[6]);
+	break;
+    case _grAlphaBlendFunction16:
+	// void grAlphaBlendFunction(GrAlphaBlendFnc_t rgb_sf, GrAlphaBlendFnc_t rgb_df,
+	//		GrAlphaBlendFnc_t alpha_sf, GrAlphaBlendFnc_t alpha_df)
+	if(tomb == 1) {
+	    if((FP.grFunction1i = (pfunc1i)fn_pt[_grConstantColorValue4]))
+		FP.grFunction1i(0x7f000000);
+	} else if(tomb == 2) {
+	    param[5] = 0x42fe0000;
+	    param[6] = 0;
+	    if((FP.grFunction4f = (pfunc4f)fn_pt[_grConstantColorValue416]))
+		FP.grFunction4f(F(param[5]), F(param[6]), F(param[6]), F(param[6]));
+	}
+	FP.grFunction4i = (pfunc4i)fn_pt[i];
+	FP.grFunction4i(param[1], param[2], param[3], param[4]);
+	break;
+    case _grAlphaCombine20:
+	// void grAlphaCombine(GrCombineFunction_t func, GrCombineFactor_t factor,
+	//		GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+	FP.grFunction5i = (pfunc5i)fn_pt[i];
+	FP.grFunction5i(param[1], param[2], param[3], param[4], param[5]);
+	break;
+    case _grAlphaControlsITRGBLighting4:
+	// void grAlphaControlsITRGBLighting(FxBool enable)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grAlphaTestFunction4:
+	// void grAlphaTestFunction(GrCmpFnc_t function)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grAlphaTestReferenceValue4:
+	// void grAlphaTestReferenceValue(GrAlpha_t value)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grBufferClear12:
+	// void grBufferClear(GrColor_t color, GrAlpha_t alpha, FxU16 depth)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grBufferNumPending0:
+	// int grBufferNumPending(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grBufferSwap4:
+	// void grBufferSwap(int swap_interval)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grCheckForRoom4:
+	// void grCheckForRoom(FxI32 n)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grChromakeyMode4:
+	// void grChromakeyMode(GrChromakeyMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grChromakeyValue4:
+	// void grChromakeyValue(GrColor_t value)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grClipWindow16:
+	// void grClipWindow(FxU32 minx, FxU32 miny, FxU32 maxx, FxU32 maxy)
+	FP.grFunction4i = (pfunc4i)fn_pt[i];
+	FP.grFunction4i(param[1], param[2], param[3], param[4]);
+	break;
+    case _grColorCombine20:
+	// void grColorCombine(GrCombineFunction_t func, GrCombineFactor_t factor,
+	//    		GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+	FP.grFunction5i = (pfunc5i)fn_pt[i];
+	FP.grFunction5i(param[1], param[2], param[3], param[4], param[5]);
+	break;
+    case _grColorMask8:
+	// void grColorMask(FxBool rgb, FxBool alpha)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grConstantColorValue416:
+	// void grConstantColorValue4(float a, float r, float g, float b)
+	FP.grFunction4f = (pfunc4f)fn_pt[i];
+	FP.grFunction4f(F(param[1]), F(param[2]), F(param[3]), F(param[4]));
+	break;
+    case _grConstantColorValue4:
+	// void grConstantColorValue(GrColor_t color)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grCullMode4:
+	// void grCullMode(GrCullMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthBiasLevel4:
+	// void grDepthBiasLevel(FxI16 level)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthBufferFunction4:
+	// void grDepthBufferFunction(GrCmpFnc_t func)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthBufferMode4:
+	// void grDepthBufferMode(GrDepthBufferMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthMask4:
+	// void grDepthMask(FxBool enable)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDisableAllEffects0:
+	// void grDisableAllEffects(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grDitherMode4:
+	// void grDitherMode(GrDitherMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDrawLine8:
+	// void grDrawLine(const GrVertex *a, const GrVertex *b)
+	FP.grFunction2p = (pfunc2p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	FP.grFunction2p(&vertex[0], &vertex[1]);
+	break;
+    case _grDrawPlanarPolygon12:
+	// void grDrawPlanarPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+	FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	i = sizeof(FxI32)*param[1];
+	MEM_BlockRead32(param[2], ilist, i);
+
+	// Find the number of vertices (?)
+	k = 0;
+	for(j = 0; j < param[1]; j++) {
+	    if(ilist[j] > k)
+		k = ilist[j];
+	}
+	k++;
+
+	MEM_BlockRead32(param[3], ilist+i, sizeof(GrVertex)*k);
+	FP.grFunction1i2p(param[1], ilist, ilist+i);
+	break;
+    case _grDrawPlanarPolygonVertexList8:
+	// void grDrawPlanarPolygonVertexList(int nVertices, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _grDrawPoint4:
+	// void grDrawPoint(const GrVertex *a)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	FP.grFunction1p(&vertex[0]);
+	break;
+    case _grDrawPolygon12:
+	// void grDrawPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+	FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	i = sizeof(FxI32)*param[1];
+	MEM_BlockRead32(param[2], ilist, i);
+
+	// Find the number of vertices (?)
+	k = 0;
+	for(j = 0; j < param[1]; j++) {
+	    if(ilist[j] > k)
+		k = ilist[j];
+	}
+	k++;
+
+	MEM_BlockRead32(param[3], ilist+i, sizeof(GrVertex)*k);
+	FP.grFunction1i2p(param[1], ilist, ilist+i);
+	break;
+    case _grDrawPolygonVertexList8:
+	// void grDrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);	
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _grDrawTriangle12:
+	// void grDrawTriangle(const GrVertex *a, const GrVertex *b, const GrVertex *c)
+	FP.grFunction3p = (pfunc3p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p(&vertex[0], &vertex[1], &vertex[2]);
+	break;
+/*
+    case _grErrorSetCallback4:
+	// void grErrorSetCallback(void (*function)(const char *string, FxBool fatal))
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(*param[1]);
+	break;
+*/
+    case _grFogColorValue4:
+	// void grFogColorValue(GrColor_t value)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grFogMode4:
+	// void grFogMode(GrFogMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grFogTable4:
+	// void grFogTable(const GrFog_t grTable[GR_FOG_TABLE_SIZE])
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrFog_t)*GR_FOG_TABLE_SIZE);
+	FP.grFunction1p(texmem);
+	break;
+    case _grGammaCorrectionValue4:
+	// void grGammaCorrectionValue(float value)
+	FP.grFunction1f = (pfunc1f)fn_pt[i];
+	FP.grFunction1f(F(param[1]));
+	break;
+    case _grGlideGetState4:
+	// void grGlideGetState(GrState *state)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrState));
+	FP.grFunction1p(texmem);
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrState));
+	break;
+    case _grGlideGetVersion4:
+	// void grGlideGetVersion(char version[80])
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	FP.grFunction1p(filename);
+	k = 0;
+	do {
+	    mem_writeb(param[1]++, filename[k++]);
+	} while(filename[k] != '\0');
+	mem_writeb(param[1], '\0');
+	break;
+    case _grGlideInit0:
+	// void grGlideInit(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	if(!strncasecmp(RunningProgram, "Tombub", 6)) tomb = 2;
+	else if(!strncasecmp(RunningProgram, "Tomb", 4)) tomb = 1;
+	else tomb = 0;
+
+	// Set LFB pointer
+	if(mem_readd(param[1]) == 0xFFFFFFFF) {		// Find LFB magic
+	    mem_writed(param[1], glide.lfb_pagehandler->GetPhysPt());
+	} else {
+	    LOG_MSG("Glide:Detected incompatible guest ovl/dll!");
+	}
+	break;
+    case _grGlideSetState4:
+	// void grGlideSetState(const GrState *state)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrState));
+	FP.grFunction1p(texmem);
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrState));
+	break;
+    case _grGlideShamelessPlug4:
+	// void grGlideShamelessPlug(const FxBool on)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grGlideShutdown0:
+	// void grGlideShutdown(void)
+	if(glide.enabled) {
+	    FP.grFunction0 = (pfunc0)fn_pt[_grSstWinClose0];
+	    FP.grFunction0();
+	    glide.enabled = false;
+	    VGA_SetOverride(false);
+	    GFX_ResetScreen();
+	}
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	glide.splash = true;
+
+#if LOG_GLIDE
+	for(j=0;j<(GLIDE_MAX+1);j++) {
+	    if(GLIDE_count[j]) {
+		LOG_MSG("Glide:%6d calls function %s (%d)", GLIDE_count[j], grTable[j].name, j);
+	    }
+	}
+	LOG_MSG("Glide: %d framebuffer locks (%d read, %d write)", GLIDE_count[_grLfbLock24],
+	    GLIDE_count[GLIDE_MAX+1], GLIDE_count[_grLfbLock24] - GLIDE_count[GLIDE_MAX+1]);		
+	SDL_memset(GLIDE_count, 0, sizeof(GLIDE_count));
+#endif
+	break;
+    case _grHints8:
+	// void grHints(GrHints_t type, FxU32 hintMask)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grLfbConstantAlpha4:
+	// void grLfbConstantAlpha(GrAlpha_t alpha)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grLfbConstantDepth4:
+	// void grLfbConstantDepth(FxU16 depth)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grLfbLock24:
+	// FxBool grLfbLock(GrLock_t type, GrBuffer_t buffer, GrLfbWriteMode_t writeMode,
+	//		GrOriginLocation_t origin, FxBool pixelPipeline, GrLfbInfo_t *info)
+	FP.grRFunction5i1p = (prfunc5i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	// Read parameters
+	MEM_BlockRead32(param[6], &dblfbinfo, sizeof(DBGrLfbInfo_t));
+	lfbinfo.size = sizeof(GrLfbInfo_t);
+	lfbinfo.origin = dblfbinfo.origin;
+	lfbinfo.lfbPtr = texmem;
+
+	k = FXTRUE;
+	j = param[1]&1; j++;
+
+	if(glide.lfb_pagehandler) {
+
+	    if(j&lfbacc) {
+		// Lock the buffer
+		k = FP.grRFunction5i1p(param[1], param[2], param[3], param[4], param[5], &lfbinfo);
+		if(k == FXTRUE) {
+		    glide.lfb_pagehandler->locked++;
+		    dblfbinfo.writeMode = lfbinfo.writeMode;
+		    dblfbinfo.strideInBytes = lfbinfo.strideInBytes;
+		    dblfbinfo.lfbPtr = glide.lfb_pagehandler->GetPhysPt();
+		    MEM_BlockWrite32(param[6], &dblfbinfo, sizeof(DBGrLfbInfo_t));
+		} else {
+		    LOG_MSG("Glide:LFB Lock failed!");
+		}
+	    } // else lock is faked (texmem used for read/write)
+
+	    // Set LFB address for page handler
+	    glide.lfb_pagehandler->SetLFBAddr((HostPt)lfbinfo.lfbPtr);
+
+	    if(j == 1) {// Is a read-only lock
+#if LOG_GLIDE
+		LOG_MSG("Glide:Read-only lock. Real LFB is at 0x%p.", lfbinfo.lfbPtr);
+		GLIDE_count[GLIDE_MAX+1]++;
+#endif
+	    } else {	// Is a write-only lock
+#if LOG_GLIDE
+		LOG_MSG("Glide:Write-only lock. Real LFB is at 0x%p.", lfbinfo.lfbPtr);
+#endif
+	    }
+	} else { // Fail
+	    LOG_MSG("Glide:Failed to install page handler!");
+	    k = FXFALSE;
+	}
+
+	mem_writed(ret, k);
+	ret_value = G_OK;
+	break;
+    case _grLfbReadRegion28:
+	// FxBool grLfbReadRegion(GrBuffer_t src_buffer, FxU32 src_x, FxU32 src_y, FxU32 src_width,
+	//		FxU32 src_height, FxU32 dst_stride, void *dst_data)
+	FP.grRFunction6i1p = (prfunc6i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction6i1p(param[1], param[2], param[3], param[4], param[5], param[6], ptr16));
+	MEM_BlockWrite(param[7], ptr16, param[5]*param[6]);
+	ret_value = G_OK;
+	break;
+    case _grLfbUnlock8:
+	// FxBool grLfbUnlock(GrLock_t type, GrBuffer_t buffer)
+	FP.grRFunction2i = (prfunc2i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle (%d)!", _grLfbUnlock8);
+	    return;
+	}
+	k = FXTRUE;
+	if(glide.lfb_pagehandler && glide.lfb_pagehandler->locked) {
+	    k = FP.grRFunction2i(param[1], param[2]);
+	    glide.lfb_pagehandler->locked--;
+	}
+	mem_writed(ret, k);
+	ret_value = G_OK;
+	break;
+    case _grLfbWriteColorFormat4:
+	// void grLfbWriteColorFormat(GrColorFormat_t colorFormat)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grLfbWriteColorSwizzle8:
+	// void grLfbWriteColorSwizzle(FxBool swizzleBytes, FxBool swapWords)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grLfbWriteRegion32:
+	// FxBool grLfbWriteRegion(GrBuffer_t dst_buffer, FxU32 dst_x, FxU32 dst_y,
+	//	GrLfbSrcFmt_t src_format, FxU32 src_width, FxU32 src_height, FxU32 src_stride, void *src_data)
+	FP.grRFunction7i1p = (prfunc7i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	MEM_BlockRead(param[8], ptr16, param[6]*param[7]);
+	mem_writed(ret, FP.grRFunction7i1p(param[1], param[2], param[3], param[4], param[5], param[6], param[7], ptr16));
+	ret_value = G_OK;
+	break;
+    case _grRenderBuffer4:
+	// void grRenderBuffer(GrBuffer_t buffer)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grResetTriStats0:
+	// void grResetTriStats()
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grSplash20:
+	// void grSplash(float x, float y, float width, float height, FxU32 frame)
+	FP.grFunction4f1i = (pfunc4f1i)fn_pt[i];
+	FP.grFunction4f1i(F(param[1]), F(param[2]), F(param[3]), F(param[4]), param[5]);
+	break;
+/*
+    case _grSstConfigPipeline12:
+	//
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i();
+	break;
+*/
+    case _grSstControl4:
+	// FxBool grSstControl(FxU32 code)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _grSstIdle0:
+	// void grSstIdle(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grSstIsBusy0:
+	// FxBool grSstIsBusy(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstOrigin4:
+	// void grSstOrigin(GrOriginLocation_t origin)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	GrOriginLocation = param[1];
+	break;
+    case _grSstPerfStats4:
+	// void grSstPerfStats(GrSstPerfStats_t *pStats)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrSstPerfStats_t));
+	FP.grFunction1p(texmem);
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrSstPerfStats_t));
+	break;
+    case _grSstQueryBoards4:
+	// FxBool grSstQueryBoards(GrHwConfiguration *hwConfig)
+	FP.grRFunction1p = (prfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrHwConfiguration));
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1p(texmem));
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrHwConfiguration));
+	ret_value = G_OK;
+	break;
+    case _grSstQueryHardware4:
+	// FxBool grSstQueryHardware(GrHwConfiguration *hwConfig)
+	FP.grRFunction1p = (prfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrHwConfiguration));
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1p(texmem));
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrHwConfiguration));
+	ret_value = G_OK;
+	break;
+    case _grSstResetPerfStats0:
+	// void grSstResetPerfStats(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grSstScreenHeight0:
+	// FxU32 grSstScreenHeight(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstScreenWidth0:
+	// FxU32 grSstScreenWidth(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstSelect4:
+	// void grSstSelect(int which_sst)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grSstStatus0:
+	// FxU32 grSstStatus(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstVRetraceOn0:
+	// FxBool grSstVRetraceOn(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+/*
+    case _grSstVidMode8:
+	//
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i();
+	break;
+*/
+    case _grSstVideoLine0:
+	// FxU32 grSstVideoLine(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstWinClose0:
+	// void grSstWinClose(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	if(glide.enabled) {
+	    glide.enabled = false;
+	    VGA_SetOverride(false);
+	    GFX_ResetScreen();
+	}
+	break;
+    case _grSstWinOpen28:
+	// FxBool grSstWinOpen(FxU32 hwnd, GrScreenResolution_t res, GrScreenRefresh_t ref,
+	//	GrColorFormat_t cformat, GrOriginLocation_t org_loc, int num_buffers, int num_aux_buffers)
+	FP.grRFunction1p6i = (prfunc1p6i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	if(glide.enabled) {
+	    LOG_MSG("Glide:grSstWinOpen called when glide is active!");
+	    mem_writed(ret, FXFALSE);
+	    ret_value = G_OK;
+	    break;
+	}
+
+	// Check for successful memory map
+	if(mem_readd(param[10]) == 0) {
+	    LOG_MSG("Glide:LFB memory map failed, using default LFB address!");
+	    // Write physical address instead, it can crash but it just might work
+	    mem_writed(param[10], glide.lfb_pagehandler->GetPhysPt());
+	}
+
+	glide.enabled = true;
+	glide.width = param[8];
+	glide.height = param[9];
+	GrOriginLocation = param[5];
+
+	// Resize window and disable updates
+	GLIDE_ResetScreen();
+
+	k = FP.grRFunction1p6i(hwnd, param[2], param[3], param[4], param[5], param[6], param[7]);
+	if(k == FXFALSE) {
+	    LOG_MSG("Glide:grSstWinOpen failed!");
+	    glide.enabled = false;
+	    VGA_SetOverride(false);
+	    GFX_ResetScreen();
+	    mem_writed(ret, FXFALSE);
+	    ret_value = G_OK;
+	    break;
+	}
+
+	mem_writed(ret, k);
+	if(glide.splash) {
+	    grSplash();
+	    glide.splash = false;
+	}
+
+	LOG_MSG("Glide:Resolution set to:%dx%d, LFB at 0x%x (linear: 0x%x)", glide.width, glide.height, glide.lfb_pagehandler->GetPhysPt(), mem_readd(param[10]));
+	ret_value = G_OK;
+	break;
+    case _grTexCalcMemRequired16:
+	// FxU32 grTexCalcMemRequired(GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspect,
+	//	    GrTextureFormat_t format)
+	FP.grRFunction4i = (prfunc4i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction4i(param[1], param[2], param[3], param[4]));
+	ret_value = G_OK;
+	break;
+    case _grTexClampMode12:
+	// void grTexClampMode(GrChipID_t tmu, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grTexCombine28:
+	// void grTexCombine(GrChipID_t tmu, GrCombineFunction_t rgb_function, GrCombineFactor_t rgb_factor,
+	//	GrCombineFunction_t alpha_function, GrCombineFactor_t alpha_factor, FxBool rgb_invert,
+	//	FxBool alpha_invert)
+	FP.grFunction7i = (pfunc7i)fn_pt[i];
+	FP.grFunction7i(param[1], param[2], param[3], param[4], param[5], param[6], param[7]);
+	break;
+    case _grTexCombineFunction8:
+	// void grTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t fnc)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grTexDetailControl16:
+	// void grTexDetailControl(GrChipID_t tmu, int lodBias, FxU8 detailScale, float detailMax)
+	FP.grFunction3i1f = (pfunc3i1f)fn_pt[i];
+	FP.grFunction3i1f(param[1], param[2], param[3], F(param[4]));
+	break;
+    case _grTexDownloadMipMap16:
+	// void grTexDownloadMipMap(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	if(FP.grRFunction1i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+	    return;
+	}
+
+	MEM_BlockRead32(param[4], &dbtexinfo, sizeof(DBGrTexInfo));
+
+	texinfo.smallLod = dbtexinfo.smallLod;
+ 	texinfo.largeLod = dbtexinfo.largeLod;
+	texinfo.aspectRatio = dbtexinfo.aspectRatio;
+	texinfo.format = dbtexinfo.format;
+	texinfo.data = NULL;
+
+	texsize = FP.grRFunction1i1p(param[3], &texinfo);
+	MEM_BlockRead(dbtexinfo.data, texmem, texsize);
+	texinfo.data = texmem;
+
+	FP.grFunction3i1p = (pfunc3i1p)fn_pt[i];
+	FP.grFunction3i1p(param[1], param[2], param[3], &texinfo);
+	break;
+    case _grTexDownloadMipMapLevel32:
+	// void grTexDownloadMipMapLevel(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod,
+	//	GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format,
+	//	FxU32 evenOdd, void *data)
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	if(FP.grRFunction1i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+	    return;
+	}
+
+	texinfo.smallLod = param[3];
+ 	texinfo.largeLod = param[4];
+	texinfo.aspectRatio = param[5];
+	texinfo.format = param[6];
+	texinfo.data = NULL;
+
+	texsize = FP.grRFunction1i1p(param[7], &texinfo);
+	MEM_BlockRead(param[8], texmem, texsize);
+
+	FP.grFunction7i1p = (pfunc7i1p)fn_pt[i];
+	FP.grFunction7i1p(param[1], param[2], param[3], param[4], param[5], param[6], param[7], texmem);
+	break;
+    case _grTexDownloadMipMapLevelPartial40:
+	// FX_ENTRY void FX_CALL grTexDownloadMipMapLevelPartial(GrChipID_t tmu, FxU32 startAddress,
+	//    GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format,
+	//    FxU32 evenOdd, void *data, int start, int end);
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	if(FP.grRFunction1i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+	    return;
+	}
+
+	texinfo.smallLod = param[3];
+ 	texinfo.largeLod = param[4];
+	texinfo.aspectRatio = param[5];
+	texinfo.format = param[6];
+	texinfo.data = NULL;
+
+	texsize = FP.grRFunction1i1p(param[7], &texinfo);
+	MEM_BlockRead(param[8], texmem, texsize);
+
+	FP.grFunction7i1p2i = (pfunc7i1p2i)fn_pt[i];
+	FP.grFunction7i1p2i(param[1], param[2], param[3], param[4], param[5], param[6], param[7], texmem,
+			    param[9], param[10]);
+	break;
+    case _grTexDownloadTable12:
+	// void grTexDownloadTable(GrChipID_t tmu, GrTexTable_t type, void *data)
+	FP.grFunction2i1p = (pfunc2i1p)fn_pt[i];
+
+	if(param[2] == GR_TEXTABLE_PALETTE)
+	    MEM_BlockRead32(param[3], texmem, sizeof(GuTexPalette));
+	else // GR_TEXTABLE_NCC0 or GR_TEXTABLE_NCC1
+	    MEM_BlockRead32(param[3], texmem, sizeof(GuNccTable));
+
+	FP.grFunction2i1p(param[1], param[2], texmem);
+	break;
+    case _grTexDownloadTablePartial20:
+	// void grTexDownloadTablePartial(GrChipID_t tmu, GrTexTable_t type, void *data, int start, int end)
+	FP.grFunction2i1p2i = (pfunc2i1p2i)fn_pt[i];
+
+	if(param[2] == GR_TEXTABLE_PALETTE) {
+	    MEM_BlockRead32(param[3], texmem, sizeof(GuTexPalette));
+	    FP.grFunction2i1p2i(param[1], param[2], texmem, param[4], param[5]);
+	} else { // GR_TEXTABLE_NCC0 or GR_TEXTABLE_NCC1
+	    LOG_MSG("Glide:Downloading partial NCC tables is not supported!");
+	}
+
+	break;
+    case _grTexFilterMode12:
+	// void grTexFilterMode(GrChipID_t tmu, GrTextureFilterMode_t minFilterMode,
+	//	GrTextureFilterMode_t magFilterMode)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grTexLodBiasValue8:
+	// void grTexLodBiasValue(GrChipID_t tmu, float bias)
+	FP.grFunction1i1f = (pfunc1i1f)fn_pt[i];
+	FP.grFunction1i1f(param[1], F(param[2]));
+	break;
+    case _grTexMaxAddress4:
+	// FxU32 grTexMaxAddress(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _grTexMinAddress4:
+	// FxU32 grTexMinAddress(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _grTexMipMapMode12:
+	// void grTexMipMapMode(GrChipID_t tmu, GrMipMapMode_t mode, FxBool lodBlend)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grTexMultibase8:
+	// void grTexMultibase(GrChipID_t tmu, FxBool enable)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+/*
+    case _grTexMultibaseAddress20:
+	// void grTexMultibaseAddress(GrChipID_t tmu, GrTexBaseRange_t range, FxU32 startAddress,
+	//	FxU32 evenOdd, GrTexInfo *info)
+	FP.grFunction4i1p = (pfunc4i1p)fn_pt[i];
+
+	// This is a bit more complicated since *info contains a pointer to data
+	texinfo = (GrTexInfo*)param[5];
+	data = (PhysPt)texinfo->data;			// Store for later reference
+	texinfo->data = VIRTOREAL(data);
+#if LOG_GLIDE
+	if(log_func[value-_grAADrawLine8] == 1) {
+	    LOG_MSG("Glide:Replacing pointer 0x%x with 0x%x in function %d", data, texinfo->data, _grTexMultibaseAddress20);
+	    log_func[value-_grAADrawLine8] = 2;
+	}
+#endif
+	FP.grFunction20(param[1], param[2], param[3], param[4], (int)texinfo);
+	texinfo->data = (void*)data;			// Change the pointer back
+	break;
+*/
+    case _grTexNCCTable8:
+	// void grTexNCCTable(GrChipID_t tmu, GrNCCTable_t table)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grTexSource16:
+	// void grTexSource(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+	FP.grFunction3i1p = (pfunc3i1p)fn_pt[i];
+
+	// Copy the data from DB struct
+	MEM_BlockRead32(param[4], &dbtexinfo, sizeof(DBGrTexInfo));
+
+	texinfo.smallLod = dbtexinfo.smallLod;
+ 	texinfo.largeLod = dbtexinfo.largeLod;
+	texinfo.aspectRatio = dbtexinfo.aspectRatio;
+	texinfo.format = dbtexinfo.format;
+
+	FP.grFunction3i1p(param[1], param[2], param[3], &texinfo);
+	break;
+    case _grTexTextureMemRequired8:
+	// FxU32 grTexTextureMemRequired(FxU32 evenOdd, GrTexInfo *info)
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	// Copy the data from DB struct
+	MEM_BlockRead32(param[2], &dbtexinfo, sizeof(DBGrTexInfo));
+
+	texinfo.smallLod = dbtexinfo.smallLod;
+ 	texinfo.largeLod = dbtexinfo.largeLod;
+	texinfo.aspectRatio = dbtexinfo.aspectRatio;
+	texinfo.format = dbtexinfo.format;
+
+	mem_writed(ret, FP.grRFunction1i1p(param[1], &texinfo));
+
+	ret_value = G_OK;
+	break;
+    case _grTriStats8:
+	// void grTriStats(FxU32 *trisProcessed, FxU32 *trisDrawn)
+	FP.grFunction2p = (pfunc2p)fn_pt[i];
+	MEM_BlockRead32(param[1], ilist, sizeof(FxU32));
+	MEM_BlockRead32(param[2], ilist + 1, sizeof(FxU32));
+	FP.grFunction2p(ilist, ilist + 1);
+	MEM_BlockWrite32(param[1], ilist, sizeof(FxU32));
+	MEM_BlockWrite32(param[2], ilist + 1, sizeof(FxU32));
+	break;
+    case _gu3dfGetInfo8:
+	// FxBool gu3dfGetInfo(const char *filename, Gu3dfInfo *info)
+	FP.grRFunction2p = (prfunc2p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	MEM_StrCopy(param[1], filename, 512);
+
+#if LOG_GLIDE
+	LOG_MSG("Glide:Filename info found in gu3dfGetInfo: %s", filename);
+#endif
+	if(!GetFileName(filename)) break;
+	mem_writed(ret, FP.grRFunction2p(filename, &guinfo));
+
+	// Copy the data back to DB struct if successful
+	if(mem_readd(ret)) {
+	    MEM_BlockRead32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	    dbguinfo.header.width = (Bit32u)guinfo.header.width;
+	    dbguinfo.header.height = (Bit32u)guinfo.header.height;
+	    dbguinfo.header.small_lod = (Bit32s)guinfo.header.small_lod;
+	    dbguinfo.header.large_lod = (Bit32s)guinfo.header.large_lod;
+	    dbguinfo.header.aspect_ratio = (Bit32s)guinfo.header.aspect_ratio;
+	    dbguinfo.header.format = (Bit32s)guinfo.header.format;
+	    dbguinfo.mem_required = (Bit32u)guinfo.mem_required;
+	    MEM_BlockWrite32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	}
+
+	ret_value = G_OK;
+	break;
+    case _gu3dfLoad8:
+	// FxBool gu3dfLoad(const char *filename, Gu3dfInfo *info)
+	FP.grRFunction2p = (prfunc2p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	// Although glide ref specifies *info should be filled by gu3dfGetInfo before calling gu3dfLoad,
+	// OpenGlide will re-read the header in gu3dfLoad as well
+	MEM_BlockRead32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	MEM_StrCopy(param[1], filename, 512);
+
+#if LOG_GLIDE
+	LOG_MSG("Glide:Filename info found in gu3dfLoad: %s", filename);
+#endif
+	if(!GetFileName(filename)) break;
+
+	guinfo.data = texmem;
+	mem_writed(ret, FP.grRFunction2p(filename, &guinfo));
+
+	// Copy the data back to DB struct if successful
+	if(mem_readd(ret)) {
+	    for(j=0;j<256;j++)
+		dbguinfo.table.palette.data[j] = (Bit32u)guinfo.table.palette.data[j];
+	    MEM_BlockWrite(dbguinfo.data, guinfo.data, guinfo.mem_required);
+	}
+
+	MEM_BlockWrite32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	ret_value = G_OK;
+	break;
+    case _guAADrawTriangleWithClip12:
+	// void guAADrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+	FP.grFunction3p = (pfunc3p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p(&vertex[0], &vertex[1], &vertex[2]);
+	break;
+    case _guAlphaSource4:
+	// void guAlphaSource(GrAlphaSourceMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _guColorCombineFunction4:
+	// void guColorCombineFunction(GrColorCombineFunction_t func)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _guDrawPolygonVertexListWithClip8:
+	// void guDrawPolygonVertexListWithClip(int nverts, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _guDrawTriangleWithClip12:
+	// void guDrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+	FP.grFunction3p = (pfunc3p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p(&vertex[0], &vertex[1], &vertex[2]);
+	break;
+/*
+    case _guEncodeRLE1616:
+	//
+	FP.grFunction16 = (pfunc16)fn_pt[i];
+	FP.grFunction16();
+	break;
+    case _guEndianSwapBytes4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+    case _guEndianSwapWords4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+*/
+    case _guFogGenerateExp28:
+	// void guFogGenerateExp2(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+	FP.grFunction1p1f = (pfunc1p1f)fn_pt[i];
+	FP.grFunction1p1f(texmem, F(param[2]));
+	MEM_BlockWrite32(param[1], texmem, GR_FOG_TABLE_SIZE*sizeof(GrFog_t));
+	break;
+    case _guFogGenerateExp8:
+	// void guFogGenerateExp(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+	FP.grFunction1p1f = (pfunc1p1f)fn_pt[i];
+	FP.grFunction1p1f(texmem, F(param[2]));
+	MEM_BlockWrite32(param[1], texmem, GR_FOG_TABLE_SIZE*sizeof(GrFog_t));
+	break;
+    case _guFogGenerateLinear12:
+	// void guFogGenerateLinear(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float nearW, float farW)
+	FP.grFunction1p2f = (pfunc1p2f)fn_pt[i];
+	FP.grFunction1p2f(texmem, F(param[2]), F(param[3]));
+	MEM_BlockWrite32(param[1], texmem, GR_FOG_TABLE_SIZE*sizeof(GrFog_t));
+	break;
+    case _guFogTableIndexToW4: {
+	// float guFogTableIndexToW(int i)
+	FP.grFFunction1i = (pffunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	float tmp = FP.grFFunction1i(param[1]);
+	mem_writed(ret, *((Bit32u*)&tmp));
+	ret_value = G_OK;
+	break;
+    }
+/*
+    case _guMPDrawTriangle12:
+	//
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i();
+	break;
+    case _guMPInit0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _guMPTexCombineFunction4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+    case _guMPTexSource8:
+	//
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i();
+	break;
+    case _guMovieSetName4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+    case _guMovieStart0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _guMovieStop0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+*/
+    case _guTexAllocateMemory60:
+	// GrMipMapId_t guTexAllocateMemory(GrChipID_t tmu, FxU8 evenOddMask, int width, int height,
+	//	    GrTextureFormat_t format, GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod,
+	//	    GrAspectRatio_t aspectRatio, GrTextureClampMode_t sClampMode,
+	//	    GrTextureClampMode_t tClampMode, GrTextureFilterMode_t minFilterMode,
+	//	    GrTextureFilterMode_t magFilterMode, float lodBias, FxBool lodBlend)
+	FP.grRFunction13i1f1i = (prfunc13i1f1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction13i1f1i(param[1], param[2], param[3], param[4], param[5], param[6], param[7],
+			    param[8], param[9], param[10], param[11], param[12], param[13], F(param[14]), param[15]));
+	ret_value = G_OK;
+	break;
+    case _guTexChangeAttributes48:
+	// FxBool guTexChangeAttributes(GrMipMapID_t mmid, int width, int height, GrTextureFormat_t format,
+	//	    GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio,
+	//	    GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode,
+	//	    GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode)
+	FP.grRFunction12i = (prfunc12i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction12i(param[1], param[2], param[3], param[4], param[5], param[6], param[7],
+			param[8], param[9], param[10], param[11], param[12]));
+	ret_value = G_OK;
+	break;
+    case _guTexCombineFunction8:
+	// void guTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t func)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+/*
+    case _guTexCreateColorMipMap0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+*/
+    case _guTexDownloadMipMap12:
+	// void guTexDownloadMipMap(GrMipMapId_t mmid, const void *src, const GuNccTable *nccTable)
+	FP.grRPTFunction1i = (prptfunc1i)fn_pt[_guTexGetMipMapInfo4];
+	mipmap = (GrMipMapInfo*)FP.grRPTFunction1i(param[1]);
+
+	if(mipmap) {
+	    texinfo.aspectRatio = mipmap->aspect_ratio;
+	    texinfo.format      = mipmap->format;
+	    texinfo.largeLod    = mipmap->lod_max;
+	    texinfo.smallLod    = mipmap->lod_min;
+
+	    FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	    if(FP.grRFunction1i1p == NULL) {
+		LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+		return;
+	    }
+
+	    texsize = FP.grRFunction1i1p(mipmap->odd_even_mask, &texinfo);
+
+	    MEM_BlockRead(param[2], texmem, texsize);
+	    MEM_BlockRead32(param[3], (Bit8u*)texmem+texsize, sizeof(GuNccTable));
+
+	    FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	    FP.grFunction1i2p(param[1], texmem, (Bit8u*)texmem+texsize);
+	} else {
+	    LOG_MSG("Glide:Unable to get GrMipMapInfo pointer");
+	}
+	break;
+/*
+    case _guTexDownloadMipMapLevel12:
+	// void guTexDownloadMipMapLevel(GrMipMapId_t mmid, GrLOD_t lod, const void **src)
+	FP.grFunction2i1p = (pfunc2i1p)fn_pt[i];
+	FP.grFunction2i1p(param[1], param[2], *param[3]);
+	break;
+*/
+    case _guTexGetCurrentMipMap4:
+	// GrMipMapId_t guTexGetCurrentMipMap(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+/*
+    case _guTexGetMipMapInfo4:
+	// GrMipMapInfo *guTexGetMipMapInfo(GrMipMapId_t mmid)
+	FP.grRFunction4 = (prfunc4)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction4(param[1]));
+	ret_value = G_OK;
+	break;
+*/
+    case _guTexMemQueryAvail4:
+	// FxU32 guTexMemQueryAvail(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _guTexMemReset0:
+	// void guTexMemReset(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _guTexSource4:
+	// void guTexSource(GrMipMapId_t mmid)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _ConvertAndDownloadRle64: {
+	// void ConvertAndDownloadRle(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod,
+	//				GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd,
+	//				FxU8 *bm_data, long  bm_h, FxU32 u0, FxU32 v0, FxU32 width, FxU32 height,
+	//				FxU32 dest_width, FxU32 dest_height, FxU16 *tlut)
+
+#if LOG_GLIDE
+	LOG_MSG("Glide: RLE width: %d, height: %d, bm_h: %d, u0: %d, v0: %d, dest %dx%d",
+	    param[12], param[13], param[9], param[10], param[11], param[14], param[15]);
+#endif
+
+	FxU8 c;
+	FxU32 scount = 0;
+	FxU32 dcount = 0;
+
+	FxU16 * src = ptr16 + param[14]*param[15];
+	FxU32 offset = 4 + param[9];
+
+	// Line offset (v0)
+	for(j = 0; j < param[11]; j++ ) {
+	    offset += mem_readb(param[8]+4+j);
+	}
+
+	// Write height lines
+	for(k = 0; k < param[13]; k++) {
+
+	    // Decode one RLE line
+	    scount = offset;
+	    while((c = mem_readb(param[8]+scount)) != 0xE0) {
+
+		if(c > 0xE0) {
+		    for(int count = 0; count < (c&0x1f); count++) {
+
+			// tlut is FxU16*
+			src[dcount] = mem_readw(param[16]+(mem_readb(param[8]+scount+1)<<1));
+			dcount++;
+		    }
+		    scount += 2;
+
+		} else {
+		    src[dcount] = mem_readw(param[16]+(c<<1));
+		    dcount++; scount++;
+		}
+	    }
+
+	    // Copy Line into destination texture, offset u0
+	    SDL_memcpy(ptr16 + (k*param[14]), src + param[10], sizeof(FxU16)*param[14]);
+	    offset += mem_readb(param[8] + 4 + j++);
+	    dcount = 0;
+	}
+
+	// One additional line
+	if(param[13] < param[15])
+	    SDL_memcpy(ptr16 + (k*param[14]), src + param[10], sizeof(FxU16)*param[14]);
+
+	// Download decoded texture
+	texinfo.smallLod = param[3];
+	texinfo.largeLod = param[4];
+	texinfo.aspectRatio = param[5];
+	texinfo.format = param[6];
+	texinfo.data = ptr16;
+
+	// void grTexDownloadMipMap(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+	FP.grFunction3i1p = (pfunc3i1p)fn_pt[_grTexDownloadMipMap16];
+	if(FP.grFunction3i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexDownloadMipMap");
+	    break;
+	}
+	FP.grFunction3i1p(param[1], param[2], param[7], &texinfo);
+	break;
+    }
+    default:
+	LOG_MSG("Glide:Unsupported glide call %s", grTable[i].name);
+	break;
+
+    }	/* switch */
+}	/* process_msg() */
diff -urN dosbox.orig/src/hardware/Makefile.am dosbox/src/hardware/Makefile.am
--- dosbox.orig/src/hardware/Makefile.am	2012-09-29 02:17:58.456050210 -0300
+++ dosbox/src/hardware/Makefile.am	2012-09-29 02:18:28.538098428 -0300
@@ -10,6 +10,6 @@
                         memory.cpp mixer.cpp pcspeaker.cpp pci_bus.cpp pic.cpp sblaster.cpp tandy_sound.cpp timer.cpp \
 			vga.cpp vga_attr.cpp vga_crtc.cpp vga_dac.cpp vga_draw.cpp vga_gfx.cpp vga_other.cpp \
 			vga_memory.cpp vga_misc.cpp vga_seq.cpp vga_xga.cpp vga_s3.cpp vga_tseng.cpp vga_paradise.cpp \
-			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp ne2000.cpp
+			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp ne2000.cpp glide.cpp
 
 
diff -urN dosbox.orig/src/hardware/Makefile.am.orig dosbox/src/hardware/Makefile.am.orig
--- dosbox.orig/src/hardware/Makefile.am.orig	2012-09-29 02:17:58.459383401 -0300
+++ dosbox/src/hardware/Makefile.am.orig	1969-12-31 21:00:00.000000000 -0300
@@ -1,15 +0,0 @@
-AM_CPPFLAGS = -I$(top_srcdir)/include
-
-SUBDIRS = serialport
-
-EXTRA_DIST = opl.cpp opl.h adlib.h dbopl.h pci_devices.h
-
-noinst_LIBRARIES = libhardware.a
-
-libhardware_a_SOURCES = adlib.cpp dma.cpp gameblaster.cpp hardware.cpp iohandler.cpp joystick.cpp keyboard.cpp \
-                        memory.cpp mixer.cpp pcspeaker.cpp pci_bus.cpp pic.cpp sblaster.cpp tandy_sound.cpp timer.cpp \
-			vga.cpp vga_attr.cpp vga_crtc.cpp vga_dac.cpp vga_draw.cpp vga_gfx.cpp vga_other.cpp \
-			vga_memory.cpp vga_misc.cpp vga_seq.cpp vga_xga.cpp vga_s3.cpp vga_tseng.cpp vga_paradise.cpp \
-			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp
-
-
diff -urN dosbox.orig/src/hardware/memory.cpp dosbox/src/hardware/memory.cpp
--- dosbox.orig/src/hardware/memory.cpp	2012-09-29 02:17:58.456050210 -0300
+++ dosbox/src/hardware/memory.cpp	2012-09-29 02:18:02.912526503 -0300
@@ -23,6 +23,7 @@
 #include "setup.h"
 #include "paging.h"
 #include "regs.h"
+#include "glidedef.h"
 
 #include <string.h>
 
@@ -140,6 +141,8 @@
 	} else if ((phys_page>=memory.lfb.start_page+0x01000000/4096) &&
 				(phys_page<memory.lfb.start_page+0x01000000/4096+16)) {
 		return memory.lfb.mmiohandler;
+	} else if ((phys_page>=(GLIDE_LFB>>12)) && (phys_page<(GLIDE_LFB>>12)+GLIDE_PAGES)) {
+		if(glide.enabled) return (PageHandler*)glide.lfb_pagehandler;
 	}
 	return &illegal_page_handler;
 }
@@ -191,6 +194,24 @@
 	}
 }
 
+void MEM_BlockRead32(PhysPt pt,void * data,Bitu size) {
+	Bit32u * write=(Bit32u *) data;
+	size>>=2;
+	while (size--) {
+		*write++=mem_readd_inline(pt);
+		pt+=4;
+	}
+}
+
+void MEM_BlockWrite32(PhysPt pt,void * data,Bitu size) {
+	Bit32u * read=(Bit32u *) data;
+	size>>=2;
+	while (size--) {
+		mem_writed_inline(pt,*read++);
+		pt+=4;
+	}
+}
+
 void MEM_BlockCopy(PhysPt dest,PhysPt src,Bitu size) {
 	mem_memcpy(dest,src,size);
 }
