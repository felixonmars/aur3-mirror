
Property changes on: src/netbeans.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/term.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/term.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/digraph.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ex_docmd.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ex_cmds.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/message.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ex_cmds.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/mark.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ascii.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/termlib.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/if_perlsfio.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/menu.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ex_cmds2.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/configure.in
===================================================================
--- src/configure.in	(.../vendor/vim/current)	(revision 223)
+++ src/configure.in	(.../trunk/vim)	(revision 223)
@@ -986,6 +986,13 @@
   AC_DEFINE(FEAT_CSCOPE)
 fi
 
+dnl FEAT_GDB defined later
+AC_MSG_CHECKING(--enable-gdb argument)
+AC_ARG_ENABLE(gdb,
+	[  --enable-gdb       Include GDB support.], ,
+	[enable_gdb="no"])
+AC_MSG_RESULT($enable_gdb)
+
 AC_MSG_CHECKING(--enable-workshop argument)
 AC_ARG_ENABLE(workshop,
 	[  --enable-workshop       Include Sun Visual Workshop support.], ,
@@ -2006,6 +2013,20 @@
 AC_SUBST(GUITYPE)
 AC_SUBST(GUI_X_LIBS)
 
+dnl do not add pty.o when a GUI is used
+if test "$enable_gdb" = "yes"; then
+  AC_DEFINE(FEAT_GDB)
+  if test "x$GUITYPE" = "xNONE"; then
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c pty.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o objects/pty.o"
+  else
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o"
+  fi
+  AC_SUBST(GDB_SRC)
+  AC_SUBST(GDB_OBJ)
+fi
+
 if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
   AC_MSG_ERROR([cannot use workshop without Motif])
 fi

Property changes on: src/hangulin.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/move.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/option.c
===================================================================
--- src/option.c	(.../vendor/vim/current)	(revision 223)
+++ src/option.c	(.../trunk/vim)	(revision 223)
@@ -524,6 +524,11 @@
 			    {(char_u *)0L, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+#ifdef FEAT_GDB
+    {"asm",	    NULL,   P_NUM|P_VI_DEF,
+			    (char_u *)&p_asm, PV_NONE,
+			    {(char_u *)10L, (char_u *)0L}},
+#endif
 #ifdef FEAT_AUTOCHDIR
     {"autochdir",  "acd",   P_BOOL|P_VI_DEF,
 			    (char_u *)&p_acd, PV_NONE,
@@ -1153,6 +1158,14 @@
 			    {(char_u *)FALSE, (char_u *)0L}
 #endif
 			    SCRIPTID_INIT},
+#ifdef FEAT_GDB
+    {"gdbvariables", "gdbvar",P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+			    (char_u *)&p_gvar, PV_NONE,
+			    {(char_u *)"gdb-variables", (char_u *)0L} },
+    {"gdbprg",	    "gdp",  P_STRING|P_EXPAND|P_VI_DEF|P_SECURE,
+			    (char_u *)&p_gdp, PV_NONE,
+			    {(char_u *)"gdb", (char_u *)0L} },
+#endif
     {"gdefault",    "gd",   P_BOOL|P_VI_DEF|P_VIM,
 			    (char_u *)&p_gd, PV_NONE,
 			    {(char_u *)FALSE, (char_u *)0L}},

Property changes on: src/option.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/workshop.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/option.h
===================================================================
--- src/option.h	(.../vendor/vim/current)	(revision 223)
+++ src/option.h	(.../trunk/vim)	(revision 223)
@@ -558,6 +558,11 @@
 EXTERN char_u	*p_isp;		/* 'isprint' */
 EXTERN int	p_js;		/* 'joinspaces' */
 EXTERN char_u	*p_kp;		/* 'keywordprg' */
+#ifdef FEAT_GDB
+EXTERN long	p_asm;		/* 'asm' */
+EXTERN char_u	*p_gvar;	/* 'gdbvariables' */
+EXTERN char_u	*p_gdp;		/* 'gdbprg' */
+#endif
 #ifdef FEAT_VISUAL
 EXTERN char_u	*p_km;		/* 'keymodel' */
 #endif

Property changes on: src/option.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/workshop.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/proto/gdb.pro
===================================================================
--- src/proto/gdb.pro	(.../vendor/vim/current)	(revision 0)
+++ src/proto/gdb.pro	(.../trunk/vim)	(revision 223)
@@ -0,0 +1,22 @@
+/* gdb.c */
+gdb_handle_T *gdb_new __ARGS((void));
+void gdb_delete __ARGS((gdb_handle_T **));
+int gdb_isrunning __ARGS((gdb_handle_T *));
+int gdb_fd __ARGS((gdb_handle_T *));
+pid_t gdb_pid __ARGS((gdb_handle_T *));
+int gdb_isbuffer __ARGS((gdb_handle_T *, buf_T *));
+int gdb_allowed __ARGS((gdb_handle_T *));
+int gdb_event __ARGS((gdb_handle_T *));
+int gdb_sigchld __ARGS((gdb_handle_T *));
+void gdb_set_event __ARGS((gdb_handle_T *, int));
+void gdb_set_sigchld __ARGS((gdb_handle_T *, int));
+int gdb_safe_vgetc __ARGS((gdb_handle_T *));
+void gdb_buffer_free __ARGS((gdb_handle_T *, buf_T *));
+void gdb_label __ARGS((gdb_handle_T *, buf_T *, char_u *, size_t));
+void gdb_docmd __ARGS((gdb_handle_T *, char_u *));
+void gdb_setwinput __ARGS((gdb_handle_T *, char_u *));
+int gdb_iswinput __ARGS((gdb_handle_T *));
+void gdb_winput __ARGS((gdb_handle_T *));
+long gdb_process_output __ARGS((gdb_handle_T *, long, void *));
+win_T *gdb_window __ARGS((gdb_handle_T *));
+/* vim: set ft=c : */

Property changes on: src/quickfix.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/gui.c
===================================================================
--- src/gui.c	(.../vendor/vim/current)	(revision 223)
+++ src/gui.c	(.../trunk/vim)	(revision 223)
@@ -2647,6 +2647,10 @@
     long    wtime;
 {
     int	    retval;
+#if defined(FEAT_GDB) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+    struct timeval  start_tv;
+    gettimeofday(&start_tv, NULL);
+#endif
 
     /*
      * If we're going to wait a bit, update the menus and mouse shape for the
@@ -2673,7 +2677,35 @@
 	/* Blink when waiting for a character.	Probably only does something
 	 * for showmatch() */
 	gui_mch_start_blink();
+
+#ifdef FEAT_GDB
+	while ((retval = gui_mch_wait_for_chars(wtime)) == FAIL)
+	{
+	    if (gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+		gui_mch_stop_blink();	// cursor off while drawing status line
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		if ((wtime = gdb_process_output(gdb, wtime, (void *)&start_tv)) < 0)
+# else
+		/* guess we got interrupted halfway */
+		wtime = wtime / 2;
+
+		if ((wtime = gdb_process_output(gdb, wtime, NULL)) < 0)
+# endif
+		{
+		    return 0;    /* launch input-line window */
+		}
+		gui_mch_start_blink();
+
+		if (wtime == 0L)
+		    break;
+	    }
+	    else
+		break;
+	}
+#else
 	retval = gui_mch_wait_for_chars(wtime);
+#endif
 	gui_mch_stop_blink();
 	return retval;
     }
@@ -2689,7 +2721,27 @@
      * 'updatetime' and if nothing is typed within that time put the
      * K_CURSORHOLD key in the input buffer.
      */
+# ifdef FEAT_GDB
+    for (;;)
+    {
+	retval = gui_mch_wait_for_chars(p_ut);
+	if (retval == FAIL && gdb_event(gdb) && gdb_allowed(gdb))
+	{
+	    gui_mch_stop_blink();	// cursor off while drawing status line
+	    if (gdb_process_output(gdb, -1L, NULL) < 0)
+	    {
+		return 0;    /* launch input-line window */
+	    }
+	    gui_mch_start_blink();
+	}
+	else
+	    break;
+    }
+
+    if (retval == OK)
+# else
     if (gui_mch_wait_for_chars(p_ut) == OK)
+# endif
 	retval = OK;
 #ifdef FEAT_AUTOCMD
     else if (trigger_cursorhold())
@@ -2710,7 +2762,25 @@
     {
 	/* Blocking wait. */
 	before_blocking();
+#ifdef FEAT_GDB
+	for (;;)
+	{
+	    retval = gui_mch_wait_for_chars(-1L);
+	    if (retval == FAIL && gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+		gui_mch_stop_blink();	// cursor off while drawing status line
+		if (gdb_process_output(gdb, -1L, NULL) < 0)
+		{
+		    return 0;    /* launch input-line window */
+		}
+		gui_mch_start_blink();
+	    }
+	    else
+		break;
+	}
+#else
 	retval = gui_mch_wait_for_chars(-1L);
+#endif
     }
 
     gui_mch_stop_blink();

Property changes on: src/gui.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/macros.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/regexp.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/regexp.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/config.mk.in
===================================================================
--- src/config.mk.in	(.../vendor/vim/current)	(revision 223)
+++ src/config.mk.in	(.../trunk/vim)	(revision 223)
@@ -71,6 +71,9 @@
 WORKSHOP_SRC	= @WORKSHOP_SRC@
 WORKSHOP_OBJ	= @WORKSHOP_OBJ@
 
+GDB_SRC		= @GDB_SRC@
+GDB_OBJ		= @GDB_OBJ@
+
 NETBEANS_SRC	= @NETBEANS_SRC@
 NETBEANS_OBJ	= @NETBEANS_OBJ@
 

Property changes on: src/vim.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_at_fs.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_athena.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/structs.h
===================================================================
--- src/structs.h	(.../vendor/vim/current)	(revision 223)
+++ src/structs.h	(.../trunk/vim)	(revision 223)
@@ -577,7 +577,7 @@
     linenr_T	lnum;		/* line number which has this sign */
     int		typenr;		/* typenr of sign */
     signlist_T	*next;		/* next signlist entry */
-# ifdef FEAT_NETBEANS_INTG
+# if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB)
     signlist_T  *prev;		/* previous entry -- for easy reordering */
 # endif
 };
@@ -589,6 +589,13 @@
 #define SIGN_TEXT	3
 #endif
 
+#ifdef FEAT_GDB
+typedef struct
+{
+    int dummy;
+} gdb_handle_T;
+#endif
+
 /*
  * Argument list: Array of file names.
  * Used for the global argument list and the argument lists local to a window.

Property changes on: src/structs.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ui.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/getchar.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/memfile.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/xxd
___________________________________________________________________
Name: svn:ignore
   + xxd


Index: src/feature.h
===================================================================
--- src/feature.h	(.../vendor/vim/current)	(revision 223)
+++ src/feature.h	(.../trunk/vim)	(revision 223)
@@ -1210,6 +1210,24 @@
 #endif
 
 /*
+ * +gdb			Gdb interface. Must be included through configure,
+ *			see Makefile and uncomment "--enable-gdb"
+ *			Not included when required features are missing
+ *			and use explicitly the following FEAT_NORMAL features:
+ *			FEAT_CMDWIN FEAT_EVAL FEAT_STL_OPT FEAT_MODIFY_FNAME
+ *			FEAT_SEARCHPATH FEAT_WINDOWS FEAT_QUICKFIX
+ */
+#ifdef FEAT_GDB
+# if !defined(FEAT_NORMAL) || !defined(HAVE_SYS_WAIT_H) || !defined(HAVE_FCNTL_H)
+#  undef FEAT_GDB
+# else
+#  ifndef FEAT_SIGNS
+#   define FEAT_SIGNS	/* include +signs */
+#  endif
+# endif
+#endif
+
+/*
  * +balloon_eval	Allow balloon expression evaluation. Used with a
  *			debugger and for tooltips.
  *			Only for GUIs where it was implemented.

Property changes on: src/feature.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/undo.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/buffer.c
===================================================================
--- src/buffer.c	(.../vendor/vim/current)	(revision 223)
+++ src/buffer.c	(.../trunk/vim)	(revision 223)
@@ -613,6 +613,9 @@
 #ifdef FEAT_AUTOCMD
     aubuflocal_remove(buf);
 #endif
+#ifdef FEAT_GDB
+    gdb_buffer_free(gdb, buf);
+#endif
     vim_free(buf);
 }
 
@@ -5093,7 +5096,7 @@
 	newsign->lnum = lnum;
 	newsign->typenr = typenr;
 	newsign->next = next;
-#ifdef FEAT_NETBEANS_INTG
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB)
 	newsign->prev = prev;
 	if (next != NULL)
 	    next->prev = newsign;
@@ -5139,12 +5142,12 @@
 	    return;
 	}
 	else if (
-#ifndef FEAT_NETBEANS_INTG  /* keep signs sorted by lnum */
+#if !defined(FEAT_NETBEANS_INTG) && !defined(FEAT_GDB)  /* keep signs sorted by lnum */
 		   id < 0 &&
 #endif
 			     lnum < sign->lnum)
 	{
-#ifdef FEAT_NETBEANS_INTG /* insert new sign at head of list for this lnum */
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB) /* insert new sign at head of list for this lnum */
 	    /* XXX - GRP: Is this because of sign slide problem? Or is it
 	     * really needed? Or is it because we allow multiple signs per
 	     * line? If so, should I add that feature to FEAT_SIGNS?
@@ -5161,7 +5164,7 @@
 	}
 	prev = sign;
     }
-#ifdef FEAT_NETBEANS_INTG /* insert new sign at head of list for this lnum */
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB) /* insert new sign at head of list for this lnum */
     /* XXX - GRP: See previous comment */
     while (prev != NULL && prev->lnum == lnum)
 	prev = prev->prev;
@@ -5237,7 +5240,7 @@
 	if (sign->id == id)
 	{
 	    *lastp = next;
-#ifdef FEAT_NETBEANS_INTG
+#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GDB)
 	    if (next != NULL)
 		next->prev = sign->prev;
 #endif
@@ -5417,12 +5420,41 @@
     long	amount_after;
 {
     signlist_T	*sign;		/* a sign in a b_signlist */
+# ifdef FEAT_GDB
+    int lnum;
 
     for (sign = curbuf->b_signlist; sign != NULL; sign = sign->next)
     {
+	lnum = sign->lnum;
+
 	if (sign->lnum >= line1 && sign->lnum <= line2)
 	{
 	    if (amount == MAXLNUM)
+		lnum = line1;
+	    else
+		lnum += amount;
+	}
+	else if (sign->lnum > line2)
+	    lnum += amount_after;
+
+	/* Keep sign->lnum unchanged, but mark as changed the sign line and
+	 * the new line position if we had moved the line
+	 * (otherwise their highlighting may be scrolled along) */
+	if (gdb_isrunning(gdb) && lnum != sign->lnum)
+	{
+	    changed_lines(sign->lnum, 0, sign->lnum + 1, 0);
+	    changed_lines(lnum, 0, lnum + 1, 0);
+	}
+	else
+	    sign->lnum = lnum;
+    }
+# else
+
+    for (sign = curbuf->b_signlist; sign != NULL; sign = sign->next)
+    {
+	if (sign->lnum >= line1 && sign->lnum <= line2)
+	{
+	    if (amount == MAXLNUM)
 		sign->lnum = line1;
 	    else
 		sign->lnum += amount;
@@ -5430,6 +5462,7 @@
 	else if (sign->lnum > line2)
 	    sign->lnum += amount_after;
     }
+# endif
 }
 #endif /* FEAT_SIGNS */
 

Property changes on: src/buffer.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/pty.c
===================================================================
--- src/pty.c	(.../vendor/vim/current)	(revision 223)
+++ src/pty.c	(.../trunk/vim)	(revision 223)
@@ -37,7 +37,7 @@
  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
  */
 
-/* RCS_ID("$Id: pty.c,v 1.1 2004/06/13 20:04:27 vimboss Exp $ FAU") */
+/* RCS_ID("$Id$ FAU") */
 
 #include "vim.h"
 

Property changes on: src/pty.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/misc1.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/main.c
===================================================================
--- src/main.c	(.../vendor/vim/current)	(revision 223)
+++ src/main.c	(.../trunk/vim)	(revision 223)
@@ -198,6 +198,10 @@
     vim_tcl_init(params.argv[0]);
 #endif
 
+#ifdef FEAT_GDB
+    gdb = gdb_new();
+#endif
+
 #ifdef MEM_PROFILE
     atexit(vim_mem_profile_dump);
 #endif
@@ -1275,6 +1279,11 @@
     apply_autocmds(EVENT_VIMLEAVEPRE, NULL, NULL, FALSE, curbuf);
 #endif
 
+#ifdef FEAT_GDB
+    /* Before viminfo stuff to wipeout gdb buffer and remove from list */
+    gdb_delete(&gdb);
+#endif
+
 #ifdef FEAT_VIMINFO
     if (*p_viminfo != NUL)
 	/* Write out the registers, history, marks etc, to the viminfo file */

Property changes on: src/main.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/edit.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/syntax.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/eval.c
===================================================================
--- src/eval.c	(.../vendor/vim/current)	(revision 223)
+++ src/eval.c	(.../trunk/vim)	(revision 223)
@@ -540,6 +540,9 @@
 static void f_foreground __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_function __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_garbagecollect __ARGS((typval_T *argvars, typval_T *rettv));
+#ifdef FEAT_GDB
+static void f_gdb __ARGS((typval_T *argvars, typval_T *rettv));
+#endif
 static void f_get __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getbufline __ARGS((typval_T *argvars, typval_T *rettv));
 static void f_getbufvar __ARGS((typval_T *argvars, typval_T *rettv));
@@ -7499,6 +7502,9 @@
     {"foreground",	0, 0, f_foreground},
     {"function",	1, 1, f_function},
     {"garbagecollect",	0, 1, f_garbagecollect},
+#ifdef FEAT_GDB
+    {"gdb",		1, 1, f_gdb},
+#endif
     {"get",		2, 3, f_get},
     {"getbufline",	2, 3, f_getbufline},
     {"getbufvar",	2, 2, f_getbufvar},
@@ -10326,7 +10332,26 @@
 	garbage_collect_at_exit = TRUE;
 }
 
+#ifdef FEAT_GDB
 /*
+ * "gdb()" function
+ */
+    static void
+f_gdb(argvars, rettv)
+    typval_T	*argvars;
+    typval_T	*rettv;
+{
+    char_u *cmd = get_tv_string(&argvars[0]);
+
+    if (*cmd == NUL)
+	gdb_setwinput(gdb, (char_u *)"");   /* open the window input-line */
+    else
+	gdb_docmd(gdb, cmd);	/* send cmd to gdb */
+    rettv->vval.v_number = 1;
+}
+#endif
+
+/*
  * "get()" function
  */
     static void
@@ -11479,6 +11504,9 @@
 #if !defined(USE_SYSTEM) && defined(UNIX)
 	"fork",
 #endif
+#ifdef FEAT_GDB
+	"gdb",
+#endif
 #ifdef FEAT_GETTEXT
 	"gettext",
 #endif

Property changes on: src/eval.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/normal.c
===================================================================
--- src/normal.c	(.../vendor/vim/current)	(revision 223)
+++ src/normal.c	(.../trunk/vim)	(revision 223)
@@ -637,9 +637,23 @@
     dont_scroll = FALSE;	/* allow scrolling here */
 #endif
 
+#if defined(FEAT_GDB) && defined(FEAT_CMDWIN)
+    /* Launch the input-line window */
+    if (cmdwin_type == 0 && gdb_iswinput(gdb))
+    {
+	gdb_winput(gdb);
+	goto normal_end;
+    }
+#endif
+
     /*
      * Get the command character from the user.
      */
+#ifdef FEAT_GDB
+    if (toplevel)
+        c = gdb_safe_vgetc(gdb);
+    else
+#endif
     c = safe_vgetc();
 
 #ifdef FEAT_LANGMAP
@@ -725,6 +739,11 @@
 		++allow_keys;		/* no mapping for nchar, but keys */
 	    }
 	    ++no_zero_mapping;		/* don't map zero here */
+#ifdef FEAT_GDB
+            if (toplevel)
+                c = gdb_safe_vgetc(gdb);
+            else
+#endif
 	    c = plain_vgetc();
 #ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
@@ -750,6 +769,11 @@
 	    ca.count0 = 0;
 	    ++no_mapping;
 	    ++allow_keys;		/* no mapping for nchar, but keys */
+#ifdef FEAT_GDB
+            if (toplevel)
+                c = gdb_safe_vgetc(gdb);
+            else
+#endif
 	    c = plain_vgetc();		/* get next character */
 #ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(c, TRUE);
@@ -940,6 +964,11 @@
 	     * For 'g' get the next character now, so that we can check for
 	     * "gr", "g'" and "g`".
 	     */
+#ifdef FEAT_GDB
+            if (toplevel)
+                ca.nchar = gdb_safe_vgetc(gdb);
+            else
+#endif
 	    ca.nchar = plain_vgetc();
 #ifdef FEAT_LANGMAP
 	    LANGMAP_ADJUST(ca.nchar, TRUE);
@@ -997,6 +1026,11 @@
 		im_set_active(TRUE);
 #endif
 
+#ifdef FEAT_GDB
+            if (toplevel)
+                *cp = gdb_safe_vgetc(gdb);
+            else
+#endif
 	    *cp = plain_vgetc();
 
 	    if (langmap_active)
@@ -1104,6 +1138,11 @@
 	    while (enc_utf8 && lang && (c = vpeekc()) > 0
 				 && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))
 	    {
+#ifdef FEAT_GDB
+                if (toplevel)
+                    c = gdb_safe_vgetc(gdb);
+                else
+#endif
 		c = plain_vgetc();
 		if (!utf_iscomposing(c))
 		{
@@ -8668,6 +8707,10 @@
 		&& cap->opcount == 0
 		&& cap->count0 == 0
 		&& cap->oap->regname == 0
+#ifdef FEAT_GDB
+		/* don't beep when opening gdb input-line window */
+		&& !gdb_iswinput(gdb)
+#endif
 		&& !p_im);
 
     if (cap->arg)		/* TRUE for CTRL-C */

Property changes on: src/normal.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_gtk.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/if_cscope.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_beval.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/if_ruby.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/if_cscope.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/if_python.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_beval.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/proto.h
===================================================================
--- src/proto.h	(.../vendor/vim/current)	(revision 223)
+++ src/proto.h	(.../trunk/vim)	(revision 223)
@@ -238,6 +238,10 @@
 #  include "if_xcmdsrv.pro"
 # endif
 
+# ifdef FEAT_GDB
+#  include "gdb.pro"
+# endif
+
 /*
  * The perl include files pollute the namespace, therefore proto.h must be
  * included before the perl include files.  But then CV is not defined, which

Property changes on: src/proto.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_motif.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/charset.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/Makefile
===================================================================
--- src/Makefile	(.../vendor/vim/current)	(revision 223)
+++ src/Makefile	(.../trunk/vim)	(revision 223)
@@ -412,6 +412,9 @@
 # WORKSHOP - Sun Visual Workshop interface.  Only works with Motif!
 #CONF_OPT_WORKSHOP = --enable-workshop
 
+# GDB - Include support for gdb
+CONF_OPT_GDB = --enable-gdb
+
 # NETBEANS - NetBeans interface. Only works with Motif, GTK, and gnome.
 # Motif version must have XPM libraries (see |workshop-xpm|).
 # Uncomment this when you do not want the netbeans interface.
@@ -1414,12 +1417,14 @@
 
 SRC =	$(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) $(MZSCHEME_SRC) \
 	$(PERL_SRC) $(PYTHON_SRC) $(TCL_SRC) $(RUBY_SRC) \
+	$(GDB_SRC) \
 	$(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC)
 
 TAGS_SRC = *.c *.cpp if_perl.xs
 
 EXTRA_SRC = hangulin.c if_mzsch.c auto/if_perl.c if_perlsfio.c \
 	    if_python.c if_tcl.c if_ruby.c if_sniff.c gui_beval.c \
+		gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c \
 	    workshop.c wsdebug.c integration.c netbeans.c
 
 # All sources, also the ones that are not configured
@@ -1429,6 +1434,7 @@
 # checks more, but may not work well for checking a GUI that wasn't configured.
 # The perl sources also don't work well with lint.
 LINT_SRC = $(BASIC_SRC) $(GUI_SRC) $(HANGULIN_SRC) $(PYTHON_SRC) $(TCL_SRC) \
+	$(GDB_SRC) \
 	$(SNIFF_SRC) $(WORKSHOP_SRC) $(WSDEBUG_SRC) $(NETBEANS_SRC)
 #LINT_SRC = $(SRC)
 #LINT_SRC = $(ALL_SRC)
@@ -1489,6 +1495,7 @@
 	$(RUBY_OBJ) \
 	$(OS_EXTRA_OBJ) \
 	$(WORKSHOP_OBJ) \
+	$(GDB_OBJ) \
 	$(NETBEANS_OBJ) \
 	$(WSDEBUG_OBJ)
 
@@ -1544,6 +1551,7 @@
 	window.pro \
 	gui_beval.pro \
 	workshop.pro \
+	gdb.pro \
 	netbeans.pro \
 	$(ALL_GUI_PRO) \
 	$(TCL_PRO)
@@ -1577,6 +1585,7 @@
 		$(CONF_OPT_TCL) $(CONF_OPT_RUBY) $(CONF_OPT_NLS) \
 		$(CONF_OPT_CSCOPE) $(CONF_OPT_MULTIBYTE) $(CONF_OPT_INPUT) \
 		$(CONF_OPT_OUTPUT) $(CONF_OPT_GPM) $(CONF_OPT_WORKSHOP) \
+		$(CONF_OPT_GDB) \
 		$(CONF_OPT_SNIFF) $(CONF_OPT_FEAT) $(CONF_TERM_LIB) \
 		$(CONF_OPT_COMPBY) $(CONF_OPT_ACL)  $(CONF_OPT_NETBEANS) \
 		$(CONF_ARGS) $(CONF_OPT_MZSCHEME) $(CONF_OPT_PLTHOME) \
@@ -2552,6 +2561,21 @@
 objects/workshop.o: workshop.c
 	$(CCC) -o $@ workshop.c
 
+objects/gdb.o: gdb.c
+	$(CCC) -o $@ gdb.c
+
+objects/gdb_lvl2.o: clewn/gdb_lvl2.c
+	$(CCC) -o $@ clewn/gdb_lvl2.c
+
+objects/gdb_lvl3.o: clewn/gdb_lvl3.c
+	$(CCC) -o $@ clewn/gdb_lvl3.c
+
+objects/misc.o: clewn/misc.c
+	$(CCC) -o $@ clewn/misc.c
+
+objects/obstack.o: clewn/obstack.c
+	$(CCC) -o $@ clewn/obstack.c
+
 objects/wsdebug.o: wsdebug.c
 	$(CCC) -o $@ wsdebug.c
 
@@ -2948,6 +2972,13 @@
   os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \
   structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h \
   proto.h globals.h farsi.h arabic.h version.h workshop.h
+objects/gdb.o: gdb.c clewn/gdb.h clewn/misc.h auto/config.h vim.h feature.h
+objects/gdb_lvl2.o: clewn/misc.h clewn/gdb_lvl2.c clewn/gdb_lvl3.c \
+	gdb.c clewn/gdb.h auto/config.h vim.h feature.h
+objects/gdb_lvl3.o: clewn/misc.h clewn/gdb_lvl3.c gdb.c clewn/gdb.h\
+	auto/config.h vim.h feature.h
+objects/misc.o: clewn/misc.c clewn/misc.h
+objects/obstack.o: clewn/obstack.c clewn/obstack.h
 objects/wsdebug.o: wsdebug.c
 objects/integration.o: integration.c vim.h auto/config.h feature.h os_unix.h \
   auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \

Property changes on: src/if_tcl.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/wsdebug.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/wsdebug.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/nbdebug.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/diff.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/tag.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/nbdebug.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/misc2.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/config.h.in
===================================================================
--- src/config.h.in	(.../vendor/vim/current)	(revision 223)
+++ src/config.h.in	(.../trunk/vim)	(revision 223)
@@ -367,6 +367,9 @@
 /* Define if you want to include Sun Visual Workshop support. */
 #undef FEAT_SUN_WORKSHOP
 
+/* Define if you want to include GDB support. */
+#undef FEAT_GDB
+
 /* Define if you want to include NetBeans integration. */
 #undef FEAT_NETBEANS_INTG
 

Property changes on: src/mbyte.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/gui_gtk_x11.c
===================================================================
--- src/gui_gtk_x11.c	(.../vendor/vim/current)	(revision 223)
+++ src/gui_gtk_x11.c	(.../trunk/vim)	(revision 223)
@@ -6381,7 +6381,13 @@
 gui_mch_update(void)
 {
     while (gtk_events_pending() && !vim_is_input_buf_full())
+    {
+#ifdef FEAT_GDB
+	if (gdb_event(gdb))	/* got a gdb event */
+	    return;
+#endif
 	gtk_main_iteration_do(FALSE);
+    }
 }
 
     static gint
@@ -6418,7 +6424,25 @@
 }
 #endif
 
+#ifdef FEAT_GDB
 /*
+ * Callback function, used when data is available on the gdb file descriptor.
+ */
+/* ARGSUSED */
+    static void
+gdb_request_cb(
+    gpointer	data,
+    gint	source_fd,
+    GdkInputCondition condition)
+{
+    gdb_set_event(gdb, TRUE);
+
+    if (gtk_main_level() > 0)
+	gtk_main_quit();
+}
+#endif
+
+/*
  * GUI input routine called by gui_wait_for_chars().  Waits for a character
  * from the keyboard.
  *  wtime == -1     Wait forever.
@@ -6437,6 +6461,10 @@
     static int	sniff_on = 0;
     static gint	sniff_input_id = 0;
 #endif
+#ifdef FEAT_GDB
+    static int gdb_on        = 0;
+    static gint gdb_input_id = 0;
+#endif
 
 #ifdef FEAT_SNIFF
     if (sniff_on && !want_sniff_request)
@@ -6454,6 +6482,25 @@
     }
 #endif
 
+#ifdef FEAT_GDB
+    /* Remove call back for previous gdb connection */
+    if (! gdb_allowed(gdb) && gdb_on)
+    {
+	if (gdb_input_id)
+	    gdk_input_remove(gdb_input_id);
+	gdb_on = 0;
+    }
+
+    /* A new gdb connection */
+    if (gdb_allowed(gdb) && !gdb_on)
+    {
+	/* Add gdb file descriptor to watch for available data in main loop. */
+	gdb_input_id = gdk_input_add(gdb_fd(gdb),
+			       GDK_INPUT_READ, gdb_request_cb, NULL);
+	gdb_on = 1;
+    }
+#endif
+
     timed_out = FALSE;
 
     /* this timeout makes sure that we will return if no characters arrived in
@@ -6498,6 +6545,15 @@
 		gtk_timeout_remove(timer);
 	    return OK;
 	}
+
+#ifdef FEAT_GDB
+	if (wtime != 0L && gdb_allowed(gdb) && gdb_event(gdb))
+	{
+	    if (timer != 0 && !timed_out)
+		gtk_timeout_remove(timer);
+	    return FAIL;
+	}
+#endif
     } while (wtime < 0 || !timed_out);
 
     /*

Property changes on: src/gui_gtk_x11.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/os_unix.c
===================================================================
--- src/os_unix.c	(.../vendor/vim/current)	(revision 223)
+++ src/os_unix.c	(.../trunk/vim)	(revision 223)
@@ -183,6 +183,9 @@
 static RETSIGTYPE sig_alarm __ARGS(SIGPROTOARG);
 static int sig_alarm_called;
 #endif
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+static RETSIGTYPE gdb_catch_sigchld __ARGS(SIGPROTOARG);
+#endif
 static RETSIGTYPE deathtrap __ARGS(SIGPROTOARG);
 
 static void catch_int_signal __ARGS((void));
@@ -312,6 +315,9 @@
 #ifdef SIGPIPE
     {SIGPIPE,	    "PIPE",	FALSE},
 #endif
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+    {SIGCHLD,	    "CHLD",	FALSE},
+#endif
     {-1,	    "Unknown!", FALSE}
 };
 
@@ -341,6 +347,10 @@
     int		tb_change_cnt;
 {
     int		len;
+#if defined(FEAT_GDB) && defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+    struct timeval  start_tv;
+    gettimeofday(&start_tv, NULL);
+#endif
 
     /* Check if window changed size while we were busy, perhaps the ":set
      * columns=99" command was used. */
@@ -351,6 +361,21 @@
     {
 	while (WaitForChar(wtime) == 0)		/* no character available */
 	{
+#ifdef FEAT_GDB
+	    if (gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		if ((wtime = gdb_process_output(gdb, wtime, (void *)&start_tv)) < 0)
+# else
+		/* guess we got interrupted halfway */
+		wtime = wtime / 2;
+
+		if ((wtime = gdb_process_output(gdb, wtime, NULL)) < 0)
+# endif
+		    return 0;	/* launch input-line window */
+		continue;
+	    }
+#endif
 	    if (!do_resize)	/* return if not interrupted by resize */
 		return 0;
 	    handle_resize();
@@ -363,8 +388,25 @@
 	 * flush all the swap files to disk.
 	 * Also done when interrupted by SIGWINCH.
 	 */
+#ifdef FEAT_GDB
+	{
+        wtime = p_ut;
+        while (WaitForChar(wtime) == 0)
+        {
+	    if (gdb_event(gdb) && gdb_allowed(gdb))
+	    {
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+		if ((wtime = gdb_process_output(gdb, wtime, (void *)&start_tv)) < 0)
+# else
+		if ((wtime = gdb_process_output(gdb, wtime, NULL)) < 0)
+# endif
+		    return 0;	/* launch input-line window */
+		continue;
+            }
+#else
 	if (WaitForChar(p_ut) == 0)
 	{
+#endif
 #ifdef FEAT_AUTOCMD
 	    if (trigger_cursorhold() && maxlen >= 3
 					   && !typebuf_changed(tb_change_cnt))
@@ -376,6 +418,10 @@
 	    }
 #endif
 	    before_blocking();
+#ifdef FEAT_GDB
+             break;
+	} /* while (WaitForChar(wtime) == 0) */
+#endif
 	}
     }
 
@@ -387,6 +433,16 @@
 	 * we want to be interrupted by the winch signal
 	 */
 	WaitForChar(-1L);
+
+#ifdef FEAT_GDB
+	if (gdb_event(gdb) && gdb_allowed(gdb))
+	{
+	    if (gdb_process_output(gdb, -1L, NULL) < 0)
+		return 0;	/* launch input-line window */
+	    continue;
+	}
+#endif
+
 	if (do_resize)	    /* interrupted by SIGWINCH signal */
 	    continue;
 
@@ -858,6 +914,30 @@
 }
 #endif
 
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+/*
+ * On SIGCHLD, note when gdb process is defunct or does not exist any more
+ */
+    static RETSIGTYPE
+gdb_catch_sigchld SIGDEFARG(sigarg)
+{
+    pid_t wait_pid;
+    pid_t pid;
+
+    if (sigarg == SIGCHLD && (pid = gdb_pid(gdb)) != -1)
+    {
+	wait_pid = waitpid(pid, NULL, WNOHANG);
+
+	if ((wait_pid == (pid_t)-1 && errno == ECHILD)
+		|| wait_pid == pid)
+	    gdb_set_sigchld(gdb, TRUE);
+    }
+
+    signal(SIGCHLD, (RETSIGTYPE (*)())gdb_catch_sigchld);
+    SIGRETURN;
+}
+#endif
+
 #if (defined(HAVE_SETJMP_H) \
 	&& ((defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)) \
 	    || defined(FEAT_LIBCALL))) \
@@ -1203,6 +1283,13 @@
 #endif
 
     /*
+     * Catch SIGCHLD to monitor gdb process state
+     */
+#if defined(FEAT_GDB) && defined(SIGCHLD)
+    signal(SIGCHLD, (RETSIGTYPE (*)())gdb_catch_sigchld);
+#endif
+
+    /*
      * Arrange for other signals to gracefully shutdown Vim.
      */
     catch_signals(deathtrap, SIG_ERR);
@@ -4733,7 +4820,12 @@
 # endif
 #endif
 #ifndef HAVE_SELECT
+# ifdef FEAT_GDB
+	struct pollfd   fds[6];
+	int		gdb_idx = -1;
+# else
 	struct pollfd   fds[5];
+# endif
 	int		nfd;
 # ifdef FEAT_XCLIPBOARD
 	int		xterm_idx = -1;
@@ -4794,7 +4886,23 @@
 	    nfd++;
 	}
 # endif
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    /* handle pending SIGCHLD from gdb */
+	    if (gdb_sigchld(gdb))
+	    {
+		gdb_set_event(gdb, TRUE);
+		return 0;
+	    }
 
+	    gdb_idx = nfd;
+	    fds[nfd].fd = gdb_fd(gdb);
+	    fds[nfd].events = POLLIN;
+	    nfd++;
+	}
+# endif
+
 	ret = poll(fds, nfd, towait);
 # ifdef FEAT_MZSCHEME
 	if (ret == 0 && mzquantum_used)
@@ -4802,6 +4910,27 @@
 	    finished = FALSE;
 # endif
 
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    if (ret > 0 && fds[gdb_idx].revents & POLLIN)
+	    {
+		ret--;
+		if (!got_int)
+		    gdb_set_event(gdb, TRUE);
+		else
+		    gdb_set_event(gdb, FALSE);
+	    }
+
+	    /* EINTR poll error */
+	    if (ret < 0 && gdb_sigchld(gdb) && !got_int)
+		gdb_set_event(gdb, TRUE);
+
+	    /* an event: gdb's SIGCHLD or gdb data output */
+	    if (gdb_event(gdb))
+		return 0;
+	}
+# endif
 # ifdef FEAT_SNIFF
 	if (ret < 0)
 	    sniff_disconnect(1);
@@ -4928,7 +5057,24 @@
 		maxfd = xsmp_icefd;
 	}
 # endif
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    int fd = gdb_fd(gdb);
 
+	    /* handle pending SIGCHLD from gdb */
+	    if (gdb_sigchld(gdb))
+	    {
+		gdb_set_event(gdb, TRUE);
+		return 0;
+            }
+
+	    FD_SET(fd, &rfds);
+	    if (maxfd < fd)
+		maxfd = fd;
+	}
+# endif
+
 # ifdef OLD_VMS
 	/* Old VMS as v6.2 and older have broken select(). It waits more than
 	 * required. Should not be used */
@@ -4950,6 +5096,27 @@
 	    finished = FALSE;
 # endif
 
+# ifdef FEAT_GDB
+	if (msec != 0L && gdb_allowed(gdb))
+	{
+	    if (ret > 0 && FD_ISSET(gdb_fd(gdb), &rfds))
+	    {
+		ret--;
+		if (! got_int)
+		    gdb_set_event(gdb, TRUE);
+		else
+		    gdb_set_event(gdb, FALSE);
+	    }
+
+	    /* EINTR select error */
+	    if (ret < 0 && gdb_sigchld(gdb) && ! got_int)
+		gdb_set_event(gdb, TRUE);
+
+	    /* an event: gdb's SIGCHLD or gdb data output */
+	    if (gdb_event(gdb))
+		return 0;
+	}
+# endif
 # ifdef FEAT_SNIFF
 	if (ret < 0 )
 	    sniff_disconnect(1);

Property changes on: src/os_unix.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/fold.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/version.c
===================================================================
--- src/version.c	(.../vendor/vim/current)	(revision 223)
+++ src/version.c	(.../trunk/vim)	(revision 223)
@@ -236,6 +236,11 @@
 #if !defined(USE_SYSTEM) && defined(UNIX)
 	"+fork()",
 #endif
+#ifdef FEAT_GDB
+	"+gdb",
+#else
+	"-gdb",
+#endif
 #ifdef FEAT_GETTEXT
 # ifdef DYNAMIC_GETTEXT
 	"+gettext/dyn",

Property changes on: src/version.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/os_unix.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/version.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/keymap.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/ex_getln.c
===================================================================
--- src/ex_getln.c	(.../vendor/vim/current)	(revision 223)
+++ src/ex_getln.c	(.../trunk/vim)	(revision 223)
@@ -723,6 +723,12 @@
 #ifdef FEAT_CMDWIN
 	if (c == cedit_key || c == K_CMDWIN)
 	{
+#ifdef FEAT_GDB
+            /* Set cmdfirstc before calling ex_window (up to now it is NUL:
+	     * the input line does not have a '@' leading character) */
+            if (firstc == '@')
+                ccline.cmdfirstc = firstc;
+#endif
 	    /*
 	     * Open a window to edit the command line (and history).
 	     */
@@ -6011,6 +6017,30 @@
     /* don't use a new tab page */
     cmdmod.tab = 0;
 
+# ifdef FEAT_GDB
+    /* Split below the displayed gdb window */
+    if (gdb_iswinput(gdb) && (wp = gdb_window(gdb)) != NULL
+	    && (wp = wp->w_next) != NULL)
+    {
+	linenr_T topline;
+	
+	curwin = wp;
+	curbuf = curwin->w_buffer;
+	topline = curwin->w_topline;
+
+	if (win_split((int)p_cwh, WSP_ABOVE) == FAIL)
+	{
+	    curwin = old_curwin;
+	    curbuf = old_curbuf;
+	    beep_flush();
+	    return K_IGNORE;
+	}
+
+	/* Do not scroll the window below gdb window */
+	set_topline(wp, topline + p_cwh + STATUS_HEIGHT);
+    }
+    else
+# endif
     /* Create a window for the command-line buffer. */
     if (win_split((int)p_cwh, WSP_BOT) == FAIL)
     {
@@ -6057,6 +6087,20 @@
 	set_option_value((char_u *)"ft", 0L, (char_u *)"vim", OPT_LOCAL);
     }
 
+# ifdef FEAT_GDB
+    if (gdb_iswinput(gdb))      /* gdb window input-line */
+    {
+	add_map((char_u *)"<buffer> <C-Z> <C-Z><CR>", INSERT);
+	add_map((char_u *)"<buffer> <Tab> <C-Q><C-I><CR>", INSERT);
+	set_option_value((char_u *)"ft", 0L, (char_u *)"gdb", OPT_LOCAL);
+	set_option_value((char_u *)"fdc", 0L, NULL, OPT_LOCAL);
+
+        /* The window search-line does not have this: with a two lines history,
+	 * the window shows an empty line at top */
+        curwin->w_valid = FALSE;
+    }
+# endif
+
     /* Reset 'textwidth' after setting 'filetype' (the Vim filetype plugin
      * sets 'textwidth' to 78). */
     curbuf->b_p_tw = 0;
@@ -6180,6 +6224,10 @@
 	    cmdwin_result = Ctrl_C;
 	else
 	{
+#ifdef FEAT_GDB
+            if (ccline.cmdfirstc == '@')
+                ccline.cmdfirstc = NUL;
+#endif
 	    ccline.cmdlen = (int)STRLEN(ccline.cmdbuff);
 	    ccline.cmdbufflen = ccline.cmdlen + 1;
 	    ccline.cmdpos = curwin->w_cursor.col;

Property changes on: src/ex_getln.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/screen.c
===================================================================
--- src/screen.c	(.../vendor/vim/current)	(revision 223)
+++ src/screen.c	(.../trunk/vim)	(revision 223)
@@ -5753,6 +5753,11 @@
 	fillchar = fillchar_status(&attr, wp == curwin);
 
 	get_trans_bufname(wp->w_buffer);
+#ifdef FEAT_GDB
+	/* Replace fname with gdb window label */
+	gdb_label(gdb, wp->w_buffer, NameBuff, MAXPATHL);
+	trans_characters(NameBuff, MAXPATHL);
+#endif
 	p = NameBuff;
 	len = (int)STRLEN(p);
 

Property changes on: src/screen.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/os_unixx.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/arabic.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/memline.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/arabic.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/auto/configure
===================================================================
--- src/auto/configure	(.../vendor/vim/current)	(revision 223)
+++ src/auto/configure	(.../trunk/vim)	(revision 223)
@@ -757,6 +757,8 @@
 HANGULIN_OBJ
 HANGULIN_SRC
 GUI_X_LIBS
+GDB_SRC
+GDB_OBJ
 GUITYPE
 GUI_LIB_LOC
 GUI_INC_LOC
@@ -794,6 +796,7 @@
 enable_cscope
 enable_workshop
 enable_netbeans
+enable_gdb
 enable_sniff
 enable_multibyte
 enable_hangulinput
@@ -1465,6 +1468,7 @@
   --enable-rubyinterp     Include Ruby interpreter.
   --enable-cscope         Include cscope interface.
   --enable-workshop       Include Sun Visual Workshop support.
+  --enable-gdb		  Include GDB support.
   --disable-netbeans      Disable NetBeans integration support.
   --enable-sniff          Include Sniff interface.
   --enable-multibyte      Include multibyte editing support.
@@ -5788,6 +5792,18 @@
 
 fi
 
+echo "$as_me:$LINENO: checking --enable-gdb argument" >&5
+echo $ECHO_N "checking --enable-gdb argument... $ECHO_C" >&6
+# Check whether --enable-gdb or --disable-gdb was given.
+if test "${enable_gdb+set}" = set; then
+  enableval="$enable_gdb"
+
+else
+  enable_gdb="no"
+fi;
+echo "$as_me:$LINENO: result: $enable_gdb" >&5
+echo "${ECHO_T}$enable_gdb" >&6
+
 { $as_echo "$as_me:$LINENO: checking --enable-workshop argument" >&5
 $as_echo_n "checking --enable-workshop argument... " >&6; }
 # Check whether --enable-workshop was given.
@@ -10197,6 +10213,22 @@
 
 
 
+if test "$enable_gdb" = "yes"; then
+  cat >>confdefs.h <<\_ACEOF
+#define FEAT_GDB 1
+_ACEOF
+
+  if test "x$GUITYPE" = "xNONE"; then
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c pty.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o objects/pty.o"
+  else
+    GDB_SRC="gdb.c clewn/gdb_lvl2.c clewn/gdb_lvl3.c clewn/misc.c clewn/obstack.c"
+    GDB_OBJ="objects/gdb.o objects/gdb_lvl2.o objects/gdb_lvl3.o objects/misc.o objects/obstack.o"
+  fi
+
+
+fi
+
 if test "$enable_workshop" = "yes" -a -n "$SKIP_MOTIF"; then
   { { $as_echo "$as_me:$LINENO: error: cannot use workshop without Motif" >&5
 $as_echo "$as_me: error: cannot use workshop without Motif" >&2;}

Property changes on: src/auto
___________________________________________________________________
Name: svn:ignore
   + osdef.h
config.status
config.cache
link.sed
pathdef.c
link.log
config.log



Property changes on: src/gui_at_sb.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_gtk_f.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ops.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_at_sb.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/gui_gtk_f.h
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/if_xcmdsrv.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/farsi.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/search.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/fileio.c
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/window.c
===================================================================
--- src/window.c	(.../vendor/vim/current)	(revision 223)
+++ src/window.c	(.../trunk/vim)	(revision 223)
@@ -6053,6 +6053,10 @@
 # ifdef FEAT_QUICKFIX
 		    || wp->w_p_pvw
 # endif
+# ifdef FEAT_GDB
+		    /* not counting a gdb window */
+		    || gdb_isbuffer(gdb, wp->w_buffer)
+# endif
 	     ) || wp == curwin)
 	    ++count;
     return (count <= 1);

Property changes on: src/window.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/farsi.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/gui_x11.c
===================================================================
--- src/gui_x11.c	(.../vendor/vim/current)	(revision 223)
+++ src/gui_x11.c	(.../trunk/vim)	(revision 223)
@@ -148,6 +148,9 @@
 #ifdef FEAT_SNIFF
 static void gui_x11_sniff_request_cb __ARGS((XtPointer closure, int *source, XtInputId *id));
 #endif
+#ifdef FEAT_GDB
+static void gdb_request_cb __ARGS((XtPointer closure, int *source, XtInputId *id));
+#endif
 static void gui_x11_check_copy_area __ARGS((void));
 #ifdef FEAT_CLIENTSERVER
 static void gui_x11_send_event_handler __ARGS((Widget, XtPointer, XEvent *, Boolean *));
@@ -1181,7 +1184,22 @@
 }
 #endif
 
+#ifdef FEAT_GDB
 /*
+ * Callback function, used when data is available on the gdb file descriptor.
+ */
+/* ARGSUSED */
+    static void
+gdb_request_cb (closure, source, id)
+    XtPointer	closure;
+    int		*source;
+    XtInputId	*id;
+{
+    gdb_set_event(gdb, TRUE);
+}
+#endif
+
+/*
  * End of call-back routines
  */
 
@@ -2834,7 +2852,13 @@
 	desired = (XtIMAll);
     while ((mask = XtAppPending(app_context)) && (mask & desired)
 	    && !vim_is_input_buf_full())
+    {
+#ifdef FEAT_GDB
+	if (gdb_event(gdb))	/* got a gdb event */
+	    return;
+#endif
 	XtAppProcessEvent(app_context, desired);
+    }
 }
 
 /*
@@ -2863,6 +2887,10 @@
     static int	    sniff_on = 0;
     static XtInputId sniff_input_id = 0;
 #endif
+#ifdef FEAT_GDB
+    static int gdb_on = 0;
+    static XtInputId gdb_input_id = 0;
+#endif
 
     timed_out = FALSE;
 
@@ -2881,6 +2909,25 @@
     }
 #endif
 
+#ifdef FEAT_GDB
+    /* Remove call back for previous gdb connection */
+    if (! gdb_allowed(gdb) && gdb_on)
+    {
+	if (gdb_input_id)
+	    XtRemoveInput(gdb_input_id);
+	gdb_on = 0;
+    }
+
+    /* A new gdb connection */
+    if (gdb_allowed(gdb) && !gdb_on)
+    {
+	/* Add gdb file descriptor to watch for available data in main loop. */
+	gdb_input_id = XtAppAddInput(app_context, gdb_fd(gdb),
+		     (XtPointer)XtInputReadMask, gdb_request_cb, 0);
+	gdb_on = 1;
+    }
+#endif
+
     if (wtime > 0)
 	timer = XtAppAddTimeOut(app_context, (long_u)wtime, gui_x11_timer_cb,
 								  &timed_out);
@@ -2920,6 +2967,15 @@
 		XtRemoveTimeOut(timer);
 	    return OK;
 	}
+
+#ifdef FEAT_GDB
+	if (wtime != 0L && gdb_allowed(gdb) && gdb_event(gdb))
+	{
+	    if (timer != (XtIntervalId)0 && !timed_out)
+		XtRemoveTimeOut(timer);
+	    return FAIL;
+	}
+#endif
     }
     return FAIL;
 }

Property changes on: src/gui_x11.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/integration.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/ex_eval.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src/integration.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/globals.h
===================================================================
--- src/globals.h	(.../vendor/vim/current)	(revision 223)
+++ src/globals.h	(.../trunk/vim)	(revision 223)
@@ -1189,6 +1189,10 @@
 extern cursorentry_T shape_table[SHAPE_IDX_COUNT];
 #endif
 
+#ifdef FEAT_GDB
+EXTERN gdb_handle_T *gdb INIT(= NULL);	/* gdb opaque handle */
+#endif
+
 #ifdef FEAT_PRINTER
 /*
  * Printer stuff shared between hardcopy.c and machine-specific printing code.

Property changes on: src/globals.h
___________________________________________________________________
Name: svn:keywords
   + Id

Index: src/gdb.c
===================================================================
--- src/gdb.c	(.../vendor/vim/current)	(revision 0)
+++ src/gdb.c	(.../trunk/vim)	(revision 223)
@@ -0,0 +1,2457 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *			gdb support by Xavier de Gaye
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ *
+ * $Id$
+ */
+
+#include "vim.h"
+
+#ifdef FEAT_GDB	    /* possibly undefined in feature.h */
+# include "clewn/obstack.h"
+# include "clewn/gdb.h"
+# include "clewn/misc.h"
+
+# ifndef FEAT_GUI
+#  include "pty.pro"
+# endif
+
+# ifdef HAVE_SYS_WAIT_H
+#  include <sys/wait.h>
+# endif
+
+# ifdef HAVE_FCNTL_H
+#  include <fcntl.h>
+# endif
+
+# if defined(HAVE_SYS_SELECT_H) && \
+	(!defined(HAVE_SYS_TIME_H) || defined(SYS_SELECT_WITH_SYS_TIME))
+#  include <sys/select.h>
+# endif
+
+# ifndef HAVE_SELECT
+#  ifdef HAVE_SYS_POLL_H
+#   include <sys/poll.h>
+#  else
+#   ifdef HAVE_POLL_H
+#    include <poll.h>
+#   endif
+#  endif
+# endif
+
+# ifdef HAVE_TERMIOS_H
+#  include <termios.h>
+# else
+#  include <termio.h>
+# endif
+
+/* sun's sys/ioctl.h redefines symbols from termio world */
+# if defined(HAVE_SYS_IOCTL_H) && !defined(sun)
+#  include <sys/ioctl.h>
+# endif
+
+# define SCROLLOFF	6	/* min lines around frame highlite */
+# define MAXMEM		64L	/* 'maxmem' option */
+
+/* Not allowed after ^O in INS REP mode or from the input-line window */
+# define NOT_ALLOWED_MODE (restart_edit != 0 || cmdwin_type != 0)
+
+/* storage for mtrace hooks */
+# if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+__ptr_t (*s_malloc) (size_t, const void *);
+void (*s_free) (void *, const void *);
+__ptr_t (*s_realloc) (void *, size_t, const void *);
+# endif	/* GDB_MTRACE */
+
+static int module_state = -1;	/* initial state (not OK, nor FAIL) */
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+static char_u *inputrc;		/* readline inputrc file name */
+# endif
+
+/* The gdb keyword */
+typedef struct
+{
+    int type;
+    char_u *keyword;	/* keyword */
+    char_u *tail;	/* optional tail */
+    regprog_T *regprog;	/* compiled regexp */
+} token_T;
+
+static token_T tokens[] = {
+    {CMD_DIR,	    (char_u *)"dir",	(char_u *)"ectory",	NULL},
+    {CMD_DETACH,    (char_u *)"det",	(char_u *)"ach",	NULL},
+    {CMD_SHELL,	    (char_u *)"she",	(char_u *)"ll",		NULL},
+    {CMD_STEPI,	    (char_u *)"si",	(char_u *)"",		NULL},
+    {CMD_STEPI,	    (char_u *)"stepi",	(char_u *)"",		NULL},
+    {CMD_STEPI,	    (char_u *)"ni",	(char_u *)"",		NULL},
+    {CMD_STEPI,	    (char_u *)"nexti",	(char_u *)"",		NULL},
+    {CMD_EXECF,	    (char_u *)"fil",	(char_u *)"e",		NULL},
+    {CMD_EXECF,	    (char_u *)"ex",	(char_u *)"ec-file",	NULL},
+    {CMD_EXECF,	    (char_u *)"cor",	(char_u *)"e-file",	NULL},
+    {CMD_BREAK,	    (char_u *)"b",	(char_u *)"reak",	NULL},
+    {CMD_BREAK,	    (char_u *)"tb",	(char_u *)"reak",	NULL},
+    {CMD_BREAK,	    (char_u *)"hb",	(char_u *)"reak",	NULL},
+    {CMD_BREAK,	    (char_u *)"thb",	(char_u *)"reak",	NULL},
+    {CMD_DISPLAY,   (char_u *)"disp",	(char_u *)"lay",	NULL},
+    {CMD_CREATEVAR, (char_u *)"cr",	(char_u *)"eatevar",	NULL},
+    {CMD_UP_SILENT, (char_u *)"up-",	(char_u *)"silently",	NULL},
+    {CMD_UP,	    (char_u *)"up",	(char_u *)"",		NULL},
+    {CMD_DOWN_SILENT,(char_u *)"down-",	(char_u *)"silently",	NULL},
+    {CMD_DOWN,	    (char_u *)"do",	(char_u *)"wn",		NULL},
+    {CMD_FRAME,	    (char_u *)"f",	(char_u *)"rame",	NULL},
+    {CMD_DISABLE,   (char_u *)"disab",	(char_u *)"le",		NULL},
+    {CMD_DELETE,    (char_u *)"del",	(char_u *)"ete",	NULL},
+    {CMD_SLECT_FRAME,(char_u *)"sel",	(char_u *)"ect-frame",	NULL},
+    {CMD_SYMF,	    (char_u *)"sy",	(char_u *)"mbol-file",	NULL},
+    {CMD_SYMF,	    (char_u *)"add-sy",	(char_u *)"mbol-file",	NULL},
+    {CMD_ANY,	    NULL,	NULL,		NULL}
+};
+
+/* The gdb pattern */
+typedef struct {
+    int id;		/* pattern id */
+    char_u *str;	/* string pattern */
+    regprog_T *regprog;	/* compiled regexp */
+} pattern_T;
+
+static pattern_T patterns[] = {
+    {PAT_DIR,		(char_u *)"^\\s*Source directories searched:\\s*\\(.*\\)$", NULL},
+    {PAT_CHG_ANNO,	(char_u *)"^\\s*set\\s\\+an\\%[notate]\\s\\+.*$", NULL},
+    {PAT_ADD,		(char_u *)"^0x0*\\(\\x\\+\\)\\>", NULL},
+    {PAT_PID,		(char_u *)"^\\s*at\\%[tach] \\+\\([0-9]\\+\\) *$", NULL},
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    {PAT_SOURCE,	(char_u *)"^\\s*\\([^:]*\\):\\([^:]*\\):[^:]*:[^:]*:0x0*\\(\\x\\+\\)$", NULL},
+    {PAT_QUERY,		(char_u *)"^.*(y or n) \\=$", NULL},
+    {PAT_YES,		(char_u *)"^\\s*\\(\\<y\\%[es]\\>\\)\\s*$", NULL},
+    {PAT_SFILE,		(char_u *)"^Symbols from\\s*\"\\([^\"]\\+\\)", NULL},
+    {PAT_BP_CONT,	(char_u *)"^\\s*\\(c\\)\\>\\|^\\s*\\(cont\\)\\%[inue]\\>", NULL},
+    {PAT_ASM_FUNC,	(char_u *)"^\\(\\S\\{-1,}\\)\\%((.*)\\)* .*in section .text$", NULL},
+    {PAT_ASM_FUNC_P,	(char_u *)"^.*<\\(\\S\\{-1,}\\)\\%(+\\d\\+\\)*>$", NULL},
+    {PAT_FRAME,		(char_u *)"^#\\d\\+\\s\\+0x0*\\(\\x\\+\\)\\>", NULL},
+# endif
+# ifdef GDB_LVL2_SUPPORT
+    /* MUST add '.*' at end of each info (possibly last) breakpoint field
+     * pattern because GDB adds the hit count, in a new line, after
+     * printing the last field and within its annotation context */
+    {PAT_BP_ASM,	(char_u *)"^<\\(\\S\\+\\)+\\d\\+>.*$\\|^<\\(\\S\\+\\)>.*$", NULL},
+    {PAT_BP_SOURCE,	(char_u *)"^.\\{-}\\(\\S\\+\\):\\(\\d\\+\\).*$", NULL},
+    {PAT_DISPLAY,	(char_u *)"^\\s*disp\\%[lay]\\s*$", NULL},
+    {PAT_DISPINFO,	(char_u *)"^\\(\\d\\+\\):", NULL},
+    {PAT_CREATEVAR,	(char_u *)"^\\s*cr\\%[eatevar]\\>\\s*\\(.*\\)$", NULL},
+# endif
+# ifdef GDB_LVL3_SUPPORT
+    {PAT_CRVAR_FMT,	(char_u *)"^\\s*cr\\%[eatevar]\\>\\s*\\(/[tdxo]\\)\\{,1}\\>\\s*\\(.*\\)$", NULL},
+    {PAT_INFO_FRAME,	(char_u *)"^Stack level \\(\\d\\+\\), frame at ", NULL},
+# endif
+    {0,			NULL, NULL}
+};
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+/* gdb readline inputrc file content */
+static char *readline[] = {
+    "set show-all-if-ambiguous on\n",
+	"set completion-query-items 20\n",	/* max without prompting user */
+	"Control-u: unix-line-discard\n",
+	NULL
+};
+# endif
+
+/* Gdb process mgmt */
+# define GDB_STATE(i,s) (((i) != NULL) ? ((((gdb_T *)(i))->state) & (s)):FALSE)
+static void gdb_abort __ARGS((void));
+static int start_gdb_process __ARGS((gdb_T *, char_u *));
+static int module_init __ARGS((void));
+static void module_end __ARGS((void));
+static void clear_gdb_T __ARGS((gdb_T *));
+static int exec_gdb __ARGS((gdb_T *));
+
+/* Window and buffer mgmt */
+static win_T *ftowin __ARGS((char_u *));
+static buf_T *buffer_create __ARGS((char_u *, int, int, int, char_u *));
+static void cursor_atbot __ARGS((gdb_T *));
+static int line_append __ARGS((gdb_T *, char_u *));
+
+/* Utilities */
+static void histdel __ARGS((char_u *));
+
+/** Create gdb, return its handle */
+    gdb_handle_T *
+gdb_new()
+{
+    gdb_T *gdb;
+
+# if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+    mtrace();
+    mv_hooks;
+#endif
+    /* register an abort function for when allocating memory fails */
+    xatabort(gdb_abort);
+    obstack_alloc_failed_handler = gdb_abort;
+
+    gdb = (gdb_T *)xcalloc((unsigned)sizeof(gdb_T));
+    gdb->state = GS_INIT;
+    gdb->pid   = (pid_t)-1;
+
+    return (gdb_handle_T *)gdb;
+}
+
+/** Abort GDB */
+    static void
+gdb_abort()
+{
+#if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+    muntrace();
+#endif
+    fprintf(stderr, "\nvirtual memory exhausted\n");
+    mch_exit(1);
+}
+
+/** Delete gdb */
+    void
+gdb_delete(pgdb)
+    gdb_handle_T **pgdb;
+{
+    gdb_T *this;
+
+    if (pgdb == NULL || (this = (gdb_T *)*pgdb) == NULL)
+	return;
+
+    if (this->buf != NULL)	/* wipe out the buffer */
+	(void)do_bufdel(DOBUF_WIPE, (char_u *)"", 1, 0, this->buf->b_fnum, TRUE);
+
+    gdb_close(this);
+    module_end();		/* release module resources */
+    clear_gdb_T(this);
+    xfree(this);
+    *pgdb = NULL;
+# if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+    muntrace();
+# endif
+}
+
+/** Return TRUE when gdb is running */
+    int
+gdb_isrunning(gdb)
+    gdb_handle_T *gdb;
+{
+    return GDB_STATE(gdb, GS_UP);
+}
+
+/** Return gdb pty file descriptor */
+    int
+gdb_fd(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? ((gdb_T *)gdb)->fd : -1);
+}
+
+/** Return gdb process id */
+    pid_t
+gdb_pid(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? ((gdb_T *)gdb)->pid : (pid_t)-1);
+}
+
+/** Return TRUE when buf is the gdb buffer */
+    int
+gdb_isbuffer(gdb, buf)
+    gdb_handle_T *gdb;
+    buf_T *buf;		/* buffer to check for */
+{
+    return ((gdb != NULL && ((gdb_T *)gdb)->buf != NULL)
+	    ? ((gdb_T *)gdb)->buf == buf : FALSE);
+}
+
+/** Return TRUE when gdb output may be processed from low level functions */
+    int
+gdb_allowed(gdb)
+    gdb_handle_T *gdb;
+{
+    return (GDB_STATE(gdb, GS_UP) && GDB_STATE(gdb, GS_ALLOWED));
+}
+
+/** Return TRUE when a gdb event is pending */
+    int
+gdb_event(gdb)
+    gdb_handle_T *gdb;
+{
+    return GDB_STATE(gdb, GS_EVENT);
+}
+
+/** Return TRUE when there is a pending SIGCHLD */
+    int
+gdb_sigchld(gdb)
+    gdb_handle_T *gdb;
+{
+    return GDB_STATE(gdb, GS_SIGCHLD);
+}
+
+/** Set or unset a gdb event */
+    void
+gdb_set_event (gdb, set)
+    gdb_handle_T *gdb;
+    int set;		/* TRUE when setting event */
+{
+    if (gdb == NULL)
+	return;
+
+    ((gdb_T *)gdb)->state &= ~GS_EVENT;
+    if (set)
+	((gdb_T *)gdb)->state |= GS_EVENT;
+}
+
+/** Set or unset a SIGCHLD event */
+    void
+gdb_set_sigchld (gdb, set)
+    gdb_handle_T *gdb;
+    int set;		/* TRUE when setting SIGCHLD event */
+{
+    if (gdb == NULL)
+	return;
+
+    ((gdb_T *)gdb)->state &= ~GS_SIGCHLD;
+    if (set)
+	((gdb_T *)gdb)->state |= GS_SIGCHLD;
+}
+
+/**
+ * Entry point for safe_vgetc().
+ * Set a flag to prevent recursion and enable gdb to read its pseudo tty
+ * in the low level routines.
+ * Return safe_vgetc return value.
+ */
+    int
+gdb_safe_vgetc(gdb)
+    gdb_handle_T *gdb;
+{
+    gdb_T *this = (gdb_T *)gdb;
+    int s_a;
+    int rc;
+
+    if (this == NULL)
+	return safe_vgetc();
+
+    s_a = (this->state & GS_ALLOWED);
+
+    /* set state GS_ALLOWED TRUE when called from top level,
+     * not in visual mode and not in the input-line window */
+    if (this->recurse == 0 && cmdwin_type == 0 && !VIsual_active)
+    {
+	this->state |= GS_ALLOWED;
+	s_a = FALSE;
+    }
+    else
+	this->state &= ~GS_ALLOWED;
+
+    this->recurse++;
+    rc = safe_vgetc();	/* call it now */
+    this->recurse--;
+
+    this->state &= ~GS_ALLOWED;
+    if (s_a)
+	this->state |= GS_ALLOWED;
+    return rc;
+}
+
+/** Take note Vim is freeing a buffer */
+    void
+gdb_buffer_free(gdb, buf)
+    gdb_handle_T *gdb;
+    buf_T *buf;		/* buffer being freed */
+{
+    gdb_T *this = (gdb_T *)gdb;
+    bpinfo_T *p, **pt;
+    int i;
+
+    if (this != NULL)
+    {
+	if (this->buf == buf)
+	    this->buf = NULL;
+
+	/* variables window buffer */
+	else if (this->var_buf == buf)
+	{
+	    this->var_buf = NULL;
+
+	    /* call mode specifice var_delete */
+	    if (this->var_delete != NULL)
+		this->var_delete(this);	/* delete all variables */
+	}
+
+	/* asm buffers */
+	else
+	    for (i = 0; i < this->pool.max; i++)
+		if (this->pool.buf[i] == buf)
+		{
+		    this->pool.buf[i] = NULL;
+		    break;
+		}
+
+	/* remove in bpinfo list the records corresponding to the
+	 * signs in buf
+	 * the signs themselves are supposed to be removed by Vim
+	 * in free_buffer()*/
+	for (pt = &(this->bpinfo); *pt != NULL; )
+	{
+	    p = *pt;
+	    if (p->buf == buf)
+	    {
+		gdb_undefine_sign(p->typenr);
+		*pt = p->next;		/* unlink record */
+		xfree(p);
+	    }
+	    else
+		pt = &(p->next);
+	}
+    }
+}
+
+# define STL_GDB  "gdb "
+# define STL_SEP1 "- "
+# define STL_SEP2 " ["
+# define STL_TAIL "]"
+/** Write gdb status line label in dst */
+    void
+gdb_label(gdb, buf, dst, len)
+    gdb_handle_T *gdb;
+    buf_T *buf;		/* stl's buffer */
+    char_u *dst;	/* where to write the label */
+    size_t len;		/* label max length */
+{
+    gdb_T *this = (gdb_T *)gdb;
+    size_t cnt = 0;
+    char_u *fname;
+    size_t l;
+# define STLCPY(s) {\
+	l = (((s)!=NULL) ? STRLEN((s)):0);\
+	l = MIN(l,len-cnt-1);	\
+	STRNCPY(dst+cnt,(s),l);	\
+	cnt+=l;			\
+	}
+
+    /* a console window displaying gdb buffer */
+    if (this != NULL && this->buf == buf && (this->state & GS_UP)
+	    && dst != NULL && len > 0)
+    {
+	STLCPY(STL_GDB);
+	if (this->sfile != NULL)
+	{
+	    STLCPY(STL_SEP1);
+	    fname = gettail(this->sfile);
+	    STLCPY(fname);
+	}
+
+	STLCPY(STL_SEP2);
+	STLCPY(this->status);
+	STLCPY(STL_TAIL);
+	*(dst + cnt) = NUL;
+    }
+}
+
+/** Send a cmd to gdb */
+    void
+gdb_docmd(gdb, cmd)
+    gdb_handle_T *gdb;
+    char_u  *cmd;	/* gdb cmd */
+{
+    gdb_T *this = (gdb_T *)gdb;
+
+    if (this == NULL || NOT_ALLOWED_MODE)
+	return;
+
+    /* start gdb */
+    this->state &= ~GS_STARTED;
+    if (!(this->state & GS_UP) && start_gdb_process(this, cmd) == FAIL)
+	return;
+
+    /* process first cmd later */
+    if (this->state & GS_STARTED)
+	return;
+
+    /* pop up gdb console */
+    gdb_popup_console(this);
+
+    /* The next statement has the following purpose:
+     * When stepping by hitting continuously key 'I', the discarded command
+     * give_warning (see few lines below) may be permanently displayed losing
+     * thus all meaning: better to clear the cmd line before possibly
+     * outputing the msg. */
+    msg_clr_cmdline();
+
+    /* accept one cmd at a time, allow intr */
+    if (cmd != NULL && *cmd != NUL && *(cmd + STRLEN(cmd) - 1) == KEY_INTERUPT)
+	this->oob.state |= OS_INTR;
+    else if (this->oob.state & OS_CMD)
+    {
+	give_warning((char_u *)"GDB busy: command discarded, please retry", TRUE);
+	return;
+    }
+    else
+	this->oob.idx = -1;	/* needed when last oob was aborted with OS_QUITs */
+    this->oob.state |= OS_CMD;
+
+    /* call mode specific docmd */
+    if (this->gdb_docmd != NULL)
+	this->gdb_docmd(this, cmd);
+}
+
+/** Set the cmd to be inserted later in the input-line window */
+    void
+gdb_setwinput(gdb, cmd)
+    gdb_handle_T *gdb;
+    char_u *cmd;	/* cmd to insert */
+{
+    gdb_T *this = (gdb_T *)gdb;
+
+    if (this == NULL || NOT_ALLOWED_MODE)
+	return;
+
+    if (cmd == NULL)
+	cmd = (char_u *)"";
+
+    if (STRCHR(cmd, (int)NL) != NULL)	/* assert no NL in cmd */
+	return;
+
+    xfree(this->winput_cmd);
+    this->winput_cmd = vim_strsave_escaped(cmd, (char_u *)"\"");
+}
+
+/** Return TRUE if we are opening the gdb input-line window */
+    int
+gdb_iswinput(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? ((gdb_T *)gdb)->winput_cmd != NULL : FALSE);
+}
+
+/** Launch the input-line window */
+    void
+gdb_winput(gdb)
+    gdb_handle_T *gdb;
+{
+    gdb_T *this = (gdb_T *)gdb;
+    int s_silent = cmd_silent;
+    char_u *cedit = NULL;
+    char_u *cmd = NULL;
+    char_u *res = NULL;
+    char_u key[2] = {NUL, NUL};
+    char_u *trim;
+    char_u *p;
+    char_u *q = NULL;		/* initialized to please the compiler */
+    char_u *r;
+
+    if (this == NULL || NOT_ALLOWED_MODE)
+	return;
+
+    if (this->winput_cmd == NULL || !stuff_empty() || typebuf.tb_len != 0)
+	goto fin;
+
+    /* pop up gdb console */
+    if (this->state & GS_UP)
+	gdb_popup_console(this);
+
+    /* insert in typebuf: <C-F> . "a" . winput_cmd */
+    /* 'a' start insert mode */
+    p = NULL;
+    key[0] = Ctrl_F;
+    gdb_cat(&p, key);
+    gdb_cat(&p, (char_u *)"a");
+    gdb_cat(&p, this->winput_cmd);
+
+    if (ins_typebuf(p, REMAP_NONE, 0, TRUE, TRUE) == FAIL)
+    {
+	xfree(p);
+	goto fin;
+    }
+    xfree(p);
+
+    /* set cedit */
+    (void)get_option_value((char_u *)"cedit", NULL, &cedit, OPT_GLOBAL);
+    set_option_value((char_u *)"cedit", 0L, key, OPT_GLOBAL);
+
+    /* Launch the input-line window */
+    /* careful: must free cmd with vim_free */
+    cmd_silent = FALSE;
+    cmd = getcmdline_prompt((int)'@', NULL, 0, EXPAND_NOTHING, NULL);
+    cmd_silent = s_silent;
+    msg_didout = FALSE;
+
+    /* restore cedit */
+    if (cedit != NULL)
+    {
+	set_option_value((char_u *)"cedit", 0L, cedit, OPT_GLOBAL);
+	xfree(cedit);
+    }
+    cursor_atbot(this);
+
+    /* Do not start gdb when interrupt */
+    if (!(this->state & GS_UP)
+	    && (cmd == NULL || STRCHR(cmd, KEY_INTERUPT) != NULL))
+    {
+	histdel(cmd);
+	goto fin;
+    }
+
+    /* User typed ^C^C: send an interrupt */
+    if (cmd == NULL)
+    {
+	key[0] = KEY_INTERUPT;
+	gdb_docmd(gdb, key);
+    }
+    else	/* Cleanup history */
+    {
+	/* p first word, q first white after last word */
+	trim = (char_u *)clewn_strsave((char *)cmd);
+	r = p = skipwhite(trim);
+	do {
+	    q = skiptowhite(r);
+	    r = skipwhite(q);
+	} while (*r != NUL);
+
+	if ((res = STRCHR(cmd, '\t')) != NULL)
+	{
+	    histdel(cmd);
+	    *(res + 1) = NUL;	/* trim after <Tab> */
+	}
+	else if ((res = STRCHR(cmd, KEY_INTERUPT)) != NULL)
+	{
+	    histdel(cmd);
+	    *(res + 1) = NUL;	/* trim after ^Z */
+	}
+	/* trim surrounding spaces for syntax highliting */
+	else if (trim != NULL && (p != trim || *q != NUL))
+	{
+	    histdel(cmd);
+	    if (*q != NUL)
+		*q = NUL;
+	    if (*p != NUL)
+		add_to_history(HIST_INPUT, p, FALSE, NUL);
+	}
+	xfree(trim);
+
+	FREE(this->winput_cmd);
+
+	/* send cmd */
+	gdb_docmd(gdb, cmd);
+
+	vim_free(cmd);
+	return;
+    }
+fin:
+    vim_free(cmd);
+    FREE(this->winput_cmd);
+}
+
+/**
+ * Invoke parse_output and compute time left to wait for a character in
+ * the caller, mch_inchar.
+ * Return time left or -1 when mch_inchar must trigger the input-line window.
+ */
+    long
+gdb_process_output(gdb, wtime, start)
+    gdb_handle_T *gdb;
+    long wtime;		/* time left */
+    void *start;	/* start time in mch_inchar */
+{
+    gdb_T *this = (gdb_T *)gdb;
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+    struct timeval  * pstart = (struct timeval *)start;
+    struct timeval  tv;
+# endif
+    int rc;
+
+    if (this != NULL && (this->state & GS_ALLOWED))
+    {
+	if (this->parse_output == NULL)
+	    return (wtime > 0 ? wtime : 0L);
+
+	/* call mode specific parser */
+	this->state &= ~GS_ALLOWED;	/* prevent recursion */
+	rc = this->parse_output(this);
+	this->state |= GS_ALLOWED;
+
+	this->state &= ~GS_EVENT;
+
+	if (rc)
+	    return -1L;
+
+	if (wtime > 0)
+	{
+# if defined(HAVE_GETTIMEOFDAY) && defined(HAVE_SYS_TIME_H)
+	    /* compute new remaining time */
+	    if (pstart != NULL)
+	    {
+		gettimeofday(&tv, NULL);
+		wtime -= (tv.tv_sec - pstart->tv_sec) * 1000L
+				+ (tv.tv_usec - pstart->tv_usec) / 1000L;
+		pstart->tv_sec = tv.tv_sec;	/* reset start time */
+		pstart->tv_usec = tv.tv_usec;
+	    }
+	    else
+# endif
+	    {
+		/* estimated gdb processing is 10 msecs */
+		wtime -= 10L;
+	    }
+	}
+    }
+    return (wtime > 0 ? wtime : 0L);
+}
+
+/* Start a gdb process; return OK when succcess, FAIL otherwise */
+    static int
+start_gdb_process(this, cmd)
+    gdb_T *this;
+    char_u *cmd;	/* the first gdb cmd */
+{
+    char_u *res = NULL;
+    char_u *p;
+    int i;
+
+    clear_gdb_T(this);
+
+    if (module_init() == OK && exec_gdb(this) == OK)
+    {
+	/* save first non empty cmd */
+	if (cmd != NULL)
+	{
+	    p = skipwhite(cmd);
+	    if (*p != NUL)
+		this->firstcmd = (char_u *)clewn_strsave((char *)cmd);
+	}
+
+	/* create variables window buffer */
+	if (p_gvar != NULL && *p_gvar != NUL)
+	    this->var_buf = buffer_create(p_gvar, TRUE, TRUE, TRUE, (char_u *)"gdbvar");
+
+	/* create pool of asm buffers */
+	this->pool.max = MIN(ABS(p_asm), ASM_MAX_BUFF);
+	this->pool.idx = 0;
+	for (i = 0; i < this->pool.max; i++)
+	{
+	    gdb_cat(&res, (char_u *)ASM_BUF_NAME);
+	    gdb_cat(&res, gdb_itoa(i + 1));
+
+	    this->pool.buf[i] = buffer_create(res, FALSE, FALSE, FALSE, NULL);
+	    this->pool.age[i] = ASM_OLD;
+	    FREE(res);
+	}
+	this->pool.last = i + 1;
+	cursor_atbot(this);
+
+	this->directories = (char_u *)clewn_strsave(",,");  /* path: current directory */
+	return OK;
+    }
+    return FAIL;
+}
+
+/*
+ * Initialize this module: set inputrc file, define signs, compile regexp.
+ * Return OK when succcess, FAIL otherwise.
+ */
+    static int
+module_init()
+{
+    char_u *s_cpo = p_cpo;
+    pattern_T *pat;
+    token_T *tok;
+    exarg_T eap;
+    char_u *pattern;
+    int len;
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    char **p;
+    int fd;
+# endif
+
+    if (module_state == -1)
+    {
+	module_state = FAIL;	/* do it only once */
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	/* Set gdb readline inputrc file contents
+	 * careful: must free inputrc with vim_free
+	 * We don't know yet if we are going to use GDB/MI, so we need to
+	 * setup inputrc just in case, even though it might never be used */
+	if ((inputrc = vim_tempname((int)'A')) != NULL
+		&& (fd = mch_open((char *)inputrc, O_CREAT | O_RDWR | O_EXTRA, 0644)) >= 0)
+	{
+	    for (p = readline; *p; p++)
+		write(fd, *p, strlen(*p));
+	    close(fd);
+	    vim_setenv((char_u *)"INPUTRC", inputrc);
+	}
+# endif
+
+	/* define breakpoint and frame signs */
+	do_highlight((char_u *)"gdb_bp term=bold ctermbg=Blue ctermfg=Black guibg=Blue guifg=Black", 0, 0);
+	do_highlight((char_u *)"gdb_dbp term=bold ctermbg=Green ctermfg=Black guibg=Green guifg=Black", 0, 0);
+	do_highlight((char_u *)"gdb_fr term=bold ctermbg=DarkYellow ctermfg=Black guibg=DarkYellow guifg=Black", 0, 0);
+
+	/* We use for frame and phantom sign type numbers the same
+	 * value as their sign numbers. They are respectively FRAME_SIGN
+	 * and PHANTOM_SIGN */
+	eap.arg = (char_u *)clewn_strsave(
+		"define 1 linehl=gdb_fr text==> texthl=Search");
+	ex_sign(&eap);
+	xfree(eap.arg);
+
+	eap.arg = (char_u *)clewn_strsave(
+		"define 2 linehl=Normal text=.. texthl=NonText");
+	ex_sign(&eap);
+	xfree(eap.arg);
+
+	/* make sure no sign in use */
+	buf_delete_all_signs();
+
+	/* Compile patterns */
+	p_cpo = (char_u *)"";   /* so that 'l' flag doesn't work */
+	for (pat = patterns; pat->str != NULL; pat++)
+	    if ((pat->regprog = vim_regcomp(pat->str, TRUE)) == NULL)
+		goto fin;
+
+	/* Compile tokens */
+	for (tok = tokens; tok->keyword != NULL; tok++)
+	{
+	    len = (tok->tail != NULL ? STRLEN(tok->tail) : 0);
+
+	    /* pattern: '^\s*\(\<token\%[option]\>\).*$' */
+	    pattern = NULL;
+	    gdb_cat(&pattern, (char_u *)"^\\s*\\(\\<");
+	    gdb_cat(&pattern, tok->keyword);
+
+	    if (len != 0)
+	    {
+		gdb_cat(&pattern, (char_u *)"\\%[");
+		gdb_cat(&pattern, tok->tail);
+		gdb_cat(&pattern, (char_u *)"]");
+	    }
+
+	    gdb_cat(&pattern, (char_u *)"\\>\\).*$");
+
+	    if ((tok->regprog = vim_regcomp(pattern, TRUE)) == NULL)
+	    {
+		xfree(pattern);
+		goto fin;
+	    }
+	    xfree(pattern);
+	}
+
+	module_state = OK;
+    }
+fin:
+    p_cpo = s_cpo;
+    return module_state;
+}
+
+/* Release module resources */
+    static void
+module_end()
+{
+    pattern_T *pat;
+    token_T *tok;
+    exarg_T eap;
+
+    module_state = -1;
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+    if (inputrc != NULL)
+    {
+	mch_remove(inputrc);
+	vim_free(inputrc);
+	inputrc = NULL;
+    }
+# endif
+
+    /* remove signs */
+    do_highlight((char_u *)"clear gdb_bp", 0, 0);
+    do_highlight((char_u *)"clear gdb_dbp", 0, 0);
+    do_highlight((char_u *)"clear gdb_fr", 0, 0);
+
+    /* make sure no sign in use */
+    buf_delete_all_signs();
+
+    emsg_skip++;
+    eap.arg = (char_u *)clewn_strsave("undefine 1");
+    ex_sign(&eap);
+    xfree(eap.arg);
+
+    eap.arg = (char_u *)clewn_strsave("undefine 2");
+    ex_sign(&eap);
+    xfree(eap.arg);
+    emsg_skip--;
+
+    /* patterns an tokens */
+    for (pat = patterns; pat->str != NULL; pat++)
+	if (pat->regprog != NULL)
+	    FREE(pat->regprog);
+
+    for (tok = tokens; tok->keyword != NULL; tok++)
+	if (tok->regprog != NULL)
+	    FREE(tok->regprog);
+}
+
+/* Initialize a gdb_T structure */
+    static void
+clear_gdb_T(this)
+    gdb_T *this;
+{
+    if (this != NULL)
+    {
+	this->pid = (pid_t)-1;
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->height = 0;
+#endif
+	this->state = GS_INIT;
+	FREE(this->status);
+	this->recurse = 0;
+
+	this->cmd_type = CMD_ANY;
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->cli_cmd.state = CS_START;
+	this->cli_cmd.cnt = 0;
+	FREE(this->cli_cmd.gdb);
+	FREE(this->cli_cmd.readline);
+	FREE(this->cli_cmd.echoed);
+#endif
+
+	FREE(this->firstcmd);
+	FREE(this->winput_cmd);
+	FREE(this->directories);
+	FREE(this->sfile);
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->note = ANO_NONE;
+	this->annoted = FALSE;
+	this->newline = FALSE;
+	FREE(this->annotation);
+#endif
+	FREE(this->line);
+	FREE(this->pc);
+	FREE(this->frame_pc);
+	FREE(this->oob_result);
+	FREE(this->asm_add);
+	FREE(this->asm_func);
+
+#if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	this->bp_state = 0;
+	gdb_free_bplist(&(this->tmplist));
+#endif
+	FREE(this->record);
+	this->cont = FALSE;
+	gdb_free_bplist(&(this->bpinfo));
+	this->frame_curlvl = -1;
+	this->frame_lnum = (linenr_T) -1;
+	FREE(this->frame_fname);
+
+
+	this->fr_buf = NULL;
+
+	this->oob.state = 0;
+	this->oob.idx = -1;
+
+	this->pool.hilite = FALSE;
+
+	/* free mode specific data within gdb_T */
+	if (this->clear_gdb_T != NULL)
+	    this->clear_gdb_T(this);
+
+	this->oobfunc = NULL;
+	this->parse_output = NULL;
+	this->gdb_docmd = NULL;
+	this->var_delete = NULL;
+	this->clear_gdb_T = NULL;
+    }
+}
+
+/* Spawn a gdb process; return OK when sucess, FAIL otherwise */
+    static int
+exec_gdb(this)
+    gdb_T *this;
+{
+    char_u *err = NULL;
+    int fd = -1;	/* slave pty file descriptor */
+    char *tty;		/* pty name */
+    buf_T *buf;
+# ifdef HAVE_TERMIOS_H
+    struct termios tio;
+# else
+    struct termio tio;
+# endif
+
+    /* process already running */
+    if (this->pid != (pid_t)-1 && waitpid(this->pid, NULL, WNOHANG) == 0)
+	return OK;
+
+    /* Open pty */
+    if ((this->fd = OpenPTY(&tty)) < 0
+	    || (fd = open(tty, O_RDWR|O_NOCTTY|O_EXTRA, 0)) < 0
+	    || SetupSlavePTY(fd) == -1)
+    {
+	err = (char_u *)"Cannot open gdb pty";
+	goto err;
+    }
+
+    /* Set terminal attributes */
+# ifdef HAVE_TERMIOS_H
+    if (tcgetattr(fd, &tio) == 0)
+# else
+    if (ioctl(fd, TCGETA, &tio) >= 0)
+# endif
+    {
+	tio.c_oflag &= ~ONLCR;		/* don't map NL to CR-NL on output */
+	tio.c_cc[VINTR] = KEY_INTERUPT;
+# ifdef HAVE_TERMIOS_H
+	if (tcsetattr(fd, TCSAFLUSH, &tio) != 0)
+# else
+	if (ioctl(fd, TCSETA, &tio) < 0)
+# endif
+	{
+	    err = (char_u *)"Cannot set gdb pty";
+	    goto err;
+	}
+    }
+    else
+    {
+	err = (char_u *)"Cannot get gdb pty";
+	goto err;
+    }
+
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+#  if defined(TIOCGWINSZ) && defined(TIOCSWINSZ)
+	{
+	    struct winsize win;
+
+	    /* set tty height */
+	    if (ioctl(fd, TIOCGWINSZ, &win) >= 0)
+	    {
+		win.ws_row = LPP_LINES;
+		if (ioctl(fd, TIOCSWINSZ, &win) >= 0)
+		    this->height = LPP_LINES;
+	    }
+	}
+#  endif
+# endif
+
+    /* Fork */
+    if ((this->pid = fork()) == (pid_t)-1)
+    {
+	err = (char_u *)"Cannot fork gdb";
+	goto err;
+    }
+/* The child */
+    else if (this->pid == (pid_t)0)
+    {
+	/* Grab control of terminal (from `The GNU C Library' (glibc-2.3.1)) */
+	setsid();
+# ifdef TIOCSCTTY
+	if (ioctl(fd, TIOCSCTTY, (char *)NULL) == -1)
+	    _exit(1);
+# else
+	{ int newfd;
+	char *fdname = ttyname(fd);
+
+	/* This might work (it does on Linux) */
+	if (fdname)
+	{
+	    if (fd != 0)
+		close (0);
+	    if (fd != 1)
+		close (1);
+	    if (fd != 2)
+		close (2);
+	    newfd = open(fdname, O_RDWR);
+	    close(newfd);
+	}
+	}
+# endif
+
+	close(0); dup(fd);
+	close(1); dup(fd);
+	close(2); dup(fd);
+
+	if (fd > 2)
+	    close(fd);
+
+	close(this->fd);
+
+	/* close all swap files: on Cygwin, Windows fail to unlink the swap
+	 * files while there is still an open file descriptor held by
+	 * another (child) process */
+	for (buf = firstbuf; buf != NULL; buf = buf->b_next)
+	    if (buf->b_ml.ml_mfp != NULL
+		    && buf->b_ml.ml_mfp->mf_fd >= 0)
+		close(buf->b_ml.ml_mfp->mf_fd);
+
+# ifdef GDB_MI_SUPPORT
+	if (p_gdbmi)
+	{
+	    /* MI mi2 is available starting with GDB 6.0 */
+	    execlp(p_gdp, p_gdp, "--interpreter=mi2", NULL);
+	    _exit(EXIT_FAILURE);
+	}
+# endif
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	clewn_exec((char *)p_gdp);
+# endif /* defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT) */
+
+	_exit(EXIT_FAILURE);
+    }
+/* The parent */
+    else
+    {
+	close(fd);
+	this->state |= GS_UP;
+	this->state |= GS_STARTED;
+
+# ifdef GDB_MI_SUPPORT
+	if (p_gdbmi)
+	{
+	    if (gdb_setup_mi(this) != OK)
+	    {
+		gdb_cat(&err, (char_u *)"Cannot start GDB program \"");
+		gdb_cat(&err, p_gdp);
+		gdb_cat(&err, (char_u *)"\" (MI)");
+		if (err != NULL)
+		{
+		    EMSG(_(err));
+		    xfree(err);
+		}
+		this->state = GS_INIT;
+		return FAIL;
+	    }
+	    else
+		return OK;
+	}
+# endif
+# if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+	if (gdb_setup_cli(this) != OK)
+	{
+	    this->state = GS_INIT;
+	    return FAIL;
+	}
+	else
+	    return OK;
+# endif
+
+	this->state = GS_INIT;
+	return FAIL;
+    }
+err:
+    if (this->fd >= 0)
+	close(this->fd);
+    if (fd >= 0)
+	close(fd);
+    if (err != NULL)
+	EMSG(_(err));
+    return FAIL;
+}
+
+# define CG_QUIT "quit\n"
+# define CG_YES  "yes\n"
+# define CG_TERM "Terminated\n\n"
+# define CG_SEP  "####################################\n"
+# define CG_POLL 100
+/* Close gdb process */
+    void
+gdb_close(this)
+    gdb_T *this;
+{
+    pid_t pid;
+    int i;
+    int rc;
+
+    if (this->state & GS_CLOSING)	/* prevent recursive calls */
+	return;
+    this->state |= GS_CLOSING;
+
+    this->syntax = TRUE;		/* force syntax highlite */
+    gdb_write_buf(this, (char_u *)CG_TERM, TRUE);
+    gdb_write_buf(this, (char_u *)CG_SEP, TRUE);
+    this->syntax = FALSE;
+
+    if (this->buf != NULL)
+	close_windows(this->buf, FALSE);
+
+    buf_delete_all_signs();
+
+    /* wipe out variables window buffer */
+    if (this->var_buf != NULL)
+	(void)do_bufdel(DOBUF_WIPE, (char_u *)"", 1, 0, this->var_buf->b_fnum, TRUE);
+
+    /* wipe out asm buffers */
+    for (i = 0; i < this->pool.max; i++)
+	if (this->pool.buf[i] != NULL)
+	    (void)do_bufdel(DOBUF_WIPE, (char_u *)"", 1, 0, this->pool.buf[i]->b_fnum, TRUE);
+
+    /* free breakpoints table */
+    gdb_free_bplist(&(this->bpinfo));
+
+    /*  a) attempt to gracefully terminate gdb process
+     *  b) if this fails, SIGTERM it
+     *  c) if this fails, too bad, just return */
+    if (this->pid != (pid_t)-1)
+    {
+	pid = waitpid(this->pid, NULL, WNOHANG);
+
+	if ((pid == (pid_t)-1 && errno == ECHILD) || pid == this->pid)
+	    close(this->fd);
+	else	/* still running */
+	{
+	    char c     = KEY_INTERUPT;
+	    int killed = FALSE;
+	    char_u buf[MAX_BUFFSIZE];
+	    int t;
+
+	    /* a) write an interrupt followed by a 'quit' cmd */
+	    write(this->fd, &c, 1);
+	    if (gdb_read(this, buf, MAX_BUFFSIZE, 1000) >= 0)
+	    {
+		write(this->fd, CG_QUIT, strlen(CG_QUIT));
+		while ((rc = gdb_read(this, buf, MAX_BUFFSIZE, 100)) > 0)
+		    ;
+
+		if (rc != -1)
+		    write(this->fd, CG_YES, strlen(CG_YES));
+	    }
+	    close(this->fd);
+
+	    /* make sure gdb is terminated: poll for waitpid() */
+	    for (t = 0; !killed; t += CG_POLL)
+	    {
+		/* 1 second elapsed since start of polling for waitpid */
+		if (t >= 1000 )
+		{
+# ifdef SIGTERM
+		    /* b) kill it now */
+		    kill(this->pid, SIGTERM);
+# endif
+		    killed = TRUE;
+		}
+
+		mch_delay(CG_POLL, TRUE);
+		pid = waitpid(this->pid, NULL, WNOHANG);
+		if ((pid == (pid_t)-1 && errno == ECHILD) || pid == this->pid)
+		    break;
+	    }
+	}
+	MSG_ATTR(_("GDB terminated"), hl_attr(HLF_E));
+    }
+
+    gdb_redraw(curbuf);	/* force redrawing */
+    this->state = GS_INIT;
+    this->pid = (pid_t)-1;
+}
+
+/* Highlite asm_add line; return TRUE when asm_add found in asm buffer */
+    int
+gdb_as_frset(this, obs)
+    gdb_T *this;
+    struct obstack *obs;
+{
+    char_u *ptrn = NULL;
+    int first = this->pool.idx;
+    pos_T pos;
+    win_T *win;
+    int i;
+
+    if (this->asm_func == NULL)
+	return FALSE;
+
+    /* age asm buffers */
+    for (i = 0; i < this->pool.max; i++)
+	if (this->pool.age[i] < ASM_OLD)
+	    this->pool.age[i]++;
+
+    if (this->asm_add != NULL)
+    {
+	obstack_strcat(obs, "^\\s*0x0*");
+	obstack_strcat0(obs, this->asm_add);
+	ptrn = (char_u *)obstack_finish(obs);
+    }
+
+    if (ptrn != NULL)
+    {
+	/* Search all asm buffers whose name start with this->asm_func
+	 * for ptrn.
+	 * Start with the current one. */
+	i = first;
+	do
+	{
+	    pos.lnum = 1;
+	    pos.col = 0;
+
+	    if (this->pool.buf[i] != NULL
+		    && STRSTR(this->pool.buf[i]->b_fname, this->asm_func) != NULL
+		    && !(this->pool.buf[i]->b_ml.ml_flags & ML_EMPTY)
+		    && searchit(NULL, this->pool.buf[i], &pos,
+			FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+	    {
+		this->pool.idx = i;
+		this->pool.age[i] = 0;
+		this->pool.lnum = pos.lnum;
+
+		if (this->pool.hilite)
+		    gdb_fr_set(this, NULL, NULL, obs);
+		else if ((win = gdb_btowin(this->pool.buf[i])) != NULL)
+		    gdb_set_cursor(win, pos.lnum);
+
+		FREE(this->asm_add);
+		return TRUE;
+	    }
+	} while ((i = ++i % this->pool.max) != first);
+
+    }
+    return FALSE;
+}
+
+/*
+ * Highlight line within frame
+ * Return -1 when failing to load the buffer, 0 otherwise
+ */
+    int
+gdb_fr_set(this, file, line, obs)
+    gdb_T *this;
+    char_u *file;
+    linenr_T *line;
+    struct obstack *obs;
+{
+    win_T *oldwin = curwin;
+    buf_T *buf = NULL;
+    linenr_T lnum;
+
+    /* Do not set frame hilite when this breakpoint has a 'commands'
+     * with a 'continue' statement */
+    if (this->cont)
+    {
+	this->cont = FALSE;
+	return 0;
+    }
+
+    if (line == NULL)		/* in asm window */
+    {
+	buf = this->pool.buf[this->pool.idx];
+	lnum = this->pool.lnum;
+    }
+    else			/* in source file */
+	lnum = *line;
+
+    if (buf != NULL || file != NULL)
+    {
+	if (gdb_edit_file(this, buf, file, lnum, obs) != NULL)
+	{
+	    /* MUST redraw the screen before calling update_debug_sign():
+	     *	update_debug_sign() invokes win_update()
+	     *	the screen might have been scrolled when Vim ask the
+	     *	user to confirm changes made to the previous buffer */
+	    gdb_redraw(curwin->w_buffer);
+
+	    gdb_fr_lite(this, curwin->w_buffer, lnum, obs);
+	}
+	else {
+	    win_goto(oldwin);
+	    return -1;
+	}
+    }
+    return 0;
+}
+
+/* Highlite frame */
+    void
+gdb_fr_lite(this, buf, lnum, obs)
+    gdb_T *this;
+    buf_T *buf;		/* where to highlite */
+    linenr_T lnum;	/* line number */
+    struct obstack *obs;
+{
+    buf_T *disped = NULL;
+
+    if (obs) {}	    /* keep compiler happy */
+
+    if (buf == NULL || lnum <= 0)
+	return;
+
+    /*
+     * Remove previous frame sign:
+     * GDB sends ANO_FRAME_INVALID annotations whenever stepping, running, etc...
+     * and these annotations invoke gdb_fr_unlite() that turn off the previous frame sign.
+     * But when moving along the stack frame with GDB 'up', 'down', 'frame' commands,
+     * we don't get annotations and must turn off the previous frame sign.
+     */
+    if (this->fr_buf != NULL)
+	disped = gdb_unlite(FRAME_SIGN);
+
+    /* add new frame highlite */
+    buf_addsign(buf, FRAME_SIGN, lnum, FRAME_SIGN);
+    update_debug_sign(buf, lnum);
+
+    /* remove phantom highlite */
+    disped = gdb_unlite(PHANTOM_SIGN);
+
+    this->fr_buf = buf;
+    if (gdb_btowin(buf) != NULL)
+	disped = buf;
+
+    gdb_redraw(disped);	/* only when displayed */
+}
+
+/* Unlite frame */
+    void
+gdb_fr_unlite(this)
+    gdb_T *this;
+{
+    buf_T *disped = NULL;
+    buf_T *buf = this->fr_buf;
+    linenr_T lnum;
+
+    if (buf == NULL)
+	return;
+    this->fr_buf = NULL;
+
+    /* To avoid screen blinks: replace with phantom sign */
+    if (gdb_btowin(buf) != NULL && (lnum = BUFLASTL(buf)) > 0)
+    {
+	buf_addsign(buf, PHANTOM_SIGN, lnum, PHANTOM_SIGN);
+	update_debug_sign(buf, lnum);
+    }
+
+    disped = gdb_unlite(FRAME_SIGN);
+    gdb_redraw(disped);	/* only when displayed */
+}
+
+/*
+ * Unlite a sign.
+ * Return last displayed buffer that contained this sign.
+ */
+    buf_T *
+gdb_unlite(id)
+    int id;		/* sign id */
+{
+    buf_T *disped = NULL;
+    buf_T *buf;
+    linenr_T lnum;
+
+    for (buf = firstbuf; buf != NULL; buf = buf->b_next)
+	if ((lnum = buf_delsign(buf, id)) != 0)
+	{
+	    update_debug_sign(buf, lnum);
+	    if (gdb_btowin(buf) != NULL)
+		disped = buf;
+	}
+    return disped;
+}
+
+/*
+ * Define a breakpoint sign. There is one sign type per breakpoint
+ * sign in order to have breakpoints numbers as the sign text.
+ * Returns sign type number or -1 if error.
+ */
+    int
+gdb_define_sign(id, enabled)
+    int id;		/* breakpoint number */
+    int enabled;	/* TRUE when breakpoint is enabled */
+{
+    exarg_T eap;
+    char_u text[NUMBUFLEN];
+    int r;
+
+    if (id <= 0)
+	return -1;
+
+    /* the sign text is two chars max */
+    if (id < 100)
+	STRCPY(text, gdb_itoa(id));
+    else
+    {
+	if ((r = id % 100) < 10)
+	{
+	    text[0] = '0';
+	    STRCPY(text + 1, gdb_itoa(r));
+	}
+	else
+	    STRCPY(text, gdb_itoa(r));
+    }
+
+    /* With id = 1 and enabled TRUE, build the following:
+     * "define 3 linehl=gdb_bp text=1 texthl=LineNr" */
+    eap.arg = NULL;
+    gdb_cat(&(eap.arg), (char_u *)"define ");
+    gdb_cat(&(eap.arg), gdb_itoa(BP_SIGN_ID(id)));
+    gdb_cat(&(eap.arg), (char_u *)" linehl=");
+
+    if (enabled)
+	gdb_cat(&(eap.arg), (char_u *)"gdb_bp");
+    else
+	gdb_cat(&(eap.arg), (char_u *)"gdb_dbp");
+
+    gdb_cat(&(eap.arg), (char_u *)" text=");
+    gdb_cat(&(eap.arg), text);
+    gdb_cat(&(eap.arg), (char_u *)" texthl=LineNr");
+
+    ex_sign(&eap);
+    xfree(eap.arg);
+    return BP_SIGN_ID(id);
+}
+
+/* Undefine a breakpoint sign */
+    void
+gdb_undefine_sign(typenr)
+    int typenr;		/* sign type number to undefine */
+{
+    exarg_T eap;
+
+    if (typenr <= 0)
+	return;
+
+    emsg_skip++;
+    eap.arg = NULL;
+    gdb_cat(&(eap.arg), (char_u *)"undefine ");
+    gdb_cat(&(eap.arg), gdb_itoa(typenr));
+    ex_sign(&eap);
+    xfree(eap.arg);
+    emsg_skip--;
+}
+
+/** Return the (first) console window where is displayed gdb */
+    win_T *
+gdb_window(gdb)
+    gdb_handle_T *gdb;
+{
+    return (gdb != NULL ? gdb_btowin(((gdb_T *)gdb)->buf): NULL);
+}
+
+/* Return (first) window where buf is displayed */
+    win_T *
+gdb_btowin(buf)
+    buf_T *buf;
+{
+    win_T *win;
+
+    if (buf != NULL)
+	for (win = firstwin; win != NULL; win = win->w_next)
+	    if (win->w_buffer == buf)
+		return win;
+    return NULL;
+}
+
+/* Return (first) window where file fname is displayed */
+    static win_T *
+ftowin(fname)
+    char_u *fname;
+{
+    buf_T *buf = NULL;
+    char_u *name;
+
+    /* first make the name into a full path name
+     * force expansion, get rid of symbolic links */
+    if (fname != NULL && (name = FullName_save(fname, TRUE)) != NULL)
+    {
+	buf = buflist_findname(name);
+	xfree(name);
+    }
+    return gdb_btowin(buf);
+}
+
+/* Pop up gdb console, load the buffer when first time */
+    void
+gdb_popup_console(this)
+    gdb_T *this;
+{
+    win_T *oldwin = curwin;
+    char_u *name  = NULL;
+    long s_mm     = p_mm;
+    long splitbelow;
+    long splitright;
+    int flags;
+
+    /* already displayed */
+    if (this->buf != NULL && gdb_btowin(this->buf) != NULL)
+	return;
+
+    /* get a unique name */
+    if (this->buf == NULL &&
+	    (! (this->state & GS_UP)
+	     || (name = vim_tempname((int)'A')) == NULL))
+	return;
+
+    /* get splitbelow and splitright options values */
+    (void) get_option_value((char_u *)"sb", &splitbelow, NULL, OPT_LOCAL);
+    (void) get_option_value((char_u *)"spr", &splitright, NULL, OPT_LOCAL);
+
+    if (splitbelow) {
+	if (splitright)
+	    flags = WSP_BOT;		    /* bottom */
+	else
+	    flags = WSP_VERT | WSP_TOP;	    /* left */
+    }
+    else {
+	if (splitright)
+	    flags = WSP_VERT | WSP_BOT;	    /* right */
+	else
+	    flags = WSP_TOP;		    /* the default: top */
+    }
+
+    /* create new window */
+    if (win_split(p_pvh > 0 ? p_pvh : 0, flags) == FAIL)
+    {
+	vim_free(name);	    /* free name with vim_free */
+	return;
+    }
+
+    if (this->buf == NULL)
+    {
+	p_mm = MAXMEM;	/* buffer max virtual memory */
+	(void)do_ecmd(0, name, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
+	p_mm = s_mm;
+
+	vim_free(name);			/* free name with vim_free */
+	msg_clr_cmdline();
+	curwin->w_alt_fnum = 0;		/* no alternate */
+	this->buf = curbuf;
+
+	/* set buffer local options
+	 * wrap, linebreak, nomodifiable, nolist
+	 * filetype=gdbvim - bufhidden=hide - buftype=nowrite */
+	set_option_value((char_u *)"wrap", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"lbr", 1L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"ma", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"list", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"syn", 0L, (char_u *)"gdbvim", OPT_LOCAL);
+	set_option_value((char_u *)"bh", 0L, (char_u *)"hide", OPT_LOCAL);
+	set_option_value((char_u *)"bt", 0L, (char_u *)"nowrite", OPT_LOCAL);
+	set_option_value((char_u *)"bl", 0L, NULL, OPT_LOCAL);
+    }
+    else if (this->buf != curbuf)
+    {
+	set_curbuf(this->buf, DOBUF_GOTO);
+
+	/* nobuflisted must be set each time it's displayed */
+	set_option_value((char_u *)"bl", 0L, NULL, OPT_LOCAL);
+    }
+
+    /* return to previous window */
+    if (win_valid(oldwin))
+    {
+	prevwin = oldwin;
+	win_goto(oldwin);
+    }
+}
+
+/* Create an assembly buffer */
+    static buf_T *
+buffer_create(name, wrap, modifiable, listed, syntax)
+    char_u *name;	/* buffer name */
+    int wrap;		/* TRUE when option 'wrap' is set */
+    int modifiable;	/* TRUE when option 'modifiable' is set */
+    int listed;		/* TRUE when option 'listed' is set */
+    char_u *syntax;	/* buffer syntax */
+{
+    win_T *oldwin = curwin;
+    buf_T *buf = NULL;
+    win_T *wp;
+    garray_T sizes;
+
+    /* save window sizes */
+    win_size_save(&sizes);
+
+# ifdef FEAT_AUTOCMD
+    ++autocmd_busy;
+# endif
+    /* create a tmp window */
+    if (win_split(0, WSP_BOT) == OK)
+    {
+	/* create the asm buffer empty */
+	(void)do_ecmd(0, NULL, NULL, NULL, ECMD_ONE, ECMD_HIDE, NULL);
+	gdb_as_setname(name);
+# ifdef FEAT_AUTOCMD
+	/* allow autocommands for loading syntax */
+	--autocmd_busy;
+# endif
+	set_option_value((char_u *)"wrap", (long)wrap, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"ma", (long)modifiable, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"bl", (long)listed, NULL, OPT_LOCAL);
+
+	if (syntax != NULL)
+	    set_option_value((char_u *)"syn", 0L, syntax, OPT_LOCAL);
+
+	set_option_value((char_u *)"bt", 0L, (char_u *)"nofile", OPT_LOCAL);
+	set_option_value((char_u *)"swf", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"list", 0L, NULL, OPT_LOCAL);
+	set_option_value((char_u *)"bh", 0L, (char_u *)"hide", OPT_LOCAL);
+# ifdef FEAT_AUTOCMD
+	++autocmd_busy;
+# endif
+	if (curwin != oldwin)
+	{
+	    buf = curbuf;
+	    wp = curwin;
+	    win_goto(oldwin);
+	    win_close(wp, FALSE);
+	}
+    }
+# ifdef FEAT_AUTOCMD
+    --autocmd_busy;
+# endif
+    win_size_restore(&sizes);
+    ga_clear(&sizes);
+    return buf;
+}
+
+/* Set a unique buffer name */
+    void
+gdb_as_setname(name)
+    char_u *name;	/* buffer name */
+{
+    char_u *res = NULL;
+    int s_t = p_title;
+    int s_i = p_icon;
+    int i = 0;
+    char_u *buf;
+
+    p_title = p_icon = FALSE;
+    do
+    {
+	buf = gdb_itoa(i);
+	if (i == 0)
+	    *buf = NUL;
+	i++;
+
+	FREE(res);
+	gdb_cat(&res, name);
+	gdb_cat(&res, buf);
+    } while (setfname(curbuf, res, NULL, FALSE) == FAIL);
+
+    xfree(res);
+    p_title = s_t;
+    p_icon  = s_i;
+}
+
+/*
+ * Clear an asm buffer of its content and signs.
+ * Rename it to an asm generic name.
+ */
+    void
+gdb_clear_asmbuf(this, buf)
+    gdb_T *this;
+    buf_T *buf;		/* asm buffer to clear */
+{
+    buf_T *oldbuf = curbuf;
+    char_u *res   = NULL;
+    bpinfo_T *p, **pt;
+    linenr_T lnum;
+
+    if (buf == NULL)
+	return;
+
+    curbuf = buf;
+
+    /* rename buffer if its name is not a generic name */
+    if ((buf->b_sfname == NULL || STRSTR(buf->b_sfname, ASM_BUF_NAME) != buf->b_sfname))
+    {
+	gdb_cat(&res, (char_u *)ASM_BUF_NAME);
+	gdb_cat(&res, gdb_itoa(this->pool.last++));
+	gdb_as_setname(res);
+	FREE(res);
+    }
+
+    lnum = BUFLASTL(buf);
+    while (lnum-- > 0)	/* clear buffer */
+	ml_delete(buf->b_ml.ml_line_count, FALSE);
+    curbuf = oldbuf;
+
+    /* remove all the buffer signs:
+     *	in buf
+     *	their corresponding bpinfo record
+     *	their corresponding sign type */
+    for (pt = &(this->bpinfo); *pt != NULL; )
+    {
+	p = *pt;
+	if (p->buf == buf)
+	{
+	    buf_delsign(buf, BP_SIGN_ID(p->id));
+	    gdb_undefine_sign(p->typenr);
+	    *pt = p->next;		/* unlink record */
+	    xfree(p);
+	}
+	else
+	    pt = &(p->next);
+    }
+
+    /* remove frame sign if present */
+    if (this->fr_buf == buf)
+    {
+	gdb_unlite(FRAME_SIGN);
+	this->fr_buf = NULL;
+    }
+}
+
+/* Put back gdb console's last line at bottom. */
+/* needed after win_close messes up gdb topline when 'equalalways' on */
+    static void
+cursor_atbot(this)
+    gdb_T *this;
+{
+    win_T *oldwin = curwin;
+    win_T *win;
+
+    if ((win = gdb_btowin(this->buf)) != NULL)
+    {
+	curwin = win;
+	curbuf = curwin->w_buffer;
+	scroll_cursor_bot(0, TRUE);
+	redraw_later(VALID);
+	curwin = oldwin;
+	curbuf = curwin->w_buffer;
+    }
+}
+
+/* Append line to gdb buffer */
+    static int
+line_append(this, line)
+    gdb_T *this;
+    char_u *line;	/* line to append */
+{
+    linenr_T lnum = BUFLASTL(this->buf);
+    char_u *res = NULL;
+    win_T *win;
+    int rc;
+
+# define LN_PREFIX   "  "
+    /* disable syntax highliting by prefixing with LN_PREFIX */
+    if (! this->syntax)
+    {
+	gdb_cat(&res, (char_u *)LN_PREFIX);
+	gdb_cat(&res, line);
+	if ((line = res) == NULL)
+	    return FAIL;
+    }
+
+    /* first line ever: remove empty line after the one just inserted */
+    if ((rc = ml_append(lnum, line, 0, 0)) == OK && lnum == 0)
+	ml_delete(this->buf->b_ml.ml_line_count, FALSE);
+
+    if ((win = gdb_btowin(this->buf)) != NULL)
+	redraw_win_later(win, NOT_VALID);
+
+    xfree(res);
+    return rc;
+}
+
+/* Append to/Replace last line in gdb buffer */
+    void
+gdb_write_buf(this, chunk, add)
+    gdb_T *this;
+    char_u *chunk;	/* a chunk may contain one, many or no NL */
+    int add;		/* TRUE when chunk is added */
+{
+    win_T *oldwin = curwin;
+    win_T *win;
+    char_u *start;
+    char_u *ptr;
+    int cnt;		    /* number of lines appended */
+
+    if (chunk == NULL || this->buf == NULL)
+	return;
+
+    /* make a copy */
+    chunk = (char_u *)clewn_strsave((char *)chunk);
+
+    /* set curbuf to buf */
+    curbuf = this->buf;
+
+    /* delete last line */
+    if (!add)
+	ml_delete(this->buf->b_ml.ml_line_count, FALSE);
+
+    /* append to buffer line after line */
+    cnt = 0;
+    for (ptr = start = chunk; *ptr != NUL; ptr++)
+    {
+	if (*ptr == NL)
+	{
+	    *ptr = NUL;
+	    line_append(this, start);
+	    start = ptr + 1;
+	    cnt++;
+	}
+    }
+
+    /* handle an empty line or last non NL terminated stuff */
+    if (start == chunk || *start != NUL)
+    {
+	line_append(this, start);
+	cnt++;
+    }
+
+    changed_lines(this->buf->b_ml.ml_line_count - cnt, 0,
+	    this->buf->b_ml.ml_line_count, cnt);
+
+    /* window displayed */
+    if ((win = gdb_btowin(this->buf)) != NULL)
+    {
+	/* update top line */
+	curwin = win;
+	curwin->w_cursor.lnum = this->buf->b_ml.ml_line_count;
+	update_topline();
+
+	/* status line changed */
+	curwin->w_redr_status = TRUE;
+    }
+
+    curwin = oldwin;
+    curbuf = curwin->w_buffer;
+    xfree(chunk);
+}
+
+/*
+ * Edit a file in a non-console window.
+ * Use buf if non NULL, otherwise fname using gdb source path to find the file.
+ * Return NULL if error, curwin otherwise.
+ */
+    win_T *
+gdb_edit_file(this, buf, fname, lnum, obs)
+    gdb_T *this;
+    buf_T *buf;		/* asm buffer to load */
+    char_u *fname;	/* file name */
+    linenr_T lnum;	/* line number */
+    struct obstack *obs;
+{
+#ifdef GDB_LVL3_SUPPORT
+    char_u * source_cur = this->lvl3.source_cur;    /* GDB current source */
+    char_u * source_list = this->lvl3.source_list;  /* GDB source list */
+#else
+    char_u * source_cur = NULL;
+    char_u * source_list = NULL;
+#endif
+    char_u *fpn;
+    win_T *win;
+    int i;
+
+    if (obs) {}	    /* keep comiler happy */
+
+    if (buf == NULL && (fname == NULL || *fname == NUL))
+	return NULL;
+
+#ifdef FEAT_GUI
+    need_mouse_correct = TRUE;
+#endif
+
+    /* found a window where source is already displayed */
+    if ((win = gdb_btowin(buf)) != NULL || (win = ftowin(fname)) != NULL)
+    {
+	gdb_set_cursor(win, lnum);
+	win_goto(win);
+	return win;
+    }
+    win = NULL;
+
+    /* use a non-console window */
+    if (curbuf == this->buf)
+	for (win = firstwin; win != NULL; win = win->w_next)
+	    if (win->w_buffer != this->buf)
+	    {
+		win_goto(win);
+		break;
+	    }
+
+    if (win == NULL)
+	win = curwin;
+
+    if (buf == NULL)
+    {
+	/* get the first existing full path name in GDB source directories
+	 * matching this name */
+	if ((fpn = (char_u *)get_fullpath((char *)fname, (char *)this->directories,
+			(char *)source_cur, (char *)source_list, obs)) == NULL)
+	{
+	    return NULL;
+	}
+
+	(void)do_ecmd(0, fpn, NULL, NULL, lnum,
+		      (P_HID(curbuf) ? ECMD_HIDE : 0) + ECMD_OLDBUF, curwin);
+    }
+    else if (buf != curbuf)
+	set_curbuf(buf, DOBUF_GOTO);
+
+    /* asm buffers are not listed */
+    if (buf != NULL && buf == curbuf)
+	for (i = 0; i < this->pool.max; i++)
+	    if (this->pool.buf[i] == buf)
+	    {
+		set_option_value((char_u *)"bl", 0L, NULL, OPT_LOCAL);
+		break;
+	    }
+
+    if (win_valid(win))
+    {
+	gdb_set_cursor(win, lnum);
+	prevwin = win;
+	return win;
+    }
+
+    return NULL;
+}
+
+/* Set cursor to lnum with at least SCROLLOFF lines around it */
+    void
+gdb_set_cursor(win, lnum)
+    win_T *win;
+    linenr_T lnum;
+{
+    win_T *oldwin = curwin;
+    long s_so = p_so;
+
+    if (win != NULL)
+    {
+	curwin = win;
+	curbuf = curwin->w_buffer;
+
+	curwin->w_cursor.lnum = lnum;
+	curwin->w_cursor.col = 0;
+	check_cursor();
+
+	if (p_so < SCROLLOFF )
+	    p_so = SCROLLOFF;
+	update_topline();
+
+	win->w_redr_status = TRUE;
+
+	p_so = s_so;
+	curwin = oldwin;
+	curbuf = curwin->w_buffer;
+    }
+}
+
+/* Display a cmd line busy msg */
+    void
+gdb_msg_busy(str)
+    char_u *str;
+{
+    static char *prop[] = { "/", "-", "\\", "|" };
+    static char busy[IOSIZE];
+    static int cnt;
+
+    /* set busy string */
+    if (str != NULL)
+    {
+	STRNCPY(busy, str, IOSIZE - 1);
+	busy[IOSIZE - 1] = NUL;
+    }
+    else
+    {
+	msg_scroll = FALSE;
+	msg_start();
+	msg_outtrans((char_u *)busy);
+	msg_puts((char_u *)" [");
+	msg_puts((char_u *)prop[(++cnt % 4)]);
+	msg_puts((char_u *)"]");
+	msg_clr_eos();
+	out_flush();
+    }
+}
+
+/* Set status and and mark stl dirty */
+    void
+gdb_status(this, status, obs)
+    gdb_T *this;
+    char_u *status;	/* gdb status */
+    struct obstack *obs;
+{
+    win_T *win;
+
+    if (obs) {}	    /* keep comiler happy */
+
+    xfree(this->status);
+    this->status = (char_u *)clewn_strsave((char *)status);
+    if ((win = gdb_btowin(this->buf)) != NULL)
+	win->w_redr_status = TRUE;
+}
+
+/* Update screen when buf is displayed */
+/* needed only from low level functions, not elsewhere */
+    void
+gdb_redraw(buf)
+    buf_T *buf;
+{
+    int s_r = RedrawingDisabled;
+    int s_lz = p_lz;
+    win_T *win;
+
+    if (buf == NULL)
+	return;
+
+    for (win = firstwin; win != NULL; win = win->w_next)
+	if (win->w_buffer == buf)
+	{
+	    RedrawingDisabled = 0;
+	    p_lz = FALSE;
+	    update_screen(0);
+	    RedrawingDisabled = s_r;
+	    p_lz = s_lz;
+
+	    /* reset cursor */
+	    cursor_on();
+	    setcursor();
+	    out_flush();
+	    break;
+	}
+}
+
+/* Do the OOB_COMPLETE part of an oob cmd and send the next one */
+    void
+gdb_oob_send(this, obs)
+    gdb_T *this;
+    struct obstack *obs;
+{
+    int keep    = FALSE;    /* when TRUE, do not switch to next oob function */
+    char *res   = NULL;
+    int *pi     = &(this->oob.idx);
+    int s_a     = (this->state & GS_ALLOWED);
+
+    /* prevent recursive calls to parse_output() since breakpoint
+     * or frame highlighting may cause Vim to query the user when
+     * changes have been made in the previous buffer */
+    this->state &= ~GS_ALLOWED;
+
+    if (this->oobfunc == NULL)
+	return;
+
+    if (*pi == -1)
+    {
+	this->oob.state &= ~OS_INTR;
+	if (this->oob.state & OS_QUIT)
+	    goto quit;
+    }
+
+    if (*pi >= 0 && (this->oobfunc)[*pi].oob != NULL) /* assert != NULL */
+    {
+	if ((this->oobfunc)[*pi].oob(this, OOB_COMPLETE, NULL, obs) != NULL)
+	    keep = TRUE;
+
+	if (this->oob.state & OS_QUIT)
+	    goto quit;
+    }
+
+    if (! keep)
+	++(*pi);
+
+    while ((this->oobfunc)[*pi].oob != NULL && !(this->oob.state & OS_INTR))
+    {
+	if ((res = (this->oobfunc)[*pi].oob(this, OOB_CMD, NULL, obs)) != NULL)
+	{
+	    this->oob.cnt = 0;
+
+	    /* send the command to GDB */
+	    write(this->fd, res, strlen(res));
+
+	    this->state &= ~GS_ALLOWED;
+	    if (s_a)
+		this->state |= GS_ALLOWED;
+	    return;
+	}
+
+	++(*pi);
+    }
+
+    *pi = -1;
+quit:
+    this->oob.state &= ~OS_CMD;
+    this->oob.state &= ~OS_QUIT;
+
+    this->state &= ~GS_ALLOWED;
+    if (s_a)
+	this->state |= GS_ALLOWED;
+}
+
+/* Receive out of band response to idx cmd */
+    void
+gdb_oob_receive(this, chunk, obs)
+    gdb_T *this;
+    char_u *chunk;	/* response (possibly incomplete) */
+    struct obstack *obs;
+{
+    char_u *res = NULL;
+    int s_a = (this->state & GS_ALLOWED);
+
+    /* prevent recursive calls to parse_output() since breakpoint
+     * or frame highlighting may cause Vim to query the user when
+     * changes have been made in the previous buffer */
+    this->state &= ~GS_ALLOWED;
+
+    if (this->oobfunc == NULL)
+	return;
+
+    if(IS_OOBACTIVE(this))
+    {
+	/* silently discard when interrupted */
+	if (!(this->oob.state & OS_INTR) && chunk != NULL)
+	{
+	    if (this->parser != PS_PREPROMPT && this->parser != PS_PROMPT
+		&& (this->oobfunc)[this->oob.idx].oob != NULL) /* assert != NULL */
+	    {
+		this->oob.cnt++;
+		(void)(this->oobfunc)[this->oob.idx].oob(this, OOB_COLLECT, chunk, obs);
+
+		this->state &= ~GS_ALLOWED;
+		if (s_a)
+		    this->state |= GS_ALLOWED;
+		return;
+	    }
+	}
+
+	/* keep the last prompt */
+	if (this->parser == PS_PREPROMPT)
+	{
+	    gdb_cat(&res, this->line);
+	    gdb_cat(&res, chunk);
+	    xfree(this->line);
+	    this->line = res;
+	}
+    }
+
+    this->state &= ~GS_ALLOWED;
+    if (s_a)
+	this->state |= GS_ALLOWED;
+}
+
+/*
+ * Fill up buff with a NUL terminated string of max size - 1 bytes from gdb.
+ * Return bytes read count, -1 if error or zero for nothing to read.
+ */
+    int
+gdb_read(this, buff, size, wtime)
+    gdb_T *this;
+    char_u *buff;	/* where to write */
+    int size;		/* buff size */
+    int wtime;		/* msecs time out, -1 wait forever */
+{
+    int len;
+    int rc;
+# ifndef HAVE_SELECT
+    struct pollfd fds;
+
+    fds.fd = this->fd;
+    fds.events = POLLIN;
+# else
+    struct timeval tv;
+    struct timeval start_tv;
+    fd_set rfds;
+
+    FD_ZERO(&rfds);
+    FD_SET(this->fd, &rfds);
+
+#  ifdef HAVE_GETTIMEOFDAY
+    if (wtime >= 0)
+	gettimeofday(&start_tv, NULL);
+#  endif
+# endif
+
+    if (size <= 0 || buff == NULL || !(this->state & GS_UP))
+	return -1;
+
+    /* make sure there is some data to read */
+    while (1)
+    {
+	if (this->state & GS_SIGCHLD)
+	    goto close;
+
+# ifndef HAVE_SELECT
+	if ((rc = poll(&fds, 1, wtime)) > 0)
+# else
+	if (wtime >= 0)
+	{
+	    tv.tv_sec = wtime / 1000;
+	    tv.tv_usec = (wtime % 1000) * (1000000/1000);
+	}
+
+	if ((rc = select(this->fd + 1, &rfds, NULL, NULL, (wtime >= 0) ? &tv : NULL)) > 0)
+# endif
+	    break;
+
+	if (rc == -1 && errno == EINTR)
+	{
+	    if (wtime >= 0)
+	    {
+		/* compute remaining wait time */
+# if ! defined(HAVE_SELECT) || ! defined(HAVE_GETTIMEOFDAY)
+		/* guess: interrupted halfway, gdb processing 10 msecs */
+		wtime = wtime / 2 - 10L;
+# else
+		gettimeofday(&tv, NULL);
+		wtime -= (tv.tv_sec - start_tv.tv_sec) * 1000L
+				+ (tv.tv_usec - start_tv.tv_usec) / 1000L;
+# endif
+		if (wtime < 0)
+		    return 0;
+	    }
+	}
+	else if (rc == 0)
+	    return 0;
+	else
+	    goto close;
+    }
+
+    /* read the data */
+    if ((len = read(this->fd, (char *)buff, size - 1)) < 0)
+	goto close;
+
+    buff[len] = NUL;
+    return len;
+close:
+    gdb_close(this);
+    return -1;
+}
+
+/* Free a bpinfo_T list and set address referenced by plist to NULL */
+    void
+gdb_free_bplist (plist)
+    bpinfo_T ** plist;
+{
+    bpinfo_T *p, *next;
+
+    if (plist == NULL)
+	return;
+
+    for (p = *plist; p != NULL; p = next)
+    {
+	gdb_undefine_sign(p->typenr);
+	next = p->next;
+	xfree(p);
+    }
+
+    *plist = NULL;
+}
+
+/* Remove str from input history */
+    static void
+histdel(str)
+    char_u *str;	/* string to remove */
+{
+    char_u *pat;
+    char_u *res;
+
+    if (str != NULL && (res = vim_strsave_escaped(str, (char_u *)"\\")) != NULL)
+    {
+	/* nomagic: only the backslash has a special meaning */
+	pat = NULL;
+	gdb_cat(&pat, (char_u *)"\\V\\^");
+	gdb_cat(&pat, res);
+	gdb_cat(&pat, (char_u *)"\\$");
+
+	(void)del_history_entry(HIST_INPUT, pat);
+	xfree(pat);
+
+	xfree(res);
+    }
+}
+
+/* Get the GDB command type */
+    void
+gdb_cmd_type(this, cmd)
+    gdb_T *this;
+    char_u *cmd;
+{
+    regmatch_T regmatch;
+    token_T *tok;
+
+    regmatch.rm_ic = FALSE;	/* always match case */
+    this->cmd_type = CMD_ANY;
+    for (tok = tokens; tok->keyword != NULL; tok++)
+	if ((regmatch.regprog = tok->regprog) != NULL
+		&& vim_regexec(&regmatch, cmd, (colnr_T)0))
+	{
+	    this->cmd_type = tok->type;
+	    break;
+	}
+}
+
+/*
+ * Append src to string pointed to by pdest or copy src to a new allocated
+ * string when *pdest is NULL.
+ * *pdest is reallocated to make room for src.
+ * Append an empty string when src is NULL.
+ */
+    void
+gdb_cat(pdest, src)
+    char_u **pdest;	/* string address to append to */
+    char_u *src;	/* string to append */
+{
+    int ldest = (*pdest != NULL ? STRLEN(*pdest) : 0);
+    int lsrc  = (src != NULL ? STRLEN(src) : 0);
+    char_u *res;
+
+    if (lsrc != 0 || *pdest == NULL)
+    {
+	res = (char_u *)xmalloc(ldest + lsrc + 1);
+
+	if (ldest == 0)
+	{
+	    if (lsrc != 0)
+		STRCPY(res, src);
+	    else
+		STRCPY(res, "");
+	}
+	else
+	{
+	    STRCPY(res, *pdest);
+	    STRCAT(res, src);	/* assert src != NULL */
+	}
+
+	xfree(*pdest);
+	*pdest = res;
+    }
+}
+
+/*
+ * Return an allocated string that is the sub-match indexed by subid ([0-9])
+ * using compiled pattern id.
+ * Return NULL if str does not match (or no such sub-match in pattern).
+ */
+    char_u *
+gdb_regexec(str, id, subid, obs)
+    char_u *str;	/* string to match against */
+    int id;		/* pattern id */
+    int subid;		/* sub-match index */
+    struct obstack *obs;/* obstack to use for allocating memory */
+{
+    pattern_T *pat;
+    regmatch_T regmatch;
+
+    if (str == NULL || *str == NUL || subid < 0 || subid > 9)
+	return NULL;
+
+    for (pat = patterns; pat->str != NULL; pat++)
+	if (pat->id == id)
+	{
+	    regmatch.rm_ic = FALSE;	/* always match case */
+	    if ((regmatch.regprog = pat->regprog) != NULL
+		    && vim_regexec(&regmatch, str, (colnr_T)0)
+		    && regmatch.startp[subid] != NULL)
+	    {
+		if (obs != NULL)
+		    return (char_u *)obstack_copy0(obs, regmatch.startp[subid],
+			    (int)(regmatch.endp[subid] - regmatch.startp[subid]));
+		else
+		    return (char_u *)clewn_strnsave((char *)regmatch.startp[subid],
+			    (int)(regmatch.endp[subid] - regmatch.startp[subid]));
+	    }
+	    break;
+	}
+    return NULL;
+}
+
+/* Return an integer as a string */
+    char_u *
+gdb_itoa(i)
+    int i;		/* integer to stringify */
+{
+    static char buf[NUMBUFLEN];
+
+    sprintf(buf, "%ld", (long)i);
+    return (char_u *)buf;
+}
+#endif /* FEAT_GDB */

Property changes on: src/gdb.c
___________________________________________________________________
Name: svn:keywords
   + Id


Property changes on: src
___________________________________________________________________
Name: svn:ignore
   + objects
2
clewn
config.log
vim
tags


diff -c --new-file old/clewn/gdb.h src/clewn/gdb.h
*** old/clewn/gdb.h	1970-01-01 01:00:00.000000000 +0100
--- src/clewn/gdb.h	2007-07-21 18:35:40.000000000 +0200
***************
*** 0 ****
--- 1,685 ----
+ /* vi:set ts=8 sts=4 sw=4:
+  *
+  * Copyright (C) 2004 Xavier de Gaye.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program (see the file COPYING); if not, write to the
+  * Free Software Foundation, Inc.,
+  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+  *
+  * $Id: gdb.h 148 2007-07-21 16:35:40Z xavier $
+  */
+ 
+ #ifndef GDB_H
+ # define GDB_H
+ 
+ #define obstack_chunk_alloc  malloc
+ #define obstack_chunk_free   free
+ #define obstack_strsave(o,s) (char_u *)obstack_copy0((o), (s), STRLEN((s)))
+ #define obstack_strcat(o,s)			    \
+ ( (s) ? obstack_grow((o), (s), STRLEN((s))) : 0)
+ #define obstack_strcat0(o,s)			    \
+ ( (s)						    \
+   ? obstack_grow0((o), (s), STRLEN((s)))	    \
+   : obstack_grow0((o), "", 0))
+ 
+ #define GDB_LVL2_SUPPORT
+ #define GDB_LVL3_SUPPORT
+ /*#define GDB_MI_SUPPORT */
+ 
+ /* |+gdb| modes */
+ #define GDB_MODE_LVL2		1   /* CLI with annotations level 2 */
+ #define GDB_MODE_LVL3		2   /* CLI with annotations level 3 and GDB/MI */
+ #define GDB_MODE_MI		3   /* GDB/MI */
+ 
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ /*
+  * GDB does not send ANO_BP_INVALID annotation when hitting a breakpoint
+  * that has been 'enable once'.
+  * Undefine BP_INVALID_ANO_MISSING after GDB fixes this
+  */
+ # define BP_INVALID_ANO_MISSING
+ #endif
+ 
+ #define KEY_INTERUPT	Ctrl_Z	/* interrupt */
+ #define MAX_BUFFSIZE	1024
+ 
+ /* The breakpoint info record structure */
+ typedef struct bpinfo_struct bpinfo_T;
+ 
+ struct bpinfo_struct
+ {
+     int id;		/* breakpoint number */
+     int typenr;		/* sign type number, for Clewn: sequence sign type number in this buffer */
+ #ifdef BP_INVALID_ANO_MISSING
+     int disposition;	/* TRUE when keep, FALSE when disabled */
+ #endif
+     int enabled;	/* TRUE when enabled */
+     int cont;		/* TRUE when 'commands' includes continue */
+ #ifdef FEAT_GDB
+     buf_T *buf;		/* breakpoint buffer */
+ #else
+     int buf;		/* Clewn buffer number */
+     int typenr_en;	/* enabled breakpoint sequence number */
+     int typenr_dis;	/* disabled breakpoint sequence number */
+ #endif
+     linenr_T lnum;	/* breakpoint line number */
+     bpinfo_T *next;
+ };
+ 
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ /* Annotation types */
+ # define ANO_NONE		0
+ # define ANO_ANY		1	/* some unrecognized annotation */
+ 
+ /* level 2 and level 3 annotations */
+ # define ANO_PREPROMPT		101
+ # define ANO_PROMPT		102
+ # define ANO_POSTPROMPT		103
+ # define ANO_PRECMDS		104
+ # define ANO_CMDS		105
+ # define ANO_PREOVERLOAD	106
+ # define ANO_OVERLOAD		107
+ # define ANO_PREQUERY		108
+ # define ANO_QUERY		109
+ # define ANO_PREPMT_FORMORE	110
+ # define ANO_PMT_FORMORE	111
+ # define ANO_POSTPMT_FORMORE	112
+ # define ANO_QUIT		113
+ # define ANO_ERROR_BEG		114
+ # define ANO_FRAME_INVALID	115
+ # define ANO_BP_INVALID		116
+ # define ANO_STARTING		117
+ # define ANO_STOPPED		118
+ # define ANO_EXITED		119
+ # define ANO_SIGNALLED		120
+ # define ANO_BREAKPOINT		121
+ # define ANO_SOURCE		122
+ 
+ # define KEY_KILL	Ctrl_U	/* readline 'unix-line-discard' */
+ # define LPP_LINES	500	/* large output interruption interval */
+ 
+ /* Command completion states */
+ # define CS_START	0
+ # define CS_PENDING	1
+ # define CS_CHOICE	2
+ # define CS_DONE	3
+ # define CS_QUERY	4
+ 
+ /* The gdb CLI cmd */
+ typedef struct
+ {
+     int state;		/* cmd completion state */
+     int cnt;		/* lines output by gdb since last cmd */
+     char_u *gdb;	/* partial cmd sent to gdb */
+     char_u *readline;	/* gdb readline content */
+     char_u *echoed;	/* echoed cmd */
+ } cli_cmd_T;
+ 
+ /* breakpoint states */
+ # define BPS_INVALID	0x0100	/* got "breakpoints-invalid" annotation */
+ # define BPS_BP_HIT	0x0200	/* got "breakpoint" annotation */
+ # define BPS_FR_INVALID 0x0400	/* got "frames-invalid" annotation */
+ # define BPS_BP_SET	0x0800	/* a break type GDB cmd is being processed */
+ # define BPS_RECORD	0x1000	/* parsing a record in the breakpoint table */
+ # define BPS_START	0x2000	/* start of a record */
+ #endif /* defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT) */
+ 
+ #ifdef GDB_LVL2_SUPPORT
+ /* level 2 annotations */
+ # define ANO_FRAME_BEGIN	201
+ # define ANO_FRAME_END		202
+ # define ANO_BP_HEADER		203
+ # define ANO_BP_TABLE		204
+ # define ANO_BP_RECORD		205
+ # define ANO_BP_FIELD0		206	/* Number */
+ # define ANO_BP_FIELD1		207	/* Type */
+ # define ANO_BP_FIELD2		208	/* Disposition */
+ # define ANO_BP_FIELD3		209	/* Enable */
+ # define ANO_BP_FIELD4		210	/* Address */
+ # define ANO_BP_FIELD5		211	/* What */
+ # define ANO_BP_FIELD6		212	/* Frame */
+ # define ANO_BP_FIELD7		213	/* Condition */
+ # define ANO_BP_FIELD8		214	/* Ignore-count */
+ # define ANO_BP_FIELD9		215	/* Commands */
+ # define ANO_BP_END		216
+ # define ANO_DISP_BEG		217
+ # define ANO_DISP_NUMEND	218
+ # define ANO_DISP_FMT		219
+ # define ANO_DISP_EXP		220
+ # define ANO_DISP_EXPEND	221
+ # define ANO_DISP_VALUE		222	/* not output by GDB */
+ # define ANO_DISP_END		223
+ # define ANO_FIELD_BEG		224
+ # define ANO_FIELD_NAMEND	225
+ # define ANO_FIELD_VALUE	226
+ # define ANO_FIELD_END		227
+ # define ANO_ARRAY_BEG		228
+ # define ANO_ARRAY_ELT		229
+ # define ANO_ARRAY_ELTREP	230
+ # define ANO_ARRAY_ELTEND	231
+ # define ANO_ARRAY_END		232
+ 
+ /* breakpoints */
+ # define IS_RECORD(s)		((s) & BPS_RECORD)
+ # define RECORD_INDEX(s)	((s) & 0xff)
+ # define SET_RECORD_IDX(s, i)	(((s) & ~0xff) | (i))
+ 
+ /* breakpoint annotation fields indexes */
+ # define BI_NUM		0
+ # define BI_TYPE	1
+ # define BI_DISPO	2
+ # define BI_ENABLE	3
+ # define BI_ADDRESS	4
+ # define BI_WHAT	5
+ # define BI_FRAME	6
+ # define BI_COND	7
+ # define BI_COUNT	8
+ # define BI_CMMDS	9	/* commands */
+ # define BI_FIELDS	10	/* number of bp info annotation fields */
+ 
+ /* The display object structure */
+ typedef struct gdbdisp_struct gdbdisp_T;
+ 
+ struct gdbdisp_struct
+ {
+     int num;		/* display number */
+     int state;		/* highlighted or/and changed */
+     gdbdisp_T * next;
+ };
+ 
+ /* display states */
+ # define DSP_INIT	0
+ # define DSP_STOPPED	1
+ 
+ /* The display list structure */
+ typedef struct
+ {
+     int state;
+     gdbdisp_T * list;
+ } displist_T;
+ 
+ /* The display entry structure used to store a GDB display output */
+ typedef struct
+ {
+     char_u * num;	/* display item number */
+     char_u * expression;/* display item format and expression */
+     char_u * value;	/* display item value */
+ } doutput_T;
+ 
+ /* The lvl2 mode structure: lvl2 specific data */
+ typedef struct
+ {
+     /* breakpoints */
+     char_u *info[BI_FIELDS]; /* breakpoint info record contents */
+ 
+     /* variables (display) window */
+     displist_T varlist;	/* list of display items */
+     doutput_T dentry;	/* current GDB display output entry */
+     int doing_value;	/* when TRUE: currently handling a display value */
+     char_u *dispinfostr;/* current line output after "info display" */
+     char_u *dispinfo;	/* all item numbers result of a "info display" */
+ } lvl2_T;
+ #endif /* GDB_LVL2_SUPPORT */
+ 
+ #ifdef GDB_LVL3_SUPPORT
+ /* The variable object structure */
+ typedef struct varobj_struct varobj_T;
+ 
+ /* varobj states */
+ #define VS_INIT	    0x01    /* object creation */
+ #define VS_ERROR    0x02    /* a command on this object produced an error */
+ 
+ struct varobj_struct
+ {
+     int state;
+     char_u *name;	/* variable name ("NNN" in "varNNN") */
+     int children;	/* TRUE when has children */
+     char_u *format;	/* print format is "/[tdxo]"*/
+     char_u *expression;	/* variable expression */
+     varobj_T * next;
+ };
+ 
+ /* GDB/MI var commands */
+ # define VCMD_INIT	0
+ # define VCMD_CREATE	1
+ # define VCMD_DELETE	2
+ # define VCMD_CHILDREN	3
+ # define VCMD_UPDATE	4
+ # define VCMD_PRINT	5
+ # define VCMD_EVALUATE	6
+ # define VCMD_FORMAT	7
+ 
+ /* The lvl3 mode structure: lvl3 specific data */
+ typedef struct
+ {
+     char_u *result;	/* result of a GDB/MI command */
+ 
+     int get_source_list;
+     char_u *source_cur;	/* result of -file-list-exec-source-file */
+     char_u *source_list;/* result of -file-list-exec-source-files */
+ 
+     /* variables window */
+     varobj_T *varlist;	/* list of variable objects */
+     varobj_T *varitem;  /* current object in varlist */
+     int varcmd;		/* GDB/MI var cmd being processed */
+     int varnext_cmd;	/* GDB/MI var next cmd to process */
+ } lvl3_T;
+ #endif /* GDB_LVL3_SUPPORT */
+ 
+ /* Command types */
+ #define CMD_ANY		0
+ #ifdef FEAT_GDB
+ # define CMD_DIR	1
+ #endif
+ #define CMD_DETACH	2
+ #define CMD_SHELL	3
+ #define CMD_STEPI	4	/* instruction stepping cmds */
+ #define CMD_EXECF	5	/* invalidating asm buffers cmds */
+ #define CMD_BREAK	6
+ #define CMD_DISPLAY	7
+ #define CMD_CREATEVAR	8
+ #define CMD_UP		9
+ #define CMD_DOWN	10
+ #define CMD_FRAME	11
+ #define CMD_DISABLE	12
+ #define CMD_DELETE	13
+ #define CMD_UP_SILENT	14
+ #define CMD_DOWN_SILENT	15
+ #define CMD_SLECT_FRAME 16
+ #define CMD_SYMF	17
+ #define CMD_RESTART	18
+ #define CMD_QUIT	19
+ 
+ #define ASM_MAX_BUFF	64	    /* asm buffers pool size */
+ #define ASM_BUF_NAME	"gdb-asm-"  /* asm buffer name prefix */
+ #define ASM_OLD	(char_u)(~0U)	    /* asm buffer max age */
+ 
+ /* The assembly buffer pool */
+ typedef struct
+ {
+ #ifdef FEAT_GDB
+     int max;			/* buffers in use */
+     int idx;			/* current buffer */
+     buf_T * buf[ASM_MAX_BUFF];	/* asm buffers */
+     char_u age[ASM_MAX_BUFF];	/* buffer's age */
+     int last;			/* used for generating unique asm names */
+ #else
+     int buf;			/* number of the asm buffer being disassembled */
+     FILE *fd;			/* stream descriptor of asm file being written to */
+     char_u *name;		/* file name of the function being disassembled */
+     long line_offset;		/* offset of start of last line in file */
+ #endif
+     linenr_T lnum;		/* highlited line number */
+     int hilite;			/* TRUE when $pc in asm is highlited */
+ } asm_T;
+ 
+ /* The gdb structure */
+ typedef struct gdb_struct gdb_T;
+ 
+ /* Out of band states */
+ #define OS_CMD    0x01		/* a cmd is being processed */
+ #define OS_INTR   0x02		/* interrupt sent to gdb */
+ #define OS_QUIT   0x04		/* 'quit' annotation received */
+ 
+ /* Out of Band */
+ #define OOB_CMD		0
+ #define OOB_COLLECT	1
+ #define OOB_COMPLETE	2
+ #define IS_OOBACTIVE(t) (((t)->oob.idx) >= 0)
+ 
+ /* The out of band process */
+ typedef struct
+ {
+     int state;			/* oob state */
+     int idx;			/* current function index */
+     int cnt;			/* asm output lines count */
+ } oob_T;
+ 
+ /*
+  * oobfunc_T function:
+  *
+  * When an oobfunc_T[] array is processed by gdb_oob_send() and
+  * gdb_oob_receive(), each oob function in the array is called with
+  * successive state values of:
+  *
+  * OOB_CMD:	called at each 'prompt'; should return the GDB cmd
+  *		to send to GDB or NULL when no command must be sent;
+  *		in this case the next oob function in the oobfunc_T[]
+  *		array is processed next with OOB_CMD
+  *
+  * OOB_COLLECT:	oob may process chunk, a (possibly partial) line from GDB
+  *		result of GDB command; may be invoked more than once, or not at all
+  *
+  * OOB_COMPLETE:indicates end of GDB output; oob may do any final processing;
+  *		if oob returns a non NULL value, the same oob function is
+  *		called once again with OOB_CMD and the same cycle starts again;
+  *		if oob returns a NULL value, the next oob function in the
+  *		oobfunc_T[] array is processed with OOB_CMD
+  *
+  * Return:	NULL, except when state is OOB_CMD or OOB_COMPLETE
+  */
+ 
+ typedef struct {
+     char * (*oob)(gdb_T *, int state, char_u *chunk, struct obstack *);
+ } oobfunc_T;
+ 
+ /* gdb states */
+ #define GDB_STATE(i,s) (((i) != NULL) ? ((((gdb_T *)(i))->state) & (s)):FALSE)
+ #define GS_INIT	    0		/* initial state */
+ #define GS_CLOSING  0x001	/* gdb process closing */
+ #define GS_UP	    0x002	/* gdb up and running */
+ #define GS_STARTED  0x004	/* gdb just started */
+ #define GS_ALLOWED  0x008	/* select on pty is allowed */
+ #define GS_EVENT    0x010	/* got SIGCHLD or gdb output some data */
+ #define GS_SIGCHLD  0x020	/* got SIGCHLD from gdb */
+ #define GS_STOPPED  0x040	/* debuggee is stopped */
+ #define GS_ANO	    0x080	/* parsing an annotation table or list */
+ #define GS_QUITTING 0x100	/* quitting clewn */
+ 
+ /* parser states */
+ #define PS_ANY		0
+ #define PS_PREPROMPT	1	/* before the prompt, after any output from GDB */
+ #define PS_PROMPT	2	/* after prompt, but before user input */
+ 
+ /* project file sourced states */
+ #define PROJ_INIT	0
+ #define PROJ_SOURCEIT	1
+ #define PROJ_DONE	2
+ 
+ /* The gdb structure */
+ struct gdb_struct
+ {
+     /* process */
+     int instance;	/* gdb instance number */
+     int fd;		/* pty file descriptor */
+     pid_t pid;		/* process id */
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+     int height;		/* pseudo tty height, non zero when ioctl set */
+     int intr_sent;	/* hack: an interrupt has been sent by the user */
+ #endif
+     int state;		/* gdb state */
+     char_u *status;	/* gdb status */
+     int recurse;	/* disable GS_ALLOWED when calling safe_vgetc */
+ 
+     /* cmds */
+     int cmd_type;	/* cmd type */
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+     cli_cmd_T cli_cmd;	/* current CLI cmd (common to lvl2 and lvl3) */
+ #endif
+     char_u *firstcmd;	/* first cmd in new GDB session */
+     int parser;		/* parser states */
+     int syntax;		/* when TRUE, enable syntax highlighting */
+     char_u *line;	/* last incomplete line */
+     char_u *winput_cmd; /* cmd inserted in input-line window */
+     char_u *directories;/* gdb search path for source files */
+ #ifndef FEAT_GDB
+     char_u *prompt;	/* the current GDB prompt */
+     char * version;	/* clewn version */
+     char_u * pwd;	/* current working directory */
+     char_u * args;	/* debugge command line arguments */
+ #endif
+     char_u *sfile;	/* symbol file name */
+ 
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+     /* annotations */
+     int note;		/* annotation type */
+     int annoted;	/* TRUE when parsing an annotation */
+     int newline;	/* pending NL, possibly an annotation first char */
+     int valid_note;	/* last non prompt-for-more annotation type */
+     int prev_note;	/* previous annotation type */
+     char_u *annotation;	/* last incomplete annotation */
+ #endif
+ 
+     /* disassembly */
+     asm_T pool;		/* asm buffers pool */
+     char_u *pc;		/* program counter where debuggee is stopped */
+     char_u *frame_pc;	/* current frame program counter */
+     char_u *oob_result;	/* result of oob gdb_get_frame */
+     char_u *asm_add;	/* address whose function must be disassembled */
+     char_u *asm_func;	/* asm function name */
+ 
+     /* breakpoints */
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+     int bp_state;	/* breakpoint annotation state (and index) */
+     bpinfo_T *tmplist;	/* tmp new bp list when reading "info beakpoints" */
+ #endif
+     bpinfo_T *record;	/* current record  */
+     int bufIsChanged;	/* TRUE when curbuf is changed after edit failed */
+     int cont;		/* TRUE when pgm is continuing at this bp */
+     bpinfo_T *bpinfo;	/* breakpoints info table */
+     int frame_curlvl;	/* current frame level */
+     linenr_T frame_lnum;/* current frame line number */
+     char_u * frame_fname;/* current frame file name */
+ 
+ #ifdef FEAT_GDB
+     buf_T *buf;		/* gdb buffer */
+     buf_T *fr_buf;	/* frame sign buffer */
+     buf_T *var_buf;	/* variables window buffer */
+ #else /* Clewn implementation */
+     linenr_T lastline;	/* lastline being disassembled */
+     int fr_buf;		/* frame sign buffer number */
+     linenr_T lnum;	/* frame sign line number */
+     int var_buf;	/* variables buffer number */
+     char_u *var_name;	/* variables file name */
+     char_u *balloon_txt;/* text over which is pointed the mouse */
+     char * project_file;/* project file name */
+     int project_state;	/* project file sourced state */
+ #endif
+     oob_T oob;		/* out of band data */
+ 
+     /* |+gdb| modes */
+     int mode;		/* current |+gdb| mode */
+ #ifdef GDB_LVL2_SUPPORT
+     lvl2_T lvl2;	/* annotations level 2 */
+ #endif
+ #ifdef GDB_LVL3_SUPPORT
+     lvl3_T lvl3;	/* annotations level 3 and GDB/MI */
+ #endif
+ 
+     /* pointers to mode specific functions */
+     oobfunc_T *oobfunc;		    /* the current oob functions array */
+     oobfunc_T *std_oobfunc;	    /* the standard oob functions array */
+     int (*parse_output)(gdb_T *);   /* parser function */
+     void (*gdb_docmd)(gdb_T *, char_u *);/* GDB command input function */
+     void (*var_delete)(gdb_T *);    /* delete all variables function */
+     void (*clear_gdb_T)(gdb_T *);   /* clear mode specific stuff */
+ };
+ 
+ /* Regexp patterns */
+ #define PAT_DIR		1
+ #define PAT_CHG_ANNO	2
+ #define PAT_ADD		3
+ #define PAT_PID		4
+ 
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ # define PAT_SOURCE	101
+ # define PAT_QUERY	102
+ # define PAT_YES	103
+ # define PAT_SFILE	104
+ # define PAT_BP_CONT	105
+ # define PAT_ASM_FUNC	106
+ # define PAT_ASM_FUNC_P	107
+ # define PAT_FRAME	108
+ # define PAT_HEIGHT	109
+ #endif
+ 
+ #ifdef GDB_LVL2_SUPPORT
+ # define PAT_BP_ASM	201
+ # define PAT_BP_SOURCE	202
+ # define PAT_DISPLAY	203
+ # define PAT_DISPINFO	204
+ # define PAT_CREATEVAR	205
+ #endif
+ 
+ # ifdef GDB_LVL3_SUPPORT
+ # define PAT_CRVAR_FMT	301
+ # define PAT_INFO_FRAME	302
+ #endif
+ 
+ /* User interface */
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ void gdb_docmd_cli __ARGS((gdb_T *, char_u *));
+ void gdb_send_cmd __ARGS((gdb_T *, char_u *));
+ #endif
+ 
+ /* Vim low level hook */
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ int gdb_parse_output_cli __ARGS((gdb_T *));
+ #endif
+ 
+ /* Gdb process mgmt */
+ void gdb_close __ARGS((gdb_T *));
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ int gdb_setup_cli __ARGS((gdb_T *));
+ #endif
+ 
+ /* Gdb mode initialization */
+ #ifdef GDB_LVL2_SUPPORT
+ void gdb_lvl2_init __ARGS((gdb_T *));
+ #endif
+ #ifdef GDB_LVL3_SUPPORT
+ void gdb_lvl3_init __ARGS((gdb_T *));
+ #endif
+ 
+ /* Sign highliting */
+ #define FRAME_SIGN 1
+ #ifdef FEAT_GDB
+ # define PHANTOM_SIGN 2
+ # define BP_SIGN_ID(n) ((n)+2)	/* reserved sign ids: 1 frame, 2 phantom */
+ void gdb_fr_lite __ARGS((gdb_T *, buf_T *, linenr_T, struct obstack *));
+ int gdb_define_sign __ARGS((int, int));
+ void gdb_undefine_sign __ARGS((int));
+ buf_T * gdb_unlite __ARGS((int));
+ #else
+ # define BP_SIGN_ID(n) ((n)+1)	/* reserved sign id: 1 frame */
+ void gdb_fr_lite __ARGS((gdb_T *, int, linenr_T, struct obstack *));
+ int gdb_define_bpsign __ARGS((bpinfo_T *, struct obstack *));
+ void gdb_unlite __ARGS((int));
+ #endif
+ int gdb_as_frset __ARGS((gdb_T *, struct obstack *));
+ int gdb_fr_set __ARGS((gdb_T *, char_u *, linenr_T *, struct obstack *));
+ void gdb_fr_unlite __ARGS((gdb_T *));
+ 
+ /* Window and buffer mgmt */
+ #ifdef FEAT_GDB
+ win_T *gdb_btowin __ARGS((buf_T *));
+ void gdb_as_setname __ARGS((char_u *));
+ void gdb_clear_asmbuf __ARGS((gdb_T *, buf_T *));
+ win_T * gdb_edit_file __ARGS((gdb_T *, buf_T *, char_u *, linenr_T, struct obstack *));
+ void gdb_set_cursor __ARGS((win_T *, linenr_T));
+ void gdb_popup_console __ARGS((gdb_T *));
+ void gdb_redraw __ARGS((buf_T *));
+ #else
+ int gdb_edit_file __ARGS((int, char_u *, linenr_T, int, struct obstack *));
+ #endif
+ void gdb_msg_busy __ARGS((char_u *));
+ void gdb_showBalloon __ARGS((char_u *, struct obstack *));
+ void gdb_status __ARGS((gdb_T *, char_u *, struct obstack *));
+ void gdb_write_buf __ARGS((gdb_T *, char_u *, int));
+ 
+ /* Out Of Band */
+ void gdb_oob_send __ARGS((gdb_T *, struct obstack *));
+ void gdb_oob_receive __ARGS((gdb_T *, char_u *, struct obstack *));
+ #if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ char * gdb_print_value __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_pc __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_frame __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_info_frame __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_stack_frame __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_sfile __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ #ifndef FEAT_GDB
+ char * gdb_source_project __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_pwd __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_args __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ #endif
+ char * gdb_source_cur __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_source_list __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_sourcedir __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_asmfunc __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_asmfunc_hack __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ char * gdb_get_asm __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ void gdb_process_record __ARGS((gdb_T *, char_u *, char_u *, char_u *, char_u *, struct obstack *));
+ #endif
+ 
+ /* Variables window management */
+ #ifdef GDB_LVL2_SUPPORT
+ void gdb_process_display __ARGS((gdb_T *, char_u *, struct obstack *));
+ #endif
+ 
+ /* Utilities */
+ #ifndef MIN
+ #define MIN(a,b) (((a)<(b))?(a):(b))
+ #endif
+ #ifndef ABS
+ #define ABS(x) (((x)<0)?(-(x)):(x))
+ #endif
+ #define STRCHR(s,c) (char_u *)strchr((char *)(s),(int)(c))
+ #define STRSTR(h,n) (char_u *)strstr((char *)(h),(char *)(n))
+ #define FREE(p) {xfree((p)); (p) = NULL;}
+ #define IS_ANNOTATION(l) (STRSTR((l),"\032\032") == (l))
+ #define BUFLASTL(b) (!(((b)->b_ml.ml_flags) & ML_EMPTY)?((b)->b_ml.ml_line_count):0)
+ int gdb_read __ARGS((gdb_T *, char_u *, int, int));
+ void gdb_free_bplist __ARGS((bpinfo_T **));
+ void gdb_cmd_type __ARGS((gdb_T *, char_u *));
+ void gdb_cat __ARGS((char_u **, char_u *));
+ char_u * gdb_regexec __ARGS((char_u *, int, int, struct obstack *));
+ char_u * gdb_itoa __ARGS((int));
+ 
+ /* Gdb memory leaks mtrace */
+ #if defined(GDB_MTRACE) && defined(HAVE_MTRACE)
+ # include <malloc.h>
+ # include <mcheck.h>
+ /* storage for mtrace hooks */
+ extern __ptr_t (*s_malloc) (size_t, const void *);
+ extern void (*s_free) (void *, const void *);
+ extern __ptr_t (*s_realloc) (void *, size_t, const void *);
+ 
+ # define mv_hooks() do {	\
+     s_malloc = __malloc_hook;	\
+     s_free = __free_hook;	\
+     s_realloc = __realloc_hook;	\
+     __malloc_hook = NULL;	\
+     __free_hook = NULL;		\
+     __realloc_hook = NULL;	\
+     } while (0)
+ 
+ # define get_hooks() do {	\
+     __malloc_hook = s_malloc;	\
+     __free_hook = s_free;	\
+     __realloc_hook = s_realloc;	\
+     } while (0)
+ 
+ /* we do call sometimes vim_free directly and allocation is not mtraced:
+  * when the called Vim function does not free all its allocated memory
+  * after it returns */
+ # define xmalloc(s) ({char_u *mret; get_hooks(); mret=xmalloc((s)); mv_hooks(); mret;})
+ # define xcalloc(s) ({char_u *mret; get_hooks(); mret=xcalloc((s)); mv_hooks(); mret;})
+ # define xrealloc(m,s) ({char_u *mret; get_hooks(); mret=xrealloc((m),(s)); mv_hooks(); mret;})
+ 
+ # define xfree(x) do {		\
+     get_hooks();		\
+     xfree((x));			\
+     mv_hooks();			\
+     } while (0)
+ 
+ # define clewn_strsave(s) ({char_u *mret; get_hooks(); mret=clewn_strsave((s)); mv_hooks(); mret;})
+ # define clewn_strnsave(s,l) ({char_u *mret; get_hooks(); mret=clewn_strnsave((s),(l)); mv_hooks(); mret;})
+ 
+ # define vim_strsave_escaped(s,e) ({char_u *mret; get_hooks(); mret=vim_strsave_escaped((s),(e)); mv_hooks(); mret;})
+ # define vim_regcomp(s,m) ({regprog_T *mret; get_hooks(); mret=vim_regcomp((s),(m)); mv_hooks(); mret;})
+ # define FullName_save(n,f) ({char_u *mret; get_hooks(); mret=FullName_save((n),(f)); mv_hooks(); mret;})
+ # define get_option_value(n,u,s,o) ({int r; get_hooks(); r=get_option_value((n),(u),(s),(o)); mv_hooks(); r;})
+ #endif	/* GDB_MTRACE */
+ #endif	/* GDB_H */
+ 
diff -c --new-file old/clewn/gdb_lvl2.c src/clewn/gdb_lvl2.c
*** old/clewn/gdb_lvl2.c	1970-01-01 01:00:00.000000000 +0100
--- src/clewn/gdb_lvl2.c	2008-10-13 16:38:07.000000000 +0200
***************
*** 0 ****
--- 1,1085 ----
+ /* vi:set ts=8 sts=4 sw=4:
+  *
+  * Copyright (C) 2004 Xavier de Gaye.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program (see the file COPYING); if not, write to the
+  * Free Software Foundation, Inc.,
+  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+  *
+  * $Id: gdb_lvl2.c 222 2008-10-13 14:38:07Z xavier $
+  */
+ 
+ # ifdef HAVE_CLEWN
+ #  include <config.h>
+ #  include "obstack.h"
+ #  include "clewn.h"
+ # else
+ #  include "vim.h"
+ #  include "clewn/obstack.h"
+ # endif
+ 
+ #if defined(FEAT_GDB) || defined(HAVE_CLEWN)
+ 
+ # include "gdb.h"
+ # include "misc.h"
+ 
+ # ifdef GDB_LVL2_SUPPORT
+ 
+ /* display item states */
+ #  define DISP_CHANGED 0x01	/* item expression value has changed */
+ #  define DISP_HILITED 0x02	/* item expression value is hilited */
+ 
+ /* Gdb process mgmt */
+ static void clear_gdb_T __ARGS((gdb_T *));
+ 
+ /* Out Of Band */
+ static char *get_lastbp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ static char *get_bp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ static void process_record __ARGS((gdb_T *, struct obstack *));
+ static void set_bpfield __ARGS((gdb_T *, char_u *));
+ static char *get_display __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ static char *undisplay __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ 
+ /* Variables window management */
+ static void var_delete __ARGS((gdb_T *));
+ 
+ /* The function ordering in this array is important as some of
+  * these functions must be invoked in the right order */
+ static oobfunc_T oobfunc[] = {
+     {gdb_get_pc},
+     {gdb_get_frame},
+     {gdb_get_sfile},
+     {gdb_get_sourcedir},
+     {get_lastbp},	    /* after gdb_get_frame */
+     {gdb_get_asmfunc},	    /* after get_lastbp */
+     {gdb_get_asmfunc_hack}, /* after gdb_get_asmfunc */
+     {gdb_get_asm},	    /* after gdb_get_asmfunc */
+     {get_bp},		    /* after gdb_get_asm and get_lastbp */
+     {get_display},
+     {undisplay},
+     {NULL}
+ };
+ 
+ /* Initialize the gdb_T structure lvl2 component that lvl2 is responsible for */
+     static void
+ clear_gdb_T(this)
+     gdb_T *this;
+ {
+     gdbdisp_T *item, *next;
+     int i;
+ 
+     if (this != NULL)
+     {
+ 	for (item = this->lvl2.varlist.list; item != NULL; item = next)
+ 	{
+ 	    next = item->next;
+ 	    xfree(item);
+ 	}
+ 	this->lvl2.varlist.list = NULL;
+ 
+ 	for (i = 0; i < BI_FIELDS; i++)
+ 	    FREE(this->lvl2.info[i]);
+ 
+ 	this->lvl2.doing_value = FALSE;
+ 	FREE(this->lvl2.dentry.num);
+ 	FREE(this->lvl2.dentry.expression);
+ 	FREE(this->lvl2.dentry.value);
+ 	FREE(this->lvl2.dispinfostr);
+ 	FREE(this->lvl2.dispinfo);
+     }
+ }
+ 
+ /* Initialize lvl2 function pointers */
+     void
+ gdb_lvl2_init(this)
+     gdb_T *this;
+ {
+     this->mode = GDB_MODE_LVL2;
+     this->oobfunc = oobfunc;
+     this->std_oobfunc = oobfunc;
+     this->parse_output = gdb_parse_output_cli;
+     this->gdb_docmd = gdb_docmd_cli;
+     this->var_delete = var_delete;
+     this->clear_gdb_T = clear_gdb_T;
+ }
+ 
+ /*
+  * When a breakpoint is being set and asm option is on, get the
+  * instruction address of the last breakpoint, the one being set.
+  * This address is used in get_asm() to disassemble the function
+  * containing this address.
+  */
+     static char *
+ get_lastbp(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     int found = FALSE;
+     bpinfo_T *p;
+     int bp_num;
+     int i;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch (state)
+     {
+ 	case OOB_CMD:
+ 	    /* GDB sends sometimes ANO_BP_INVALID when stepping, even
+ 	     * though no breakpoints have been changed.
+ 	     * Avoid checking for last bp in this case, because this
+ 	     * may cause hiliting a bp in a new buffer when what is
+ 	     * expected is a new frame */
+ 	    if (this->bp_state & BPS_FR_INVALID)
+ 		return NULL;
+ 
+ 	    /* A breakpoint is being set in assembly */
+ 	    if (p_asm != 0 && (this->bp_state & BPS_INVALID)
+ 		    && (this->bp_state & BPS_BP_SET))
+ 	    {
+ 		this->bp_state &= ~BPS_BP_SET;
+ 
+ 		/* fetch GDB bp table info */
+ 		return "server info breakpoint\n";
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    /* initialize fields at start of bp record */
+ 	    if (this->bp_state & BPS_START)
+ 	    {
+ 		this->bp_state &= ~BPS_START;
+ 
+ 		for (i = 0; i < BI_FIELDS; i++)
+ 		    FREE(this->lvl2.info[i]);
+ 	    }
+ 
+ 	    /* get info[] field from annotation content */
+ 	    set_bpfield(this, line);
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    /* the last bp in the table */
+ 	    if (this->lvl2.info[BI_NUM] != NULL
+ 		    && (bp_num = atoi((char *)this->lvl2.info[BI_NUM])) > 0)
+ 	    {
+ 		/* look it up in bpinfo list */
+ 		for (p = this->bpinfo; p != NULL; p = p->next)
+ 		{
+ 		    if (bp_num == p->id)
+ 		    {
+ 			found = TRUE;
+ 			break;
+ 		    }
+ 		}
+ 
+ 		/* not found: set asm_add so that get_asm will
+ 		 * do the disassembling */
+ 		if (! found)
+ 		{
+ 		    xfree(this->asm_add);
+ 		    this->asm_add =
+ 			gdb_regexec(this->lvl2.info[BI_ADDRESS], PAT_ADD, 1, NULL);
+ 		}
+ 	    }
+ 
+ 	    for (i = 0; i < BI_FIELDS; i++)
+ 		FREE(this->lvl2.info[i]);
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /*
+  * Get the breakpoints info record table.
+  */
+     static char *
+ get_bp(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     bpinfo_T *p;
+     int i;
+ 
+     switch (state)
+     {
+ 	case OOB_CMD:
+ 	    /* When an ANO_BP_INVALID annotation has been received,
+ 	     * or when we are stepping (more accurately: got a new frame):
+ 	     * fetch bp table */
+ 	    if (this->bp_state & BPS_INVALID || this->bp_state & BPS_FR_INVALID)
+ 	    {
+ 		this->bufIsChanged = FALSE;
+ 
+ 		/* handle case where an error occured last time */
+ 		FREE(this->record);
+ 		gdb_free_bplist(&(this->tmplist));
+ 
+ 		return "server info breakpoint\n";
+ 	    }
+ 
+ 	    this->bp_state &= ~BPS_INVALID;
+ 	    this->bp_state &= ~BPS_FR_INVALID;
+ 	    this->bp_state &= ~BPS_BP_HIT;
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    if (this->bp_state & BPS_START)
+ 	    {
+ 		this->bp_state &= ~BPS_START;
+ 
+ 		/* process last record */
+ 		process_record(this, obs);
+ 		for (i = 0; i < BI_FIELDS; i++)
+ 		    FREE(this->lvl2.info[i]);
+ 
+ 		/* allocate a new record or reuse an existing one
+ 		 * and initialize its fields */
+ 		if (this->record == NULL)
+ 		    this->record = (bpinfo_T *)xcalloc(sizeof(bpinfo_T));
+ 
+ 		this->record->id	    = -1;
+ 		this->record->enabled	    = TRUE;
+ #  ifdef BP_INVALID_ANO_MISSING
+ 		this->record->disposition   = TRUE;
+ #  endif
+ 		this->record->cont	    = FALSE;
+ #  ifdef FEAT_GDB
+ 		this->record->buf	    = NULL;
+ #  else
+ 		this->record->buf	    = -1;
+ 		this->record->typenr_en	    = -1;
+ 		this->record->typenr_dis    = -1;
+ #  endif
+ 		this->record->lnum	    = 0;
+ 		this->record->next	    = NULL;
+ 	    }
+ 
+ 	    /* get info[] field from annotation content */
+ 	    set_bpfield(this, line);
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    /* process last record */
+ 	    process_record(this, obs);
+ 	    FREE(this->record);
+ 	    for (i = 0; i < BI_FIELDS; i++)
+ 		FREE(this->lvl2.info[i]);
+ 
+ 	    /* All records left in the old table are breakpoints that have
+ 	     * been deleted: delete the corresponding highliting sign */
+ 	    for (p = this->bpinfo; p != NULL; p = p->next)
+ 		gdb_unlite(BP_SIGN_ID(p->id));
+ 
+ 	    this->bp_state &= ~BPS_INVALID;
+ 	    this->bp_state &= ~BPS_FR_INVALID;
+ 	    this->bp_state &= ~BPS_BP_HIT;
+ 
+ 	    /* replace with new table */
+ 	    gdb_free_bplist(&(this->bpinfo));
+ 	    this->bpinfo = this->tmplist;
+ 	    this->tmplist = NULL;
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /* Process the current info record */
+     static void
+ process_record(this, obs)
+     gdb_T *this;
+     struct obstack *obs;
+ {
+     bpinfo_T *record  = this->record;
+     char_u *bp_add    = NULL;
+     char_u *bp_at     = NULL;
+     char_u *bp_line   = NULL;
+     char_u *bp_source = NULL;
+     char_u *ptr;
+ 
+     if (record == NULL)
+ 	return;
+ 
+     /* breakpoint number */
+     if (this->lvl2.info[BI_NUM] != NULL)
+ 	record->id = atoi((char *)this->lvl2.info[BI_NUM]);
+ 
+     /* enabled state */
+     if (this->lvl2.info[BI_ENABLE] != NULL && *(this->lvl2.info[BI_ENABLE]) == 'n')
+ 	record->enabled = FALSE;
+ 
+ #  ifdef BP_INVALID_ANO_MISSING
+     /* disposition */
+     if (this->lvl2.info[BI_DISPO] != NULL
+ 	    && STRSTR(this->lvl2.info[BI_DISPO], "keep") == NULL)
+ 	record->disposition = FALSE;
+ #  endif
+ 
+     /* parse 'commands' for 'continue' as last statement */
+     if (this->lvl2.info[BI_CMMDS] != NULL)
+     {
+ 	/* get last line */
+ 	if ((ptr = (char_u *)strrchr(
+ 	    (char *)this->lvl2.info[BI_CMMDS], (int)'\n')) == NULL)
+ 	    ptr = this->lvl2.info[BI_CMMDS];
+ 	else
+ 	    ptr++;
+ 
+ 	if (gdb_regexec(ptr, PAT_BP_CONT, 1, obs) != NULL
+ 		|| gdb_regexec(ptr, PAT_BP_CONT, 2, obs) != NULL)
+ 	{
+ 	    record->cont = TRUE;    /* continue */
+ 	}
+     }
+ 
+     /* sanity check and discard watchpoints and others */
+     if (record->id <= 0 || this->lvl2.info[BI_TYPE] == NULL
+ 	    || STRSTR(this->lvl2.info[BI_TYPE], "breakpoint") == NULL
+ 	    || this->lvl2.info[BI_ADDRESS] == NULL
+ 	    || this->lvl2.info[BI_WHAT] == NULL)
+ 	return;
+ 
+     bp_add = gdb_regexec(this->lvl2.info[BI_ADDRESS], PAT_ADD, 1, obs);
+     bp_line = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_SOURCE, 2, obs);
+     bp_source = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_SOURCE, 1, obs);
+     if ((bp_at = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_ASM, 1, obs)) == NULL)
+ 	bp_at = gdb_regexec(this->lvl2.info[BI_WHAT], PAT_BP_ASM, 2, obs);
+ 
+     gdb_process_record(this, bp_add, bp_at, bp_line, bp_source, obs);
+ }
+ 
+ /* Set the annotated indexed field with its possibly partial content */
+     static void
+ set_bpfield(this, content)
+     gdb_T *this;
+     char_u *content;
+ {
+     char_u *res = NULL;
+     char_u **pfield;
+ 
+     /*
+      * Set info[] with each breakpoint info field annotation
+      */
+     if (IS_RECORD(this->bp_state))
+     {
+ 	pfield = &(this->lvl2.info[RECORD_INDEX(this->bp_state)]);
+ 
+ 	if (*pfield == NULL)	    /* a new field */
+ 	    *pfield = (char_u *)clewn_strsave((char *)content);
+ 	else if (this->annoted)	    /* concatenate */
+ 	{
+ 	    gdb_cat(&res, *pfield);
+ 	    gdb_cat(&res, content);
+ 	    xfree(*pfield);
+ 	    *pfield = res;
+ 	}
+ 	else			    /* a new line in this field */
+ 	{
+ 	    gdb_cat(&res, *pfield);
+ 	    gdb_cat(&res, (char_u *)"\n");
+ 	    gdb_cat(&res, content);
+ 	    xfree(*pfield);
+ 	    *pfield = res;
+ 	}
+     }
+ }
+ 
+ /*
+  * Remove highlighting for all values that are unchanged and get
+  * from GDB the current "automatic display list"
+  */
+     static char *
+ get_display(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res   = NULL;
+     gdbdisp_T *item;
+     char_u *oldline;
+     char_u *ptr;
+ #  ifdef FEAT_GDB
+     buf_T *oldbuf = curbuf;
+     char_u *ptrn;
+     win_T *win;
+     pos_T pos;
+ #  endif
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ #  ifndef FEAT_GDB
+ 	    /* tell Vim to not update screen */
+ 	    cnb_startAtomic(this->var_buf);
+ #  endif
+ 
+ 	    if (
+ #  ifdef FEAT_GDB
+ 		    this->var_buf != NULL && this->lvl2.varlist.state == DSP_STOPPED)
+ #  else
+ 		    this->var_buf > 0 && this->lvl2.varlist.state == DSP_STOPPED)
+ #  endif
+ 	    {
+ 		/* remove highlighting for all values that are unchanged */
+ 		for (item = this->lvl2.varlist.list; item != NULL; item = item->next)
+ 		{
+ #  ifdef FEAT_GDB
+ 		    if (! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+ 			    && ! (item->state & DISP_CHANGED)
+ 			    && (item->state & DISP_HILITED))
+ 		    {
+ 			pos.lnum = 1;
+ 			pos.col = 0;
+ 
+ 			/* search for display item in variables window */
+ 			obstack_strcat(obs, "^\\s*");
+ 			obstack_strcat(obs, gdb_itoa(item->num));
+ 			obstack_strcat0(obs, ":");
+ 			ptrn = (char_u *)obstack_finish(obs);
+ 
+ 			if (searchit(NULL, this->var_buf, &pos,
+ 				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+ 			{
+ 			    oldline = ml_get_buf(this->var_buf, pos.lnum, FALSE);
+ 			    oldline = obstack_strsave(obs, oldline);
+ 
+ 			    /* this assumes that  "={*}" is not valid in
+ 			     * any expression or value for all GDB supported
+ 			     * languages */
+ 			    if ((ptr = STRSTR(oldline, " ={*} ")) != NULL)
+ 			    {
+ 				*(ptr + 3) = '=';
+ 
+ 				/* replace line */
+ 				curbuf = this->var_buf;
+ 				ml_replace(pos.lnum, oldline, TRUE);
+ 				changed_lines(pos.lnum, 0, pos.lnum + 1, 0);
+ 				curbuf = oldbuf;
+ 
+ 				if ((win = gdb_btowin(this->var_buf)) != NULL)
+ 				    redraw_win_later(win, NOT_VALID);
+ 			    }
+ 			}
+ 
+ 			item->state &= ~DISP_HILITED;
+ 		    }
+ #  else
+ 		    if (! (item->state & DISP_CHANGED)
+ 			    && (item->state & DISP_HILITED))
+ 		    {
+ 			int lnum;
+ 
+ 			/* search for display item in variables window */
+ 			if ((oldline = cnb_search_obj(gdb_itoa(item->num), &lnum)) != NULL)
+ 			{
+ 			    line = obstack_strsave(obs, oldline);
+ 
+ 			    /* this assumes that  "={*}" is not valid in
+ 			     * any expression or value for all GDB supported
+ 			     * languages */
+ 			    if ((ptr = STRSTR(line, " ={*} ")) != NULL)
+ 			    {
+ 				*(ptr + 3) = '=';
+ 
+ 				/* replace line */
+ 				cnb_replace(this->var_buf, line, lnum, obs);
+ 			    }
+ 			}
+ 			item->state &= ~DISP_HILITED;
+ 		    }
+ #  endif
+ 
+ 		    item->state &= ~DISP_CHANGED;
+ 		}
+ 
+ 		FREE(this->lvl2.dispinfostr);
+ 		xfree(this->lvl2.dispinfo);
+ 		this->lvl2.dispinfo = (char_u *)clewn_strsave(" ");
+ 		return "server info display\n";
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    if (this->annoted)	    /* concatenate */
+ 	    {
+ 		gdb_cat(&res, this->lvl2.dispinfostr);
+ 		gdb_cat(&res, line);
+ 		xfree(this->lvl2.dispinfostr);
+ 		this->lvl2.dispinfostr = res;
+ 	    }
+ 	    else		    /* a new line */
+ 	    {
+ 		/* add item number to list */
+ 		if ((res = gdb_regexec(this->lvl2.dispinfostr, PAT_DISPINFO, 1, obs)) != NULL)
+ 		{
+ 		    gdb_cat(&(this->lvl2.dispinfo), res);
+ 		    gdb_cat(&(this->lvl2.dispinfo), (char_u *)" ");
+ 		}
+ 
+ 		xfree(this->lvl2.dispinfostr);
+ 		this->lvl2.dispinfostr = (char_u *)clewn_strsave((char *)line);
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    /* add last item number to list */
+ 	    if ((res = gdb_regexec(this->lvl2.dispinfostr, PAT_DISPINFO, 1, obs)) != NULL)
+ 	    {
+ 		gdb_cat(&(this->lvl2.dispinfo), res);
+ 		gdb_cat(&(this->lvl2.dispinfo), (char_u *)" ");
+ 	    }
+ 	    FREE(this->lvl2.dispinfostr);
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /*
+  * Synchronise the gdb variables window list and our varlist with
+  * GDB "automatic display list".
+  * It should be sufficient that all items in varlist are included
+  * both in the gdb variables window list and in GDB
+  * "automatic display list".
+  */
+     static char *
+ undisplay(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ #  ifdef FEAT_GDB
+ {
+     char_u *sequence = NULL;	/* sequence of items to undisplay */
+     win_T *oldwin    = curwin;
+     buf_T *oldbuf    = curbuf;
+     char_u *num;
+     char_u *ptrn;
+     gdbdisp_T **pt;
+     gdbdisp_T *next;
+     char_u *numstr;
+     pos_T pos;
+     win_T *win;
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->lvl2.varlist.state == DSP_STOPPED)
+ 	    {
+ 		for (pt = &(this->lvl2.varlist.list); *pt != NULL; )
+ 		{
+ 		    numstr = gdb_itoa((*pt)->num);
+ 
+ 		    /* not in * GDB "automatic display list" */
+ 		    obstack_strcat(obs, " ");
+ 		    obstack_strcat(obs, numstr);
+ 		    obstack_strcat0(obs, " ");
+ 		    num = (char_u *)obstack_finish(obs);
+ 
+ 		    if (this->lvl2.dispinfo != NULL
+ 			    && this->var_buf != NULL
+ 			    && STRSTR(this->lvl2.dispinfo, num) == NULL)
+ 		    {
+ 			pos.lnum = 1;
+ 			pos.col = 0;
+ 
+ 			/* remove line from window if exists */
+ 			obstack_strcat(obs, "^\\s*");
+ 			obstack_strcat(obs, numstr);
+ 			obstack_strcat0(obs, ":");
+ 			ptrn = (char_u *)obstack_finish(obs);
+ 
+ 			if (! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+ 				&& searchit(NULL, this->var_buf, &pos,
+ 				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+ 			{
+ 			    curbuf = this->var_buf;
+ 			    ml_delete(pos.lnum, FALSE);
+ 			    deleted_lines(pos.lnum, 1);
+ 
+ 			    if ((win = gdb_btowin(this->var_buf)) != NULL)
+ 			    {
+ 				curwin = win;
+ 				check_cursor();
+ 				update_topline();
+ 				curwin = oldwin;
+ 
+ 				win->w_redr_status = TRUE;
+ 
+ 				redraw_win_later(win, NOT_VALID);
+ 			    }
+ 			    curbuf = oldbuf;
+ 			}
+ 
+ 			/* remove from varlist */
+ 			next = (*pt)->next;
+ 			xfree(*pt);
+ 			*pt = next;
+ 
+ 			continue;
+ 		    }
+ 
+ 		    /* not in gdb variables window */
+ 		    obstack_strcat(obs, "^\\s*");
+ 		    obstack_strcat(obs, numstr);
+ 		    obstack_strcat0(obs, ":");
+ 		    ptrn = (char_u *)obstack_finish(obs);
+ 
+ 		    if (this->var_buf == NULL
+ 			    || (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+ 			    || (searchit(NULL, this->var_buf, &pos,
+ 				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) == FAIL))
+ 		    {
+ 			/* add to sequence */
+ 			obstack_strcat(obs, numstr);
+ 			obstack_strcat0(obs, " ");
+ 			sequence = (char_u *)obstack_finish(obs);
+ 
+ 			/* remove from varlist */
+ 			next = (*pt)->next;
+ 			xfree(*pt);
+ 			*pt = next;
+ 
+ 			continue;
+ 		    }
+ 
+ 		    pt = &((*pt)->next);
+ 		}
+ 
+ 		this->lvl2.varlist.state = DSP_INIT;
+ 		FREE(this->lvl2.dispinfo);
+ 
+ 		if (sequence != NULL)
+ 		{
+ 		    obstack_strcat(obs, "server undisplay ");
+ 		    obstack_strcat(obs, sequence);
+ 		    obstack_strcat0(obs, "\n");
+ 		    return (char *)obstack_finish(obs);
+ 		}
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    line = NULL;    /* keep compiler happy */
+ 	    break;
+     }
+     return NULL;
+ }
+ #  else
+ {
+     char_u *sequence = NULL;	/* sequence of items to undisplay */
+     char_u *num;
+     gdbdisp_T **pt;
+     gdbdisp_T *next;
+     char_u *numstr;
+     int lnum;
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->lvl2.varlist.state == DSP_STOPPED)
+ 	    {
+ 		for (pt = &(this->lvl2.varlist.list); *pt != NULL; )
+ 		{
+ 		    numstr = gdb_itoa((*pt)->num);
+ 
+ 		    /* not in * GDB "automatic display list" */
+ 		    obstack_strcat(obs, " ");
+ 		    obstack_strcat(obs, numstr);
+ 		    obstack_strcat0(obs, " ");
+ 		    num = (char_u *)obstack_finish(obs);
+ 
+ 		    if (this->lvl2.dispinfo != NULL
+ 			    && this->var_buf > 0
+ 			    && STRSTR(this->lvl2.dispinfo, num) == NULL)
+ 		    {
+ 			/* replace line in window if exists with an empty line */
+ 			if (cnb_search_obj(numstr, &lnum) != NULL)
+ 			    cnb_replace(this->var_buf, "", lnum, obs);
+ 
+ 			/* remove from varlist */
+ 			next = (*pt)->next;
+ 			xfree(*pt);
+ 			*pt = next;
+ 
+ 			continue;
+ 		    }
+ 
+ 		    /* not in gdb variables window */
+ 		    if (this->var_buf <= 0 || cnb_search_obj(numstr, &lnum) == NULL)
+ 		    {
+ 			/* add to sequence */
+ 			obstack_strcat(obs, numstr);
+ 			obstack_strcat0(obs, " ");
+ 			sequence = (char_u *)obstack_finish(obs);
+ 
+ 			/* remove from varlist */
+ 			next = (*pt)->next;
+ 			xfree(*pt);
+ 			*pt = next;
+ 
+ 			continue;
+ 		    }
+ 
+ 		    pt = &((*pt)->next);
+ 		}
+ 
+ 		this->lvl2.varlist.state = DSP_INIT;
+ 		FREE(this->lvl2.dispinfo);
+ 
+ 		if (sequence != NULL)
+ 		{
+ 		    obstack_strcat(obs, "server undisplay ");
+ 		    obstack_strcat(obs, sequence);
+ 		    obstack_strcat0(obs, "\n");
+ 		    return (char_u *)obstack_finish(obs);
+ 		}
+ 	    }
+ 	    /* tell Vim to update screen */
+ 	    cnb_endAtomic(this->var_buf);
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    /* tell Vim to update screen */
+ 	    cnb_endAtomic(this->var_buf);
+ 	    line = NULL;    /* keep compiler happy */
+ 	    break;
+     }
+     return NULL;
+ }
+ #  endif
+ 
+ /*
+  * Handle the content of a display annotation.
+  * Fill up each field.
+  * When entry complete, process it:
+  *	. if it's the result of a GDB "display" command with an argument:
+  *	  add to variables window and varlist
+  *	. if it is the output produced by GDB when the program stops or
+  *	  an equivalent GDB "display" command without argument: hilite
+  *	  changed values in variables window
+  */
+     void
+ gdb_process_display(this, line, obs)
+     gdb_T *this;
+     char_u *line;	/* display annotation content */
+     struct obstack *obs;
+ {
+     char_u *res = NULL;
+     int note    = this->note;
+     char_u *displine;		    /* the new display item line */
+     gdbdisp_T *item;
+     char_u *last, *end, *start;
+     char_u *ptr;
+     int num;
+ #  ifdef FEAT_GDB
+     win_T *oldwin    = curwin;
+     buf_T *oldbuf    = curbuf;
+     char_u *ptrn;
+     linenr_T lnum;
+     win_T *win;
+     pos_T pos;
+ #  endif
+ 
+ #  ifdef FEAT_GDB
+     if (this->var_buf == NULL)
+ #  else
+     if (this->var_buf <= 0)
+ #  endif
+ 	return;
+ 
+     /* GDB bug: outputs ANO_DISP_EXP instead of ANO_DISP_VALUE
+      * use doing_value as a hack to know when we are parsing the value */
+     if (this->lvl2.doing_value && note == ANO_DISP_EXP)
+ 	note = ANO_DISP_VALUE;
+ 
+     /* nested structure or array */
+     if (this->lvl2.doing_value
+ 	    && ((note >= ANO_FIELD_BEG && note <= ANO_FIELD_END)
+ 		|| (note >= ANO_ARRAY_BEG && note <= ANO_ARRAY_END)))
+ 	note = ANO_DISP_VALUE;
+ 
+     switch (note)
+     {
+ 	case ANO_DISP_BEG:
+ #  ifndef FEAT_GDB
+ 	    /* tell Vim to not update screen */
+ 	    cnb_startAtomic(this->var_buf);
+ #  endif
+ 
+ 	    this->lvl2.doing_value = FALSE;
+ 
+ 	    /* display number */
+ 	    if (this->lvl2.dentry.num == NULL)
+ 		this->lvl2.dentry.num = (char_u *)clewn_strsave((char *)line);
+ 	    else
+ 	    {
+ 		gdb_cat(&res, this->lvl2.dentry.num);
+ 		gdb_cat(&res, line);
+ 		xfree(this->lvl2.dentry.num);
+ 		this->lvl2.dentry.num = res;
+ 	    }
+ 	    break;
+ 
+ 	case ANO_DISP_FMT:
+ 	case ANO_DISP_EXP:
+ 	    /* display format and expression */
+ 	    if (this->lvl2.dentry.expression == NULL)
+ 		this->lvl2.dentry.expression = (char_u *)clewn_strsave((char *)line);
+ 	    else
+ 	    {
+ 		gdb_cat(&res, this->lvl2.dentry.expression);
+ 		gdb_cat(&res, line);
+ 		xfree(this->lvl2.dentry.expression);
+ 		this->lvl2.dentry.expression = res;
+ 	    }
+ 	    break;
+ 
+ 	case ANO_DISP_EXPEND:
+ 	    this->lvl2.doing_value = TRUE;
+ 	    break;
+ 
+ 	case ANO_DISP_VALUE:
+ 	    /* display value */
+ 	    if (this->lvl2.dentry.value == NULL)
+ 		this->lvl2.dentry.value = (char_u *)clewn_strsave((char *)line);
+ 	    else
+ 	    {
+ 		gdb_cat(&res, this->lvl2.dentry.value);
+ 		gdb_cat(&res, line);
+ 		xfree(this->lvl2.dentry.value);
+ 		this->lvl2.dentry.value = res;
+ 	    }
+ 	    break;
+ 
+ 	/* Process the entry now it's complete */
+ 	case ANO_DISP_END:
+ 	    this->lvl2.doing_value = FALSE;
+ 
+ 	    /* sanity checks */
+ 	    if (this->lvl2.dentry.num == NULL
+ 		    || (num = atoi((char *)this->lvl2.dentry.num)) <= 0
+ 		    || this->lvl2.dentry.expression == NULL
+ 		    || this->lvl2.dentry.value == NULL)
+ 	    {
+ 		FREE(this->lvl2.dentry.num);
+ 		FREE(this->lvl2.dentry.expression);
+ 		FREE(this->lvl2.dentry.value);
+ 		return;
+ 	    }
+ 
+ 	    /* Build the display line including ={*}, the hiliting sign */
+ 	    obstack_strcat(obs, this->lvl2.dentry.num);
+ 	    obstack_strcat(obs, ":");
+ 	    obstack_strcat(obs, this->lvl2.dentry.expression);
+ 	    obstack_strcat(obs, " ={*} ");
+ 	    obstack_strcat0(obs, this->lvl2.dentry.value);
+ 	    displine = (char_u *)obstack_finish(obs);
+ 
+ 	    /*
+ 	     * The result of a GDB "display" command with argument
+ 	     */
+ 	    if (this->cmd_type == CMD_DISPLAY)
+ 	    {
+ 		item = (gdbdisp_T *)xcalloc(sizeof(gdbdisp_T));
+ 
+ 		/* add item to varlist */
+ 		item->num = num;
+ 		item->state = DISP_HILITED;
+ 		item->next = this->lvl2.varlist.list;
+ 		this->lvl2.varlist.list = item;
+ 
+ #  ifdef FEAT_GDB
+ 		lnum = BUFLASTL(this->var_buf);
+ 
+ 		/* edit variables buffer in available window */
+ 		if (gdb_edit_file(this, this->var_buf, NULL, lnum, obs) != NULL)
+ 		{
+ 		    /* add to variables buffer */
+ 		    if (ml_append(lnum, displine, 0, 0) == OK)
+ 		    {
+ 			/* first line ever: remove empty line after the
+ 			 * one just inserted */
+ 			if (lnum == 0)
+ 			    ml_delete(this->var_buf->b_ml.ml_line_count, FALSE);
+ 
+ 			changed_lines(this->var_buf->b_ml.ml_line_count - 1,
+ 				0, this->var_buf->b_ml.ml_line_count, 1);
+ 		    }
+ 
+ 		    /* update top line */
+ 		    curwin->w_cursor.lnum = this->var_buf->b_ml.ml_line_count;
+ 		    update_topline();
+ 
+ 		    /* status line changed */
+ 		    curwin->w_redr_status = TRUE;
+ 
+ 		    /* move back to previous window if still there */
+ 		    if ((win = gdb_btowin(oldbuf)) != NULL)
+ 			win_goto(win);
+ 		}
+ #  else
+ 		/* add to variables buffer */
+ 		cnb_append(this->var_buf, displine, obs);
+ #  endif
+ 	    }
+ 
+ 	    /*
+ 	     * Highlight existing changed values in variables window
+ 	     */
+ 	    else
+ 	    {
+ #  ifdef FEAT_GDB
+ 		pos.lnum = 1;
+ 		pos.col = 0;
+ 
+ 		/* search for display item in variables window */
+ 		obstack_strcat(obs, "^\\s*");
+ 		obstack_strcat(obs, this->lvl2.dentry.num);
+ 		obstack_strcat0(obs, ":");
+ 		ptrn = (char_u *)obstack_finish(obs);
+ 
+ 		if ( ! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+ 			&& searchit(NULL, this->var_buf, &pos,
+ 			    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+ 		{
+ 		    lnum = pos.lnum;
+ 
+ 		    obstack_strcat(obs, "} ");
+ 		    obstack_strcat0(obs, this->lvl2.dentry.value);
+ 		    res = (char_u *)obstack_finish(obs);
+ 
+ 		    last = NULL;
+ 		    start = ml_get_buf(this->var_buf, lnum, FALSE);
+ 		    end = start + STRLEN(start);
+ 
+ 		    /* get last occurence of "} " + value in this line */
+ 		    for (ptr = start; ptr != NULL; )
+ 			if ((ptr=STRSTR(ptr, res)) != NULL)
+ 			{
+ 			    last = ptr;
+ 			    ptr++;
+ 			}
+ 
+ 		    /* a changed value (res not found at line end) */
+ 		    if (last == NULL || end != last + STRLEN(res))
+ 		    {
+ 			/* replace line */
+ 			curbuf = this->var_buf;
+ 			ml_replace(lnum, displine, TRUE);
+ 			changed_lines(lnum, 0, lnum + 1, 0);
+ 
+ 			if ((win = gdb_btowin(this->var_buf)) != NULL)
+ 			{
+ 			    win->w_cursor.lnum = lnum;
+ 
+ 			    curwin = win;
+ 			    check_cursor();
+ 			    update_topline();
+ 			    curwin = oldwin;
+ 
+ 			    win->w_redr_status = TRUE;
+ 
+ 			    redraw_win_later(win, NOT_VALID);
+ 			}
+ 			curbuf = oldbuf;
+ 
+ 			/* update item state */
+ 			for (item = this->lvl2.varlist.list; item != NULL;
+ 				item = item->next)
+ 			    if (item->num == num)
+ 			    {
+ 				item->state |= DISP_HILITED | DISP_CHANGED;
+ 				break;
+ 			    }
+ 		    }
+ 		}
+ #  else
+ 		int line_nb;
+ 
+ 		/* search for display item in variables window */
+ 		if ((start = cnb_search_obj(this->lvl2.dentry.num, &line_nb)) != NULL)
+ 		{
+ 		    obstack_strcat(obs, "} ");
+ 		    obstack_strcat0(obs, this->lvl2.dentry.value);
+ 		    res = (char_u *)obstack_finish(obs);
+ 
+ 		    last = NULL;
+ 		    end = start + STRLEN(start);
+ 
+ 		    /* get last occurence of "} " + value in this line */
+ 		    for (ptr = start; ptr != NULL; )
+ 			if ((ptr=STRSTR(ptr, res)) != NULL)
+ 			{
+ 			    last = ptr;
+ 			    ptr++;
+ 			}
+ 
+ 		    /* a changed value (res not found at line end) */
+ 		    if (last == NULL || end != last + STRLEN(res))
+ 		    {
+ 			/* replace line */
+ 			cnb_replace(this->var_buf, displine, line_nb, obs);
+ 
+ 			/* update item state */
+ 			for (item = this->lvl2.varlist.list; item != NULL;
+ 				item = item->next)
+ 			    if (item->num == num)
+ 			    {
+ 				item->state |= DISP_HILITED | DISP_CHANGED;
+ 				break;
+ 			    }
+ 		    }
+ 		}
+ #  endif
+ 	    }
+ 
+ 	    FREE(this->lvl2.dentry.num);
+ 	    FREE(this->lvl2.dentry.expression);
+ 	    FREE(this->lvl2.dentry.value);
+ 
+ #  ifndef FEAT_GDB
+ 	    /* tell Vim to update screen */
+ 	    cnb_endAtomic(this->var_buf);
+ #  endif
+ 	    break;
+ 
+ 	default:
+ 	    break;
+     }
+ }
+ 
+ /* Undisplay all variables */
+     static void
+ var_delete(this)
+     gdb_T *this;
+ {
+     struct obstack obs;	/* use an obstack for temporary allocated memory */
+     char_u *res;
+ 
+     /* undisplay all */
+     this->lvl2.varlist.state = DSP_STOPPED;
+ 
+     (void)obstack_init(&obs);
+ 
+     if ((res = (char_u *)undisplay(this, OOB_CMD, (char_u *)"", &obs)) != NULL)
+ 	gdb_send_cmd(this, res);
+ 
+     obstack_free(&obs, NULL);
+ }
+ # endif /* GDB_LVL2_SUPPORT */
+ #endif /* defined(FEAT_GDB) || defined(HAVE_CLEWN) */
diff -c --new-file old/clewn/gdb_lvl3.c src/clewn/gdb_lvl3.c
*** old/clewn/gdb_lvl3.c	1970-01-01 01:00:00.000000000 +0100
--- src/clewn/gdb_lvl3.c	2008-10-13 16:38:07.000000000 +0200
***************
*** 0 ****
--- 1,4116 ----
+ /* vi:set ts=8 sts=4 sw=4:
+  *
+  * Copyright (C) 2004 Xavier de Gaye.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program (see the file COPYING); if not, write to the
+  * Free Software Foundation, Inc.,
+  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+  *
+  * $Id: gdb_lvl3.c 222 2008-10-13 14:38:07Z xavier $
+  */
+ 
+ # ifdef HAVE_CLEWN
+ #  include <config.h>
+ #  include "obstack.h"
+ #  include "clewn.h"
+ static int got_int;	/* not used with Clewn */
+ # else
+ #  include "vim.h"
+ #  include "clewn/obstack.h"
+ # endif
+ 
+ #if defined(FEAT_GDB) || defined(HAVE_CLEWN)
+ 
+ # include "gdb.h"
+ # include "misc.h"
+ 
+ # if defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT)
+ 
+ static char gdb_buf[MAX_BUFFSIZE];  /* general purpose buffer */
+ 
+ typedef struct
+ {
+     int id;	    /* annoted identifier */
+     char_u *str;    /* GDB annotation */
+ } annotation_T;
+ 
+ static annotation_T annotations[] = {
+     {ANO_PREPROMPT,		(char_u *)"pre-prompt"},
+     {ANO_PROMPT,		(char_u *)"prompt"},
+     {ANO_POSTPROMPT,		(char_u *)"post-prompt"},
+     {ANO_PRECMDS,		(char_u *)"pre-commands"},
+     {ANO_CMDS,			(char_u *)"commands"},
+     {ANO_PREOVERLOAD,		(char_u *)"pre-overload-choice"},
+     {ANO_OVERLOAD,		(char_u *)"overload-choice"},
+     {ANO_PREQUERY,		(char_u *)"pre-query"},
+     {ANO_QUERY,			(char_u *)"query"},
+     {ANO_PREPMT_FORMORE,	(char_u *)"pre-prompt-for-continue"},
+     {ANO_PMT_FORMORE,		(char_u *)"prompt-for-continue"},
+     {ANO_POSTPMT_FORMORE,	(char_u *)"post-prompt-for-continue"},
+     {ANO_QUIT,			(char_u *)"quit"},
+     {ANO_ERROR_BEG,		(char_u *)"error-begin"},
+     {ANO_FRAME_INVALID,		(char_u *)"frames-invalid"},
+     {ANO_BP_INVALID,		(char_u *)"breakpoints-invalid"},
+     {ANO_STARTING,		(char_u *)"starting"},
+     {ANO_STOPPED,		(char_u *)"stopped"},
+     {ANO_EXITED,		(char_u *)"exited"},
+     {ANO_SIGNALLED,		(char_u *)"signalled"},
+     {ANO_BREAKPOINT,		(char_u *)"breakpoint"},
+ #  ifdef GDB_LVL2_SUPPORT
+     {ANO_SOURCE,		(char_u *)"source"},
+     {ANO_FRAME_BEGIN,		(char_u *)"frame-begin"},
+     {ANO_FRAME_END,		(char_u *)"frame-end"},
+     {ANO_BP_HEADER,		(char_u *)"breakpoints-headers"},
+     {ANO_BP_TABLE,		(char_u *)"breakpoints-table"},
+     {ANO_BP_RECORD,		(char_u *)"record"},
+     {ANO_BP_FIELD0,		(char_u *)"field 0"},
+     {ANO_BP_FIELD1,		(char_u *)"field 1"},
+     {ANO_BP_FIELD2,		(char_u *)"field 2"},
+     {ANO_BP_FIELD3,		(char_u *)"field 3"},
+     {ANO_BP_FIELD4,		(char_u *)"field 4"},
+     {ANO_BP_FIELD5,		(char_u *)"field 5"},
+     {ANO_BP_FIELD6,		(char_u *)"field 6"},
+     {ANO_BP_FIELD7,		(char_u *)"field 7"},
+     {ANO_BP_FIELD8,		(char_u *)"field 8"},
+     {ANO_BP_FIELD9,		(char_u *)"field 9"},
+     {ANO_BP_END,		(char_u *)"breakpoints-table-end"},
+     {ANO_DISP_BEG,		(char_u *)"display-begin"},
+     {ANO_DISP_NUMEND,		(char_u *)"display-number-end"},
+     {ANO_DISP_FMT,		(char_u *)"display-format"},
+     {ANO_DISP_EXP,		(char_u *)"display-expression"},
+     {ANO_DISP_EXPEND,		(char_u *)"display-expression-end"},
+     {ANO_DISP_VALUE,		(char_u *)"display-value"},
+     {ANO_DISP_END,		(char_u *)"display-end"},
+     {ANO_FIELD_BEG,		(char_u *)"field-begin"},
+     {ANO_FIELD_NAMEND,		(char_u *)"field-name-end"},
+     {ANO_FIELD_VALUE,		(char_u *)"field-value"},
+     {ANO_FIELD_END,		(char_u *)"field-end"},
+     {ANO_ARRAY_BEG,		(char_u *)"array-section-begin"},
+     {ANO_ARRAY_ELT,		(char_u *)"elt"},
+     {ANO_ARRAY_ELTREP,		(char_u *)"elt-rep"},
+     {ANO_ARRAY_ELTEND,		(char_u *)"elt-rep-end"},
+     {ANO_ARRAY_END,		(char_u *)"array-section-end"},
+ #  endif
+     {0,				NULL}
+ };
+ 
+ /* User interface */
+ static char_u *process_cmd __ARGS((gdb_T *, char_u *));
+ 
+ /* Vim low level hook */
+ /* Not allowed after ^O in INS REP mode or from the input-line window */
+ static char_u *process_annotation __ARGS((gdb_T *, char_u *, struct obstack *));
+ static char_u * process_completion __ARGS((cli_cmd_T *, char_u *, struct obstack *));
+ static char_u * eol_choices __ARGS((cli_cmd_T *, struct obstack *));
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ /* Gdb process mgmt */
+ static void clear_gdb_T __ARGS((gdb_T *));
+ 
+ /* Out Of Band */
+ static char *get_lastbp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ static char *get_bp __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ static void process_record __ARGS((gdb_T *, char_u *, struct obstack *));
+ static char *varobj_update __ARGS((gdb_T *, int, char_u *, struct obstack *));
+ static char *varobj_complete __ARGS((gdb_T *, struct obstack *));
+ static void varobj_hilite __ARGS((gdb_T *, varobj_T *, int, struct obstack *));
+ static void varobj_replace __ARGS((gdb_T *, varobj_T *, char_u *, struct obstack *));
+ static void remove_object __ARGS((gdb_T *, varobj_T *));
+ #  endif
+ 
+ /* Utilities */
+ static char_u * parse_note __ARGS((gdb_T *, char_u *));
+ #  ifndef FEAT_GDB
+ static int get_note __ARGS((gdb_T *, char_u *));
+ #  endif
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ /* The function ordering in this array is important as some of
+  * these functions must be invoked in the right order */
+ static oobfunc_T oobfunc[] = {
+     {gdb_get_pc},
+     {gdb_get_frame},
+     {gdb_get_sourcedir},
+ #ifndef FEAT_GDB
+     {gdb_source_project},
+     {gdb_get_pwd},
+     {gdb_get_args},
+ #endif
+     {gdb_source_cur},
+     {gdb_source_list},
+     {gdb_get_sfile},
+     {gdb_info_frame},
+     {gdb_stack_frame},	    /* after gdb_info_frame */
+     {get_lastbp},	    /* after gdb_get_frame */
+     {gdb_get_asmfunc},	    /* after get_lastbp */
+     {gdb_get_asmfunc_hack}, /* after gdb_get_asmfunc */
+     {gdb_get_asm},	    /* after gdb_get_asmfunc */
+     {get_bp},		    /* after gdb_get_asm and get_lastbp */
+     {varobj_update},
+     {NULL}
+ };
+ #  endif
+ 
+ /** Send a cmd to gdb */
+     void
+ gdb_docmd_cli(this, cmd)
+     gdb_T *this;
+     char_u  *cmd;	/* gdb cmd */
+ {
+ #  ifdef GDB_LVL3_SUPPORT
+     char_u *expression = NULL;
+     varobj_T *varobj;
+ #  endif
+     char_u *res;
+     char_u *ptr;
+     char_u *last;
+     int len;
+ 
+     /* make a copy so we can mess with it */
+     if (cmd == NULL)
+     {
+ 	this->cmd_type = CMD_ANY;
+ 	goto empty_cmd;
+     }
+     cmd = (char_u *)clewn_strsave((char *)cmd);
+ 
+     /* remove illegal characters */
+     for (ptr = last = cmd; *last != NUL; last++)
+ 	if (*last == NL
+ 		|| *last == TAB
+ 		|| *last == KEY_INTERUPT 
+ 		|| !iscntrl((int)(*last)))
+ 	    *ptr++ = *last;
+     *ptr = NUL;
+ 
+     /* remove backslash at last position */
+     if (ptr != cmd && *(ptr - 1) == '\\')
+ 	*(ptr - 1) = NUL;
+ 
+     if (this->cli_cmd.state == CS_QUERY || this->note == ANO_QUERY)
+     {
+ 	if (*cmd == NUL)
+ 	    goto empty_cmd;
+ 	goto send;
+     }
+ 
+     /* now we can forget last cmd */
+     this->cmd_type = CMD_ANY;
+ 
+     /* an interrupt */
+     if (STRCHR(cmd, KEY_INTERUPT) != NULL)
+ 	goto send;
+ 
+     /* a TAB */
+     if (STRCHR(cmd, TAB) != NULL)
+     {
+ 	gdb_cmd_type(this, cmd);	/* get cmd type */
+ 
+ 	/* handle completion for all non-gdb commands */
+ 	if (this->cmd_type == CMD_RESTART) {
+ 	    gdb_setwinput((gdb_handle_T *)this, (char_u *)"cl_restart ");
+ 	    xfree(cmd);
+ 	    this->oob.state &= ~OS_CMD;
+ 	    return;
+ 	}
+ 	else if (this->cmd_type == CMD_CREATEVAR)
+ 	{
+ 	    gdb_setwinput((gdb_handle_T *)this, (char_u *)"createvar ");
+ 	    xfree(cmd);
+ 	    this->oob.state &= ~OS_CMD;
+ 	    return;
+ 	}
+ 	goto send;
+     }
+ 
+     if ((res = gdb_regexec(cmd, PAT_CHG_ANNO, 0, NULL)) != NULL)
+     {
+ 	EMSG(_("Sorry, cannot change annotation level"));
+ 	xfree(res);
+ 	goto empty_cmd;
+     }
+ 
+ #  ifndef FEAT_GDB  /* Clewn follows GDB behavior with empty commands */
+     if (*cmd == NUL)
+     {
+ 	gdb_send_cmd(this, (char_u *)"\n");
+ 	xfree(cmd);
+ 	return;
+     }
+ #  endif
+ 
+     /* process the cmd */
+     if ((res = process_cmd(this, cmd)) != NULL)
+     {
+ 	xfree(cmd);
+ 	cmd = res;
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ 	/* a |+gdb| createvar command is processed later in oob varobj_update() */
+ 	if (this->mode == GDB_MODE_LVL3 && this->cmd_type == CMD_CREATEVAR)
+ 	{
+ #   ifdef FEAT_GDB
+ 	    if (this->var_buf == NULL)
+ #   else
+ 	    if (this->var_buf <= 0)
+ #   endif
+ 	    {
+ 		EMSG(_("Variables buffer does not exist anymore: unable to create variable"));
+ 		goto empty_cmd;
+ 	    }
+ 
+ 	    if (
+ #   ifdef FEAT_GDB
+ 		    (expression = gdb_regexec(cmd, PAT_CRVAR_FMT, 2, NULL)) != NULL
+ #   else
+ 		    (expression = gdb_regexec(cmd, PAT_CRVAR_FMT, 3, NULL)) != NULL
+ #   endif
+ 		    && *expression != NUL)
+ 	    {
+ 		varobj = (varobj_T *)xcalloc(sizeof(varobj_T));
+ 
+ 		/* create a new varobj_T element and link it to the list */
+ 		varobj->state      = VS_INIT;
+ 		varobj->children   = FALSE;
+ #   ifdef FEAT_GDB
+ 		varobj->format     = gdb_regexec(cmd, PAT_CRVAR_FMT, 1, NULL);
+ #   else
+ 		varobj->format     = gdb_regexec(cmd, PAT_CRVAR_FMT, 2, NULL);
+ #   endif
+ 		varobj->expression = expression;
+ 		varobj->next = this->lvl3.varlist;
+ 		this->lvl3.varlist = varobj;
+ 
+ 		goto empty_cmd;
+ 	    }
+ 
+ 	    xfree(expression);
+ 	    EMSG(_("Unvalid arguments to \"createvar\" command"));
+ 	    goto empty_cmd;
+ 	}
+ #  endif
+     }
+     else
+ 	goto empty_cmd;
+ 
+     /* add a newline to cmd if needed */
+     len = STRLEN(cmd);
+     if (len == 0 || *(cmd + len - 1) != NL)
+     {
+ 	res = NULL;
+ 	gdb_cat(&res, cmd);
+ 	gdb_cat(&res, (char_u *)"\n");
+ 	xfree(cmd);
+ 	cmd = res;
+     }
+ send:
+     gdb_send_cmd(this, cmd);
+     xfree(cmd);
+     return;
+ empty_cmd:
+     gdb_send_cmd(this, (char_u *)" \n");
+     xfree(cmd);
+     return;
+ }
+ 
+ /*
+  * Process a gdb cmd according to its type.
+  * Return an allocated sanitized cmd or NULL if error.
+  */
+     static char_u *
+ process_cmd(this, cmd)
+     gdb_T *this;
+     char_u  *cmd;	/* user's gdb cmd */
+ {
+     char_u *delete  = NULL;
+     char_u *range   = NULL;
+     char_u *res;
+ #  ifdef FEAT_GDB
+     int i;
+     buf_T *buf	    = NULL;
+     win_T *oldwin   = curwin;
+ #  endif
+ 
+     /* make a copy so we can mess with it */
+     if (cmd == NULL || *cmd == NUL)
+ 	return NULL;
+     cmd = (char_u *)clewn_strsave((char *)cmd);
+ 
+     gdb_cmd_type(this, cmd);	/* get cmd type */
+ 
+ #  ifdef GDB_LVL2_SUPPORT
+     /* Replace "createvar" command with GDB "display" command */
+     if (this->mode == GDB_MODE_LVL2 && this->cmd_type == CMD_CREATEVAR)
+     {
+ #   ifdef FEAT_GDB
+ 	if ((res = gdb_regexec(cmd, PAT_CREATEVAR, 1, NULL)) != NULL)
+ #   else
+ 	if ((res = gdb_regexec(cmd, PAT_CREATEVAR, 2, NULL)) != NULL)
+ #   endif
+ 	{
+ 	    /* replace */
+ 	    this->cmd_type = CMD_DISPLAY;
+ 	    FREE(cmd);
+ 	    gdb_cat(&cmd, (char_u *)"display ");
+ 	    gdb_cat(&cmd, res);
+ 	    xfree(res);
+ 
+ 	    if (cmd == NULL)
+ 	    {
+ 		this->cmd_type = CMD_ANY;
+ 		return NULL;
+ 	    }
+ 	}
+     }
+ #  endif
+ 
+ #  ifndef FEAT_GDB
+     /* Prevent use of a low height size because of "prompt-for-continue" messages.
+      * The annotations lines printed by GDB are part of the lines count that
+      * is used by GDB for "prompt-for-continue" messages, however we do not
+      * display them. */
+     if ((res = gdb_regexec(cmd, PAT_HEIGHT, 2, NULL)) != NULL)
+     {
+ 	fprintf(stderr, "Cannot change the screen size\n");
+ 	xfree(cmd);
+ 	xfree(res);
+ 	return NULL;
+     }
+ #  endif
+ 
+     /* Cannot attach to oneself */
+ #  ifdef FEAT_GDB
+     if ((res = gdb_regexec(cmd, PAT_PID, 1, NULL)) != NULL)
+ #  else
+     if ((res = gdb_regexec(cmd, PAT_PID, 2, NULL)) != NULL)
+ #  endif
+     {
+ 	if (getpid() == atoi((char *)res))
+ 	{
+ 	    EMSG(_("I refuse to debug myself!"));
+ 	    xfree(cmd);
+ 	    xfree(res);
+ 	    return NULL;
+ 	}
+ 	xfree(res);
+     }
+ 
+     /* no processing for 'define' type cmds */
+     if (this->note == ANO_CMDS || this->note == ANO_OVERLOAD)
+ 	return cmd;
+ 
+     switch (this->cmd_type)
+     {
+ #  ifdef GDB_LVL2_SUPPORT
+ 	case CMD_DISPLAY:
+ 	    /* A "display" command without argument is equivalent to the
+ 	     * debuggee being stopped */
+ 	    if ((res = gdb_regexec(cmd, PAT_DISPLAY, 0, NULL)) != NULL)
+ 	    {
+ 		xfree(res);
+ 		this->cmd_type = CMD_ANY;
+ #   ifdef FEAT_GDB
+ 		if (this->var_buf != NULL)
+ #   else
+ 		if (this->var_buf > 0)
+ #   endif
+ 		    this->lvl2.varlist.state = DSP_STOPPED;
+ 	    }
+ 	    break;
+ #  endif
+ 
+ 	case CMD_SHELL:
+ 	    EMSG(_("Sorry, cannot spawn a shell"));
+ 	    xfree(cmd);
+ 	    return NULL;
+ 
+ 	/* unlite frame on 'detach' */
+ 	case CMD_DETACH:
+ 	    gdb_fr_unlite(this);
+ 	    break;
+ 
+ 	/* clear dirty asm buffers */
+ 	case CMD_EXECF:
+ #  ifdef FEAT_GDB
+ 	    for (i = 0; i < this->pool.max; i++)
+ 	    {
+ 		if ((curbuf = this->pool.buf[i]) == NULL)
+ 		    continue;
+ 
+ 		/* clear the buffer */
+ 		gdb_clear_asmbuf(this, curbuf);
+ 
+ 		/* asm buffer is displayed */
+ 		if ((curwin = gdb_btowin(curbuf)) != NULL)
+ 		{
+ 		    check_cursor();
+ 		    buf = curbuf;
+ 		}
+ 		curwin = oldwin;
+ 	    }
+ 	    curbuf = curwin->w_buffer;
+ 	    gdb_redraw(buf);	/* redraw only if one asm displayed */
+ #  else
+ 	    /* unlink all asm buffers */
+ 	    cnb_unlink_asm();
+ #  endif
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ 	    /* get source files list */
+ 	    this->lvl3.get_source_list = TRUE;
+ #  endif
+ 	    break;
+ 
+ 	case CMD_SYMF:
+ #  ifdef GDB_LVL3_SUPPORT
+ 	    /* get source files list */
+ 	    this->lvl3.get_source_list = TRUE;
+ #  endif
+ 	    break;
+ 
+ 	case CMD_UP:
+ 	case CMD_UP_SILENT:
+ 	case CMD_DOWN:
+ 	case CMD_DOWN_SILENT:
+ 	case CMD_FRAME:
+ 	case CMD_SLECT_FRAME:
+ 	    if (this->mode != GDB_MODE_LVL3)
+ 	    {
+ 		this->pool.hilite = TRUE;
+ 
+ 		/* this should not be necessary but sometimes we
+ 		 * don't get the ANO_FRAME_INVALID */
+ 		this->bp_state |= BPS_FR_INVALID;
+ 	    }
+ 	    break;
+ 
+ 	case CMD_DELETE:
+ 	case CMD_DISABLE:
+ 	    /* keep BPS_FR_INVALID state */
+ 	    this->bp_state &= BPS_FR_INVALID;
+ 	    this->bp_state |= BPS_INVALID;
+ 	    break;
+ 
+ 	/* the restart command is mapped to the gdb 'quit' command,
+ 	 * and that will cause gdb to be restarted (the 'quit'
+ 	 * command itself is trapped and
+ 	 * causes a clean termination of clewn and vim) */
+ 	case CMD_RESTART:
+ 	    xfree(cmd);
+ 	    cmd = (char_u *)clewn_strsave("quit");
+ 	    break;
+ 
+ 	/* terminate clewn and vim */
+ 	case CMD_QUIT:
+ 	    this->state |= GS_QUITTING;
+ 	    break;
+ 
+ 	default:
+ 	    break;
+     }
+     xfree(range);
+     xfree(delete);
+     return cmd;
+ }
+ 
+ /* Send a cmd to gdb */
+     void
+ gdb_send_cmd(this, cmd)
+     gdb_T *this;
+     char_u  *cmd;	/* gdb cmd */
+ {
+     int do_free = TRUE;		/* TRUE when readline must be freed */
+     int offset = 0;
+     char_u *res;
+     char_u *start;
+     int len;
+     int l;
+ 
+     if ( ! GDB_STATE(this, GS_UP))
+ 	return;
+ 
+     this->intr_sent = FALSE;
+ 
+     /* make a copy so we can mess with it */
+     if (cmd == NULL || (len = STRLEN(cmd)) == 0 )
+ 	return;
+     cmd = (char_u *)clewn_strsave((char *)cmd);
+ 
+     /* paranoia: trim after NL */
+     if ((res = STRCHR(cmd, (int)NL)) != NULL)
+ 	*(res + 1) = NUL;
+ 
+     /* answering to a query: any stuff not 'y[es]' is converted to 'no' */
+     if (this->cli_cmd.state == CS_QUERY || this->note == ANO_QUERY)
+     {
+ 	len = 1;
+ 	if ((res = gdb_regexec(cmd, PAT_YES, 0, NULL)) != NULL)
+ 	{
+ 	    *cmd = 'y';
+ 	    xfree(res);
+ 	}
+ 	else
+ 	    *cmd = 'n';
+ 
+ #  ifdef FEAT_GDB
+ 	/* CMD_DIR is acted upon when parsing gdb output */
+ 	if (this->cmd_type != CMD_DIR)
+ 	    this->cmd_type = CMD_ANY;
+ #  endif
+ 
+ 	if (this->cli_cmd.state == CS_QUERY)	/* no NL when a completion */
+ 	{
+ 	    this->cli_cmd.state = CS_CHOICE;
+ 	    do_free = FALSE;
+ 
+ 	    /* a standalone <Tab> */
+ 	    if (this->cli_cmd.readline == NULL
+ 		    && this->cli_cmd.gdb != NULL && *(this->cli_cmd.gdb) == NUL)
+ 		this->oob.state &= ~OS_CMD;
+ 	}
+ 	else
+ 	{
+ 	    this->cli_cmd.state = CS_START;
+ 	    *(cmd + 1) = NL;
+ 	    len = 2;	/* enough room since cmd length not zero */
+ 	}
+ 	goto write_answer;
+     }
+ 
+     /* an interrupt */
+     if (STRCHR(cmd, KEY_INTERUPT) != NULL)
+     {
+ 	this->intr_sent = TRUE;
+ 	this->cli_cmd.state = CS_START;
+ 	goto write_answer;
+     }
+ 
+     /* a cmd following a completion response by gdb */
+     if (this->cli_cmd.state == CS_DONE && this->cli_cmd.readline != NULL)
+     {
+ 	/* readline matches start of cmd: send 'user cmd - readline' */
+ 	if (STRSTR(cmd, this->cli_cmd.readline) == cmd)
+ 	{
+ 	    offset = STRLEN(this->cli_cmd.readline);
+ 	    len -= offset;
+ 	    do_free = FALSE;
+ 	}
+ 	/* no match */
+ 	else
+ 	{
+ 	    /* send KEY_KILL to erase gdb's readline */
+ 	    gdb_buf[0] = KEY_KILL;
+ 	    write(this->fd, gdb_buf, 1);
+ 
+ 	    /* discard gdb answer:
+ 	     * '\r' plus the termcap entry 'ce' (clear to end of line) */
+ 	    l = gdb_read(this, (char_u *)gdb_buf, MAX_BUFFSIZE, 1000);
+ 
+ 	    /* do what the discarded stuff above was meant to do:
+ 	     * replace last line by getting rid of readline */
+ 	    /* find the rightmost match */
+ 	    res = NULL;
+ 	    for (start = this->line; *start != NUL; start++)
+ 		if ((start = STRSTR(start, this->cli_cmd.readline)) != NULL)
+ 		    res = start;
+ 		else
+ 		    break;
+ 
+ 	    if (res != NULL)
+ 	    {
+ 		*res = NUL;
+ 		gdb_write_buf(this, this->line, FALSE);
+ 	    }
+ 	    FREE(this->cli_cmd.echoed);
+ 	}
+     }
+ 
+     this->cli_cmd.state = CS_START;
+ 
+     /* a completion request */
+     if (*(cmd + offset + len - 1) == TAB)
+     {
+ 	this->cli_cmd.state = CS_PENDING;
+ 
+ 	xfree(this->cli_cmd.gdb);
+ 	this->cli_cmd.gdb = (char_u *)clewn_strsave((char *)(cmd + offset));
+ 	*(this->cli_cmd.gdb + len - 1) = NUL;	/* remove <Tab> */
+     }
+ write_answer:
+     if (do_free)
+ 	FREE(this->cli_cmd.readline);
+     write(this->fd, (char *)cmd + offset, len);
+     xfree(cmd);
+     return;
+ }
+ 
+ #  ifdef FEAT_GDB
+ #   if defined(MACOS_X) || defined(MACOS_X_UNIX)
+ /* Strip terminating carriage return from a line */
+     static void
+ strip_cr(line)
+     char_u *line;
+ {
+     int len = STRLEN(line);
+ 
+     if (len != 0 && line[len - 1] == '\r')
+ 	line[len - 1] = NUL;
+ }
+ #   endif
+ #  endif
+ 
+ #  ifndef FEAT_GDB
+     /* Handle "prompt-for-continue" annotations.
+      * This is not needed by VimGDB as the screen height is very large. */
+ #   define MANAGE_PRMPT_FORMORE
+ 
+      /* The fix for writing through readline the concatenation of multiple
+       * lines output by gdb, is only correctly implemented for clewn */
+ #   define FIX_CONCATENATION_WRITE
+ #  endif
+ /*
+  * Parse gdb output for annotation and completion. Update gdb console.
+  * Return TRUE when the user must be prompted by the input-line window.
+  */
+     int
+ gdb_parse_output_cli(this)
+     gdb_T *this;
+ {
+ #  ifdef FIX_CONCATENATION_WRITE
+     static int pending_write = FALSE;   /* TRUE, this->line content has not been written yet */
+ #  endif
+     struct obstack obs;	/* use an obstack for temporary allocated memory */
+     char_u *start;
+     char_u *end;
+     char_u *line;
+     char_u *res;
+     int rc;
+     int len;
+ #  ifdef MANAGE_PRMPT_FORMORE
+     int do_newline;
+ #  endif
+ 
+     /* read gdb data */
+     if (this == NULL || ! GDB_STATE(this, GS_UP)
+ 	    || gdb_read(this, (char_u *)gdb_buf, MAX_BUFFSIZE, 0) <= 0)
+ 	return FALSE;
+ 
+     (void)obstack_init(&obs);
+ 
+     /* Process line after line */
+     for (start = end = (char_u *)gdb_buf; end != NULL; start = end)
+     {
+ 	/* Get next line */
+ 	if ((end = STRCHR(start, NL)) != NULL)
+ 	    *end++ = NUL;
+ 	else if (*start == NUL) /* nothing left to read */
+ 	    break;
+ 
+ 	/* concatenate with incomplete annotation */
+ 	if (this->annotation != NULL)
+ 	{
+ 	    obstack_strcat(&obs, this->annotation);
+ 	    obstack_strcat0(&obs, start);
+ 	    line = (char_u *)obstack_finish(&obs);
+ 	}
+ 	else
+ 	    line = obstack_strsave(&obs, start);
+ 
+ #  ifdef FEAT_GDB
+ #   if defined(MACOS_X) || defined(MACOS_X_UNIX)
+ 	strip_cr(line);
+ #   endif
+ #  endif
+ 
+ 	/* With GDB 6.0, completion giving as a result a long list of items causes
+ 	 * a "--More--" prompt to be issued after what GDB (or readline) considers
+ 	 * the height of the terminal (unfortunately not using the GDB height
+ 	 * settings). In case we could not size the terminal to a very big height
+ 	 * with an ioctl call in exec_gdb(), we must answer to the prompt. */
+ 	if (this->height == 0				/* height not set */
+ 		&& this->cli_cmd.state == CS_CHOICE	/* a completion list */
+ 		&& end == NULL
+ 		&& STRCMP(line, "--More--") == 0)	/* standalone prompt */
+ 	{
+ 	    write(this->fd, " ", 1);	/* prompt for more */
+ 	    this->annoted = FALSE;
+ 	    break;
+ 	}
+ 
+ #  ifdef FEAT_GDB   /* Clewn does not use hiliting */
+ 	/* some fuzzy gdb annotation corner: rewrite '(gdb) Quit' so that
+ 	 * it gets highlited (must be done before the newline stuff) */
+ 	if (parse_note(this, line) != NULL && this->note == ANO_QUIT)
+ 	    gdb_write_buf(this, this->line, FALSE);
+ #  endif
+ 
+ 	/* two consecutive NL: start a new line except when this annotation
+ 	 * just follows another annotation
+ 	 * IS_ANNOTATION() does not handle a standalone '\032' */
+ 	if (this->newline && (*line != '\032' || !this->annoted))
+ 	{
+ #  ifdef MANAGE_PRMPT_FORMORE
+ 	    do_newline = TRUE;
+ 
+ 	    /* do not start a new line when parsing annotations and
+ 	     *	. the next chunk is a "pre-prompt-for-continue" and
+ 	     *	  the previous chunk was an annotation
+ 	     *	. or this is a "pre-prompt-for-continue" annotation */
+ 	    if (this->mode == GDB_MODE_LVL2
+ 		    && ! IS_OOBACTIVE(this) && (this->state & GS_ANO))
+ 	    {
+ 		if (end != NULL && get_note(this, end) == ANO_PREPMT_FORMORE
+ 			&& this->prev_note != ANO_NONE)
+ 		    do_newline = FALSE;
+ 		if (line != NULL && get_note(this, line) == ANO_PREPMT_FORMORE)
+ 		    do_newline = FALSE;
+ 	    }
+ 
+ 	    if (do_newline)
+ #  endif
+ 	    {
+ 		if (this->line == NULL && *line != '\032')
+ 		{
+ 		    if (IS_OOBACTIVE(this))
+ 			gdb_oob_receive(this, (char_u *)"", &obs);
+ 		    else
+ 			gdb_write_buf(this, (char_u *)"", TRUE);
+ 		}
+ 
+ #  ifdef FIX_CONCATENATION_WRITE
+ 		if (pending_write)
+ 		    gdb_write_buf(this, this->line, TRUE);
+ #  endif
+ 
+ 		FREE(this->line);	/* start a new line */
+ 		this->note = ANO_NONE;
+ 	    }
+ 	}
+ 	this->newline = FALSE;
+ 
+ 	/* Parse for annotations */
+ 	/* we cannot parse "\n\032\032annotation\n" directly
+ 	 * as any stuff may be split across two buff read;
+ 	 * must concatenate line when interleaved with annotations */
+ 	if (*line == NUL)
+ 	{
+ 	    /* ignore echoed NL after ANO_PMT_FORMORE msg */
+ 	    if (this->note != ANO_PMT_FORMORE)
+ 		this->newline = TRUE;
+ 
+ #  ifdef MANAGE_PRMPT_FORMORE
+ 	    /* start a new line */
+ 	    if (this->mode == GDB_MODE_LVL2 && this->prev_note == ANO_POSTPMT_FORMORE)
+ 	    {
+ 		FREE(this->line);
+ 		this->note = ANO_NONE;
+ 	    }
+ #  endif
+ 	}
+ 	/* a complete annotation */
+ 	else if (IS_ANNOTATION(line) && end != NULL)
+ 	{
+ 	    /* remember last annotation type */
+ 	    if (this->note != ANO_PREPMT_FORMORE
+ 		    && this->note != ANO_PMT_FORMORE
+ 		    && this->note != ANO_POSTPMT_FORMORE)
+ 		this->valid_note = this->note;
+ 
+ 	    res = parse_note(this, line); /* assert != NULL */
+ 
+ 	    if ((res = process_annotation(this, res, &obs)) != NULL)
+ 	    {
+ 		gdb_setwinput((gdb_handle_T *)this, res);
+ 		xfree(res);
+ 
+ 		/* fake an interrupt: will empty stuff and typeahead
+ 		 * buffers aborting insert mode, pending mappings
+ 		 * and operations */
+ 		got_int = TRUE;
+ 	    }
+ 
+ 	    FREE(this->annotation);
+ 	    this->annoted = TRUE;
+ 
+ #  ifdef GDB_LVL2_SUPPORT
+ 	    /* ANO_DISP_END has no content and must be trapped here */
+ 	    if (
+ #   ifdef FEAT_GDB
+ 		    this->mode == GDB_MODE_LVL2 && this->var_buf != NULL
+ #   else
+ 		    this->mode == GDB_MODE_LVL2 && this->var_buf > 0
+ #   endif
+ 		    && this->note == ANO_DISP_END)
+ 	    {
+ 		gdb_process_display(this, (char_u *)"", &obs);
+ 	    }
+ #  endif
+ 
+ #  ifdef MANAGE_PRMPT_FORMORE
+ 	    /* start a new line when end of annotation list or table */
+ 	    if (this->mode == GDB_MODE_LVL2
+ 		    && this->prev_note == ANO_POSTPMT_FORMORE
+ 		    && (this->note == ANO_BP_TABLE
+ 			|| this->note == ANO_BP_RECORD
+ 			|| this->note == ANO_BP_END
+ 			|| this->note == ANO_FRAME_END
+ 			|| this->note == ANO_DISP_END))
+ 	    {
+ 		FREE(this->line);	/* start a new line */
+ 		this->note = ANO_NONE;
+ 	    }
+ #  endif
+ 
+ 	    /* store current annotation type */
+ 	    this->prev_note = this->note;
+ 
+ 	    /* restore annotation type */
+ 	    if (this->note == ANO_POSTPMT_FORMORE)
+ 		this->note = this->valid_note;
+ 	}
+ 	/* a partial annotation */
+ 	else if (*line == '\032'
+ 		&& (*(line + 1) == NUL || *(line + 1) == '\032')
+ 		&& end == NULL)
+ 	{
+ 	    xfree(this->annotation);
+ 	    this->annotation = (char_u *)clewn_strsave((char *)line);
+ 	    break;
+ 	}
+ 	else
+ 	{
+ #  ifdef MANAGE_PRMPT_FORMORE
+ 	    /* The breakpoint table:
+ 	     * start a new line when line starts with <TAB>.*/
+ 	    if (this->mode == GDB_MODE_LVL2
+ 		    && this->prev_note == ANO_POSTPMT_FORMORE
+ 		    && line != NULL && *line == TAB)
+ 	    {
+ 		FREE(this->line);	/* start a new line */
+ 		this->note = ANO_NONE;
+ 	    }
+ #  endif
+ 
+ 	    if (this->note == ANO_PREPMT_FORMORE)
+ 	    {
+ #  ifdef MANAGE_PRMPT_FORMORE
+ 		if (! IS_OOBACTIVE(this))
+ 		{
+ 		    /* Starting with GDB 6.0, GDB sends an ANO_PREPMT_FORMORE
+ 		     * whenever ^C have been typed more that gdb_screen_height/2. */
+ 		    if (this->state & GS_ANO || this->intr_sent)
+ 		    {
+ 			write(this->fd, "\n", 1);	/* prompt for more */
+ 		    }
+ 		    else
+ 		    {
+ 			this->oob.state &= ~OS_CMD;	/* enable next command */
+ 			xfree(this->prompt);
+ 			if (line != NULL)
+ 			    this->prompt = (char_u *)clewn_strsave((char *)line);
+ 			else
+ 			    this->prompt = (char_u *)clewn_strsave(
+ 				"---type <return> to continue, or q <return> to quit---");
+ 		    }
+ 		    this->intr_sent = FALSE;
+ 		}
+ #  endif
+ 		line = NULL;		/* remove ANO_PMT_FORMORE msg */
+ 	    }
+ 
+ #  ifdef GDB_LVL2_SUPPORT
+ 	    /* handle a display annotation content
+ 	     * take care of nested structures and arrays in value content */
+ #   ifdef FEAT_GDB
+ 	    if (this->mode == GDB_MODE_LVL2 && this->var_buf != NULL)
+ #   else
+ 	    if (this->mode == GDB_MODE_LVL2 && this->var_buf > 0)
+ #   endif
+ 	    {
+ 		if ((this->note >= ANO_DISP_BEG && this->note <= ANO_DISP_END)
+ 			|| (this->lvl2.doing_value && this->note >= ANO_FIELD_BEG
+ 			    && this->note <= ANO_FIELD_END)
+ 			|| (this->lvl2.doing_value && this->note >= ANO_ARRAY_BEG
+ 			    && this->note <= ANO_ARRAY_END))
+ 		{
+ 		    gdb_process_display(this, line, &obs);
+ 		    line = NULL;
+ 		}
+ 	    }
+ #  endif
+ 
+ 	    if (IS_OOBACTIVE(this))
+ 	    {
+ 		gdb_oob_receive(this, line, &obs);
+ 	    }
+ 	    else
+ 	    {
+ 		if (this->note == ANO_PROMPT || this->note == ANO_CMDS)
+ 		    gdb_cat(&(this->cli_cmd.echoed), line);
+ 
+ 		/* update line cnt before doing cpltn */
+ 		if (this->line == NULL || !this->annoted)
+ 		    this->cli_cmd.cnt++;
+ 
+ 		/* Parse for completion */
+ 		if ((res = process_completion( &(this->cli_cmd), line, &obs)) != NULL)
+ 		{
+ 		    gdb_setwinput((gdb_handle_T *)this, res);
+ 		    xfree(res);
+ 		    got_int = TRUE;
+ 		}
+ 
+ 		if (line != NULL && (len = STRLEN(line)) != 0
+ 			&& *(line + len - 1) == BELL)
+ 		    *(line + len - 1) = NUL;
+ 
+ 		/* concatenate after an annotation and replace, otherwise add */
+ 		if (this->line != NULL && this->annoted)
+ 		{
+ 		    if (this->note == ANO_ERROR_BEG && STRCMP(line, "Quit") == 0)
+ 			this->syntax = TRUE;
+ 
+ 		    obstack_strcat(&obs, this->line);
+ 		    obstack_strcat0(&obs, line);
+ 		    line = (char_u *)obstack_finish(&obs);
+ 
+ #  ifndef FEAT_GDB  /* do not write "(gdb) Quit"  with Clewn (already done) */
+ 		    if (this->note != ANO_ERROR_BEG)
+ #  endif
+ 		    {
+ #  ifdef FIX_CONCATENATION_WRITE
+ 			/* write a complete line */
+ 			if (end != NULL)
+ 			{
+ 			    if (pending_write)
+ 				gdb_write_buf(this, line, TRUE);
+ 			    else
+ 				gdb_write_buf(this, line, FALSE);
+ 			}
+ #  else
+ 			gdb_write_buf(this, line, FALSE);
+ #  endif
+ 		    }
+ 
+ 		}
+ 		else
+ 		{
+ #  ifdef FEAT_GDB   /* no need to map T_CE when running Clewn */
+ 		    /* a completion list */
+ 		    if (this->height == 0		/* height not set */
+ 			    && this->cli_cmd.state == CS_CHOICE)
+ 		    {
+ 			char_u *ptr;
+ 
+ 			/* discard "^\rT_CE\r" which is sent by readline
+ 			 * after answering to a prompt in a completion list
+ 			 * (not needed on systems where TIOCSWINSZ ioctls are
+ 			 * available) */
+ 			if (STRSTR(line, T_CE) == line + 1
+ 				&& STRLEN(line) >= STRLEN(T_CE) + 2)
+ 			{
+ 			    ptr = line + STRLEN(T_CE) + 2;
+ 			    line = obstack_strsave(&obs, ptr);
+ 			}
+ 		    }
+ 		    gdb_write_buf(this, line, TRUE);
+ #  else
+ 		    /* do not write the query prompt */
+ 		    if (this->cli_cmd.state == CS_QUERY)
+ 			gdb_write_buf(this, (char_u *)"", TRUE);
+ 		    else
+ 		    {
+ #  ifdef FIX_CONCATENATION_WRITE
+ 			/* write a complete line */
+ 			if (end != NULL)
+ 			{
+ 			    gdb_write_buf(this, line, TRUE);
+ 			}
+ #  else
+ 			gdb_write_buf(this, line, TRUE);
+ #  endif
+ 		    }
+ #  endif
+ 		}
+ 
+ 		xfree(this->line);
+ 		this->line = (line != NULL ? (char_u *)clewn_strsave((char *)line) : NULL);
+ 	    }
+ 
+ #  ifdef FIX_CONCATENATION_WRITE
+ 	    pending_write = FALSE;
+ 	    if (end == NULL)	/* incomplete line */
+ 	    {
+ 		pending_write = TRUE;
+ 		this->annoted = TRUE;	/* force concatenation on next read */
+ 		break;
+ 	    }
+ #  else
+ 	    if (end == NULL)	/* incomplete line */
+ 	    {
+ 		this->annoted = TRUE;	/* force concatenation on next read */
+ 		break;
+ 	    }
+ #  endif
+ 	    this->annoted = FALSE;
+ 	    this->note = ANO_NONE;
+ 	}
+     }	/* for (...) */
+ 
+     obstack_free(&obs, NULL);
+ 
+     if (IS_OOBACTIVE(this))
+ 	return FALSE;
+ 
+ #  ifdef FEAT_GDB
+     /* redraw gdb console window when displayed */
+     gdb_redraw(this->buf);
+ #  endif
+ 
+     /* Wait till we get the prompt to send the first cmd */
+     if (this->firstcmd != NULL && this->note == ANO_PROMPT)
+     {
+ 	gdb_docmd((gdb_handle_T *)this, this->firstcmd);
+ 	FREE(this->firstcmd);
+     }
+ 
+     if ((rc = gdb_iswinput((gdb_handle_T *)this)) == TRUE)
+ 	this->oob.state &= ~OS_CMD;
+     return rc;
+ }
+ 
+ /*
+  * Process an annotation.
+  * Return cmd to prompt the user with or NULL if none.
+  */
+     static char_u *
+ process_annotation(this, str, obs)
+     gdb_T *this;
+     char_u *str;	/* annotation's content */
+     struct obstack *obs;
+ {
+     int s_a = (this->state & GS_ALLOWED);
+     char_u *file = NULL;
+     char_u *line = NULL;
+     linenr_T linenumber;
+     char_u *cpn;
+     int bp_number;
+     bpinfo_T *r;
+ 
+     this->syntax = FALSE;
+     this->parser = PS_ANY;
+ 
+     switch (this->note)
+     {
+ 	/* Output end: run directory function */
+ 	case ANO_PREPROMPT:
+ 	    this->syntax = TRUE;
+ 	    this->parser = PS_PREPROMPT;
+ 	    this->cmd_type = CMD_ANY;
+ 	    this->state &= ~GS_ANO;
+ 	    break;
+ 
+ 	/* Send out of band cmd */
+ 	case ANO_PROMPT:
+ 	    this->syntax = TRUE;
+ 	    this->parser = PS_PROMPT;
+ 	    this->cli_cmd.cnt = 1;
+ 	    FREE(this->cli_cmd.echoed);
+ #  ifndef FEAT_GDB	/* store the prompt */
+ 	    if (! IS_OOBACTIVE(this) || (this->oob.state & OS_INTR))
+ 	    {
+ 		xfree(this->prompt);
+ 		if (this->line != NULL)
+ 		    this->prompt = (char_u *)clewn_strsave((char *)this->line);
+ 		else
+ 		    this->prompt = (char_u *)clewn_strsave("(gdb)   ");
+ 	    }
+ #  endif
+ 	    if (this->cli_cmd.state == CS_START) {
+ 		gdb_oob_send(this, obs);
+ 
+ 		/* reset the standard oobfunc table after invocation
+ 		 * of a one function oobfunc array */
+ 		this->oobfunc = this->std_oobfunc;
+ 	    }
+ 	    break;
+ 
+ 	case ANO_CMDS:
+ 	    this->syntax = TRUE;
+ 	    this->cli_cmd.cnt = 1;
+ 	    this->oob.state &= ~OS_CMD;
+ 	    FREE(this->cli_cmd.echoed);
+ #  ifndef FEAT_GDB	/* store the prompt */
+ 	    if (! IS_OOBACTIVE(this) || (this->oob.state & OS_INTR))
+ 	    {
+ 		xfree(this->prompt);
+ 		if (this->line != NULL)
+ 		    this->prompt = (char_u *)clewn_strsave((char *)this->line);
+ 		else
+ 		    this->prompt = (char_u *)clewn_strsave(">  ");
+ 	    }
+ #  endif
+ 
+ 	    /* should be in process_completion, but bug in gdb
+ 	     * annotations where 'pre-commands' is missing in completions */
+ 	    if (this->cli_cmd.state == CS_CHOICE
+ 		    && (cpn = eol_choices(&(this->cli_cmd), obs)) != NULL)
+ 		return cpn;
+ 
+ 	    /* a lone <Tab> does not prompt the user except in define mode */
+ 	    if ((this->cli_cmd.state != CS_PENDING
+ 			&& this->cli_cmd.state != CS_CHOICE)
+ 		    || (this->cli_cmd.readline == NULL && this->cli_cmd.gdb != NULL
+ 			    && *(this->cli_cmd.gdb) == NUL))
+ 		return (char_u *)clewn_strsave("");
+ 	    break;
+ 
+ 	case ANO_OVERLOAD:
+ 	case ANO_QUERY:
+ 	    this->oob.state &= ~OS_CMD;
+ #  ifndef FEAT_GDB	/* store the prompt */
+ 	    if (! IS_OOBACTIVE(this) || (this->oob.state & OS_INTR))
+ 	    {
+ 		xfree(this->prompt);
+ 		if (this->line != NULL)
+ 		    this->prompt = (char_u *)clewn_strsave((char *)this->line);
+ 		else
+ 		    this->prompt = (char_u *)clewn_strsave(">   ");
+ 	    }
+ #  endif
+ 	    return (char_u *)clewn_strsave("");
+ 	
+ 	case ANO_PMT_FORMORE:
+ #  ifndef FEAT_GDB	/* handle ANO_PMT_FORMORE when IS_OOBACTIVE */
+ 	    if (IS_OOBACTIVE(this))
+ #  endif
+ 	    {
+ 		if (this->oob.state & OS_INTR)
+ 		{
+ 		    clewn_beep();
+ 		    gdb_send_cmd(this, (char_u *)"q\n");	/* abort */
+ 		}
+ 		else
+ 		    gdb_send_cmd(this, (char_u *)"\n");	/* get more lines */
+ 	    }
+ 	    break;
+ 
+ 	case ANO_QUIT:
+ 	    this->syntax = TRUE;
+ 	    this->oob.state |= OS_QUIT;
+ 	    break;
+ 
+ 	case ANO_ERROR_BEG:
+ 	    this->pool.hilite = FALSE;
+ #  ifdef GDB_LVL2_SUPPORT
+ 	    /* a display expression parse error */
+ 	    this->lvl2.doing_value = FALSE;
+ 	    FREE(this->lvl2.dentry.num);
+ 	    FREE(this->lvl2.dentry.expression);
+ 	    FREE(this->lvl2.dentry.value);
+ #  endif
+ #  ifdef GDB_LVL3_SUPPORT
+ 	    if (this->lvl3.varitem != NULL)
+ 		this->lvl3.varitem->state |= VS_ERROR;
+ #  endif
+ 	    break;
+ 
+ 	case ANO_STARTING:
+ 	    this->frame_curlvl = -1;
+ 	    this->frame_lnum = (linenr_T) -1;
+ 	    FREE(this->frame_fname);
+ 
+ 	    FREE(this->frame_pc);
+ 	    this->state &= ~GS_STOPPED;
+ 	    gdb_status(this, (char_u *)"running...", obs);
+ 
+ 	    if (this->mode == GDB_MODE_LVL3)
+ 	    {
+ 		this->pool.hilite = FALSE;
+ 		if (p_asm != 0 && this->cmd_type == CMD_STEPI)  /* asm frame highlite: when stepi nexti */
+ 		    this->pool.hilite = TRUE;
+ 	    }
+ 	    else
+ 	    {
+ 		this->pool.hilite = TRUE;
+ 	    }
+ 	case ANO_FRAME_INVALID:
+ 	    gdb_fr_unlite(this);
+ 	    this->bp_state |= BPS_FR_INVALID;
+ 	    break;
+ 
+ 	case ANO_BP_INVALID:
+ 	    /* keep BPS_FR_INVALID state */
+ 	    this->bp_state &= BPS_FR_INVALID;
+ 	    this->bp_state |= BPS_INVALID;
+ 
+ 	    /* note the fact that the user is setting a 
+ 	     * breakpoint */
+ 	    if (p_asm != 0 && this->cmd_type == CMD_BREAK)
+ 		this->bp_state |= BPS_BP_SET;
+ 	    break;
+ 
+ 	case ANO_STOPPED:
+ 	    this->state |= GS_STOPPED;
+ 	    gdb_status(this, (char_u *)"stopped", obs);
+ #  ifdef GDB_LVL2_SUPPORT
+ #   ifdef FEAT_GDB
+ 	    if (this->var_buf != NULL)
+ #   else
+ 	    if (this->var_buf > 0)
+ #   endif
+ 		this->lvl2.varlist.state = DSP_STOPPED;
+ #  endif
+ 	    break;
+ 
+ 	case ANO_EXITED:
+ 	case ANO_SIGNALLED:
+ 	    FREE(this->frame_pc);
+ 
+ 	    this->state |= GS_STOPPED;
+ 	    gdb_status(this, (char_u *)"exited", obs);
+ 
+ #  ifdef FEAT_GDB
+ 	    /* remove phantom highlite */
+ 	    gdb_unlite(PHANTOM_SIGN);
+ #  endif
+ 	    break;
+ 
+ 	/* Breakpoint hit */
+ 	case ANO_BREAKPOINT:
+ 	    /* Look for this breakpoint in bpinfo list */
+ 	    if (str != NULL && (bp_number = atoi((char *)str)) > 0)
+ 	    {
+ 		for (r = this->bpinfo; r != NULL; r = r->next)
+ 		{
+ 		    if (r->id == bp_number)
+ 		    {
+ 			/* Set this->cont TRUE if this breakpoint's 'commands'
+ 			 * includes a 'continue' as last statement */
+ 			if (r->cont)
+ 			    this->cont = TRUE;
+ 
+ #  ifdef BP_INVALID_ANO_MISSING
+ 			/* Trigger get_bp(): the breakpoint we hit is
+ 			 * 'enable once' */
+ 			if (r->enabled && ! r->disposition)
+ 			{
+ 			    /* keep BPS_FR_INVALID state */
+ 			    this->bp_state &= BPS_FR_INVALID;
+ 			    this->bp_state |= BPS_INVALID | BPS_BP_HIT;
+ 			}
+ #  endif
+ 			break;
+ 		    }
+ 		}
+ 
+ 		/* Not found in the list. An asm buffer holding this bp
+ 		 * can possibly be disassembled next by oob get_asm().
+ 		 * Trigger oob get_bp() */
+ 		if (r == NULL && p_asm != 0)
+ 		{
+ 		    /* keep BPS_FR_INVALID state */
+ 		    this->bp_state &= BPS_FR_INVALID;
+ 		    this->bp_state |= BPS_INVALID | BPS_BP_HIT;
+ 		}
+ 	    }
+ 	    break;
+ 
+ #  ifdef GDB_LVL2_SUPPORT
+ 	case ANO_SOURCE:
+ 	    /* gdb stats the file when doing ANO_SOURCE, so we can't rely on
+ 	     * that annotation for remote debugging with clewn when the source
+ 	     * files are on the host and not on the target
+ 	     * => use ANO_BREAKPOINT instead in level 3
+ 	     */
+ 
+ 	    if (! IS_OOBACTIVE(this) && this->mode == GDB_MODE_LVL2)
+ 	    {
+ 		/* Uncomment next line to print source text in gdb buffer */
+ 		/* gdb_write_buf(this, str, TRUE); */
+ 
+ #   ifdef FEAT_GDB
+ 		gdb_popup_console(this);
+ #   endif
+ 
+ 		this->pool.hilite = FALSE;
+ 
+ 		/* asm frame highlite: when stepi nexti */
+ 		if (p_asm != 0 && this->cmd_type == CMD_STEPI)
+ 		    this->pool.hilite = TRUE;
+ 		else
+ 		{
+ 		    /* prevent recursive calls to parse_output() since breakpoint
+ 		     * or frame highlighting may cause Vim to query the user when
+ 		     * changes have been made in the previous buffer */
+ 		    this->state &= ~GS_ALLOWED;
+ 
+ 		    if ((line = gdb_regexec(str, PAT_SOURCE, 2, obs)) != NULL)
+ 		    {
+ 			file = gdb_regexec(str, PAT_SOURCE, 1, obs);
+ 			linenumber = atoi((char *)line);
+ 			gdb_fr_set(this, file, &linenumber, obs);
+ 		    }
+ 
+ 		    this->state &= ~GS_ALLOWED;
+ 		    if (s_a)
+ 			this->state |= GS_ALLOWED;
+ 		}
+ 	    }
+ 	    break;
+ 
+ 	case ANO_FRAME_BEGIN:
+ 	case ANO_BP_HEADER:
+ 	case ANO_DISP_BEG:
+ 	    this->state |= GS_ANO;
+ 	    break;
+ 
+ 	case ANO_FRAME_END:
+ 	case ANO_DISP_END:
+ 	    break;
+ 
+ 	/* Get the source for this frame */
+ 	case ANO_BP_RECORD:
+ 	    this->bp_state |= BPS_RECORD;
+ 	    this->bp_state |= BPS_START;
+ 	    break;
+ 
+ 	case ANO_BP_FIELD0:
+ 	case ANO_BP_FIELD1:
+ 	case ANO_BP_FIELD2:
+ 	case ANO_BP_FIELD3:
+ 	case ANO_BP_FIELD4:
+ 	case ANO_BP_FIELD5:
+ 	case ANO_BP_FIELD6:
+ 	case ANO_BP_FIELD7:
+ 	case ANO_BP_FIELD8:
+ 	case ANO_BP_FIELD9:
+ 	    this->bp_state = SET_RECORD_IDX(this->bp_state,
+ 			(this->note - ANO_BP_FIELD0) + BI_NUM);
+ 	    break;
+ 
+ 	case ANO_BP_END:
+ 	    /* Initialize state but do not forget some of them.
+ 	     * ANO_BP_END can be the one we get when fetching the
+ 	     * table with oob function get_lastbp(): get_bp() still
+ 	     * needs those states */
+ 	    this->bp_state &= (BPS_INVALID | BPS_BP_HIT | BPS_FR_INVALID);
+ 	    break;
+ #  endif
+     }
+     return NULL;
+ }
+ 
+ /*
+  * Parse gdb output for completion.
+  * Return cmd to prompt the user with or NULL if none.
+  */
+     static char_u *
+ process_completion(cmd, line, obs)
+     cli_cmd_T *cmd;
+     char_u *line;	/* line to parse */
+     struct obstack *obs;
+ {
+     char_u *res;
+     char_u *start;
+     int len;
+ 
+     if (line == NULL || *line == NUL)
+ 	return NULL;
+ 
+     switch (cmd->state)
+     {
+ 	case CS_PENDING:
+ 	    /* A completion query */
+ 	    if (cmd->cnt == 2 && gdb_regexec(line, PAT_QUERY, 0, obs) != NULL)
+ 	    {
+ 		cmd->state = CS_QUERY;
+ 		return (char_u *)clewn_strsave("");
+ 	    }
+ 
+ 	    /* A positive completion */
+ 	    if (cmd->cnt == 1 && cmd->echoed != NULL
+ 		    && (len = (cmd->gdb != NULL ? STRLEN(cmd->gdb) : 0)) > 0)
+ 	    {
+ 		/* find the rightmost match */
+ 		res = NULL;
+ 		for (start = cmd->echoed; *start != NUL; start++)
+ 		    if ((start = STRSTR(start, cmd->gdb)) != NULL)
+ 			res = start;
+ 		    else
+ 			break;
+ 
+ 		/* strictly greater and not followed by NL */
+ 		if (res != NULL && *(res + len) != NL
+ 		    && cmd->echoed + STRLEN(cmd->echoed) > res + len)
+ 		{
+ 		    if (*(res + len) == BELL)
+ 		    {
+ 			clewn_beep();
+ 			*(res + len) = NUL;
+ 		    }
+ 		    xfree(cmd->readline);
+ 		    cmd->readline = (char_u *)clewn_strsave((char *)cmd->echoed);
+ 		    cmd->state = CS_DONE;
+ 		    return (char_u *)clewn_strsave((char *)cmd->readline);
+ 		}
+ 	    }
+ 
+ 	    /* A BELL: first character */
+ 	    if (cmd->cnt == 1 && *line == BELL)
+ 	    {
+ 		*line = NUL;
+ 		clewn_beep();
+ 		cmd->state = CS_DONE;
+ 		return (cmd->readline != NULL ?
+ 			(char_u *)clewn_strsave((char *)cmd->readline) : NULL);
+ 	    }
+ 
+ 	    if (cmd->cnt > 1)
+ 		cmd->state = CS_CHOICE;
+ 	    break;
+ 
+ 	case CS_CHOICE:
+ 	    /* The end of a list of completion choices */
+ 	    if (cmd->cnt == 1 && (res = eol_choices(cmd, obs)) != NULL)
+ 		return res;
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /*
+  * The end of a list of completion choices.
+  * Return cmd to prompt the user with.
+  */
+     static char_u *
+ eol_choices(cmd, obs)
+     cli_cmd_T *cmd;
+     struct obstack *obs;
+ {
+     char_u *new;
+ 
+     obstack_strcat(obs, cmd->readline);
+     obstack_strcat0(obs, cmd->gdb);
+     new = (char_u *)obstack_finish(obs);
+ 
+     /* a match with the new readline */
+     if (cmd->echoed != NULL && STRSTR(cmd->echoed, new) == cmd->echoed)
+     {
+ 	xfree(cmd->readline);
+ 	cmd->readline = (char_u *)clewn_strsave((char *)cmd->echoed);
+ 	cmd->state = CS_DONE;
+ 	return (char_u *)clewn_strsave((char *)cmd->echoed);
+     }
+     return NULL;
+ }
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ /* Initialize the gdb_T structure lvl3 component that lvl3 is responsible for */
+     static void
+ clear_gdb_T(this)
+     gdb_T *this;
+ {
+     varobj_T *item, *next;
+ 
+     if (this != NULL)
+     {
+ 	FREE(this->lvl3.result);
+ 
+ 	this->lvl3.get_source_list = TRUE;
+ 	FREE(this->lvl3.source_cur);
+ 	FREE(this->lvl3.source_list);
+ 
+ 	for (item = this->lvl3.varlist; item != NULL; item = next)
+ 	{
+ 	    next = item->next;
+ 	    xfree(item->name);
+ 	    xfree(item->format);
+ 	    xfree(item->expression);
+ 	    xfree(item);
+ 	}
+ 	this->lvl3.varlist = NULL;
+ 	this->lvl3.varitem = NULL;
+     }
+ }
+ 
+ /* Initialize lvl3 function pointers */
+     void
+ gdb_lvl3_init(this)
+     gdb_T *this;
+ {
+     this->mode = GDB_MODE_LVL3;
+     this->oobfunc = oobfunc;
+     this->std_oobfunc = oobfunc;
+     this->parse_output = gdb_parse_output_cli;
+     this->gdb_docmd = gdb_docmd_cli;
+     this->var_delete = NULL;
+     this->clear_gdb_T = clear_gdb_T;
+ }
+ #  endif /* GDB_LVL3_SUPPORT */
+ 
+ #  ifdef FEAT_GDB
+ #   define SG_INTRO_2	"Vim |+gdb| level 2 mode\n\n"
+ #   define SG_INTRO_3	"Vim |+gdb| level 3 mode\n\n"
+ #  else
+ #   define SG_INTRO_2	"...             \
+                         \n... Clewn running GDB in level 2 mode\n...\n"
+ #   define SG_INTRO_3	"...             \
+                         \n... Clewn %s running GDB in level 3 mode\n...\n"
+ #  endif
+ #  define SG_INTERP	"server interpreter-exec mi -gdb-version\n"
+ #  define SG_LVL_2	"server set annotate 2\n"
+ #  define SG_LVL_3	"server set annotate 3\n"
+ #  define SG_HEIGHT	"server set height "
+ #  define SG_WIDTH	"server set width 0\n "
+ #  define SG_EDITING	"server set editing on\n"
+ #  define SG_VERSION	"server show version\n"
+ 
+ /* SG_TIMEOUT must be quite big as we may have Clewn, Vim and GDB all
+  * starting at the same time. Unless things go pretty bad in the parsing, we
+  * always find the needle, so the user never wait SG_TIMEOUT. */
+ #  define SG_TIMEOUT 120000 /* msecs for when the needle cannot be found */
+ /*
+  * Initialize gdb CLI (command line interface)
+  * return OK when sucess, FAIL otherwise
+  */
+     int
+ gdb_setup_cli(this)
+     gdb_T *this;
+ {
+     char *err     = NULL;
+     int needle    = FALSE;	/* defines when we can start writing to gdb console */
+     int gdb_cnt   = 0;		/* count of received "(gdb)" prompts */
+     int lvl3_mode = FALSE;	/* level */
+     char_u *buff  = (char_u *)gdb_buf;/* can't add an int to the reference to an array */
+     char * tty_name = NULL;
+ #   ifndef FEAT_GDB
+     char tmp[128];
+ #   endif
+     char_u *last;
+     char_u *ptr;
+     char_u *lpp_lines;
+     char_u *line;
+     int len;
+ 
+     this->note = ANO_NONE;
+ 
+     /* Does this GDB process supports "interpreter-exec" command ?
+      * if yes we will use level 3 mode, otherwise level 2 mode */
+     write(this->fd, SG_INTERP, strlen(SG_INTERP));
+ 
+     /* discard gdb output till we find the needle SG_VERSION
+      * MAX_BUFFSIZE must be greater than max gdb line length */
+     for (last = (char_u *)gdb_buf; buff + MAX_BUFFSIZE - last > 1; )
+     {
+ 	if ((len = gdb_read(this, last,
+ 			buff + MAX_BUFFSIZE - last, SG_TIMEOUT)) < 0)
+ 	{
+ 	    err = "Unable to read from GDB pseudo tty";
+ 	    goto fail;
+ 	}
+ 	else if (len == 0)	/* needle not found */
+ 	    break;
+ 
+ 	last += len;
+ 	ptr = (char_u *)gdb_buf;
+ 
+ 	/* First step: determine which level, process line by line */
+ 	do
+ 	{
+ 	    if (gdb_cnt >= 2)
+ 		break;
+ 
+             if (*ptr == NL)
+                 ptr++;
+ 
+ 	    if (STRSTR(ptr, "^done") == ptr)
+ 		lvl3_mode = TRUE;
+ 
+ 	    /* the first prompt is newline terminated (count it only once) */
+ 	    if (STRSTR(ptr, "(gdb) ") == ptr
+ 		    && (gdb_cnt == 1 || STRCHR(ptr, NL) != NULL))
+ 		gdb_cnt++;
+ 
+ 	    if (gdb_cnt == 2)
+ 	    {
+ #  ifdef GDB_LVL3_SUPPORT
+ 		/* set annotation level 3 */
+ 		if (lvl3_mode)
+ 		    write(this->fd, SG_LVL_3, strlen(SG_LVL_3));
+ 		else
+ #   ifdef GDB_LVL2_SUPPORT
+ 		    write(this->fd, SG_LVL_2, strlen(SG_LVL_2));
+ #   else
+ 		{
+ 		    err = "This |+gdb| version does not support level 2 mode";
+ 		    goto fail;
+ 		}
+ #   endif
+ #  else /* LVL3 */
+ 		lvl3_mode = FALSE;
+ #   ifdef GDB_LVL2_SUPPORT
+ 		/* set annotation level 2 */
+ 		if (! lvl3_mode)
+ 		    write(this->fd, SG_LVL_2, strlen(SG_LVL_2));
+ #   endif
+ #  endif /* LVL3 */
+ 
+ #  ifdef FEAT_GDB   /* Clewn does not need this */
+ 		/* ANO_PMT_FORMORE happen every LPP_LINES and provide us a mean to abort
+ 		 * large output (in get_asm for example or any user cmd) */
+ 		write(this->fd, SG_HEIGHT, strlen(SG_HEIGHT));
+ 		lpp_lines = gdb_itoa(LPP_LINES);
+ 		write(this->fd, (char *)lpp_lines, strlen((char *)lpp_lines));
+ 		write(this->fd, "\n", 1);
+ 		write(this->fd, SG_WIDTH, strlen(SG_WIDTH));
+ 		write(this->fd, SG_EDITING, strlen(SG_EDITING));
+ #  else
+ 		/* number of lines in a page is unlimited */
+ 		write(this->fd, SG_HEIGHT, strlen(SG_HEIGHT));
+ 		lpp_lines = gdb_itoa(0);
+ 		write(this->fd, lpp_lines, strlen(lpp_lines));
+ 		write(this->fd, "\n", 1);
+ 		write(this->fd, SG_WIDTH, strlen(SG_WIDTH));
+ 		write(this->fd, SG_EDITING, strlen(SG_EDITING));
+ 		write(this->fd, " \n", 2); /* avoid Undefined command: "server".  Try "help". */
+ 
+ 		/* `run' commands do input and output on clewn own terminal when possible */
+ 		if (isatty(1) && (tty_name=ttyname(1)) != NULL) {
+ 		    char_u * res = NULL;
+ 
+ 		    gdb_cat(&res, (char_u *)"server tty ");
+ 		    gdb_cat(&res, tty_name);
+ 		    gdb_cat(&res, (char_u *)"\n");
+ 		    write(this->fd, res, STRLEN(res));
+ 		    xfree(res);
+ 		}
+ #  endif
+ 		write(this->fd, SG_VERSION, strlen(SG_VERSION));
+ 	    }
+ 	} while ((ptr = STRCHR(ptr, NL)) != NULL);
+ 
+ 	/* Second step: find the needle, process line by line */
+ 	do
+ 	{
+ 	    if (ptr == NULL)
+ 		break;
+ 
+             if (*ptr == NL)
+                 ptr++;
+ 
+ 	    /* looking for the needle after a prompt */
+ 	    if (this->note == ANO_PROMPT && STRSTR(ptr, SG_VERSION) == ptr)
+ 	    {
+ 		ptr += strlen(SG_VERSION);
+ 		needle = TRUE;
+ 	    }
+ 
+ 	    /* discard post-prompt */
+ 	    if (needle && this->note == ANO_POSTPROMPT)
+ 	    {
+ 		/* store a partial last line for later parse_output */
+                 if ((line = (char_u *)strrchr(gdb_buf, (int)NL)) != NULL
+                         && *(line + 1) != NUL)
+                 {
+                     xfree(this->line);
+                     this->line = (char_u *)clewn_strsave((char *)(line + 1));
+                     this->annoted = TRUE;
+                 }
+ 
+ 		if (lvl3_mode)
+ #  ifdef GDB_LVL3_SUPPORT
+ 		{
+ #   ifdef FEAT_GDB
+ 		    gdb_popup_console(this);
+ #   endif
+ 
+ 		    this->syntax = TRUE;	/* force syntax highlite */
+ #   ifdef FEAT_GDB
+ 		    gdb_write_buf(this, (char_u *)SG_INTRO_3, TRUE);
+ #   else
+ 		    sprintf(tmp, SG_INTRO_3, this->version);
+ 		    gdb_write_buf(this, tmp, TRUE);
+ #   endif
+ 		    this->syntax = FALSE;
+ 
+ #   ifdef FEAT_GDB  /* write unconditionally with Clewn */
+ 		    /* write the remaining part and display it */
+ 		    if (*ptr != NUL)
+ #   endif
+ 			gdb_write_buf(this, ptr, TRUE);
+ 
+ #   ifdef FEAT_GDB
+ 		    /* redraw gdb console window when displayed */
+ 		    gdb_redraw(this->buf);
+ #   endif
+ 
+ 		    gdb_lvl3_init(this);
+ 		}
+ #  else
+ 		{
+ 		    err = "This |+gdb| version does not support level 3 mode";
+ 		    goto fail;
+ 		}
+ #  endif
+ 		else
+ #  ifdef GDB_LVL2_SUPPORT
+ 		{
+ #   ifdef FEAT_GDB
+ 		    gdb_popup_console(this);
+ #   endif
+ 
+ 		    this->syntax = TRUE;	/* force syntax highlite */
+ 		    gdb_write_buf(this, (char_u *)SG_INTRO_2, TRUE);
+ 		    this->syntax = FALSE;
+ 
+ #   ifdef FEAT_GDB   /* write unconditionally with Clewn */
+ 		    /* write the remaining part and display it */
+ 		    if (*ptr != NUL)
+ #   endif
+ 			gdb_write_buf(this, ptr, TRUE);
+ 
+ #   ifdef FEAT_GDB
+ 		    /* redraw gdb console window when displayed */
+ 		    gdb_redraw(this->buf);
+ #   endif
+ 
+ 		    gdb_lvl2_init(this);
+ 		}
+ #  else
+ 		{
+ 		    err = "This |+gdb| version does not support level 2 mode";
+ 		    goto fail;
+ 		}
+ #  endif
+ 		if (tty_name)
+ 		    fprintf(stderr, "`run' commands do input and output on the terminal %s\n", tty_name);
+ 
+ 		return OK;
+ 	    }
+ 	} while ((ptr = parse_note(this, ptr)) != NULL);
+ 
+ 	/* left shift buffer to last start of line */
+ 	if ((ptr = (char_u *)strrchr((char *)gdb_buf, (int)NL)) != NULL)
+ 	{
+ 	    len = STRLEN(ptr + 1);
+ 	    clewn_memmove(gdb_buf, ptr + 1, len);
+ 	    last = (char_u *)gdb_buf + len;
+ 	}
+     }
+ 
+ #  ifdef GDB_LVL2_SUPPORT
+     /* could not find the needle: hope for the best and fall back 
+      * to annotation level 2 and send version again */
+     write(this->fd, SG_LVL_2, strlen(SG_LVL_2));
+     write(this->fd, SG_VERSION, strlen(SG_VERSION));
+ #   ifdef FEAT_GDB
+     gdb_popup_console(this);
+ #   endif
+ 
+     this->syntax = TRUE;	/* force syntax highlite */
+     gdb_write_buf(this, (char_u *)SG_INTRO_2, TRUE);
+     this->syntax = FALSE;
+ 
+     gdb_lvl2_init(this);
+     return OK;
+ #  else
+     err = "This |+gdb| version does not support level 2 mode";
+     goto fail;
+ #  endif
+ fail:
+     gdb_close(this);
+ 
+     if (err != NULL)
+ 	EMSG(_(err));
+ 
+     return FAIL;
+ }
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ /* Print a value in a netbeans balloon */
+ #   define PRINT_VALUE	    "^done,value=\""
+     char *
+ gdb_print_value(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+ #   ifdef HAVE_CLEWN
+     char_u * res = NULL;
+     char_u * ptr;
+     char_u * quote;
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->balloon_txt != NULL) {
+ 		obstack_strcat(obs, "server interpreter-exec mi \"-data-evaluate-expression ");
+ 		obstack_strcat(obs, this->balloon_txt);
+ 		obstack_strcat0(obs, "\"\n");
+ 
+ 		FREE(this->lvl3.result);
+ 		return (char_u *)obstack_finish(obs);
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (this->lvl3.result != NULL
+ 		    && (ptr = STRSTR(this->lvl3.result, PRINT_VALUE)) != NULL
+ 		    && (ptr += strlen(PRINT_VALUE))
+ 		    && (quote = (char_u *)strrchr(ptr, '"')) != NULL)
+ 	    {
+ 		*quote = NUL;
+ 		obstack_strcat(obs, "\" ");
+ 		obstack_strcat(obs, this->balloon_txt);
+ 		obstack_strcat(obs, " = ");
+ 		obstack_strcat(obs, ptr);
+ 		obstack_strcat0(obs, " \"");
+ 
+ 		res = (char_u *)obstack_finish(obs);
+ 		gdb_showBalloon(res, obs);
+ 	    }
+ 
+ 	    FREE(this->balloon_txt);
+ 	    FREE(this->lvl3.result);
+ 	    break;
+     }
+ #   endif   /* HAVE_CLEWN*/
+     return NULL;
+ }
+ #  endif    /* GDB_LVL3_SUPPORT */
+ 
+ /* Get instruction at $pc */
+     char *
+ gdb_get_pc(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *ptr;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    FREE(this->pc);
+ 
+ 	    if (this->state & GS_STOPPED)
+ 	    {
+ 		this->state &= ~GS_STOPPED;
+ 		return "server x/i $pc\n";
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    if ((this->pc = gdb_regexec(line, PAT_ADD, 1, NULL)) != NULL)
+ 	    {
+ 		/* Replace TAB with a space */
+ 		for (ptr = line; *ptr != NUL; ptr++)
+ 		    if (*ptr == TAB)
+ 			*ptr = ' ';
+ 
+ 		gdb_status(this, line, obs);
+ 	    }
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /* Get frame info */
+     char *
+ gdb_get_frame(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res = NULL;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    FREE(this->oob_result);
+ 	    return "server frame\n";
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->oob_result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->oob_result);
+ 	    this->oob_result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    xfree(this->frame_pc);
+ 	    if (this->oob_result != NULL
+ 		    && (this->frame_pc = gdb_regexec(this->oob_result, PAT_FRAME, 1, NULL)) != NULL) {
+ 		xfree(this->asm_add);
+ 		this->asm_add = (char_u *)clewn_strsave((char *)this->frame_pc);
+ 	    }
+ 	    else {
+ 		if (this->pc != NULL) {
+ 		    this->frame_pc = (char_u *)clewn_strsave((char *)this->pc);
+ 		    xfree(this->asm_add);
+ 		    this->asm_add = (char_u *)clewn_strsave((char *)this->frame_pc);
+ 		}
+ 	    }
+ 
+ 	    FREE(this->oob_result);
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ /* Stack info frame */
+     char *
+ gdb_info_frame(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res = NULL;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    FREE(this->lvl3.result);
+ 	    return "server info frame\n";
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    this->frame_curlvl = -1;
+ 	    if (this->lvl3.result != NULL
+ 		    && (res = gdb_regexec(this->lvl3.result, PAT_INFO_FRAME, 1, NULL)) != NULL) {
+ 		this->frame_curlvl = atoi((char *)res);
+ 		xfree(res);
+ 	    }
+ 
+ 	    FREE(this->lvl3.result);
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ #   define SOURCE_FILENAME  "\",file=\""
+ #   define SOURCE_LINENUM   "\",line=\""
+ /* Change frame highlight according to new frame level */
+     char *
+ gdb_stack_frame(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u * res = NULL;
+     int rc	 = -1;
+     char tmp[32];
+     char_u * fname;
+     char_u * pnum;
+     char_u * quote;
+     char_u * ptr;
+     linenr_T lnum;
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    /* get info about frame_curlvl:
+ 	     * ^done,stack=[frame={level="1",addr="0x080483bb",func="main",file="cltest_main.c",line="12"}] */
+ 	    if (this->frame_curlvl >= 0) {
+ 		FREE(this->lvl3.result);
+ 
+ 		sprintf(tmp, "%d %d", this->frame_curlvl, this->frame_curlvl);
+ 		obstack_strcat(obs, "server interpreter-exec mi \"-stack-list-frames ");
+ 		obstack_strcat(obs, tmp);
+ 		obstack_strcat0(obs, "\"\n");
+ 		return (char *)obstack_finish(obs);
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (this->lvl3.result != NULL
+ 		    && (ptr = STRSTR(this->lvl3.result, SOURCE_FILENAME)) != NULL
+ 		    && (pnum = STRSTR(this->lvl3.result, SOURCE_LINENUM)) != NULL)
+ 	    {
+ 		pnum += strlen(SOURCE_FILENAME);
+ 		lnum = atoi((char *)pnum);
+ 
+ 		ptr += strlen(SOURCE_FILENAME);
+ 
+ 		if ((quote = STRCHR(ptr, '"')) != NULL) {
+ 		    fname = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+ 
+ 		    rc = 0;
+ 
+ 		    /* set frame sign only if this is a new fname/lnum position */
+ 		    if (this->frame_fname == NULL
+ 			    || STRCMP(this->frame_fname, fname) != 0 || this->frame_lnum != lnum) {
+ 			FREE(this->frame_fname);
+ 			this->frame_fname = (char_u *)clewn_strsave((char *)fname);
+ 			this->frame_lnum = lnum;
+ 			rc = gdb_fr_set(this, fname, &lnum, obs);
+ 		    }
+ 		}
+ 	    }
+ 
+ 	    if (rc != 0 && p_asm != 0)
+ 		this->pool.hilite = TRUE;   /* do asm frame highliting */
+ 	    FREE(this->lvl3.result);
+ 	    break;
+     }
+     return NULL;
+ }
+ #  endif /* GDB_LVL3_SUPPORT */
+ 
+ /* Get symbol file name */
+     char *
+ gdb_get_sfile(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res = NULL;
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    return "server info target\n";
+ 
+ 	case OOB_COLLECT:
+ 	    if (this->oob.cnt == 1
+ 		    && (res = gdb_regexec(line, PAT_SFILE, 1, obs)) != NULL
+ 		    && (this->sfile == NULL || STRCMP(res, this->sfile) != 0))
+ 	    {
+ 		gdb_status(this, (char_u *)"new symbols", obs);
+ 		xfree(this->sfile);
+ 		this->sfile = (char_u *)clewn_strsave((char *)res);
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (this->oob.cnt == 0)
+ 	    {
+ 		gdb_status(this, (char_u *)"empty target", obs);
+ 		FREE(this->sfile);
+ 	    }
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /* Get GDB source directories */
+     char *
+ gdb_get_sourcedir(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res = NULL;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    FREE(this->lvl3.result);
+ 	    return "server show directories\n";
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (this->lvl3.result != NULL)
+ 	    {
+ 		xfree(this->directories);
+ 		this->directories = gdb_regexec(this->lvl3.result, PAT_DIR, 1, NULL);
+ 		FREE(this->lvl3.result);
+ 	    }
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ #ifdef GDB_LVL3_SUPPORT
+ # ifndef FEAT_GDB
+ /* Source the project file */
+     char *
+ gdb_source_project(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->project_file != NULL
+ 		    && cnb_state()
+ 		    && this->project_state == PROJ_SOURCEIT)
+ 	    {
+ 		this->project_state = PROJ_DONE;
+ 		fprintf(stderr, "source %s\n", this->project_file);
+ 
+ 		if (this->sfile != NULL)
+ 		    fprintf(stderr, "Warning: symbol table \"%s\" was loaded before sourcing the project file\n", this->sfile);
+ 
+ 		obstack_strcat(obs, "server source ");
+ 		obstack_strcat(obs, this->project_file);
+ 		obstack_strcat0(obs, "\n");
+ 		return (char_u *)obstack_finish(obs);
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    if (line != NULL)
+ 		fprintf(stderr, "%s\n", line);
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    /* force getting the source file list from gdb */
+ 	    this->lvl3.get_source_list = TRUE;
+ 
+ 	    /* this is required after 'restart' to display the gdb prompt */
+ 	    fprintf(stderr, this->prompt);
+ 	    break;
+     }
+ 
+     return NULL;
+ }
+ 
+ #   define CWD_VALUE	"^done,cwd=\""
+ /* Get current working directory */
+     char *
+ gdb_get_pwd(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u * res = NULL;
+     char_u * ptr;
+     char_u * quote;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->mode != GDB_MODE_LVL2) {
+ 		FREE(this->lvl3.result);
+ 		return "server interpreter-exec mi \"-environment-pwd\"\n";
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (this->lvl3.result != NULL
+ 		    && (ptr = STRSTR(this->lvl3.result, CWD_VALUE)) != NULL
+ 		    && (ptr += strlen(CWD_VALUE))
+ 		    && (quote = (char_u *)strrchr(ptr, '"')) != NULL)
+ 	    {
+ 		*quote = NUL;
+ 		gdb_cat(&res, (char_u *)"cd ");
+ 		gdb_cat(&res, ptr);
+ 		gdb_cat(&res, (char_u *)"\n");
+ 		xfree(this->pwd);
+ 		this->pwd = res;
+ 	    }
+ 
+ 	    FREE(this->lvl3.result);
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ #   define ARGS_VALUE	"Argument list to give program being debugged when it is started is \""
+ /* Get args */
+     char *
+ gdb_get_args(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u * res = NULL;
+     char_u * ptr;
+     char_u * quote;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    FREE(this->lvl3.result);
+ 	    return "server show args\n";
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (this->lvl3.result != NULL
+ 		    && (ptr = STRSTR(this->lvl3.result, ARGS_VALUE)) != NULL
+ 		    && (ptr += strlen(ARGS_VALUE))
+ 		    && (quote = (char_u *)strrchr(ptr, '"')) != NULL)
+ 	    {
+ 		*quote = NUL;
+ 		gdb_cat(&res, "set args ");
+ 		gdb_cat(&res, ptr);
+ 		gdb_cat(&res, "\n");
+ 		xfree(this->args);
+ 		this->args = res;
+ 	    }
+ 
+ 	    FREE(this->lvl3.result);
+ 	    break;
+     }
+     return NULL;
+ }
+ # endif
+ 
+ /* Get GDB current source file */
+     char *
+ gdb_source_cur(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res = NULL;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    FREE(this->lvl3.source_cur);
+ 	    return "server interpreter-exec mi \"-file-list-exec-source-file\"\n";
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.source_cur);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.source_cur);
+ 	    this->lvl3.source_cur = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /* Get GDB current source file */
+     char *
+ gdb_source_list(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res = NULL;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->lvl3.get_source_list || this->lvl3.source_list == NULL) {
+ 		FREE(this->lvl3.source_list);
+ 		this->lvl3.get_source_list = FALSE;
+ 		return "server interpreter-exec mi \"-file-list-exec-source-files\"\n";
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.source_list);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.source_list);
+ 	    this->lvl3.source_list = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    break;
+     }
+     return NULL;
+ }
+ #endif /* GDB_LVL3_SUPPORT */
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ #   define BKPT_RECORD	"bkpt={number=\""
+ #   define BKPT_ADDR	"\",addr=\""
+ /*
+  * When a breakpoint is being set and asm option is on, get the
+  * instruction address of the last breakpoint, the one being set.
+  * This address is used in get_asm() to disassemble the function
+  * containing this address.
+  */
+     static char *
+ get_lastbp(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res    = NULL;
+     int found      = FALSE;
+     char_u *record = NULL;
+     char_u *ptr;
+     char_u *addr;
+     bpinfo_T *p;
+     int bp_num;
+ 
+     if (obs) {}	    /* keep compiler happy */
+ 
+     switch (state)
+     {
+ 	case OOB_CMD:
+ 	    /* GDB sends sometimes ANO_BP_INVALID when stepping, even
+ 	     * though no breakpoints have been changed.
+ 	     * Avoid checking for last bp in this case, because this
+ 	     * may cause hiliting a bp in a new buffer when what is
+ 	     * expected is a new frame */
+ 	    if (this->bp_state & BPS_FR_INVALID)
+ 		return NULL;
+ 
+ 	    /* A breakpoint is being set in assembly */
+ 	    if (p_asm != 0 && (this->bp_state & BPS_INVALID)
+ 		    && (this->bp_state & BPS_BP_SET))
+ 	    {
+ 		this->bp_state &= ~BPS_BP_SET;
+ 		FREE(this->lvl3.result);
+ 
+ 		/* fetch GDB bp table info */
+ 		return "server interpreter-exec mi -break-list\n";
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if ((ptr = this->lvl3.result) != NULL)
+ 	    {
+ 		/* search for last record in breakpoint table */
+ 		do
+ 		{
+ 		    if ((ptr = STRSTR(ptr, BKPT_RECORD)) != NULL)
+ 		    {
+ 			record = ptr;
+ 			ptr++;
+ 		    }
+ 		}
+ 		while (ptr != NULL);
+ 
+ 		/* last record */
+ 		if (record != NULL
+ 			&& (bp_num = atoi((char *)(record + strlen(BKPT_RECORD)))) > 0)
+ 		{
+ 		    /* look it up in bpinfo list */
+ 		    for (p = this->bpinfo; p != NULL; p = p->next)
+ 		    {
+ 			if (bp_num == p->id)
+ 			{
+ 			    found = TRUE;
+ 			    break;
+ 			}
+ 		    }
+ 
+ 		    /* not found: set asm_add so that get_asm will
+ 		     * do the disassembling */
+ 		    if (! found && (addr = STRSTR(record, BKPT_ADDR)) != NULL)
+ 		    {
+ 			xfree(this->asm_add);
+ 			this->asm_add =
+ 			    gdb_regexec(addr + strlen(BKPT_ADDR), PAT_ADD, 1, NULL);
+ 		    }
+ 		}
+ 
+ 		FREE(this->lvl3.result);
+ 	    }
+ 	    break;
+     }
+     return NULL;
+ }
+ #  endif /* GDB_LVL3_SUPPORT */
+ 
+ /* Get the function name corresponding to asm_add */
+     char *
+ gdb_get_asmfunc(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->asm_add != NULL)
+ 	    {
+ 		obstack_strcat(obs, "server info symbol 0x");
+ 		obstack_strcat(obs, this->asm_add);
+ 		obstack_strcat0(obs, "\n");
+ 		return (char *)obstack_finish(obs);
+ 	    }
+ 	    FREE(this->asm_func);
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    xfree(this->asm_func);
+ 	    this->asm_func = gdb_regexec(line, PAT_ASM_FUNC, 1, NULL);
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ /*
+  * This function is a hack to fix errors occuring in GDB command
+  * "info symbol ADDR" that sometimes cannot find the symbol corresponding to
+  * a given ADDR, when GDB command "print/a ADDR" can.
+  * "print/a ADDR" is used as a last resort because it changes the value history.
+  * "output/a ADDR" does not change the value history, but the output of this
+  * command misses a newline.
+  */
+     char *
+ gdb_get_asmfunc_hack(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     switch(state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->asm_add != NULL && this->asm_func == NULL)
+ 	    {
+ 		obstack_strcat(obs, "server print/a 0x");
+ 		obstack_strcat(obs, this->asm_add);
+ 		obstack_strcat0(obs, "\n");
+ 		return (char *)obstack_finish(obs);
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    xfree(this->asm_func);
+ 	    this->asm_func = gdb_regexec(line, PAT_ASM_FUNC_P, 1, NULL);
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ #  define ASM_ABORTED "DISASSEMBLY ABORTED"
+ 
+ /*
+  * Disassemble new function containing asm_add and highlight asm_add
+  * if this->pool.hilite is TRUE
+  */
+     char *
+ gdb_get_asm(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ #  ifdef FEAT_GDB
+ {
+     buf_T *buf = this->pool.buf[this->pool.idx];
+     buf_T *oldbuf = curbuf;
+     char_u *res = NULL;
+     int oldest  = 0;
+     int age	= 0;
+     linenr_T lnum;
+     win_T *win;
+     int i;
+ 
+     if (p_asm == 0)
+     {
+ 	FREE(this->asm_add);
+ 	return NULL;
+     }
+ 
+     lnum = (buf != NULL ? BUFLASTL(buf) : 0);
+ 
+     switch (state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->asm_add != NULL && !gdb_as_frset(this, obs))
+ 	    {
+ 		/* pickup least recent buffer */
+ 		for (i = this->pool.max; i > 0; )
+ 		{
+ 		    i--;
+ 		    if (this->pool.age[i] >= age && this->pool.buf[i] != NULL)
+ 		    {
+ 			age = this->pool.age[i];
+ 			oldest = i;
+ 		    }
+ 		}
+ 
+ 		/* no buffers in pool */
+ 		if ((buf = this->pool.buf[oldest]) == NULL)
+ 		{
+ 		    this->pool.hilite = FALSE;
+ 		    FREE(this->asm_add);
+ 		    return NULL;
+ 		}
+ 		this->pool.idx = oldest;
+ 
+ 		/* clear the buffer */
+ 		gdb_clear_asmbuf(this, buf);
+ 
+ 		/* init msg_busy */
+ 		obstack_strcat(obs, "Disassembling 0x");
+ 		obstack_strcat0(obs, this->asm_add);
+ 		res = (char_u *)obstack_finish(obs);
+ 		gdb_msg_busy(res);
+ 
+ 		/* send cmd */
+ 		obstack_strcat(obs, "server disassemble 0x");
+ 		obstack_strcat(obs, this->asm_add);
+ 		obstack_strcat0(obs, "\n");
+ 		return (char *)obstack_finish(obs);
+ 	    }
+ 	    this->pool.hilite = FALSE;
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    if (buf == NULL)
+ 		return NULL;
+ 	    curbuf = buf;
+ 
+ 	    /* concatenate with line after an annotation
+ 	     * and replace line, otherwise add */
+ 	    if (this->line != NULL && this->annoted)
+ 	    {
+ 		obstack_strcat(obs, this->line);
+ 		obstack_strcat0(obs, line);
+ 		line = (char_u *)obstack_finish(obs);
+ 		ml_delete(lnum--, FALSE);
+ 	    }
+ 
+ 	    /* first line: remove empty line after the inserted one */
+ 	    if (ml_append(lnum, line, 0, 0) == OK && lnum == 0)
+ 		ml_delete(buf->b_ml.ml_line_count, FALSE);
+ 	    curbuf = oldbuf;
+ 
+ 	    if ((this->oob.cnt % 1000) == 0)
+ 		gdb_msg_busy(NULL);
+ 
+ 	    xfree(this->line);
+ 	    this->line = (char_u *)clewn_strsave((char *)line);
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (buf == NULL)
+ 		return NULL;
+ 	    curbuf = buf;
+ 
+ 	    if (this->oob.state & OS_INTR)
+ 	    {
+ 		if (lnum >= 1 && STRCMP(ASM_ABORTED, ml_get(1)) != 0)
+ 		{
+ 		    /* Clear buffer when interrupted */
+ 		    while (lnum-- > 0)
+ 			ml_delete(buf->b_ml.ml_line_count, FALSE);
+ 
+ 		    ml_append(0, (char_u *)ASM_ABORTED, 0, 0);
+ 		    lnum = buf->b_ml.ml_line_count;
+ 		    changed_lines(1, 0, lnum, lnum);
+ 		    curbuf = oldbuf;
+ 
+ 		    this->pool.age[this->pool.idx] = ASM_OLD;
+ 		    gdb_edit_file(this, buf, NULL, 1, obs);
+ 		}
+ 
+ 		/* write the prompt */
+ 		gdb_write_buf(this, this->line, TRUE);
+ 		gdb_redraw(buf);
+ 	    }
+ 	    else
+ 	    {
+ 		changed_lines(1, 0, lnum, lnum);
+ 
+ 		/* set buffer name to function name */
+ 		if (this->asm_func != NULL)
+ 		{
+ 		    obstack_strcat(obs, this->asm_func);
+ 		    obstack_strcat0(obs, "-asm");
+ 		    res = (char_u *)obstack_finish(obs);
+ 		    gdb_as_setname(res);
+ 		}
+ 		curbuf = oldbuf;
+ 
+ 		/* highlite $asm_add and update window if displayed */
+ 		if (! gdb_as_frset(this, obs) && (win = gdb_btowin(buf)) != NULL)
+ 		{
+ 		    gdb_set_cursor(win, 1);
+ 		    redraw_win_later(win, NOT_VALID);
+ 		}
+ 	    }
+ 
+ 	    msg_clr_cmdline();
+ 	    FREE(this->asm_add);
+ 	    this->pool.hilite = FALSE;
+ 	    break;
+     }
+     return NULL;
+ }
+ #  else
+ {
+     char_u *res  = NULL;
+     char_u *fname;
+ 
+     if (p_asm == 0)
+     {
+ 	FREE(this->asm_add);
+ 	return NULL;
+     }
+ 
+     switch (state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->asm_add != NULL && ! gdb_as_frset(this, obs))
+ 	    {
+ 		FREE(this->pool.name);
+ 
+ 		/* get a unique file name for this disassembled function
+ 		 * and open the file for creation
+ 		 * the file name suffix is '.clasm' so that it can be set
+ 		 * to 'autoread' by the runtime file clewn.vim */
+ 		if (this->asm_func != NULL) {
+ 		    obstack_strcat(obs, this->asm_func);
+ 		    obstack_strcat0(obs, ".clasm");
+ 		    fname = (char_u *)obstack_finish(obs);
+ 		}
+ 		if (this->asm_func == NULL || (this->pool.fd = clewn_opentmpfile(fname,
+ 			&(this->pool.name), 1)) == NULL)
+ 		{
+ 		    this->pool.hilite = FALSE;
+ 		    return NULL;
+ 		}
+ 		this->pool.line_offset = 0L;
+ 
+ 		/* create the buffer */
+ 		if ((this->pool.buf = cnb_create_buf(this->pool.name)) == -1)
+ 		{
+ 		    this->pool.hilite = FALSE;
+ 
+ 		    fclose(this->pool.fd);
+ 		    this->pool.fd = NULL;
+ 		    if (this->pool.name != NULL)
+ 			(void)unlink(this->pool.name);
+ 		    FREE(this->pool.name);
+ 		    return NULL;
+ 		}
+ 
+ 		/* init msg_busy */
+ 		obstack_strcat(obs, "Disassembling 0x");
+ 		obstack_strcat0(obs, this->asm_add);
+ 		res = (char_u *)obstack_finish(obs);
+ 		gdb_msg_busy(res);
+ 
+ 		/* send cmd */
+ 		this->lastline = 0;
+ 		obstack_strcat(obs, "server disassemble 0x");
+ 		obstack_strcat(obs, this->asm_add);
+ 		obstack_strcat0(obs, "\n");
+ 		return (char_u *)obstack_finish(obs);
+ 	    }
+ 	    this->pool.hilite = FALSE;
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    if (this->pool.fd == NULL)
+ 		goto fail;
+ 
+ 	    /* ignore when interrupted */
+ 	    if (this->oob.state & OS_INTR)
+ 		return NULL;
+ 
+ 	    /* concatenate with line after an annotation
+ 	     * and replace line, otherwise add */
+ 	    if (this->line != NULL && this->annoted)
+ 	    {
+ 		obstack_strcat(obs, this->line);
+ 		obstack_strcat0(obs, line);
+ 		line = (char_u *)obstack_finish(obs);
+ 
+ 		this->lastline--;
+ 		if (fseek(this->pool.fd, this->pool.line_offset, SEEK_SET) != 0)
+ 		    goto fail;
+ 	    }
+ 
+ 	    /* write a newline except at first line */
+ 	    if (this->lastline != 0)
+ 	    {
+ 		if ((this->pool.line_offset = ftell(this->pool.fd)) == -1
+ 			|| fputs("\n", this->pool.fd) < 0)
+ 		    goto fail;
+ 	    }
+ 	    this->lastline++;
+ 
+ 	    /* write the line */
+ 	    if (fputs(line, this->pool.fd) < 0)
+ 		goto fail;
+ 
+ 	    if ((this->oob.cnt % 400) == 0)
+ 		gdb_msg_busy(NULL);
+ 
+ 	    xfree(this->line);
+ 	    this->line = (char_u *)clewn_strsave((char *)line);
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if (this->pool.fd == NULL)
+ 		goto fail;
+ 
+ 	    if (this->oob.state & OS_INTR)
+ 	    {
+ 		FREE(this->asm_add);
+ 		this->pool.hilite = FALSE;
+ 		goto fail;
+ 	    }
+ 	    else
+ 	    {
+ 		/* highlite $asm_add */
+ 		(void)gdb_as_frset(this, obs);
+ 
+ 		/* write last new line */
+ 		if (fputs("\n", this->pool.fd) < 0)
+ 		    goto fail;
+ 
+ 		/* clear the line */
+ 		gdb_msg_busy("FIN");
+ 
+ 		/* set the buffer as an asm buffer */
+ 		cnb_set_asm(this->pool.buf);
+ 	    }
+ 
+ 	    FREE(this->asm_add);
+ 
+ 	    this->pool.buf = -1;
+ 	    fclose(this->pool.fd);
+ 	    this->pool.fd = NULL;
+ 	    FREE(this->pool.name);
+ 	    this->pool.hilite = FALSE;
+ 	    break;
+     }
+     return NULL;
+ fail:
+     /* clear the line */
+     gdb_msg_busy("FIN");
+ 
+     cnb_kill(this->pool.buf);
+     this->pool.buf = -1;
+ 
+     if (this->pool.fd != NULL)
+ 	fclose(this->pool.fd);
+     this->pool.fd = NULL;
+ 
+     if (this->pool.name != NULL)
+ 	(void)unlink(this->pool.name);
+     FREE(this->pool.name);
+     return NULL;
+ }
+ #  endif /* FEAT_GDB */
+ 
+ #  ifdef GDB_LVL3_SUPPORT
+ /*
+  * Get the breakpoints info record table.
+  */
+     static char *
+ get_bp(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+     char_u *res    = NULL;
+     char_u *record = NULL;
+     char_u *ptr;
+     bpinfo_T *p;
+ 
+     switch (state)
+     {
+ 	case OOB_CMD:
+ 	    /* gdb 6.4 does not provide anymore the right annotations for breakpoints
+ 	     * when in level 3 (note that they are still there when setting annotate
+ 	     * level 2, I thought level 2 was deprecated, what a zoo !), so we look
+ 	     * for new or changed breakpoints systematically now */
+ 	    if (this->mode == GDB_MODE_LVL3)
+ 		this->bp_state = BPS_INVALID;
+ 
+ 	    /* When an ANO_BP_INVALID annotation has been received,
+ 	     * or when we are stepping (more accurately: got a new frame):
+ 	     * fetch bp table */
+ 	    if (this->bp_state & BPS_INVALID || this->bp_state & BPS_FR_INVALID)
+ 	    {
+ 		FREE(this->lvl3.result);
+ 		this->bufIsChanged = FALSE;
+ 
+ 		/* handle case where an error occured last time */
+ 		FREE(this->record);
+ 		gdb_free_bplist(&(this->tmplist));
+ 
+ 		/* fetch GDB bp table info */
+ 		return "server interpreter-exec mi -break-list\n";
+ 	    }
+ 
+ 	    this->bp_state &= ~BPS_INVALID;
+ 	    this->bp_state &= ~BPS_FR_INVALID;
+ 	    this->bp_state &= ~BPS_BP_HIT;
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ 	    if ((ptr = this->lvl3.result) != NULL)
+ 	    {
+ 		/* process all records except last */
+ 		do
+ 		{
+ 		    if ((ptr = STRSTR(ptr, BKPT_RECORD)) != NULL
+ 			    && ptr > this->lvl3.result)
+ 		    {
+ 			*(ptr - 1) = NUL;
+ 			if (record != NULL)
+ 			    process_record(this, record, obs);
+ 
+ 			record = ptr;
+ 			ptr++;
+ 		    }
+ 		}
+ 		while (ptr != NULL);
+ 
+ 		/* process last  record */
+ 		if (record != NULL)
+ 		    process_record(this, record, obs);
+ 
+ 		FREE(this->record);
+ 
+ 		/* All records left in the old table are breakpoints that have
+ 		 * been deleted: delete the corresponding highliting sign */
+ 		for (p = this->bpinfo; p != NULL; p = p->next)
+ 		    gdb_unlite(BP_SIGN_ID(p->id));
+ 
+ 		this->bp_state &= ~BPS_INVALID;
+ 		this->bp_state &= ~BPS_FR_INVALID;
+ 		this->bp_state &= ~BPS_BP_HIT;
+ 
+ 		/* replace with new table */
+ 		gdb_free_bplist(&(this->bpinfo));
+ 		this->bpinfo = this->tmplist;
+ 		this->tmplist = NULL;
+ 
+ 		FREE(this->lvl3.result);
+ 	    }
+ 	    break;
+     }
+     return NULL;
+ }
+ 
+ #   define BKPT_ENABLED	    "\",enabled=\""
+ #   define BKPT_DISP	    "\",disp=\""
+ #   define BKPT_SCRIPT	    "\",script={"
+ #   define BKPT_TYPE	    "\",type=\"breakpoint\""
+ #   define BKPT_LINE	    "\",line=\""
+ #   define BKPT_SOURCE	    "\",file=\""
+ #   define BKPT_AT	    "\",at=\"<"
+ /* Process the current info record */
+     static void
+ process_record(this, record, obs)
+     gdb_T *this;
+     char_u *record;
+     struct obstack *obs;
+ {
+     char_u *bp_add    = NULL;
+     char_u *bp_line   = NULL;
+     char_u *bp_source = NULL;
+     char_u *bp_at     = NULL;
+     char_u *ptr;
+     char_u *end;
+     char_u *quote;
+     char_u *plus;
+ 
+     /* allocate a new record or reuse an existing one
+      * and initialize its fields */
+     if (this->record == NULL)
+ 	this->record = (bpinfo_T *)xcalloc(sizeof(bpinfo_T));
+ 
+     this->record->id		= -1;
+     this->record->enabled	= TRUE;
+ #   ifdef BP_INVALID_ANO_MISSING
+     this->record->disposition	= TRUE;
+ #   endif
+     this->record->cont		= FALSE;
+ #   ifdef FEAT_GDB
+     this->record->buf		= NULL;
+ #   else
+     this->record->buf		= -1;
+     this->record->typenr_en	= -1;
+     this->record->typenr_dis	= -1;
+ #   endif
+     this->record->lnum		= 0;
+     this->record->next		= NULL;
+ 
+     /* breakpoint number */
+     this->record->id = atoi((char *)(record + strlen(BKPT_RECORD)));
+ 
+     /* enabled state */
+     if ((ptr = STRSTR(record, BKPT_ENABLED)) != NULL
+ 	    && *(ptr + strlen(BKPT_ENABLED)) == 'n')
+ 	this->record->enabled = FALSE;
+ 
+ #   ifdef BP_INVALID_ANO_MISSING
+     /* disposition */
+     if ((ptr = STRSTR(record, BKPT_DISP)) != NULL
+ 	    && STRSTR(ptr + strlen(BKPT_DISP), "keep") == NULL)
+ 	this->record->disposition = FALSE;
+ #   endif
+ 
+     /* parse script for 'continue' as last statement */
+     if ((ptr = STRSTR(record, BKPT_SCRIPT)) != NULL)
+     {
+ 	ptr += strlen(BKPT_SCRIPT);
+ 	if ((end = STRCHR(ptr, '}')) != NULL)
+ 	{
+ 	    while ((ptr = STRCHR(ptr, '"')) != NULL && ptr < end)
+ 	    {
+ 		ptr++;
+ 		if (gdb_regexec(ptr, PAT_BP_CONT, 1, obs) != NULL
+ 			|| gdb_regexec(ptr, PAT_BP_CONT, 2, obs) != NULL)
+ 		{
+ 		    this->record->cont = TRUE;    /* continue */
+ 		    break;
+ 		}
+ 	    }
+ 	}
+     }
+ 
+     /* sanity check and discard watchpoints and others */
+     if (this->record->id <= 0 || STRSTR(record, BKPT_TYPE) == NULL)
+ 	return;
+ 
+     /* address */
+     if ((ptr = STRSTR(record, BKPT_ADDR)) != NULL)
+ 	bp_add = gdb_regexec(ptr + strlen(BKPT_ADDR), PAT_ADD, 1, obs);
+ 
+     /* line */
+     if ((ptr = STRSTR(record, BKPT_LINE)) != NULL)
+     {
+ 	ptr += strlen(BKPT_LINE);
+ 	if ((quote = STRCHR(ptr, '"')) != NULL)
+ 	    bp_line = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+     }
+ 
+     /* source */
+     if ((ptr = STRSTR(record, BKPT_SOURCE)) != NULL)
+     {
+ 	ptr += strlen(BKPT_SOURCE);
+ 	if ((quote = STRCHR(ptr, '"')) != NULL)
+ 	    bp_source = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+     }
+ 
+     /* at */
+     if ((ptr = STRSTR(record, BKPT_AT)) != NULL)
+     {
+ 	ptr += strlen(BKPT_AT);
+ 	if ((quote = STRCHR(ptr, '>')) != NULL)
+ 	{
+ 	    if ((plus = STRCHR(ptr, '+')) != NULL && plus < quote)
+ 		bp_at = (char_u *)obstack_copy0(obs, ptr, (plus - ptr));
+ 	    else
+ 		bp_at = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+ 	}
+     }
+ 
+     gdb_process_record(this, bp_add, bp_at, bp_line, bp_source, obs);
+ }
+ 
+ /* Update the variables objects and the variables window */
+     static char *
+ varobj_update(this, state, line, obs)
+     gdb_T *this;
+     int state;
+     char_u *line;
+     struct obstack *obs;
+ {
+ #  ifdef FEAT_GDB
+     char_u *ptrn;
+ #  else
+     static char *result = NULL;	    /* mark the start and end of object operations */
+ #  endif
+     char_u *res  = NULL;
+     varobj_T *obj;
+ 
+     switch (state)
+     {
+ 	case OOB_CMD:
+ 	    if (this->lvl3.varitem == NULL)
+ 	    {
+ 		/* start with first in list */
+ 		this->lvl3.varitem = this->lvl3.varlist;
+ 		this->lvl3.varnext_cmd = VCMD_INIT;
+ 	    }
+ oob_cmd:
+     /* next OOB_CMD */
+ 	    if ((obj = this->lvl3.varitem) != NULL)
+ 	    {
+ 		FREE(this->lvl3.result);
+ 
+ 		/* create a new object and give it a name */
+ 		if (this->lvl3.varnext_cmd == VCMD_INIT && obj->name == NULL)
+ 		{
+ 		    if (
+ #   ifdef FEAT_GDB
+ 			    this->var_buf != NULL
+ #   else
+ 			    this->var_buf > 0
+ #   endif
+ 		       )
+ 		    {
+ 			if (obj->format != NULL)
+ 			    this->lvl3.varnext_cmd = VCMD_FORMAT;
+ 			else
+ 			    this->lvl3.varnext_cmd = VCMD_PRINT;
+ 
+ 			this->lvl3.varcmd = VCMD_CREATE;
+ 
+ 			obstack_strcat(obs, "server interpreter-exec mi \"-var-create - * (");
+ 			obstack_strcat(obs, obj->expression);
+ 			obstack_strcat0(obs, ")\"\n");
+ 			return (char *)obstack_finish(obs);
+ 		    }
+ 		    else
+ 		    {
+ 			/* remove silently from list */
+ 			remove_object(this, obj);
+ 			goto oob_cmd;
+ 		    }
+ 		}
+ 
+ 		/* sanity check: an object must have a name
+ 		 * this should never occur */
+ 		if (obj->name == NULL)
+ 		{
+ 		    /* silently ignore this error */
+ 		    this->lvl3.varnext_cmd = VCMD_INIT;
+ 		    this->lvl3.varitem = obj->next;
+ 		    goto oob_cmd;
+ 		}
+ 
+ 		/* search for the object in the variables window
+ 		 * if it does not exist, then -var-delete it */
+ 		if (this->lvl3.varnext_cmd == VCMD_INIT)
+ 		{
+ #  ifdef FEAT_GDB
+ 		    pos_T pos;
+ 
+ 		    pos.lnum = 1;
+ 		    pos.col = 0;
+ 
+ 		    obstack_strcat(obs, "^\\s*");
+ 		    obstack_strcat(obs, obj->name);
+ 		    obstack_strcat0(obs, ":");
+ 		    ptrn = (char_u *)obstack_finish(obs);
+ 
+ 		    if (this->var_buf == NULL
+ 			    || (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+ 			    || (searchit(NULL, this->var_buf, &pos,
+ 				    FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) == FAIL))
+ #  else
+ 		    int lnum;
+ 
+ 		    if (this->var_buf <= 0 || cnb_search_obj(obj->name, &lnum) == NULL)
+ #  endif
+ 		    {
+ 			/* not in gdb variables window, delete it */
+ 			this->lvl3.varcmd = VCMD_DELETE;
+ 
+ 			obstack_strcat(obs, "server interpreter-exec mi \"-var-delete var");
+ 			obstack_strcat(obs, obj->name);
+ 			obstack_strcat0(obs, "\"\n");
+ 			return (char *)obstack_finish(obs);
+ 		    }
+ 		}
+ 
+ 		/* list children if any (need to run this cmd before update) */
+ 		if (this->lvl3.varnext_cmd == VCMD_INIT)
+ 		{
+ 		    this->lvl3.varnext_cmd = VCMD_UPDATE;
+ 
+ 		    if (obj->children)
+ 		    {
+ 			this->lvl3.varcmd = VCMD_CHILDREN;
+ 
+ 			obstack_strcat(obs, "server interpreter-exec mi \"-var-list-children var");
+ 			obstack_strcat(obs, obj->name);
+ 			obstack_strcat0(obs, "\"\n");
+ 			return (char *)obstack_finish(obs);
+ 		    }
+ 		}
+ 
+ 		/* set the format */
+ 		if (this->lvl3.varnext_cmd == VCMD_FORMAT)
+ 		{
+ 		    if (obj->format != NULL && STRLEN(obj->format) == 2)
+ 		    {
+ 			obstack_strcat(obs, "server interpreter-exec mi \"-var-set-format var");
+ 			obstack_strcat(obs, obj->name);
+ 
+ 			switch(*(obj->format + 1))
+ 			{
+ 			    case 't':
+ 				obstack_strcat0(obs, " binary\"\n");
+ 				break;
+ 			    case 'd':
+ 				obstack_strcat0(obs, " decimal\"\n");
+ 				break;
+ 			    case 'x':
+ 				obstack_strcat0(obs, " hexadecimal\"\n");
+ 				break;
+ 			    case 'o':
+ 				obstack_strcat0(obs, " octal\"\n");
+ 				break;
+ 			    default:
+ 				obstack_strcat0(obs, " natural\"\n");
+ 				break;
+ 			}
+ 
+ 			this->lvl3.varnext_cmd = VCMD_PRINT;
+ 			this->lvl3.varcmd = VCMD_FORMAT;
+ 
+ 			return (char *)obstack_finish(obs);
+ 		    }
+ 		    else
+ 		    {
+ 			this->lvl3.varnext_cmd = VCMD_INIT;
+ 			this->lvl3.varitem = obj->next;
+ 			goto oob_cmd;
+ 		    }
+ 		}
+ 
+ 		/* update object */
+ 		if (this->lvl3.varnext_cmd == VCMD_UPDATE)
+ 		{
+ 		    this->lvl3.varnext_cmd = VCMD_PRINT;
+ 		    this->lvl3.varcmd = VCMD_UPDATE;
+ 
+ 		    obstack_strcat(obs, "server interpreter-exec mi \"-var-update var");
+ 		    obstack_strcat(obs, obj->name);
+ 		    obstack_strcat0(obs, "\"\n");
+ 		    return (char *)obstack_finish(obs);
+ 		}
+ 
+ 		/* print */
+ 		if (this->lvl3.varnext_cmd == VCMD_PRINT)
+ 		{
+ 		    obj->state &= ~VS_ERROR;
+ 		    this->lvl3.varcmd = VCMD_PRINT;
+ 
+ 		    obstack_strcat(obs, "server output ");
+ 		    obstack_strcat(obs, obj->format);
+ 		    obstack_strcat(obs, " ");
+ 		    obstack_strcat(obs, obj->expression);
+ 		    obstack_strcat0(obs, "\n");
+ 		    return (char *)obstack_finish(obs);
+ 		}
+ 		
+ 		/* evaluate object expression */
+ 		if (this->lvl3.varnext_cmd == VCMD_EVALUATE)
+ 		{
+ 		    this->lvl3.varcmd = VCMD_EVALUATE;
+ 
+ 		    obstack_strcat(obs, "server interpreter-exec mi \"-var-evaluate-expression var");
+ 		    obstack_strcat(obs, obj->name);
+ 		    obstack_strcat0(obs, "\"\n");
+ 		    return (char *)obstack_finish(obs);
+ 		}
+ 	    }
+ 	    break;
+ 
+ 	case OOB_COLLECT:
+ 	    gdb_cat(&res, this->lvl3.result);
+ 	    gdb_cat(&res, line);
+ 	    xfree(this->lvl3.result);
+ 	    this->lvl3.result = res;
+ 	    break;
+ 
+ 	case OOB_COMPLETE:
+ #  ifdef FEAT_GDB
+ 	    return varobj_complete(this, obs);
+ #  else
+ 	    /* start of object operations */
+ 	    if (result == NULL && this->var_buf > 0)
+ 		cnb_startAtomic(this->var_buf);
+ 
+ 	    result = varobj_complete(this, obs);
+ 
+ 	    /* end of object operations */
+ 	    if (result == NULL && this->var_buf > 0)
+ 		cnb_endAtomic(this->var_buf);
+ 
+ 	    return result;
+ #  endif
+     }
+ 
+     return NULL;
+ }
+ 
+ #   define VOBJ_NAME	    "^done,name=\"var"
+ #   define VOBJ_CHILD	    "\",numchild=\""
+ #   define VOBJ_SCOPE	    "\",in_scope=\""
+ #   define VOBJ_VALUE	    "^done,value=\""
+ /*
+  * Process the OOB_COMPLETE part of varobj_update()
+  * Return anything not NULL except when last object in varlist
+  * and after the last varcmd which may be: a failed VCMD_CREATE,
+  * VCMD_DELETE, highlighted VCMD_UPDATE, VCMD_PRINT, VCMD_EVALUATE
+  */
+     static char *
+ varobj_complete(this, obs)
+     gdb_T *this;
+     struct obstack *obs;
+ {
+     char_u *displine;	/* the new display item line */
+     char_u *res;
+ #  ifdef FEAT_GDB
+     buf_T *oldbuf    = curbuf;
+     linenr_T lnum;
+     win_T *win;
+ #  endif
+     varobj_T *obj;
+     char_u *ptr;
+     char_u *last;
+     char_u *child;
+     char_u *quote;
+ 
+     if ((obj = this->lvl3.varitem) != NULL)
+     {
+ 	switch (this->lvl3.varcmd)
+ 	{
+ 	    case VCMD_CREATE:
+ 		/* result of object creation */
+ 		if (this->lvl3.result != NULL
+ 			&& (ptr = STRSTR(this->lvl3.result, VOBJ_NAME)) != NULL
+ 			&& (ptr += strlen(VOBJ_NAME))
+ 			&& (quote = STRCHR(ptr, '"')) != NULL
+ 			&& (child = STRSTR(this->lvl3.result, VOBJ_CHILD)) != NULL)
+ 		{
+ 		    obj->name = (char_u *)clewn_strnsave((char *)ptr, (quote - ptr));
+ 		    obj->children = (atoi((char *)(child + strlen(VOBJ_CHILD))) > 0);
+ 
+ 		    FREE(this->lvl3.result);
+ 		    return (char *)obj;   /* next command */
+ 		}
+ 		else
+ 		{
+ 		    EMSG(_("Unable to create variable object"));
+ 		    remove_object(this, obj);
+ 		    FREE(this->lvl3.result);
+ 		    this->lvl3.varnext_cmd = VCMD_INIT;
+ 		    return (char *)this->lvl3.varitem;  /* next object */
+ 		}
+ 		break;
+ 
+ 	    case VCMD_DELETE:
+ 		remove_object(this, obj);
+ 		FREE(this->lvl3.result);
+ 		this->lvl3.varnext_cmd = VCMD_INIT;
+ 		return (char *)this->lvl3.varitem;  /* next object */
+ 
+ 	    case VCMD_CHILDREN:
+ 		FREE(this->lvl3.result);
+ 		return (char *)obj;   /* next command */
+ 
+ 	    case VCMD_FORMAT:
+ 		FREE(this->lvl3.result);
+ 		return (char *)obj;   /* next command */
+ 
+ 	    case VCMD_UPDATE:
+ 		if (this->lvl3.result != NULL
+ 			&&(ptr = STRSTR(this->lvl3.result, VOBJ_SCOPE)) != NULL)
+ 		{
+ 		    ptr += strlen(VOBJ_SCOPE);
+ 		    if ((STRSTR(ptr, "false")) == ptr)
+ 		    {
+ 			/* set "out of scope" highlighting (={-}) */
+ 			varobj_hilite(this, obj, (int)'-', obs);
+ 			goto nextobj;
+ 		    }
+ 		    else
+ 		    {
+ 			/* object needs updating */
+ 			FREE(this->lvl3.result);
+ 			return (char *)obj;   /* next command */
+ 		    }
+ 		}
+ 		else
+ 		{
+ 		    /* turn off highlighting */
+ 		    varobj_hilite(this, obj, (int)'=', obs);
+ 		    goto nextobj;
+ 		}
+ 		break;
+ 
+ 	    case VCMD_PRINT:
+ 		/* fall back to GDB/MI when unable to print expression
+ 		 * because it's not the right frame */
+ 		if (obj->state & VS_ERROR)
+ 		{
+ 		    obj->state &= ~VS_ERROR;
+ 		    this->lvl3.varnext_cmd = VCMD_EVALUATE;
+ 		    FREE(this->lvl3.result);
+ 		    return (char *)obj;   /* next command */
+ 		}
+ 		
+ 		/* build the display line including ={*}, the hiliting sign */
+ 		obstack_strcat(obs, obj->name);
+ 		obstack_strcat(obs, ":");
+ 		obstack_strcat(obs, obj->format);
+ 		obstack_strcat(obs, " ");
+ 		obstack_strcat(obs, obj->expression);
+ 		obstack_strcat(obs, " ={*} ");
+ 		if (this->lvl3.result != NULL) {
+ 		    obstack_strcat0(obs, this->lvl3.result);
+ 		}
+ 		displine = (char_u *)obstack_finish(obs);
+ 
+ 		/* add the newly created object to variables window */
+ 		if (obj->state & VS_INIT)
+ 		{
+ #  ifdef FEAT_GDB
+ 		    if (this->var_buf != NULL)
+ 		    {
+ 			lnum = BUFLASTL(this->var_buf);
+ 
+ 			/* edit variables buffer in available window */
+ 			if (gdb_edit_file(this, this->var_buf, NULL, lnum, obs) != NULL)
+ 			{
+ 			    /* add to variables buffer */
+ 			    if (ml_append(lnum, displine, 0, 0) == OK)
+ 			    {
+ 				/* first line ever: remove empty line after the
+ 				 * one just inserted */
+ 				if (lnum == 0)
+ 				    ml_delete(this->var_buf->b_ml.ml_line_count, FALSE);
+ 
+ 				changed_lines(this->var_buf->b_ml.ml_line_count - 1,
+ 					0, this->var_buf->b_ml.ml_line_count, 1);
+ 			    }
+ 
+ 			    /* update top line */
+ 			    curwin->w_cursor.lnum = this->var_buf->b_ml.ml_line_count;
+ 			    update_topline();
+ 
+ 			    /* status line changed */
+ 			    curwin->w_redr_status = TRUE;
+ 
+ 			    /* move back to previous window if still there */
+ 			    if ((win = gdb_btowin(oldbuf)) != NULL)
+ 				win_goto(win);
+ 			}
+ 			obj->state &= ~VS_INIT;
+ 		    }
+ #  else
+ 		    if (this->var_buf > 0)
+ 		    {
+ 			cnb_append(this->var_buf, displine, obs);
+ 			obj->state &= ~VS_INIT;
+ 		    }
+ #  endif
+ 		}
+ 
+ 		/* update and highlight object value */
+ 		else
+ 		    varobj_replace(this, obj, displine, obs);
+ 
+ 		goto nextobj;
+ 
+ 	    case VCMD_EVALUATE:
+ 		if (this->lvl3.result != NULL
+ 			&& (ptr = STRSTR(this->lvl3.result, VOBJ_VALUE)) != NULL
+ 			&& (ptr += strlen(VOBJ_VALUE))
+ 			&& (quote = (char_u *)strrchr((char *)ptr, '"')) != NULL)
+ 		{
+ 		    res = (char_u *)obstack_copy0(obs, ptr, (quote - ptr));
+ 
+ 		    /* remove all `\' in `\"' */
+ 		    for (ptr = last = res; *ptr; ptr++)
+ 		    {
+ 			if (*ptr != '\\' || *(ptr + 1) != '"')
+ 			    *last++ = *ptr;
+ 		    }
+ 		    *last = NUL;
+ 
+ 		    /* build the display line including ={*}, the hiliting sign */
+ 		    obstack_strcat(obs, obj->name);
+ 		    obstack_strcat(obs, ":");
+ 		    obstack_strcat(obs, obj->format);
+ 		    obstack_strcat(obs, " ");
+ 		    obstack_strcat(obs, obj->expression);
+ 		    obstack_strcat(obs, " ={*} ");
+ 		    obstack_strcat0(obs, res);
+ 		    displine = (char_u *)obstack_finish(obs);
+ 
+ 
+ 		    /* update and highlight object value */
+ 		    varobj_replace(this, obj, displine, obs);
+ 
+ 		}
+ 		goto nextobj;
+ 	}
+     }
+ 
+     return NULL;
+ nextobj:
+     FREE(this->lvl3.result);
+     this->lvl3.varitem = obj->next;
+     this->lvl3.varnext_cmd = VCMD_INIT;
+ 
+     /* When not at the end of varlist, return a non null object
+      * to get gdb_oob_send() to call again varobj_update() for
+      * the next object */
+     return (char *)this->lvl3.varitem;
+ }
+ 
+ #   define OBHI_CHANGED	    " ={*} "
+ #   define OBHI_UNCHANGED   " ={=} "
+ #   define OBHI_DESCOPED    " ={-} "
+ /* Change object highlighting to type */
+     static void
+ varobj_hilite(this, obj, type, obs)
+     gdb_T *this;
+     varobj_T *obj;
+     int type;	    /* hiliting type, may be '*', '=' or '-' */
+     struct obstack *obs;
+ #  ifdef FEAT_GDB
+ {
+     buf_T *oldbuf = curbuf;
+     char_u *ptrn;
+     char_u *line;
+     char_u *oldline;
+     char_u *ptr;
+     pos_T pos;
+     win_T *win;
+ 
+     pos.lnum = 1;
+     pos.col = 0;
+ 
+     /* search for obj in variables window */
+     obstack_strcat(obs, "^\\s*");
+     obstack_strcat(obs, obj->name);
+     obstack_strcat0(obs, ":");
+     ptrn = (char_u *)obstack_finish(obs);
+ 
+     if (this->var_buf != NULL && obj != NULL && obj->name != NULL
+ 	    && ! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+ 	    && searchit(NULL, this->var_buf, &pos,
+ 		FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+     {
+ 	line = ml_get_buf(this->var_buf, pos.lnum, FALSE);
+ 	oldline = obstack_strsave(obs, line);
+ 
+ 	if ((type == '-' && ((ptr = STRSTR(oldline, OBHI_CHANGED)) != NULL
+ 			|| (ptr = STRSTR(oldline, OBHI_UNCHANGED)) != NULL))
+ 		|| (type == '*' && ((ptr = STRSTR(oldline, OBHI_UNCHANGED)) != NULL
+ 			|| (ptr = STRSTR(oldline, OBHI_DESCOPED)) != NULL))
+ 		|| (type == '=' && ((ptr = STRSTR(oldline, OBHI_DESCOPED)) != NULL
+ 			|| (ptr = STRSTR(oldline, OBHI_CHANGED)) != NULL)))
+ 	{
+ 	    *(ptr + 3) = type;
+ 
+ 	    /* replace line */
+ 	    curbuf = this->var_buf;
+ 	    ml_replace(pos.lnum, oldline, TRUE);
+ 	    changed_lines(pos.lnum, 0, pos.lnum + 1, 0);
+ 	    curbuf = oldbuf;
+ 
+ 	    if ((win = gdb_btowin(this->var_buf)) != NULL)
+ 		redraw_win_later(win, NOT_VALID);
+ 	}
+     }
+ }
+ #  else
+ {
+     char_u *oldline;
+     char_u *line;
+     char_u *ptr;
+     int lnum;
+ 
+     /* search for obj in variables buffer */
+     if (this->var_buf > 0 && obj != NULL && obj->name != NULL
+ 	    && (oldline = cnb_search_obj(obj->name, &lnum)) != NULL)
+     {
+ 	line = obstack_strsave(obs, oldline);
+ 
+ 	if ((type == '-' && ((ptr = STRSTR(line, OBHI_CHANGED)) != NULL
+ 			|| (ptr = STRSTR(line, OBHI_UNCHANGED)) != NULL))
+ 		|| (type == '*' && ((ptr = STRSTR(line, OBHI_UNCHANGED)) != NULL
+ 			|| (ptr = STRSTR(line, OBHI_DESCOPED)) != NULL))
+ 		|| (type == '=' && ((ptr = STRSTR(line, OBHI_DESCOPED)) != NULL
+ 			|| (ptr = STRSTR(line, OBHI_CHANGED)) != NULL)))
+ 	{
+ 	    *(ptr + 3) = type;
+ 
+ 	    /* replace line */
+ 	    cnb_replace(this->var_buf, line, lnum, obs);
+ 	}
+     }
+ }
+ #  endif
+ 
+ /* Replace object line in variables buffer with line */
+     static void
+ varobj_replace(this, obj, line, obs)
+     gdb_T *this;
+     varobj_T *obj;
+     char_u *line;
+     struct obstack *obs;
+ #  ifdef FEAT_GDB
+ {
+     buf_T *oldbuf = curbuf;
+     win_T *oldwin = curwin;
+     char_u *ptrn;
+     linenr_T lnum;
+     win_T *win;
+     pos_T pos;
+ 
+     pos.lnum = 1;
+     pos.col = 0;
+ 
+     /* search for object in variables window */
+     obstack_strcat(obs, "^\\s*");
+     obstack_strcat(obs, obj->name);
+     obstack_strcat0(obs, ":");
+     ptrn = (char_u *)obstack_finish(obs);
+ 
+     if (this->var_buf != NULL && obj != NULL && obj->name != NULL
+ 	    && ! (this->var_buf->b_ml.ml_flags & ML_EMPTY)
+ 	    && searchit(NULL, this->var_buf, &pos,
+ 		FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+     {
+ 	lnum = pos.lnum;
+ 
+ 	/* replace line */
+ 	curbuf = this->var_buf;
+ 	ml_replace(lnum, line, TRUE);
+ 	changed_lines(lnum, 0, lnum + 1, 0);
+ 
+ 	if ((win = gdb_btowin(this->var_buf)) != NULL)
+ 	{
+ 	    win->w_cursor.lnum = lnum;
+ 
+ 	    curwin = win;
+ 	    check_cursor();
+ 	    update_topline();
+ 	    curwin = oldwin;
+ 
+ 	    win->w_redr_status = TRUE;
+ 
+ 	    redraw_win_later(win, NOT_VALID);
+ 	}
+ 	curbuf = oldbuf;
+     }
+ }
+ #  else
+ {
+     int lnum;
+ 
+     /* search for object in variables buffer */
+     if (this->var_buf > 0 && obj != NULL && obj->name != NULL
+ 	    && cnb_search_obj(obj->name, &lnum) != NULL)
+ 	cnb_replace(this->var_buf, line, lnum, obs);
+ }
+ #  endif
+ 
+ /* Remove varobj item from valist */
+     static void
+ remove_object(this, item)
+     gdb_T *this;
+     varobj_T *item;
+ {
+     varobj_T **pt;
+     varobj_T *next;
+ 
+     for (pt = &(this->lvl3.varlist); *pt != NULL; pt = &((*pt)->next))
+ 	if (*pt == item)
+ 	{
+ 	    next = (*pt)->next;
+ 	    this->lvl3.varitem = next;
+ 
+ 	    xfree(item->name);
+ 	    xfree(item->format);
+ 	    xfree(item->expression);
+ 	    xfree(item);
+ 	    *pt = next;
+ 	    return;
+ 	}
+ }
+ #  endif /* GDB_LVL3_SUPPORT */
+ 
+ /*
+  * Add a breakpoint record to the head of the tmp list and highlite
+  * the corresponding sign if the record refers to a loaded buffer
+  * or to an editable file, and in this case load it.
+  */
+     void
+ gdb_process_record(this, address, at, line, source, obs)
+     gdb_T *this;
+     char_u *address;	/* breakpoint address */
+     char_u *at;		/* breakpoint function */
+     char_u *line;	/* breakpoint line in source */
+     char_u *source;	/* breakpoint source file name */
+     struct obstack *obs;
+ #  ifdef FEAT_GDB
+ {
+     win_T *oldwin    = curwin;
+     bpinfo_T *record = this->record;
+     char_u *bp_file  = NULL;
+     buf_T *buf       = NULL;
+     char_u *ptrn;
+     bpinfo_T *p, **pt;
+     pos_T pos;
+     int i;
+     int lnum;
+ 
+     /*
+      * Look for this breakpoint in previous list
+      */
+     for (pt = &(this->bpinfo); *pt != NULL; pt = &((*pt)->next))
+     {
+ 	p = *pt;
+ 
+ 	/* The breakpoint number exists in the old table:
+ 	 *	update the highliting sign and do not even parse
+ 	 *	the line (assume the file and line of a breakpoint
+ 	 *	are immutable)
+ 	 *	move the old record to tmplist and update its sign
+ 	 */
+ 	if (record->id == p->id)
+ 	{
+ 	    /* update enabled */
+ 	    if (record->enabled != p->enabled)
+ 	    {
+ 		p->enabled = record->enabled;
+ 		if ((p->typenr = gdb_define_sign(p->id, p->enabled)) != -1)
+ 		{
+ 		    buf_addsign(p->buf, BP_SIGN_ID(p->id), p->lnum, p->typenr);
+ 		    update_debug_sign(p->buf, p->lnum);
+ 		}
+ 	    }
+ 
+ #  ifdef BP_INVALID_ANO_MISSING
+ 	    /* update disposition */
+ 	    p->disposition = record->disposition;
+ #  endif
+ 
+ 	    /* update 'continue' */
+ 	    p->cont = record->cont;
+ 
+ 	    /* move from old list to new list */
+ 	    *pt = p->next;		    /* unlink from old list */
+ 	    p->next = this->tmplist;	    /* link to head of new table */
+ 	    this->tmplist = p;
+ 	    return;			    /* record may be reused */
+ 	}
+     }
+ 
+     /*
+      * A new breakpoint number: edit the file if possible
+      */
+     /* An asm breakpoint */
+     if (address != NULL && at != NULL)
+     {
+ 	bp_file = obstack_strsave(obs, at);
+ 
+ 	/* Search all buffers in the asm buffer pool whose name starts
+ 	 * with bp_file and find the one containing a line starting
+ 	 * with address */
+ 	obstack_strcat(obs, "^\\s*0x0*");
+ 	obstack_strcat0(obs, address);
+ 	ptrn = (char_u *)obstack_finish(obs);
+ 
+ 	for (i = 0; i < this->pool.max; i++)
+ 	{
+ 	    pos.lnum = 1;
+ 	    pos.col = 0;
+ 
+ 	    if (this->pool.buf[i] != NULL
+ 		    && STRSTR(this->pool.buf[i]->b_fname, bp_file) != NULL
+ 		    && !(this->pool.buf[i]->b_ml.ml_flags & ML_EMPTY)
+ 		    && searchit(NULL, this->pool.buf[i], &pos,
+ 			FORWARD, ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+ 	    {
+ 		this->pool.age[i] = 0;
+ 		record->lnum = pos.lnum;
+ 		buf = this->pool.buf[i];
+ 		break;
+ 	    }
+ 	}
+ 
+ 	bp_file = NULL;
+     }
+ 
+     /* A plain breakpoint */
+     else if (line != NULL && (record->lnum = atoi((char *)line)) > 0
+ 	    && source != NULL)
+     {
+ 	bp_file = obstack_strsave(obs, source);
+     }
+ 
+     /*
+      * Edit the file or asm buffer
+      * when the table is reported by GDB as having changed
+      * or when this buffer is the frame buffer and the frame
+      * is invalid (because: we might be setting a frame in
+      * a newly disassembled buffer and must set again all
+      * its breakpoints)
+      */
+     if ((bp_file != NULL || buf != NULL)
+ 	    && (this->bp_state & BPS_INVALID
+ 		    || (p_asm != 0
+ 			&& buf != NULL
+ 			&& buf == this->fr_buf
+ 			&& (this->bp_state & BPS_FR_INVALID)))
+ 	    )
+     {
+ 	/* bufIsChanged is TRUE when previous gdb_edit_file() failed because
+ 	 * the user cancelled the operation after having been warned the
+ 	 * buffer is changed. In this case, do not try to gdb_edit_file()
+ 	 * again for the next new breakpoints
+ 	 * (as the operation is cancelled). */
+ 	if (! this->bufIsChanged)
+ 	{
+ 	    if (gdb_edit_file(this, buf, bp_file, record->lnum, obs) != NULL)
+ 	    {
+ 		/* MUST redraw the screen before calling update_debug_sign():
+ 		 *  update_debug_sign() invokes win_update()
+ 		 *  the screen might have been scrolled when Vim ask the
+ 		 *  user to confirm changes made to the previous buffer */
+ 		gdb_redraw(curwin->w_buffer);
+ 
+ 		record->buf = curwin->w_buffer;
+ 
+ 		if ((record->typenr =
+ 			    gdb_define_sign(record->id, record->enabled)) != -1)
+ 		{
+ 		    /* add bp sign */
+ 		    buf_addsign(record->buf, BP_SIGN_ID(record->id),
+ 			    record->lnum, record->typenr);
+ 		    update_debug_sign(record->buf, record->lnum);
+ 
+ 		    /* Set the frame sign again in case this is
+ 		     * a newly disassembled buffer */
+ 		    if (this->frame_pc != NULL
+ 			    && p_asm != 0
+ 			    && this->fr_buf == NULL
+ 			    && ! (record->buf->b_ml.ml_flags & ML_EMPTY))
+ 		    {
+ 			pos.lnum = 1;
+ 			pos.col = 0;
+ 
+ 			obstack_strcat(obs, "^\\s*0x0*");
+ 			obstack_strcat0(obs, this->frame_pc);
+ 			ptrn = (char_u *)obstack_finish(obs);
+ 
+ 			if (ptrn != NULL
+ 				&& searchit(NULL, record->buf, &pos, FORWARD,
+ 				    ptrn, 1L, SEARCH_KEEP, RE_LAST, (linenr_T)0, NULL) != FAIL)
+ 			{
+ 			    gdb_fr_lite(this, record->buf, pos.lnum, obs);
+ 			}
+ 		    }
+ 
+ 		    /* Handle the case where bps are set after the frame sign:
+ 		     * new disassembled code or reediting a wiped-out plain
+ 		     * buffer or stepping in a newly disassembled buffer */
+ 		    if (record->buf == this->fr_buf
+ 			    && (this->bp_state & BPS_BP_HIT
+ 				|| (p_asm != 0
+ 				    && (this->bp_state & BPS_FR_INVALID)))
+ 			    && (lnum =
+ 				buf_findsign(this->fr_buf, FRAME_SIGN)) != 0)
+ 		    {
+ 			/* remove frame sign and add it again on top
+ 			 * of this new breakpoint */
+ 			if (lnum == record->lnum)
+ 			    gdb_fr_lite(this, this->fr_buf, lnum, obs);
+ 
+ 			/* move back cursor to frame */
+ 			gdb_set_cursor(gdb_btowin(this->fr_buf), lnum);
+ 		    }
+ 		}
+ 
+ 		record->next = this->tmplist;	/* link to head of new table */
+ 		this->tmplist = record;
+ 		this->record = NULL;		/* forget record */
+ 	    }
+ 	    else
+ 	    {
+ 		this->bufIsChanged = bufIsChanged(curbuf);
+ 		win_goto(oldwin);
+ 	    }
+ 	}
+     }
+ 
+     return;
+ }
+ #  else
+ {
+     bpinfo_T *record = this->record;
+     char_u *bp_file  = NULL;
+     int buf          = -1;
+     bpinfo_T *p, **pt;
+     char_u *fname;
+     linenr_T lnum;
+     int bufno;
+ 
+     /*
+      * Look for this breakpoint in previous list
+      */
+     for (pt = &(this->bpinfo); *pt != NULL; pt = &((*pt)->next))
+     {
+ 	p = *pt;
+ 
+ 	/* The breakpoint number exists in the old table:
+ 	 *	remove old sign and replace by new one
+ 	 *	move the old record to tmplist and update its sign
+ 	 */
+ 	if (record->id == p->id)
+ 	{
+ 	    /* update enabled */
+ 	    if (record->enabled != p->enabled)
+ 	    {
+ 		p->enabled = record->enabled;
+ 		if ((p->typenr = gdb_define_bpsign(p, obs)) != -1)
+ 		{
+ 		    cnb_buf_delsign(p->buf, BP_SIGN_ID(p->id));
+ 		    cnb_buf_addsign(p->buf, BP_SIGN_ID(p->id), p->typenr, p->lnum, obs);
+ 		}
+ 	    }
+ 
+ #  ifdef BP_INVALID_ANO_MISSING
+ 	    /* update disposition */
+ 	    p->disposition = record->disposition;
+ #  endif
+ 
+ 	    /* update 'continue' */
+ 	    p->cont = record->cont;
+ 
+ 	    /* move from old list to new list */
+ 	    *pt = p->next;		    /* unlink from old list */
+ 	    p->next = this->tmplist;	    /* link to head of new table */
+ 	    this->tmplist = p;
+ 	    return;			    /* record may be reused */
+ 	}
+     }
+ 
+     /*
+      * A new breakpoint number: edit the file if possible
+      */
+     /* An asm breakpoint */
+     if (address != NULL && at != NULL)
+     {
+ 	bp_file = obstack_strsave(obs, at);
+ 
+ 	/* Search all buffers in the asm buffer pool whose name starts
+ 	 * with bp_file and find the one containing a line starting
+ 	 * with address */
+ 	for (bufno = 1; ! cnb_outofbounds(bufno); bufno++)
+ 	{
+ 	    if ((fname = cnb_filename(bufno)) != NULL
+ 		    && STRSTR(fname, bp_file) != NULL
+ 		    && (lnum = searchfor(fname, address)) > 0)
+ 	    {
+ 		record->lnum = lnum;
+ 		buf = bufno;
+ 		break;
+ 	    }
+ 	}
+ 
+ 	bp_file = NULL;
+     }
+ 
+     /* A plain breakpoint */
+     else if (line != NULL && (record->lnum = atoi((char *)line)) > 0
+ 	    && source != NULL)
+     {
+ 	bp_file = obstack_strsave(obs, source);
+     }
+ 
+     /*
+      * Edit the file or asm buffer
+      * when the table is reported by GDB as having changed
+      * or when this buffer is the frame buffer and the frame
+      * is invalid (because: we might be setting a frame in
+      * a newly disassembled buffer and must set again all
+      * its breakpoints)
+      */
+     if ((bp_file != NULL || cnb_isvalid_buffer(buf))
+ 	    && (this->bp_state & BPS_INVALID
+ 		    || (p_asm != 0
+ 			&& cnb_isvalid_buffer(buf)
+ 			&& buf == this->fr_buf
+ 			&& (this->bp_state & BPS_FR_INVALID)))
+ 	    )
+     {
+ 	if ((record->buf = gdb_edit_file(buf, bp_file, record->lnum, 1, obs)) > 0)
+ 	{
+ 	    if ((record->typenr = gdb_define_bpsign(record, obs)) != -1)
+ 	    {
+ 		/* add bp sign */
+ 		cnb_buf_addsign(record->buf, BP_SIGN_ID(record->id),
+ 			record->typenr, record->lnum, obs);
+ 
+ 		/* Set the frame sign again in case this is
+ 		 * a newly disassembled buffer */
+ 		if (this->frame_pc != NULL
+ 			&& p_asm != 0
+ 			&& ! cnb_isvalid_buffer(this->fr_buf)
+ 			&& (fname = cnb_filename(record->buf)) != NULL
+ 			&& (lnum = searchfor(fname, this->frame_pc)) > 0)
+ 		{
+ 		    gdb_fr_lite(this, record->buf, lnum, obs);
+ 		}
+ 
+ 		/* Handle the case where bps are set after the frame sign:
+ 		 * new disassembled code or reediting a wiped-out plain
+ 		 * buffer or stepping in a newly disassembled buffer */
+ 		if (record->buf == this->fr_buf
+ 			&& (this->bp_state & BPS_BP_HIT
+ 			    || (p_asm != 0
+ 				&& (this->bp_state & BPS_FR_INVALID)))
+ 			&& (lnum = find_fr_sign(this->fr_buf)) != 0)
+ 		{
+ 		    /* remove frame sign and add it again on top
+ 		     * of this new breakpoint */
+ 		    if (lnum == record->lnum)
+ 			gdb_fr_lite(this, this->fr_buf, lnum, obs);
+ 		}
+ 	    }
+ 
+ 	    record->next = this->tmplist;	/* link to head of new table */
+ 	    this->tmplist = record;
+ 	    this->record = NULL;		/* forget record */
+ 	}
+     }
+ 
+     return;
+ }
+ #  endif /* FEAT_GDB */
+ 
+ /*
+  * Parse str for annotation, set this->note.
+  * Return byte address following annotation, NULL if none found.
+  * Return byte address following ^Z^Z when unknown annotation.
+  */
+     static char_u *
+ parse_note(this, str)
+     gdb_T *this;
+     char_u *str;	/* string to parse */
+ {
+     char_u *note = NULL;
+     annotation_T *pt;
+     int len;
+ 
+     if (str != NULL && (note = STRSTR(str, "\032\032")) != NULL)
+     {
+ 	this->note = ANO_ANY;
+ 	note += 2;
+ 
+ 	for (pt = annotations; pt->str != NULL; pt++)
+ 	{
+ 	    len = STRLEN(pt->str);
+ 
+ 	    if (STRSTR(note, pt->str) == note
+ 		    && (*(note + len) == NUL || isspace(*(note + len))))
+ 	    {
+ 		this->note = pt->id;
+ 		return note + strlen((char *)pt->str);
+ 	    }
+ 	}
+     }
+     return note;
+ }
+ 
+ #  ifndef FEAT_GDB
+ /* Return annotation type of 'str' or ANO_NONE when not found. */
+     static int
+ get_note(this, str)
+     gdb_T *this;
+     char_u *str;	/* string to parse */
+ {
+     int oldnote = this->note;
+     int note    = ANO_NONE;
+ 
+     if (IS_ANNOTATION(str) && parse_note(this, str) != NULL)
+ 	note = this->note;
+ 
+     this->note = oldnote;
+     return note;
+ }
+ #  endif /* FEAT_GDB */
+ # endif /* defined(GDB_LVL2_SUPPORT) || defined(GDB_LVL3_SUPPORT) */
+ #endif /* defined(FEAT_GDB) || defined(HAVE_CLEWN) */
diff -c --new-file old/clewn/misc.c src/clewn/misc.c
*** old/clewn/misc.c	1970-01-01 01:00:00.000000000 +0100
--- src/clewn/misc.c	2008-10-11 16:29:18.000000000 +0200
***************
*** 0 ****
--- 1,645 ----
+ /* vi:set ts=8 sts=4 sw=4:
+  *
+  * Copyright (C) 2004 Xavier de Gaye.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program (see the file COPYING); if not, write to the
+  * Free Software Foundation, Inc.,
+  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+  *
+  * $Id: misc.c 217 2008-10-11 14:29:18Z xavier $
+  */
+ 
+ #ifdef HAVE_CLEWN
+ # include <config.h>
+ #else
+ # include <auto/config.h>
+ void vim_beep ();
+ #endif
+ 
+ #include <stdio.h>
+ #include <string.h>
+ #include <errno.h>
+ #include <ctype.h>
+ #include <sys/stat.h>
+ 
+ #ifdef HAVE_READLINE_READLINE_H
+ # include <readline/readline.h>
+ #endif
+ 
+ #ifdef HAVE_STDLIB_H
+ # include <stdlib.h>
+ #endif
+ #ifndef EXIT_FAILURE
+ # define EXIT_FAILURE 1
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif
+ 
+ #ifdef HAVE_FCNTL_H
+ # include <fcntl.h>
+ #endif
+ 
+ #if !defined(HAVE_SYS_TIME_H) || defined(TIME_WITH_SYS_TIME)
+ # include <time.h>	    /* on some systems time.h should not be
+ 			       included together with sys/time.h */
+ #endif
+ #ifdef HAVE_SYS_TIME_H
+ # include <sys/time.h>
+ #endif
+ 
+ #ifndef HAVE_SELECT
+ # ifdef HAVE_SYS_POLL_H
+ #  include <sys/poll.h>
+ # else
+ #  ifdef HAVE_POLL_H
+ #   include <poll.h>
+ #  endif
+ # endif
+ #endif
+ 
+ /* Note: Some systems need both string.h and strings.h (Savage).  However,
+  * some systems can't handle both, only use string.h in that case. */
+ #if defined(HAVE_STRINGS_H) && !defined(NO_STRINGS_WITH_STRING_H)
+ # include <strings.h>
+ #endif
+ 
+ #include "obstack.h"
+ #ifdef FEAT_GDB
+ # include "vim.h"
+ #else
+ # include "clewn.h"
+ #endif
+ 
+ /* do not define xmalloc and family */
+ #undef GDB_MTRACE
+ #include "gdb.h"
+ 
+ #include "misc.h"
+ 
+ #if defined(__CYGWIN__) || defined(__CYGWIN32__)
+ # define WIN32UNIX	/* Compiling for Win32 using Unix files. */
+ # define BINARY_FILE_IO
+ # undef HAVE_FCHDIR	/* doesn't work well in most versions */
+ #endif
+ 
+ #if defined(HAVE_GETCWD) && defined(HAVE_GETWD)
+ # define USE_GETCWD
+ #endif
+ 
+ /* boolean constants */
+ #define FALSE	0
+ #define TRUE	1
+ 
+ /*
+  * EMX doesn't have a global way of making open() use binary I/O.
+  * Use O_BINARY for all open() calls.
+  */
+ #if defined(__EMX__) || defined(__CYGWIN32__)
+ # define O_EXTRA    O_BINARY
+ #else
+ # define O_EXTRA    0
+ #endif
+ 
+ static void (*misc_abort)(void) = NULL;	    /* registered abort function */
+ 
+ /* Register an abort function for when allocating memory fails. */
+     void
+ xatabort(abort_func)
+     void (*abort_func)(void);
+ {
+     misc_abort = abort_func;
+ }
+ 
+ /* allocate memory */
+     void *
+ xmalloc(size)
+     size_t size;
+ {
+     void *value = malloc(size);
+ 
+     if (value == 0)
+     {
+ #ifdef HAVE_CLEWN
+ 	rl_cleanup_after_signal();	/* have readline reset terminal */
+ 	fprintf(stderr, "\nvirtual memory exhausted\n");
+ #endif
+ 	if (misc_abort != NULL)
+ 	    misc_abort();
+ 	else
+ 	    exit(EXIT_FAILURE);
+     }
+     return value;
+ }
+ 
+ /* Allocate memory and set all bytes to zero */
+     void *
+ xcalloc(size)
+     size_t size;
+ {
+     void *p = xmalloc(size);
+     clewn_memset(p, 0, size);
+     return p;
+ }
+ 
+ /* Changes the size of the memory block pointed to by ptr to size bytes. */
+     void *
+ xrealloc(ptr, size)
+     void *ptr;
+     size_t size;
+ {
+     void *value = realloc(ptr, size);
+ 
+     if (value == 0)
+     {
+ #ifdef HAVE_CLEWN
+ 	rl_cleanup_after_signal();	/* have readline reset terminal */
+ 	fprintf(stderr, "\nvirtual memory exhausted\n");
+ #endif
+ 	if (misc_abort != NULL)
+ 	    misc_abort();
+ 	else
+ 	    exit(EXIT_FAILURE);
+     }
+     return value;
+ }
+ 
+ /* Replacement for free() that ignores NULL pointers. */
+     void
+ xfree(x)
+     void *x;
+ {
+     if (x != NULL)
+ 	free(x);
+ }
+ 
+ #ifndef HAVE_MEMSET
+     void *
+ clewn_memset(ptr, c, size)
+     void *ptr;
+     int c;
+     size_t size;
+ {
+     char *p = ptr;
+ 
+     while (size-- > 0)
+ 	*p++ = c;
+     return ptr;
+ }
+ #endif
+ 
+ #ifdef CLEWN_MEMMOVE
+ /*
+  * Version of memmove() that handles overlapping source and destination.
+  * For systems that don't have a function that is guaranteed to do that (SYSV).
+  */
+     void
+ clewn_memmove(d, s, len)
+     void *d;
+     void *s;
+     size_t len;
+ {
+     /* a void doesn't have a size, we use char pointers */
+     char *dst = d;
+     char *src = s;
+ 
+     /* overlap, copy backwards */
+     if (dst > src && dst < src + len)
+     {
+ 	src += len;
+ 	dst += len;
+ 	while (len-- > 0)
+ 	    *--dst = *--src;
+     }
+     else    /* copy forwards */
+ 	while (len-- > 0)
+ 	    *dst++ = *src++;
+ }
+ #endif
+ 
+ /* copy a string into newly allocated memory */
+     char *
+ clewn_strsave(string)
+     char *string;
+ {
+     char *p;
+     size_t len;
+ 
+     if (string != NULL) {
+ 	len = strlen(string) + 1;
+ 	p = xmalloc(len);
+ 	clewn_memmove(p, string, len);
+     }
+     else {
+ 	p = xmalloc(1);
+ 	*p = '\0';
+     }
+     return p;
+ }
+ 
+     char *
+ clewn_strnsave(string, len)
+     char *string;
+     size_t len;
+ {
+     char *p = xmalloc(len + 1);
+ 
+     *p = '\0';
+     if (string != NULL)
+ 	strncpy(p, string, len);
+     *(p + len) = '\0';
+     return p;
+ }
+ 
+     void
+ clewn_sleep(msec)
+     int msec;
+ {
+     /*
+      * Everybody sleeps in a different way...
+      * Prefer nanosleep(), some versions of usleep() can only sleep up to
+      * one second.
+      */
+ #ifdef HAVE_NANOSLEEP
+     {
+ 	struct timespec ts;
+ 
+ 	ts.tv_sec = msec / 1000;
+ 	ts.tv_nsec = (msec % 1000) * 1000000;
+ 	(void)nanosleep(&ts, NULL);
+     }
+ #else
+ # ifdef HAVE_USLEEP
+     while (msec >= 1000)
+     {
+ 	usleep((999 * 1000));
+ 	msec -= 999;
+     }
+     usleep((msec * 1000));
+ # else
+ #  ifndef HAVE_SELECT
+     poll(NULL, 0, msec);
+ #  else
+ #   ifdef __EMX__
+     _sleep2(msec);
+ #   else
+     {
+ 	struct timeval tv;
+ 
+ 	tv.tv_sec = msec / 1000;
+ 	tv.tv_usec = (msec % 1000) * 1000;
+ 	/*
+ 	 * NOTE: Solaris 2.6 has a bug that makes select() hang here.  Get
+ 	 * a patch from Sun to fix this.  Reported by Gunnar Pedersen.
+ 	 */
+ 	select(0, NULL, NULL, NULL, &tv);
+     }
+ #   endif /* __EMX__ */
+ #  endif /* HAVE_SELECT */
+ # endif /* HAVE_NANOSLEEP */
+ #endif /* HAVE_USLEEP */
+ }
+ 
+ /* Give a warning for an error. */
+     void
+ clewn_beep()
+ {
+ #ifdef HAVE_CLEWN
+     /* use readline utility */
+ # ifdef HAVE_RL_DING
+     rl_ding();
+ # else
+     ding();	/* deprecated */
+ # endif
+ #else
+     vim_beep();
+ #endif
+ }
+ 
+ /*
+  * Get name of current directory into buffer 'buf' of length 'len' bytes.
+  * Return 1 for success, 0 for failure.
+  */
+     int
+ clewn_getwd(buf, len)
+     char *buf;
+     int len;
+ {
+ #if defined(USE_GETCWD)
+     if (getcwd(buf, len) == NULL)
+     {
+ 	strcpy(buf, strerror(errno));
+ 	return 0;
+     }
+     return 1;
+ #else
+     return (getwd(buf) != NULL ? 1 : 0);
+ #endif
+ }
+ 
+ /*
+  * Get absolute file name into buffer 'buf' of length 'len' bytes.
+  * return 0 for failure, 1 for success
+  */
+     int
+ clewn_fullpath(fname, buf, len, force)
+     char *fname;
+     char *buf;
+     int len;
+     int force;		/* also expand when already absolute path */
+ {
+     int		l;
+ #ifdef HAVE_FCHDIR
+     int		fd = -1;
+     static int	dont_fchdir = FALSE;	/* TRUE when fchdir() doesn't work */
+ #endif
+     char	olddir[MAXPATHL];
+     char	*p;
+     int		retval = 1;
+ 
+     *buf = '\0';
+     if (fname == NULL)
+ 	return 0;
+ 
+     /* expand it if forced or not an absolute path */
+     if (force || *fname != '/')
+     {
+ 	/*
+ 	 * If the file name has a path, change to that directory for a moment,
+ 	 * and then do the getwd() (and get back to where we were).
+ 	 * This will get the correct path name with "../" things.
+ 	 */
+ 	if ((p = strrchr(fname, '/')) != NULL)
+ 	{
+ #ifdef HAVE_FCHDIR
+ 	    /*
+ 	     * Use fchdir() if possible, it's said to be faster and more
+ 	     * reliable.  But on SunOS 4 it might not work.  Check this by
+ 	     * doing a fchdir() right now.
+ 	     */
+ 	    if (!dont_fchdir)
+ 	    {
+ 		fd = open(".", O_RDONLY | O_EXTRA, 0);
+ 		if (fd >= 0 && fchdir(fd) < 0)
+ 		{
+ 		    close(fd);
+ 		    fd = -1;
+ 		    dont_fchdir = TRUE;	    /* don't try again */
+ 		}
+ 	    }
+ #endif
+ 
+ 	    /* Only change directory when we are sure we can return to where
+ 	     * we are now.  After doing "su" chdir(".") might not work. */
+ 	    if (
+ #ifdef HAVE_FCHDIR
+ 		fd < 0 &&
+ #endif
+ 			(clewn_getwd(olddir, MAXPATHL) == 0
+ 					   || chdir((char *)olddir) != 0))
+ 	    {
+ 		p = NULL;	/* can't get current dir: don't chdir */
+ 		retval = 0;
+ 	    }
+ 	    else
+ 	    {
+ 		/* The directory is copied into buf[], to be able to remove
+ 		 * the file name without changing it (could be a string in
+ 		 * read-only memory) */
+ 		if (p - fname >= len)
+ 		    retval = 0;
+ 		else
+ 		{
+ 		    strncpy(buf, fname, p - fname);
+ 		    buf[p - fname] = '\0';
+ 		    if (chdir((char *)buf))
+ 			retval = 0;
+ 		    else
+ 			fname = p + 1;
+ 		    *buf = '\0';
+ 		}
+ 	    }
+ 	}
+ 
+ 	if (clewn_getwd(buf, len) == 0)
+ 	{
+ 	    retval = 0;
+ 	    *buf = '\0';
+ 	}
+ 
+ 	if (p != NULL)
+ 	{
+ #ifdef HAVE_FCHDIR
+ 	    if (fd >= 0)
+ 	    {
+ 		(void)fchdir(fd);
+ 		close(fd);
+ 	    }
+ 	    else
+ #endif
+ 		(void)chdir((char *)olddir);
+ 	}
+ 
+ 	l = strlen(buf);
+ 	if (l >= len)
+ 	    retval = 0;
+ 	else
+ 	{
+ 	    if (l > 0 && buf[l - 1] != '/' && *fname != '\0')
+ 		strcat(buf, "/");
+ 	}
+     }
+ 
+     /* catch file names which are too long */
+     if (retval == 0 || ((int)(strlen(buf) + strlen(fname)) >= len))
+ 	return 0;
+ 
+     strcat(buf, fname);
+ 
+     return 1;
+ }
+ 
+ /*
+  * Get a full path name for the file named 'name'.
+  * If name is an absolute path, just stat it. Otherwise, add name to
+  * each directory in GDB source directories and stat the result.
+  */
+     char *
+ get_fullpath(name, sourcedir, source_cur, source_list, obs)
+     char *name;	        /* file name */
+     char *sourcedir;	/* GDB source directories */
+     char *source_cur;	/* GDB current source */
+     char *source_list;  /* GDB source list */
+     struct obstack *obs;
+ {
+     char *pathname;
+     char pathbuf[MAXPATHL];
+     struct stat st;
+     char *dir;
+     char *ptr;
+     char *last;
+     char *hay;
+     char *found;
+     char *end;
+ 
+     if (name == NULL || *name == NUL)
+ 	return NULL;
+ 
+     /* an absolute path name */
+     if (*name == '/')
+     {
+ 	if (stat((char *)name, &st) == 0)
+ 	    return name;
+ 	else
+ 	    /* strip off the directory part and continue */
+ 	    name = strrchr(name, '/') + 1;
+     }
+ 
+     if (sourcedir == NULL)		    /* use current working directory */
+ 	sourcedir = GDB_CWD;
+ 
+     /* proceed with each directory in GDB source directories */
+     ptr = sourcedir;
+     do
+     {
+ 	if ((last = strchr(ptr, ':')) != NULL)
+ 	    *last++ = NUL;
+ 
+ 	if (strcmp(ptr, GDB_CDIR) == 0)	    /* compilation directory */
+ 	{
+ 	    /* hay: file="NAME",fullname=" */
+ 	    obstack_strcat(obs, "file=\"");
+ 	    obstack_strcat(obs, name);
+ 	    obstack_strcat0(obs, "\",fullname=\"");
+ 	    hay = (char *)obstack_finish(obs);
+ 
+ 	    /* name is the current sourcefile: use gdb compilation directory */
+ 	    if (source_cur != NULL && (found=strstr(source_cur, hay)) != NULL ){
+ 		found += strlen(hay);
+ 		if ((end=strstr(found, "\"")) != NULL)
+ 		    return (char *)obstack_copy0(obs, found, end - found);
+ 	    }
+ 
+ 	    /* lookup for first occurence of name in source list */
+ 	    if (source_list != NULL && (found=strstr(source_list, hay)) != NULL ){
+ 		found += strlen(hay);
+ 		if ((end=strstr(found, "\"")) != NULL)
+ 		    return (char *)obstack_copy0(obs, found, end - found);
+ 	    }
+ 
+ 	    dir = NULL;
+ 	}
+ 	else if (strcmp(ptr, GDB_CWD) == 0) /* current working directory */
+ 	{
+ 	    if (clewn_getwd(pathbuf, MAXPATHL))
+ 		dir = pathbuf;
+ 	    else
+ 		dir = NULL;
+ 	}
+ 	else
+ 	    dir = ptr;
+ 
+ 	if (dir != NULL)
+ 	{
+ 	    obstack_strcat(obs, dir);
+ 	    obstack_strcat(obs, "/");
+ 	    obstack_strcat0(obs, name);
+ 	    pathname = (char *)obstack_finish(obs);
+ 
+ 	    if (stat((char *)pathname, &st) == 0) {
+ 		/* need to handle the case where the path includes '..'
+ 		 * for example "/home/xavier/tmp/.." must be converted
+ 		 * to "/home/xavier" */
+ 		if (clewn_fullpath(pathname, pathbuf, MAXPATHL, TRUE))
+ 		    return (char *)obstack_strsave(obs, pathbuf);
+ 	    }
+ 	}
+ 
+ 	ptr = last;
+     } while (ptr != NULL && *ptr != NUL);
+ 
+     return NULL;
+ }
+ 
+ /*
+  * Execute a program with (optionnaly quoted) arguments
+  */
+     void
+ clewn_exec(cmd)
+     char *cmd;
+ {
+     char ** argv = NULL;	/* keep compiler happy */
+     char * newcmd;
+     int argc;
+     char * ptr;
+     int inquote;
+     int i;
+ 
+     if ((newcmd = clewn_strsave(cmd)) == NULL)
+ 	return;
+ 
+     /*
+      * step 1: find number of arguments
+      * step 2: separate them and built argv[]
+      */
+     for (i = 0; i < 2; i++)
+     {
+ 	ptr = newcmd;
+ 	argc = 0;
+ 
+ 	for (;;)
+ 	{
+ 	    inquote = FALSE;
+ 
+ 	    while (*ptr == ' ' || *ptr == '\t')	/* skip to next non-white */
+ 		ptr++;
+ 
+ 	    if (*ptr == '\0')
+ 		break;
+ 
+ 	    if (*ptr == '"' || *ptr == '\'')
+ 	    {
+ 		ptr++;
+ 		inquote = TRUE;
+ 	    }
+ 
+ 	    if (i == 1)
+ 		argv[argc] = ptr;
+ 
+ 	    argc++;
+ 	    while (*ptr && (inquote || (*ptr != ' ' && *ptr != '\t')))
+ 	    {
+ 		if (*ptr == '"' || *ptr == '\'')
+ 		    break;
+ 
+ 		ptr++;
+ 	    }
+ 
+ 	    if (*ptr == '\0')
+ 		break;
+ 
+ 	    if (i == 1)
+ 		*ptr = '\0';
+ 
+ 	    ptr++;
+ 	}
+ 
+ 	/* got the number of arguments */
+ 	if (i == 0 && (argv = (char **) xcalloc((size_t)((argc + 1) * sizeof(char *)))) == NULL)
+ 	    return;
+     }
+ 
+     execvp(argv[0], argv);
+ }
diff -c --new-file old/clewn/misc.h src/clewn/misc.h
*** old/clewn/misc.h	1970-01-01 01:00:00.000000000 +0100
--- src/clewn/misc.h	2007-07-21 18:35:40.000000000 +0200
***************
*** 0 ****
--- 1,92 ----
+ /* vi:set ts=8 sts=4 sw=4:
+  *
+  * Copyright (C) 2004 Xavier de Gaye.
+  *
+  * This program is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU General Public License as published by
+  * the Free Software Foundation; either version 2, or (at your option)
+  * any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  * GNU General Public License for more details.
+  *
+  * You should have received a copy of the GNU General Public License
+  * along with this program (see the file COPYING); if not, write to the
+  * Free Software Foundation, Inc.,
+  * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+  *
+  * $Id: misc.h 148 2007-07-21 16:35:40Z xavier $
+  */
+ 
+ #ifndef MISC_H
+ # define MISC_H
+ 
+ #ifndef __ARGS
+     /* The AIX VisualAge cc compiler defines __EXTENDED__ instead of __STDC__
+      * because it includes pre-ansi features. */
+ # if defined(__STDC__) || defined(__GNUC__) || defined(__EXTENDED__)
+ #  define __ARGS(x) x
+ # else
+ #  define __ARGS(x) ()
+ # endif
+ #endif
+ 
+ /* memmove is not present on all systems, use memmove, bcopy, memcpy or our
+  * own version */
+ /* Some systems have (void *) arguments, some (char *). If we use (char *) it
+  * works for all */
+ #ifdef USEMEMMOVE
+ # define clewn_memmove(to, from, len) memmove((char *)(to), (char *)(from), len)
+ #else
+ # ifdef USEBCOPY
+ #  define clewn_memmove(to, from, len) bcopy((char *)(from), (char *)(to), len)
+ # else
+ #  ifdef USEMEMCPY
+ #   define clewn_memmove(to, from, len) memcpy((char *)(to), (char *)(from), len)
+ #  else
+ #   define CLEWN_MEMMOVE
+ void clewn_memmove __ARGS((void *, void *, size_t));
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_MEMSET
+ # define clewn_memset(ptr, c, size)   memset((ptr), (c), (size))
+ #else
+ void *clewn_memset __ARGS((void *, int, size_t));
+ #endif
+ 
+ /*
+  * Maximum length of a path (for non-unix systems) Make it a bit long, to stay
+  * on the safe side.  But not too long to put on the stack.
+  */
+ #ifndef MAXPATHL
+ # ifdef MAXPATHLEN
+ #  define MAXPATHL	MAXPATHLEN
+ # else
+ #  define MAXPATHL	256
+ # endif
+ #endif
+ 
+ /* gdb directory constants */
+ #define GDB_CDIR    "$cdir"
+ #define GDB_CWD	    "$cwd"
+ 
+ void xatabort __ARGS((void (*)(void)));
+ void * xmalloc __ARGS((size_t));
+ void * xcalloc __ARGS((size_t));
+ void * xrealloc __ARGS((void *, size_t));
+ void xfree __ARGS((void *));
+ char * clewn_strsave __ARGS((char *));
+ char * clewn_strnsave __ARGS((char *, size_t));
+ void clewn_sleep __ARGS((int));
+ void clewn_beep __ARGS((void));
+ int clewn_getwd __ARGS((char *, int));
+ int clewn_fullpath __ARGS((char *, char *, int, int));
+ char * get_fullpath __ARGS((char *, char *, char *, char *, struct obstack *));
+ void clewn_exec(char *);
+ 
+ #endif	/* MISC_H */
+ 
diff -c --new-file old/clewn/obstack.c src/clewn/obstack.c
*** old/clewn/obstack.c	1970-01-01 01:00:00.000000000 +0100
--- src/clewn/obstack.c	2008-10-11 16:29:18.000000000 +0200
***************
*** 0 ****
--- 1,442 ----
+ /* obstack.c - subroutines used implicitly by object stack macros
+    Copyright (C) 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1996, 1997, 1998,
+    1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+ 
+    The GNU C Library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+ 
+    You should have received a copy of the GNU Lesser General Public
+    License along with the GNU C Library; if not, write to the Free
+    Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.  */
+ 
+ 
+ #ifdef _LIBC
+ # include <obstack.h>
+ # include <shlib-compat.h>
+ #else
+ # ifdef HAVE_CONFIG_H
+ #  ifdef HAVE_CLEWN
+ #   include <config.h>
+ #  else
+ #   include <auto/config.h>
+ #  endif
+ # endif
+ # include <stdint.h>
+ # include "obstack.h"
+ #endif
+ 
+ /* NOTE BEFORE MODIFYING THIS FILE: This version number must be
+    incremented whenever callers compiled using an old obstack.h can no
+    longer properly call the functions in this obstack.c.  */
+ #define OBSTACK_INTERFACE_VERSION 1
+ 
+ /* Comment out all this code if we are using the GNU C Library, and are not
+    actually compiling the library itself, and the installed library
+    supports the same library interface we do.  This code is part of the GNU
+    C Library, but also included in many other GNU distributions.  Compiling
+    and linking in this code is a waste when using the GNU C library
+    (especially if it is a shared library).  Rather than having every GNU
+    program understand `configure --with-gnu-libc' and omit the object
+    files, it is simpler to just do this in the source for each such file.  */
+ 
+ #include <stdio.h>		/* Random thing to get __GNU_LIBRARY__.  */
+ #if !defined _LIBC && defined __GNU_LIBRARY__ && __GNU_LIBRARY__ > 1
+ # include <gnu-versions.h>
+ # if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
+ #  define ELIDE_CODE
+ # endif
+ #endif
+ 
+ #include <stddef.h>
+ 
+ #ifndef ELIDE_CODE
+ 
+ 
+ # if HAVE_INTTYPES_H
+ #  include <inttypes.h>
+ # endif
+ # if HAVE_STDINT_H || defined _LIBC
+ #  include <stdint.h>
+ # endif
+ 
+ /* Determine default alignment.  */
+ union fooround
+ {
+   uintmax_t i;
+   long double d;
+   void *p;
+ };
+ struct fooalign
+ {
+   char c;
+   union fooround u;
+ };
+ /* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
+    But in fact it might be less smart and round addresses to as much as
+    DEFAULT_ROUNDING.  So we prepare for it to do that.  */
+ enum
+   {
+     DEFAULT_ALIGNMENT = offsetof (struct fooalign, u),
+     DEFAULT_ROUNDING = sizeof (union fooround)
+   };
+ 
+ /* When we copy a long block of data, this is the unit to do it with.
+    On some machines, copying successive ints does not work;
+    in such a case, redefine COPYING_UNIT to `long' (if that works)
+    or `char' as a last resort.  */
+ # ifndef COPYING_UNIT
+ #  define COPYING_UNIT int
+ # endif
+ 
+ 
+ /* The functions allocating more room by calling `obstack_chunk_alloc'
+    jump to the handler pointed to by `obstack_alloc_failed_handler'.
+    This can be set to a user defined function which should either
+    abort gracefully or use longjump - but shouldn't return.  This
+    variable by default points to the internal function
+    `print_and_abort'.  */
+ static void print_and_abort (void);
+ void (*obstack_alloc_failed_handler) (void) = print_and_abort;
+ 
+ /* Exit value used when `print_and_abort' is used.  */
+ # include <stdlib.h>
+ # ifdef _LIBC
+ int obstack_exit_failure = EXIT_FAILURE;
+ # else
+ #  define obstack_exit_failure EXIT_FAILURE
+ # endif
+ 
+ # ifdef _LIBC
+ #  if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_3_4)
+ /* A looong time ago (before 1994, anyway; we're not sure) this global variable
+    was used by non-GNU-C macros to avoid multiple evaluation.  The GNU C
+    library still exports it because somebody might use it.  */
+ struct obstack *_obstack_compat;
+ compat_symbol (libc, _obstack_compat, _obstack, GLIBC_2_0);
+ #  endif
+ # endif
+ 
+ /* Define a macro that either calls functions with the traditional malloc/free
+    calling interface, or calls functions with the mmalloc/mfree interface
+    (that adds an extra first argument), based on the state of use_extra_arg.
+    For free, do not use ?:, since some compilers, like the MIPS compilers,
+    do not allow (expr) ? void : void.  */
+ 
+ # define CALL_CHUNKFUN(h, size) \
+   (((h) -> use_extra_arg) \
+    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
+    : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
+ 
+ # define CALL_FREEFUN(h, old_chunk) \
+   do { \
+     if ((h) -> use_extra_arg) \
+       (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
+     else \
+       (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
+   } while (0)
+ 
+ 
+ /* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
+    Objects start on multiples of ALIGNMENT (0 means use default).
+    CHUNKFUN is the function to use to allocate chunks,
+    and FREEFUN the function to free them.
+ 
+    Return nonzero if successful, calls obstack_alloc_failed_handler if
+    allocation fails.  */
+ 
+ int
+ _obstack_begin (struct obstack *h,
+ 		int size, int alignment,
+ 		void *(*chunkfun) (long),
+ 		void (*freefun) (void *))
+ {
+   register struct _obstack_chunk *chunk; /* points to new chunk */
+ 
+   if (alignment == 0)
+     alignment = DEFAULT_ALIGNMENT;
+   if (size == 0)
+     /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+     {
+       /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+ 	 Use the values for range checking, because if range checking is off,
+ 	 the extra bytes won't be missed terribly, but if range checking is on
+ 	 and we used a larger request, a whole extra 4096 bytes would be
+ 	 allocated.
+ 
+ 	 These number are irrelevant to the new GNU malloc.  I suspect it is
+ 	 less sensitive to the size of the request.  */
+       int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+ 		    + 4 + DEFAULT_ROUNDING - 1)
+ 		   & ~(DEFAULT_ROUNDING - 1));
+       size = 4096 - extra;
+     }
+ 
+   h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
+   h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
+   h->chunk_size = size;
+   h->alignment_mask = alignment - 1;
+   h->use_extra_arg = 0;
+ 
+   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
+   if (!chunk)
+     (*obstack_alloc_failed_handler) ();
+   h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
+ 					       alignment - 1);
+   h->chunk_limit = chunk->limit
+     = (char *) chunk + h->chunk_size;
+   chunk->prev = 0;
+   /* The initial chunk now contains no empty object.  */
+   h->maybe_empty_object = 0;
+   h->alloc_failed = 0;
+   return 1;
+ }
+ 
+ int
+ _obstack_begin_1 (struct obstack *h, int size, int alignment,
+ 		  void *(*chunkfun) (void *, long),
+ 		  void (*freefun) (void *, void *),
+ 		  void *arg)
+ {
+   register struct _obstack_chunk *chunk; /* points to new chunk */
+ 
+   if (alignment == 0)
+     alignment = DEFAULT_ALIGNMENT;
+   if (size == 0)
+     /* Default size is what GNU malloc can fit in a 4096-byte block.  */
+     {
+       /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
+ 	 Use the values for range checking, because if range checking is off,
+ 	 the extra bytes won't be missed terribly, but if range checking is on
+ 	 and we used a larger request, a whole extra 4096 bytes would be
+ 	 allocated.
+ 
+ 	 These number are irrelevant to the new GNU malloc.  I suspect it is
+ 	 less sensitive to the size of the request.  */
+       int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
+ 		    + 4 + DEFAULT_ROUNDING - 1)
+ 		   & ~(DEFAULT_ROUNDING - 1));
+       size = 4096 - extra;
+     }
+ 
+   h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
+   h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
+   h->chunk_size = size;
+   h->alignment_mask = alignment - 1;
+   h->extra_arg = arg;
+   h->use_extra_arg = 1;
+ 
+   chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
+   if (!chunk)
+     (*obstack_alloc_failed_handler) ();
+   h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,
+ 					       alignment - 1);
+   h->chunk_limit = chunk->limit
+     = (char *) chunk + h->chunk_size;
+   chunk->prev = 0;
+   /* The initial chunk now contains no empty object.  */
+   h->maybe_empty_object = 0;
+   h->alloc_failed = 0;
+   return 1;
+ }
+ 
+ /* Allocate a new current chunk for the obstack *H
+    on the assumption that LENGTH bytes need to be added
+    to the current object, or a new object of length LENGTH allocated.
+    Copies any partial object from the end of the old chunk
+    to the beginning of the new one.  */
+ 
+ void
+ _obstack_newchunk (struct obstack *h, int length)
+ {
+   register struct _obstack_chunk *old_chunk = h->chunk;
+   register struct _obstack_chunk *new_chunk;
+   register long	new_size;
+   register long obj_size = h->next_free - h->object_base;
+   register long i;
+   long already;
+   char *object_base;
+ 
+   /* Compute size for new chunk.  */
+   new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;
+   if (new_size < h->chunk_size)
+     new_size = h->chunk_size;
+ 
+   /* Allocate and initialize the new chunk.  */
+   new_chunk = CALL_CHUNKFUN (h, new_size);
+   if (!new_chunk)
+     (*obstack_alloc_failed_handler) ();
+   h->chunk = new_chunk;
+   new_chunk->prev = old_chunk;
+   new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
+ 
+   /* Compute an aligned object_base in the new chunk */
+   object_base =
+     __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);
+ 
+   /* Move the existing object to the new chunk.
+      Word at a time is fast and is safe if the object
+      is sufficiently aligned.  */
+   if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
+     {
+       for (i = obj_size / sizeof (COPYING_UNIT) - 1;
+ 	   i >= 0; i--)
+ 	((COPYING_UNIT *)object_base)[i]
+ 	  = ((COPYING_UNIT *)h->object_base)[i];
+       /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
+ 	 but that can cross a page boundary on a machine
+ 	 which does not do strict alignment for COPYING_UNITS.  */
+       already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
+     }
+   else
+     already = 0;
+   /* Copy remaining bytes one by one.  */
+   for (i = already; i < obj_size; i++)
+     object_base[i] = h->object_base[i];
+ 
+   /* If the object just copied was the only data in OLD_CHUNK,
+      free that chunk and remove it from the chain.
+      But not if that chunk might contain an empty object.  */
+   if (! h->maybe_empty_object
+       && (h->object_base
+ 	  == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,
+ 			  h->alignment_mask)))
+     {
+       new_chunk->prev = old_chunk->prev;
+       CALL_FREEFUN (h, old_chunk);
+     }
+ 
+   h->object_base = object_base;
+   h->next_free = h->object_base + obj_size;
+   /* The new chunk certainly contains no empty object yet.  */
+   h->maybe_empty_object = 0;
+ }
+ # ifdef _LIBC
+ libc_hidden_def (_obstack_newchunk)
+ # endif
+ 
+ /* Return nonzero if object OBJ has been allocated from obstack H.
+    This is here for debugging.
+    If you use it in a program, you are probably losing.  */
+ 
+ /* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
+    obstack.h because it is just for debugging.  */
+ int _obstack_allocated_p (struct obstack *h, void *obj);
+ 
+ int
+ _obstack_allocated_p (struct obstack *h, void *obj)
+ {
+   register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+   register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+ 
+   lp = (h)->chunk;
+   /* We use >= rather than > since the object cannot be exactly at
+      the beginning of the chunk but might be an empty object exactly
+      at the end of an adjacent chunk.  */
+   while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
+     {
+       plp = lp->prev;
+       lp = plp;
+     }
+   return lp != 0;
+ }
+ 
+ /* Free objects in obstack H, including OBJ and everything allocate
+    more recently than OBJ.  If OBJ is zero, free everything in H.  */
+ 
+ # undef obstack_free
+ 
+ void
+ obstack_free (struct obstack *h, void *obj)
+ {
+   register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
+   register struct _obstack_chunk *plp;	/* point to previous chunk if any */
+ 
+   lp = h->chunk;
+   /* We use >= because there cannot be an object at the beginning of a chunk.
+      But there can be an empty object at that address
+      at the end of another chunk.  */
+   while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))
+     {
+       plp = lp->prev;
+       CALL_FREEFUN (h, lp);
+       lp = plp;
+       /* If we switch chunks, we can't tell whether the new current
+ 	 chunk contains an empty object, so assume that it may.  */
+       h->maybe_empty_object = 1;
+     }
+   if (lp)
+     {
+       h->object_base = h->next_free = (char *) (obj);
+       h->chunk_limit = lp->limit;
+       h->chunk = lp;
+     }
+   else if (obj != 0)
+     /* obj is not in any of the chunks! */
+     abort ();
+ }
+ 
+ # ifdef _LIBC
+ /* Older versions of libc used a function _obstack_free intended to be
+    called by non-GCC compilers.  */
+ strong_alias (obstack_free, _obstack_free)
+ # endif
+ 
+ int
+ _obstack_memory_used (struct obstack *h)
+ {
+   register struct _obstack_chunk* lp;
+   register int nbytes = 0;
+ 
+   for (lp = h->chunk; lp != 0; lp = lp->prev)
+     {
+       nbytes += lp->limit - (char *) lp;
+     }
+   return nbytes;
+ }
+ 
+ /* Define the error handler.  */
+ # ifdef _LIBC
+ #  include <libintl.h>
+ # endif
+ # ifndef _
+ #  define _(msgid) (msgid)
+ # endif
+ 
+ # ifdef _LIBC
+ #  include <libio/iolibio.h>
+ # endif
+ 
+ # ifndef __attribute__
+ /* This feature is available in gcc versions 2.5 and later.  */
+ #  if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5)
+ #   define __attribute__(Spec) /* empty */
+ #  endif
+ # endif
+ 
+ static void
+ __attribute__ ((noreturn))
+ print_and_abort (void)
+ {
+   /* Don't change any of these strings.  Yes, it would be possible to add
+      the newline to the string and use fputs or so.  But this must not
+      happen because the "memory exhausted" message appears in other places
+      like this and the translation should be reused instead of creating
+      a very similar string which requires a separate translation.  */
+ # ifdef _LIBC
+   (void) __fxprintf (NULL, "%s\n", _("memory exhausted"));
+ # else
+   fprintf (stderr, "%s\n", _("memory exhausted"));
+ # endif
+   exit (obstack_exit_failure);
+ }
+ 
+ #endif	/* !ELIDE_CODE */
diff -c --new-file old/clewn/obstack.h src/clewn/obstack.h
*** old/clewn/obstack.h	1970-01-01 01:00:00.000000000 +0100
--- src/clewn/obstack.h	2006-07-29 19:19:30.000000000 +0200
***************
*** 0 ****
--- 1,509 ----
+ /* obstack.h - object stack macros
+    Copyright (C) 1988-1994,1996-1999,2003,2004,2005
+ 	Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+    The GNU C Library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+ 
+    The GNU C Library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+ 
+    You should have received a copy of the GNU Lesser General Public
+    License along with the GNU C Library; if not, write to the Free
+    Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.  */
+ 
+ /* Summary:
+ 
+ All the apparent functions defined here are macros. The idea
+ is that you would use these pre-tested macros to solve a
+ very specific set of problems, and they would run fast.
+ Caution: no side-effects in arguments please!! They may be
+ evaluated MANY times!!
+ 
+ These macros operate a stack of objects.  Each object starts life
+ small, and may grow to maturity.  (Consider building a word syllable
+ by syllable.)  An object can move while it is growing.  Once it has
+ been "finished" it never changes address again.  So the "top of the
+ stack" is typically an immature growing object, while the rest of the
+ stack is of mature, fixed size and fixed address objects.
+ 
+ These routines grab large chunks of memory, using a function you
+ supply, called `obstack_chunk_alloc'.  On occasion, they free chunks,
+ by calling `obstack_chunk_free'.  You must define them and declare
+ them before using any obstack macros.
+ 
+ Each independent stack is represented by a `struct obstack'.
+ Each of the obstack macros expects a pointer to such a structure
+ as the first argument.
+ 
+ One motivation for this package is the problem of growing char strings
+ in symbol tables.  Unless you are "fascist pig with a read-only mind"
+ --Gosper's immortal quote from HAKMEM item 154, out of context--you
+ would not like to put any arbitrary upper limit on the length of your
+ symbols.
+ 
+ In practice this often means you will build many short symbols and a
+ few long symbols.  At the time you are reading a symbol you don't know
+ how long it is.  One traditional method is to read a symbol into a
+ buffer, realloc()ating the buffer every time you try to read a symbol
+ that is longer than the buffer.  This is beaut, but you still will
+ want to copy the symbol from the buffer to a more permanent
+ symbol-table entry say about half the time.
+ 
+ With obstacks, you can work differently.  Use one obstack for all symbol
+ names.  As you read a symbol, grow the name in the obstack gradually.
+ When the name is complete, finalize it.  Then, if the symbol exists already,
+ free the newly read name.
+ 
+ The way we do this is to take a large chunk, allocating memory from
+ low addresses.  When you want to build a symbol in the chunk you just
+ add chars above the current "high water mark" in the chunk.  When you
+ have finished adding chars, because you got to the end of the symbol,
+ you know how long the chars are, and you can create a new object.
+ Mostly the chars will not burst over the highest address of the chunk,
+ because you would typically expect a chunk to be (say) 100 times as
+ long as an average object.
+ 
+ In case that isn't clear, when we have enough chars to make up
+ the object, THEY ARE ALREADY CONTIGUOUS IN THE CHUNK (guaranteed)
+ so we just point to it where it lies.  No moving of chars is
+ needed and this is the second win: potentially long strings need
+ never be explicitly shuffled. Once an object is formed, it does not
+ change its address during its lifetime.
+ 
+ When the chars burst over a chunk boundary, we allocate a larger
+ chunk, and then copy the partly formed object from the end of the old
+ chunk to the beginning of the new larger chunk.  We then carry on
+ accreting characters to the end of the object as we normally would.
+ 
+ A special macro is provided to add a single char at a time to a
+ growing object.  This allows the use of register variables, which
+ break the ordinary 'growth' macro.
+ 
+ Summary:
+ 	We allocate large chunks.
+ 	We carve out one object at a time from the current chunk.
+ 	Once carved, an object never moves.
+ 	We are free to append data of any size to the currently
+ 	  growing object.
+ 	Exactly one object is growing in an obstack at any one time.
+ 	You can run one obstack per control block.
+ 	You may have as many control blocks as you dare.
+ 	Because of the way we do it, you can `unwind' an obstack
+ 	  back to a previous state. (You may remove objects much
+ 	  as you would with a stack.)
+ */
+ 
+ 
+ /* Don't do the contents of this file more than once.  */
+ 
+ #ifndef _OBSTACK_H
+ #define _OBSTACK_H 1
+ 
+ #ifdef __cplusplus
+ extern "C" {
+ #endif
+ 
+ /* We need the type of a pointer subtraction.  If __PTRDIFF_TYPE__ is
+    defined, as with GNU C, use that; that way we don't pollute the
+    namespace with <stddef.h>'s symbols.  Otherwise, include <stddef.h>
+    and use ptrdiff_t.  */
+ 
+ #ifdef __PTRDIFF_TYPE__
+ # define PTR_INT_TYPE __PTRDIFF_TYPE__
+ #else
+ # include <stddef.h>
+ # define PTR_INT_TYPE ptrdiff_t
+ #endif
+ 
+ /* If B is the base of an object addressed by P, return the result of
+    aligning P to the next multiple of A + 1.  B and P must be of type
+    char *.  A + 1 must be a power of 2.  */
+ 
+ #define __BPTR_ALIGN(B, P, A) ((B) + (((P) - (B) + (A)) & ~(A)))
+ 
+ /* Similiar to _BPTR_ALIGN (B, P, A), except optimize the common case
+    where pointers can be converted to integers, aligned as integers,
+    and converted back again.  If PTR_INT_TYPE is narrower than a
+    pointer (e.g., the AS/400), play it safe and compute the alignment
+    relative to B.  Otherwise, use the faster strategy of computing the
+    alignment relative to 0.  */
+ 
+ #define __PTR_ALIGN(B, P, A)						    \
+   __BPTR_ALIGN (sizeof (PTR_INT_TYPE) < sizeof (void *) ? (B) : (char *) 0, \
+ 		P, A)
+ 
+ #include <string.h>
+ 
+ struct _obstack_chunk		/* Lives at front of each chunk. */
+ {
+   char  *limit;			/* 1 past end of this chunk */
+   struct _obstack_chunk *prev;	/* address of prior chunk or NULL */
+   char	contents[4];		/* objects begin here */
+ };
+ 
+ struct obstack		/* control current object in current chunk */
+ {
+   long	chunk_size;		/* preferred size to allocate chunks in */
+   struct _obstack_chunk *chunk;	/* address of current struct obstack_chunk */
+   char	*object_base;		/* address of object we are building */
+   char	*next_free;		/* where to add next char to current object */
+   char	*chunk_limit;		/* address of char after current chunk */
+   union
+   {
+     PTR_INT_TYPE tempint;
+     void *tempptr;
+   } temp;			/* Temporary for some macros.  */
+   int   alignment_mask;		/* Mask of alignment for each object. */
+   /* These prototypes vary based on `use_extra_arg', and we use
+      casts to the prototypeless function type in all assignments,
+      but having prototypes here quiets -Wstrict-prototypes.  */
+   struct _obstack_chunk *(*chunkfun) (void *, long);
+   void (*freefun) (void *, struct _obstack_chunk *);
+   void *extra_arg;		/* first arg for chunk alloc/dealloc funcs */
+   unsigned use_extra_arg:1;	/* chunk alloc/dealloc funcs take extra arg */
+   unsigned maybe_empty_object:1;/* There is a possibility that the current
+ 				   chunk contains a zero-length object.  This
+ 				   prevents freeing the chunk if we allocate
+ 				   a bigger chunk to replace it. */
+   unsigned alloc_failed:1;	/* No longer used, as we now call the failed
+ 				   handler on error, but retained for binary
+ 				   compatibility.  */
+ };
+ 
+ /* Declare the external functions we use; they are in obstack.c.  */
+ 
+ extern void _obstack_newchunk (struct obstack *, int);
+ extern int _obstack_begin (struct obstack *, int, int,
+ 			    void *(*) (long), void (*) (void *));
+ extern int _obstack_begin_1 (struct obstack *, int, int,
+ 			     void *(*) (void *, long),
+ 			     void (*) (void *, void *), void *);
+ extern int _obstack_memory_used (struct obstack *);
+ 
+ void obstack_free (struct obstack *obstack, void *block);
+ 
+ 
+ /* Error handler called when `obstack_chunk_alloc' failed to allocate
+    more memory.  This can be set to a user defined function which
+    should either abort gracefully or use longjump - but shouldn't
+    return.  The default action is to print a message and abort.  */
+ extern void (*obstack_alloc_failed_handler) (void);
+ 
+ /* Exit value used when `print_and_abort' is used.  */
+ extern int obstack_exit_failure;
+ 
+ /* Pointer to beginning of object being allocated or to be allocated next.
+    Note that this might not be the final address of the object
+    because a new chunk might be needed to hold the final size.  */
+ 
+ #define obstack_base(h) ((void *) (h)->object_base)
+ 
+ /* Size for allocating ordinary chunks.  */
+ 
+ #define obstack_chunk_size(h) ((h)->chunk_size)
+ 
+ /* Pointer to next byte not yet allocated in current chunk.  */
+ 
+ #define obstack_next_free(h)	((h)->next_free)
+ 
+ /* Mask specifying low bits that should be clear in address of an object.  */
+ 
+ #define obstack_alignment_mask(h) ((h)->alignment_mask)
+ 
+ /* To prevent prototype warnings provide complete argument list.  */
+ #define obstack_init(h)						\
+   _obstack_begin ((h), 0, 0,					\
+ 		  (void *(*) (long)) obstack_chunk_alloc,	\
+ 		  (void (*) (void *)) obstack_chunk_free)
+ 
+ #define obstack_begin(h, size)					\
+   _obstack_begin ((h), (size), 0,				\
+ 		  (void *(*) (long)) obstack_chunk_alloc,	\
+ 		  (void (*) (void *)) obstack_chunk_free)
+ 
+ #define obstack_specify_allocation(h, size, alignment, chunkfun, freefun)  \
+   _obstack_begin ((h), (size), (alignment),				   \
+ 		  (void *(*) (long)) (chunkfun),			   \
+ 		  (void (*) (void *)) (freefun))
+ 
+ #define obstack_specify_allocation_with_arg(h, size, alignment, chunkfun, freefun, arg) \
+   _obstack_begin_1 ((h), (size), (alignment),				\
+ 		    (void *(*) (void *, long)) (chunkfun),		\
+ 		    (void (*) (void *, void *)) (freefun), (arg))
+ 
+ #define obstack_chunkfun(h, newchunkfun) \
+   ((h) -> chunkfun = (struct _obstack_chunk *(*)(void *, long)) (newchunkfun))
+ 
+ #define obstack_freefun(h, newfreefun) \
+   ((h) -> freefun = (void (*)(void *, struct _obstack_chunk *)) (newfreefun))
+ 
+ #define obstack_1grow_fast(h,achar) (*((h)->next_free)++ = (achar))
+ 
+ #define obstack_blank_fast(h,n) ((h)->next_free += (n))
+ 
+ #define obstack_memory_used(h) _obstack_memory_used (h)
+ 
+ #if defined __GNUC__ && defined __STDC__ && __STDC__
+ /* NextStep 2.0 cc is really gcc 1.93 but it defines __GNUC__ = 2 and
+    does not implement __extension__.  But that compiler doesn't define
+    __GNUC_MINOR__.  */
+ # if __GNUC__ < 2 || (__NeXT__ && !__GNUC_MINOR__)
+ #  define __extension__
+ # endif
+ 
+ /* For GNU C, if not -traditional,
+    we can define these macros to compute all args only once
+    without using a global variable.
+    Also, we can avoid using the `temp' slot, to make faster code.  */
+ 
+ # define obstack_object_size(OBSTACK)					\
+   __extension__								\
+   ({ struct obstack const *__o = (OBSTACK);				\
+      (unsigned) (__o->next_free - __o->object_base); })
+ 
+ # define obstack_room(OBSTACK)						\
+   __extension__								\
+   ({ struct obstack const *__o = (OBSTACK);				\
+      (unsigned) (__o->chunk_limit - __o->next_free); })
+ 
+ # define obstack_make_room(OBSTACK,length)				\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    int __len = (length);						\
+    if (__o->chunk_limit - __o->next_free < __len)			\
+      _obstack_newchunk (__o, __len);					\
+    (void) 0; })
+ 
+ # define obstack_empty_p(OBSTACK)					\
+   __extension__								\
+   ({ struct obstack const *__o = (OBSTACK);				\
+      (__o->chunk->prev == 0						\
+       && __o->next_free == __PTR_ALIGN ((char *) __o->chunk,		\
+ 					__o->chunk->contents,		\
+ 					__o->alignment_mask)); })
+ 
+ # define obstack_grow(OBSTACK,where,length)				\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    int __len = (length);						\
+    if (__o->next_free + __len > __o->chunk_limit)			\
+      _obstack_newchunk (__o, __len);					\
+    memcpy (__o->next_free, where, __len);				\
+    __o->next_free += __len;						\
+    (void) 0; })
+ 
+ # define obstack_grow0(OBSTACK,where,length)				\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    int __len = (length);						\
+    if (__o->next_free + __len + 1 > __o->chunk_limit)			\
+      _obstack_newchunk (__o, __len + 1);				\
+    memcpy (__o->next_free, where, __len);				\
+    __o->next_free += __len;						\
+    *(__o->next_free)++ = 0;						\
+    (void) 0; })
+ 
+ # define obstack_1grow(OBSTACK,datum)					\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    if (__o->next_free + 1 > __o->chunk_limit)				\
+      _obstack_newchunk (__o, 1);					\
+    obstack_1grow_fast (__o, datum);					\
+    (void) 0; })
+ 
+ /* These assume that the obstack alignment is good enough for pointers
+    or ints, and that the data added so far to the current object
+    shares that much alignment.  */
+ 
+ # define obstack_ptr_grow(OBSTACK,datum)				\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    if (__o->next_free + sizeof (void *) > __o->chunk_limit)		\
+      _obstack_newchunk (__o, sizeof (void *));				\
+    obstack_ptr_grow_fast (__o, datum); })				\
+ 
+ # define obstack_int_grow(OBSTACK,datum)				\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    if (__o->next_free + sizeof (int) > __o->chunk_limit)		\
+      _obstack_newchunk (__o, sizeof (int));				\
+    obstack_int_grow_fast (__o, datum); })
+ 
+ # define obstack_ptr_grow_fast(OBSTACK,aptr)				\
+ __extension__								\
+ ({ struct obstack *__o1 = (OBSTACK);					\
+    *(const void **) __o1->next_free = (aptr);				\
+    __o1->next_free += sizeof (const void *);				\
+    (void) 0; })
+ 
+ # define obstack_int_grow_fast(OBSTACK,aint)				\
+ __extension__								\
+ ({ struct obstack *__o1 = (OBSTACK);					\
+    *(int *) __o1->next_free = (aint);					\
+    __o1->next_free += sizeof (int);					\
+    (void) 0; })
+ 
+ # define obstack_blank(OBSTACK,length)					\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    int __len = (length);						\
+    if (__o->chunk_limit - __o->next_free < __len)			\
+      _obstack_newchunk (__o, __len);					\
+    obstack_blank_fast (__o, __len);					\
+    (void) 0; })
+ 
+ # define obstack_alloc(OBSTACK,length)					\
+ __extension__								\
+ ({ struct obstack *__h = (OBSTACK);					\
+    obstack_blank (__h, (length));					\
+    obstack_finish (__h); })
+ 
+ # define obstack_copy(OBSTACK,where,length)				\
+ __extension__								\
+ ({ struct obstack *__h = (OBSTACK);					\
+    obstack_grow (__h, (where), (length));				\
+    obstack_finish (__h); })
+ 
+ # define obstack_copy0(OBSTACK,where,length)				\
+ __extension__								\
+ ({ struct obstack *__h = (OBSTACK);					\
+    obstack_grow0 (__h, (where), (length));				\
+    obstack_finish (__h); })
+ 
+ /* The local variable is named __o1 to avoid a name conflict
+    when obstack_blank is called.  */
+ # define obstack_finish(OBSTACK)					\
+ __extension__								\
+ ({ struct obstack *__o1 = (OBSTACK);					\
+    void *__value = (void *) __o1->object_base;				\
+    if (__o1->next_free == __value)					\
+      __o1->maybe_empty_object = 1;					\
+    __o1->next_free							\
+      = __PTR_ALIGN (__o1->object_base, __o1->next_free,			\
+ 		    __o1->alignment_mask);				\
+    if (__o1->next_free - (char *)__o1->chunk				\
+        > __o1->chunk_limit - (char *)__o1->chunk)			\
+      __o1->next_free = __o1->chunk_limit;				\
+    __o1->object_base = __o1->next_free;					\
+    __value; })
+ 
+ # define obstack_free(OBSTACK, OBJ)					\
+ __extension__								\
+ ({ struct obstack *__o = (OBSTACK);					\
+    void *__obj = (OBJ);							\
+    if (__obj > (void *)__o->chunk && __obj < (void *)__o->chunk_limit)  \
+      __o->next_free = __o->object_base = (char *)__obj;			\
+    else (obstack_free) (__o, __obj); })
+ 
+ #else /* not __GNUC__ or not __STDC__ */
+ 
+ # define obstack_object_size(h) \
+  (unsigned) ((h)->next_free - (h)->object_base)
+ 
+ # define obstack_room(h)		\
+  (unsigned) ((h)->chunk_limit - (h)->next_free)
+ 
+ # define obstack_empty_p(h) \
+  ((h)->chunk->prev == 0							\
+   && (h)->next_free == __PTR_ALIGN ((char *) (h)->chunk,		\
+ 				    (h)->chunk->contents,		\
+ 				    (h)->alignment_mask))
+ 
+ /* Note that the call to _obstack_newchunk is enclosed in (..., 0)
+    so that we can avoid having void expressions
+    in the arms of the conditional expression.
+    Casting the third operand to void was tried before,
+    but some compilers won't accept it.  */
+ 
+ # define obstack_make_room(h,length)					\
+ ( (h)->temp.tempint = (length),						\
+   (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
+    ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0))
+ 
+ # define obstack_grow(h,where,length)					\
+ ( (h)->temp.tempint = (length),						\
+   (((h)->next_free + (h)->temp.tempint > (h)->chunk_limit)		\
+    ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
+   memcpy ((h)->next_free, where, (h)->temp.tempint),			\
+   (h)->next_free += (h)->temp.tempint)
+ 
+ # define obstack_grow0(h,where,length)					\
+ ( (h)->temp.tempint = (length),						\
+   (((h)->next_free + (h)->temp.tempint + 1 > (h)->chunk_limit)		\
+    ? (_obstack_newchunk ((h), (h)->temp.tempint + 1), 0) : 0),		\
+   memcpy ((h)->next_free, where, (h)->temp.tempint),			\
+   (h)->next_free += (h)->temp.tempint,					\
+   *((h)->next_free)++ = 0)
+ 
+ # define obstack_1grow(h,datum)						\
+ ( (((h)->next_free + 1 > (h)->chunk_limit)				\
+    ? (_obstack_newchunk ((h), 1), 0) : 0),				\
+   obstack_1grow_fast (h, datum))
+ 
+ # define obstack_ptr_grow(h,datum)					\
+ ( (((h)->next_free + sizeof (char *) > (h)->chunk_limit)		\
+    ? (_obstack_newchunk ((h), sizeof (char *)), 0) : 0),		\
+   obstack_ptr_grow_fast (h, datum))
+ 
+ # define obstack_int_grow(h,datum)					\
+ ( (((h)->next_free + sizeof (int) > (h)->chunk_limit)			\
+    ? (_obstack_newchunk ((h), sizeof (int)), 0) : 0),			\
+   obstack_int_grow_fast (h, datum))
+ 
+ # define obstack_ptr_grow_fast(h,aptr)					\
+   (((const void **) ((h)->next_free += sizeof (void *)))[-1] = (aptr))
+ 
+ # define obstack_int_grow_fast(h,aint)					\
+   (((int *) ((h)->next_free += sizeof (int)))[-1] = (aint))
+ 
+ # define obstack_blank(h,length)					\
+ ( (h)->temp.tempint = (length),						\
+   (((h)->chunk_limit - (h)->next_free < (h)->temp.tempint)		\
+    ? (_obstack_newchunk ((h), (h)->temp.tempint), 0) : 0),		\
+   obstack_blank_fast (h, (h)->temp.tempint))
+ 
+ # define obstack_alloc(h,length)					\
+  (obstack_blank ((h), (length)), obstack_finish ((h)))
+ 
+ # define obstack_copy(h,where,length)					\
+  (obstack_grow ((h), (where), (length)), obstack_finish ((h)))
+ 
+ # define obstack_copy0(h,where,length)					\
+  (obstack_grow0 ((h), (where), (length)), obstack_finish ((h)))
+ 
+ # define obstack_finish(h)						\
+ ( ((h)->next_free == (h)->object_base					\
+    ? (((h)->maybe_empty_object = 1), 0)					\
+    : 0),								\
+   (h)->temp.tempptr = (h)->object_base,					\
+   (h)->next_free							\
+     = __PTR_ALIGN ((h)->object_base, (h)->next_free,			\
+ 		   (h)->alignment_mask),				\
+   (((h)->next_free - (char *) (h)->chunk				\
+     > (h)->chunk_limit - (char *) (h)->chunk)				\
+    ? ((h)->next_free = (h)->chunk_limit) : 0),				\
+   (h)->object_base = (h)->next_free,					\
+   (h)->temp.tempptr)
+ 
+ # define obstack_free(h,obj)						\
+ ( (h)->temp.tempint = (char *) (obj) - (char *) (h)->chunk,		\
+   ((((h)->temp.tempint > 0						\
+     && (h)->temp.tempint < (h)->chunk_limit - (char *) (h)->chunk))	\
+    ? (int) ((h)->next_free = (h)->object_base				\
+ 	    = (h)->temp.tempint + (char *) (h)->chunk)			\
+    : (((obstack_free) ((h), (h)->temp.tempint + (char *) (h)->chunk), 0), 0)))
+ 
+ #endif /* not __GNUC__ or not __STDC__ */
+ 
+ #ifdef __cplusplus
+ }	/* C++ */
+ #endif
+ 
+ #endif /* obstack.h */
