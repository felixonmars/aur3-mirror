diff -Nru ./src_0.154_hi/emu/clifront.c ./src/emu/clifront.c
--- ./src_0.154_hi/emu/clifront.c	2014-07-22 08:14:55.000000000 +0200
+++ ./src/emu/clifront.c	2014-07-29 10:29:57.000000000 +0200
@@ -1668,6 +1668,7 @@
 void cli_frontend::display_help()
 {
 	osd_printf_info("%s v%s - %s\n%s\n\n", emulator_info::get_applongname(),build_version,emulator_info::get_fulllongname(),emulator_info::get_copyright_info());
+	osd_printf_info("GroovyMAME - SwitchRes version %s\n", SWITCHRES_VERSION);
 	osd_printf_info("%s\n", emulator_info::get_disclaimer());
 	emulator_info::printf_usage(emulator_info::get_appname(),emulator_info::get_gamenoun());
 	osd_printf_info("\n\n"
diff -Nru ./src_0.154_hi/emu/drivenum.c ./src/emu/drivenum.c
--- ./src_0.154_hi/emu/drivenum.c	2014-04-07 08:04:18.000000000 +0200
+++ ./src/emu/drivenum.c	2014-07-29 10:29:57.000000000 +0200
@@ -322,7 +322,7 @@
 			if (m_included[index])
 				templist[arrayindex++] = index;
 		assert(arrayindex == m_filtered_count);
-
+/*
 		// shuffle
 		for (int shufnum = 0; shufnum < 4 * s_driver_count; shufnum++)
 		{
@@ -332,7 +332,7 @@
 			templist[item1] = templist[item2];
 			templist[item2] = temp;
 		}
-
+*/
 		// copy out the first few entries
 		for (int matchnum = 0; matchnum < count; matchnum++)
 			results[matchnum] = templist[matchnum % m_filtered_count];
diff -Nru ./src_0.154_hi/emu/drivers/empty.c ./src/emu/drivers/empty.c
--- ./src_0.154_hi/emu/drivers/empty.c	2014-02-19 08:07:32.000000000 +0100
+++ ./src/emu/drivers/empty.c	2014-07-29 10:29:57.000000000 +0200
@@ -52,7 +52,7 @@
 	MCFG_SCREEN_UPDATE_DRIVER(empty_state, screen_update)
 	MCFG_SCREEN_SIZE(640,480)
 	MCFG_SCREEN_VISIBLE_AREA(0,639, 0,479)
-	MCFG_SCREEN_REFRESH_RATE(30)
+	MCFG_SCREEN_REFRESH_RATE(61)
 MACHINE_CONFIG_END
 
 
diff -Nru ./src_0.154_hi/emu/emu.h ./src/emu/emu.h
--- ./src_0.154_hi/emu/emu.h	2014-06-06 12:11:31.000000000 +0200
+++ ./src/emu/emu.h	2014-07-29 10:29:57.000000000 +0200
@@ -96,6 +96,9 @@
 // lua engine
 #include "luaengine.h"
 
+// Switchres
+#include "switchres/switchres.h"
+
 // the running machine
 #include "mame.h"
 #include "machine.h"
diff -Nru ./src_0.154_hi/emu/emu.mak ./src/emu/emu.mak
--- ./src_0.154_hi/emu/emu.mak	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/emu.mak	2014-07-29 10:29:57.000000000 +0200
@@ -20,6 +20,7 @@
 EMUMACHINE = $(EMUOBJ)/machine
 EMUIMAGEDEV = $(EMUOBJ)/imagedev
 EMUVIDEO = $(EMUOBJ)/video
+EMUSWITCHRES = $(EMUOBJ)/switchres
 
 OBJDIRS += \
 	$(EMUOBJ)/cpu \
@@ -33,6 +34,7 @@
 	$(EMUOBJ)/imagedev \
 	$(EMUOBJ)/ui \
 	$(EMUOBJ)/video \
+	$(EMUOBJ)/switchres \
 
 OSDSRC = $(SRC)/osd
 OSDOBJ = $(OBJ)/osd
@@ -200,7 +202,14 @@
 	$(EMUVIDEO)/vector.o        \
 
 
-LIBEMUOBJS = $(EMUOBJS) $(EMUSOUNDOBJS) $(EMUDRIVEROBJS) $(EMUMACHINEOBJS) $(EMUIMAGEDEVOBJS) $(EMUVIDEOOBJS)
+EMUSWITCHRESOBJS = \
+	$(EMUSWITCHRES)/modeline.o \
+	$(EMUSWITCHRES)/monitor.o \
+	$(EMUSWITCHRES)/util.o \
+	$(EMUSWITCHRES)/switchres.o \
+ 
+ 
+LIBEMUOBJS = $(EMUOBJS) $(EMUSOUNDOBJS) $(EMUDRIVEROBJS) $(EMUMACHINEOBJS) $(EMUIMAGEDEVOBJS) $(EMUVIDEOOBJS) $(EMUSWITCHRESOBJS)
 
 $(LIBEMU): $(LIBEMUOBJS)
 
diff -Nru ./src_0.154_hi/emu/emuopts.c ./src/emu/emuopts.c
--- ./src_0.154_hi/emu/emuopts.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/emuopts.c	2014-07-29 10:29:57.000000000 +0200
@@ -78,6 +78,7 @@
 	{ OPTION_FRAMESKIP ";fs(0-10)",                      "0",         OPTION_INTEGER,    "set frameskip to fixed value, 0-10 (autoframeskip must be disabled)" },
 	{ OPTION_SECONDS_TO_RUN ";str",                      "0",         OPTION_INTEGER,    "number of emulated seconds to run before automatically exiting" },
 	{ OPTION_THROTTLE,                                   "1",         OPTION_BOOLEAN,    "enable throttling to keep game running in sync with real time" },
+	{ OPTION_SYNCREFRESH ";srf",                         "0",         OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
 	{ OPTION_SLEEP,                                      "1",         OPTION_BOOLEAN,    "enable sleeping, which gives time back to other applications when idle" },
 	{ OPTION_SPEED "(0.01-100)",                         "1.0",       OPTION_FLOAT,      "controls the speed of gameplay, relative to realtime; smaller numbers are slower" },
 	{ OPTION_REFRESHSPEED ";rs",                         "0",         OPTION_BOOLEAN,    "automatically adjusts the speed of gameplay to keep the refresh rate lower than the screen" },
@@ -94,12 +95,12 @@
 
 	// artwork options
 	{ NULL,                                              NULL,        OPTION_HEADER,     "CORE ARTWORK OPTIONS" },
-	{ OPTION_ARTWORK_CROP ";artcrop",                    "0",         OPTION_BOOLEAN,    "crop artwork to game screen size" },
-	{ OPTION_USE_BACKDROPS ";backdrop",                  "1",         OPTION_BOOLEAN,    "enable backdrops if artwork is enabled and available" },
-	{ OPTION_USE_OVERLAYS ";overlay",                    "1",         OPTION_BOOLEAN,    "enable overlays if artwork is enabled and available" },
-	{ OPTION_USE_BEZELS ";bezel",                        "1",         OPTION_BOOLEAN,    "enable bezels if artwork is enabled and available" },
-	{ OPTION_USE_CPANELS ";cpanel",                      "1",         OPTION_BOOLEAN,    "enable cpanels if artwork is enabled and available" },
-	{ OPTION_USE_MARQUEES ";marquee",                    "1",         OPTION_BOOLEAN,    "enable marquees if artwork is enabled and available" },
+	{ OPTION_ARTWORK_CROP ";artcrop",                    "1",         OPTION_BOOLEAN,    "crop artwork to game screen size" },
+	{ OPTION_USE_BACKDROPS ";backdrop",                  "0",         OPTION_BOOLEAN,    "enable backdrops if artwork is enabled and available" },
+	{ OPTION_USE_OVERLAYS ";overlay",                    "0",         OPTION_BOOLEAN,    "enable overlays if artwork is enabled and available" },
+	{ OPTION_USE_BEZELS ";bezel",                        "0",         OPTION_BOOLEAN,    "enable bezels if artwork is enabled and available" },
+	{ OPTION_USE_CPANELS ";cpanel",                      "0",         OPTION_BOOLEAN,    "enable cpanels if artwork is enabled and available" },
+	{ OPTION_USE_MARQUEES ";marquee",                    "0",         OPTION_BOOLEAN,    "enable marquees if artwork is enabled and available" },
 
 	// screen options
 	{ NULL,                                              NULL,        OPTION_HEADER,     "CORE SCREEN OPTIONS" },
@@ -177,8 +178,40 @@
 	// MKChamp Hiscore Diff options
 	{ NULL,                                              NULL,        OPTION_HEADER,     "CORE MKChamp OPTIONS" },
 	{ OPTION_DISABLE_HISCORE_PATCH,                      "0",         OPTION_BOOLEAN,    "disable hiscore saving" },
-	{ OPTION_DISABLE_NAGSCREEN_PATCH,                    "0",         OPTION_BOOLEAN,    "disable suppression of nagscreens" },
-	{ OPTION_DISABLE_LOADING_PATCH,                      "0",         OPTION_BOOLEAN,    "disable suppression of loading screens /white box" },
+	{ OPTION_DISABLE_NAGSCREEN_PATCH,                    "1",         OPTION_BOOLEAN,    "disable suppression of nagscreens" },
+	{ OPTION_DISABLE_LOADING_PATCH,                      "1",         OPTION_BOOLEAN,    "disable suppression of loading screens /white box" },
+
+   	// Switchres options
+ 	{ NULL,                                              NULL,        OPTION_HEADER,     "CORE SWITCHRES OPTIONS" },
+ 	{ OPTION_MODELINE_GENERATION ";ml",                  "1",         OPTION_BOOLEAN,    "Automatic generation of modelines based on the specified monitor type" },
+ 	{ OPTION_MONITOR ";m",                               "generic_15",OPTION_STRING,     "Monitor type, e.g.: generic_15, arcade_15, lcd, custom, etc." },
+ 	{ OPTION_ORIENTATION ";or",                          "horizontal",OPTION_STRING,     "Monitor orientation (horizontal|vertical|rotate|rotate_r|rotate_l)" },
+ 	{ OPTION_CONNECTOR ";cn",                            "auto",      OPTION_STRING,     "[Linux] video card output (VGA-0|VGA-1|DVI-0|DVI-1)" },
+ 	{ OPTION_INTERLACE ";in",                            "1",         OPTION_BOOLEAN,    "Enable interlaced scanning when necessary" },
+ 	{ OPTION_DOUBLESCAN ";ds",                           "1",         OPTION_BOOLEAN,    "Enable double scanning when necessary (unsupported under Windows)" },
+ 	{ OPTION_CLEANSTRETCH ";cs",                         "0",         OPTION_INTEGER,    "Force integer scaling, 0 = automatic selection; 1 = integer both axes; 2 = integer vertical axis" },
+ 	{ OPTION_CHANGERES ";cr",                            "1",         OPTION_BOOLEAN,    "Enable dynamic in-game video mode switching" },
+ 	{ OPTION_POWERSTRIP ";ps",                           "0",         OPTION_BOOLEAN,    "Use Powerstrip API for dynamic setting of custom video timings" },
+ 	{ OPTION_LOCK_SYSTEM_MODES ";lsm",                   "1",         OPTION_BOOLEAN,    "Lock system (non-custom) video modes, only use modes created by us" },
+ 	{ OPTION_LOCK_UNSUPPORTED_MODES ";lum",              "1",         OPTION_BOOLEAN,    "Lock video modes reported as unsupported by your monitor's EDID" },
+ 	{ OPTION_REFRESH_DONT_CARE ";rdc",                   "0",         OPTION_BOOLEAN,    "Ignore video mode's refresh reported by OS when checking ranges" },
+ 	{ OPTION_DOTCLOCK_MIN ";dcm",                        "0",         OPTION_STRING,     "Lowest pixel clock supported by video card, in MHz, default is 0" },
+ 	{ OPTION_SYNC_REFRESH_TOLERANCE ";srt",              "2.0",       OPTION_STRING,     "Maximum refresh difference, in Hz, allowed in order to synchronize" },
+ 	{ OPTION_FRAME_DELAY ";fd",                          "0",         OPTION_INTEGER,    "Delays the start of each frame to minimize input lag (0-9)"},
+ 	{ OPTION_BLACK_FRAME_INSERTION ";bfi",               "0",         OPTION_BOOLEAN,    "Inserts a black frame after each normal frame, intended to reduce motion blur on 120 Hz monitors" },
+ 	{ OPTION_MODELINE ";mode",                           "auto",      OPTION_STRING,     "Use custom defined modeline" },
+ 	{ OPTION_PS_TIMING ";pst",                           "auto",      OPTION_STRING,     "Use custom Powertrip timing string" },
+ 	{ OPTION_LCD_RANGE ";lcd",                           "auto",      OPTION_STRING,     "Add custom LCD range, VfreqMin-VfreqMax, in Hz, e.g.: 55.50-61.00" },
+ 	{ OPTION_CRT_RANGE0 ";crt0",                         "auto",      OPTION_STRING,     "Add custom CRT range, see documentation for details." },
+ 	{ OPTION_CRT_RANGE1 ";crt1",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE2 ";crt2",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE3 ";crt3",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE4 ";crt4",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE5 ";crt5",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE6 ";crt6",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE7 ";crt7",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE8 ";crt8",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
+ 	{ OPTION_CRT_RANGE9 ";crt9",                         "auto",      OPTION_STRING,     "Add custom CRT range" },
 	{ NULL }
 };
 
diff -Nru ./src_0.154_hi/emu/emuopts.h ./src/emu/emuopts.h
--- ./src_0.154_hi/emu/emuopts.h	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/emuopts.h	2014-07-29 10:29:57.000000000 +0200
@@ -29,6 +29,7 @@
 	// INI-based options are NORMAL priority, in increasing order:
 	OPTION_PRIORITY_INI = OPTION_PRIORITY_NORMAL,
 	OPTION_PRIORITY_MAME_INI,
+	OPTION_PRIORITY_SWITCHRES,
 	OPTION_PRIORITY_DEBUG_INI,
 	OPTION_PRIORITY_ORIENTATION_INI,
 	OPTION_PRIORITY_SYSTYPE_INI,
@@ -88,6 +89,7 @@
 #define OPTION_FRAMESKIP            "frameskip"
 #define OPTION_SECONDS_TO_RUN       "seconds_to_run"
 #define OPTION_THROTTLE             "throttle"
+#define OPTION_SYNCREFRESH          "syncrefresh"
 #define OPTION_SLEEP                "sleep"
 #define OPTION_SPEED                "speed"
 #define OPTION_REFRESHSPEED         "refreshspeed"
@@ -184,6 +186,37 @@
 #define OPTION_HTTP_PATH            "http_path"
 #define OPTION_CONSOLE              "console"
 
+/* Switchres Options */
+#define OPTION_MODELINE_GENERATION	"modeline_generation"
+#define OPTION_MONITOR				"monitor"
+#define OPTION_CONNECTOR			"connector"
+#define OPTION_ORIENTATION			"orientation"
+#define OPTION_INTERLACE			"interlace"
+#define OPTION_DOUBLESCAN			"doublescan"
+#define OPTION_CLEANSTRETCH			"cleanstretch"
+#define OPTION_CHANGERES			"changeres"
+#define OPTION_POWERSTRIP			"powerstrip"
+#define OPTION_LOCK_SYSTEM_MODES	"lock_system_modes"
+#define OPTION_LOCK_UNSUPPORTED_MODES	"lock_unsupported_modes"
+#define OPTION_REFRESH_DONT_CARE	"refresh_dont_care"
+#define OPTION_DOTCLOCK_MIN			"dotclock_min"
+#define OPTION_SYNC_REFRESH_TOLERANCE	"sync_refresh_tolerance"
+#define OPTION_FRAME_DELAY			"frame_delay"
+#define OPTION_BLACK_FRAME_INSERTION	"black_frame_insertion"
+#define OPTION_MODELINE				"modeline"
+#define OPTION_PS_TIMING			"ps_timing"
+#define OPTION_LCD_RANGE			"lcd_range"
+#define OPTION_CRT_RANGE0			"crt_range0"
+#define OPTION_CRT_RANGE1			"crt_range1"
+#define OPTION_CRT_RANGE2			"crt_range2"
+#define OPTION_CRT_RANGE3			"crt_range3"
+#define OPTION_CRT_RANGE4			"crt_range4"
+#define OPTION_CRT_RANGE5			"crt_range5"
+#define OPTION_CRT_RANGE6			"crt_range6"
+#define OPTION_CRT_RANGE7			"crt_range7"
+#define OPTION_CRT_RANGE8			"crt_range8"
+#define OPTION_CRT_RANGE9			"crt_range9"
+
 //**************************************************************************
 //  TYPE DEFINITIONS
 //**************************************************************************
@@ -257,6 +290,7 @@
 	int frameskip() const { return int_value(OPTION_FRAMESKIP); }
 	int seconds_to_run() const { return int_value(OPTION_SECONDS_TO_RUN); }
 	bool throttle() const { return bool_value(OPTION_THROTTLE); }
+	bool sync_refresh() const { return bool_value(OPTION_SYNCREFRESH); }
 	bool sleep() const { return bool_value(OPTION_SLEEP); }
 	float speed() const { return float_value(OPTION_SPEED); }
 	bool refresh_speed() const { return bool_value(OPTION_REFRESHSPEED); }
@@ -351,6 +385,37 @@
 	const char *http_path() const { return value(OPTION_HTTP_PATH); }
 	bool console() const { return bool_value(OPTION_CONSOLE); }
 
+	// Switchres options
+	bool modeline_generation() const { return bool_value(OPTION_MODELINE_GENERATION); }
+	const char *monitor() const { return value(OPTION_MONITOR); }
+	const char *connector() const { return value(OPTION_CONNECTOR); }
+	const char *orientation() const { return value(OPTION_ORIENTATION); }
+	bool doublescan() const { return bool_value(OPTION_DOUBLESCAN); }
+	bool interlace() const { return bool_value(OPTION_INTERLACE); }
+	int cleanstretch() const { return int_value(OPTION_CLEANSTRETCH); }
+	int changeres() const { return int_value(OPTION_CHANGERES); }
+	bool powerstrip() const { return bool_value(OPTION_POWERSTRIP); }
+	bool lock_system_modes() const { return bool_value(OPTION_LOCK_SYSTEM_MODES); }
+	bool lock_unsupported_modes() const { return bool_value(OPTION_LOCK_UNSUPPORTED_MODES); }
+	bool refresh_dont_care() const { return bool_value(OPTION_REFRESH_DONT_CARE); }
+	const char *dotclock_min() const { return value(OPTION_DOTCLOCK_MIN); }
+	const char *sync_refresh_tolerance() const { return value(OPTION_SYNC_REFRESH_TOLERANCE); }
+	int frame_delay() const { return int_value(OPTION_FRAME_DELAY); }
+	bool black_frame_insertion() const { return bool_value(OPTION_BLACK_FRAME_INSERTION); }
+	const char *modeline() const { return value(OPTION_MODELINE); }
+	const char *ps_timing() const { return value(OPTION_PS_TIMING); }
+	const char *lcd_range() const { return value(OPTION_LCD_RANGE); }
+	const char *crt_range0() const { return value(OPTION_CRT_RANGE0); }
+	const char *crt_range1() const { return value(OPTION_CRT_RANGE1); }
+	const char *crt_range2() const { return value(OPTION_CRT_RANGE2); }
+	const char *crt_range3() const { return value(OPTION_CRT_RANGE3); }
+	const char *crt_range4() const { return value(OPTION_CRT_RANGE4); }
+	const char *crt_range5() const { return value(OPTION_CRT_RANGE5); }
+	const char *crt_range6() const { return value(OPTION_CRT_RANGE6); }
+	const char *crt_range7() const { return value(OPTION_CRT_RANGE7); }
+	const char *crt_range8() const { return value(OPTION_CRT_RANGE8); }
+	const char *crt_range9() const { return value(OPTION_CRT_RANGE9); }
+
 	// device-specific options
 	const char *device_option(device_image_interface &image);
 
diff -Nru ./src_0.154_hi/emu/hiscore.c ./src/emu/hiscore.c
--- ./src_0.154_hi/emu/hiscore.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/hiscore.c	2014-07-29 10:29:57.000000000 +0200
@@ -305,7 +305,7 @@
 	}
 
 	state.mem_range = NULL;
-	emu_file f(OPEN_FLAG_READ);
+	emu_file f(machine.options().hiscore_directory(), OPEN_FLAG_READ);
   	filerr = f.open("hiscore", ".dat");
 
 	if(filerr == FILERR_NONE)
diff -Nru ./src_0.154_hi/emu/machine.c ./src/emu/machine.c
--- ./src_0.154_hi/emu/machine.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/machine.c	2014-07-29 10:29:57.000000000 +0200
@@ -144,6 +144,7 @@
 		m_scheduler(*this)
 {
 	memset(&m_base_time, 0, sizeof(m_base_time));
+	memset(&switchres, 0, sizeof(switchres));
 
 	// set the machine on all devices
 	device_iterator iter(root_device());
@@ -230,6 +231,9 @@
 	// allocate a soft_reset timer
 	m_soft_reset_timer = m_scheduler.timer_alloc(timer_expired_delegate(FUNC(running_machine::soft_reset), this));
 
+	// Switchres
+	switchres_init(*this);
+
 	// init the osd layer
 	m_manager.osd().init(*this);
 
diff -Nru ./src_0.154_hi/emu/machine.h ./src/emu/machine.h
--- ./src_0.154_hi/emu/machine.h	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/machine.h	2014-07-29 10:29:57.000000000 +0200
@@ -242,6 +242,9 @@
 	// debugger-related information
 	UINT32                  debug_flags;        // the current debug flags
 
+	// SwitchRes patch
+	switchres_manager       switchres;			// SwitchRes data
+
 	// internal core information
 	romload_private *       romload_data;       // internal data from romload.c
 	ui_input_private *      ui_input_data;      // internal data from uiinput.c
diff -Nru ./src_0.154_hi/emu/render.c ./src/emu/render.c
--- ./src_0.154_hi/emu/render.c	2014-04-16 10:04:20.000000000 +0200
+++ ./src/emu/render.c	2014-07-29 10:29:57.000000000 +0200
@@ -1141,10 +1141,46 @@
 void render_target::compute_visible_area(INT32 target_width, INT32 target_height, float target_pixel_aspect, int target_orientation, INT32 &visible_width, INT32 &visible_height)
 {
 	float width, height;
-	float scale;
+	float xscale, yscale;
+	INT32 iwidth, iheight;
+	int clean_stretch = m_manager.machine().switchres.cs.cleanstretch;
+	modeline *mode = &m_manager.machine().switchres.best_mode;
+
+	compute_minimum_size(iwidth, iheight);
+	
+	// Check for resolution changes, but only for window #0
+	if (this->index() == 0)
+		switchres_check_resolution_change(m_manager.machine(), iwidth, iheight);
+	
+	// We only apply cleanstretch to window #0
+	if (this->index() == 0 && clean_stretch)
+	{	
+		width = iwidth;
+		height = iheight;
+
+		xscale = (int)target_width % (int)width;
+		yscale = (int)target_height % (int)height;
+
+		if (clean_stretch == 2)
+			xscale = (float)target_width / width;
+		else
+		{
+			target_width -= xscale;
+			xscale = (int)target_width / (int)width;
+		}
+
+		target_height -= yscale;	
+		yscale = (int)target_height / (int)height;
+
+		if (mode->hactive)
+		{
+			if (clean_stretch == 1)	xscale = mode->result.x_scale;
+			yscale = mode->result.y_scale;
+		}
+	}
 
 	// constrained case
-	if (target_pixel_aspect != 0.0f)
+	else if (target_pixel_aspect != 0.0f)
 	{
 		// start with the aspect ratio of the square pixel layout
 		width = m_curview->effective_aspect(m_layerconfig);
@@ -1159,9 +1195,9 @@
 
 		// based on the height/width ratio of the source and target, compute the scale factor
 		if (width / height > (float)target_width / (float)target_height)
-			scale = (float)target_width / width;
+			xscale = yscale = (float)target_width / width;
 		else
-			scale = (float)target_height / height;
+			xscale = yscale = (float)target_height / height;
 	}
 
 	// stretch-to-fit case
@@ -1169,12 +1205,12 @@
 	{
 		width = (float)target_width;
 		height = (float)target_height;
-		scale = 1.0f;
+		xscale = yscale = 1.0f;
 	}
 
 	// set the final width/height
-	visible_width = render_round_nearest(width * scale);
-	visible_height = render_round_nearest(height * scale);
+	visible_width = render_round_nearest(width * xscale);
+	visible_height = render_round_nearest(height * yscale);
 }
 
 
diff -Nru ./src_0.154_hi/emu/switchres/modeline.c ./src/emu/switchres/modeline.c
--- ./src_0.154_hi/emu/switchres/modeline.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/emu/switchres/modeline.c	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,648 @@
+/**************************************************************
+
+   modeline.c - Modeline generation and scoring routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2013 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+#include "emu.h"
+
+#define max(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a > _b ? _a : _b; })
+#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int modeline_get_line_params(modeline *mode, monitor_range *range);
+int scale_into_range (int value, int lower_limit, int higher_limit);
+int scale_into_range (float value, float lower_limit, float higher_limit);
+int scale_into_aspect (int source_res, int tot_res, float original_monitor_aspect, float users_monitor_aspect, float *best_diff);
+int stretch_into_range(float vfreq, monitor_range *range, bool interlace_allowed, float *interlace);
+int total_lines_for_yres(int yres, float vfreq, monitor_range *range, float interlace);
+float max_vfreq_for_yres (int yres, monitor_range *range, float interlace);
+int round_near (double number);
+
+//============================================================
+//  modeline_create
+//============================================================
+
+int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, config_settings *cs)
+{
+	float vfreq = 0;
+	float vfreq_real = 0;
+	int xres = 0;
+	int yres = 0;
+	float interlace = 1;
+	float doublescan = 1;
+	float scan_factor = 1;
+	int x_scale = 0;
+	int y_scale = 0;
+	int v_scale = 0;
+	float x_diff = 0;
+	float y_diff = 0;
+	float v_diff = 0;
+	float y_ratio = 0;
+	float x_ratio = 0;
+
+	// init all editable fields with source or user values
+	if (t_mode->type & X_RES_EDITABLE)
+		xres = cs->width? cs->width : s_mode->hactive;
+	else
+		xres = t_mode->hactive;
+	if (t_mode->type & Y_RES_EDITABLE)
+		yres = cs->height? cs->height : s_mode->vactive;
+	else
+		yres = t_mode->vactive;
+	if (t_mode->type & V_FREQ_EDITABLE)
+		vfreq = s_mode->vfreq;
+	else
+		vfreq = t_mode->vfreq;
+
+	// lock resolution fields if required
+	if (cs->width) t_mode->type &= ~X_RES_EDITABLE;
+	if (cs->height) t_mode->type &= ~Y_RES_EDITABLE;
+
+	// иии Vertical refresh иии
+	// try to fit vertical frequency into current range
+	v_scale = scale_into_range(vfreq, range->vfreq_min, range->vfreq_max);
+
+	if (!v_scale && (t_mode->type & V_FREQ_EDITABLE))
+	{
+		vfreq = vfreq < range->vfreq_min? range->vfreq_min : range->vfreq_max;
+		v_scale = 1;
+	}
+	else if (v_scale != 1 && !(t_mode->type & V_FREQ_EDITABLE))
+	{
+		t_mode->result.weight |= R_OUT_OF_RANGE;
+		return -1;
+	}
+
+	// иии Vertical resolution иии
+	// try to fit active lines in the progressive range first
+	if (range->progressive_lines_min && (!t_mode->interlace || (t_mode->type & V_FREQ_EDITABLE)))
+		y_scale = scale_into_range(yres, range->progressive_lines_min, range->progressive_lines_max);
+
+	// if not possible, try to fit in the interlaced range, if any
+	if (!y_scale && range->interlaced_lines_min && cs->interlace && (t_mode->interlace || (t_mode->type & V_FREQ_EDITABLE)))
+	{
+		y_scale = scale_into_range(yres, range->interlaced_lines_min, range->interlaced_lines_max);
+		interlace = 2;
+	}
+
+	// if we succeeded, let's see if we can apply integer scaling
+	if (y_scale == 1 || (y_scale > 1 && (t_mode->type & Y_RES_EDITABLE)))
+	{
+		// check if we should apply doublescan
+		if (cs->doublescan && y_scale % 2 == 0)
+		{
+			y_scale /= 2;
+			doublescan = 0.5;
+		}
+		scan_factor = interlace * doublescan;
+
+		// calculate expected achievable refresh for this height
+		vfreq_real = min(vfreq * v_scale, max_vfreq_for_yres(yres * y_scale, range, scan_factor));
+		if (vfreq_real != vfreq * v_scale && !(t_mode->type & V_FREQ_EDITABLE))
+		{
+			t_mode->result.weight |= R_OUT_OF_RANGE;
+			return -1;
+		}
+
+		// calculate the ratio that our scaled yres represents with respect to the original height
+		y_ratio = float(yres) * y_scale / s_mode->vactive;
+		int y_source_scaled = s_mode->vactive * floor(y_ratio);
+
+		// if our original height doesn't fit the target height, we're forced to stretch
+		if (!y_source_scaled)
+			t_mode->result.weight |= R_RES_STRETCH;
+
+		// otherwise we try to perform integer scaling
+		else
+		{
+			// calculate y borders considering physical lines (instead of logical resolution)
+			int tot_yres = total_lines_for_yres(yres * y_scale, vfreq_real, range, scan_factor);
+			int tot_source = total_lines_for_yres(y_source_scaled, vfreq_real, range, scan_factor);
+			y_diff = float(tot_yres % tot_source) / tot_yres * 100;
+
+			// we penalize for the logical lines we need to add in order to meet the user's lower active lines limit
+			int y_min = interlace == 2?range->interlaced_lines_min:range->progressive_lines_min;
+			int tot_rest = (y_min >= y_source_scaled)? y_min % y_source_scaled:0;
+			y_diff += float(tot_rest) / tot_yres * 100;
+
+			// we save the integer ratio between source and target resolutions, this will be used for prescaling
+			y_scale = floor(y_ratio);
+
+			// now if the borders obtained are low enough (< 10%) we'll finally apply integer scaling
+			// otherwise we'll stretch the original resolution over the target one
+			if (!(y_ratio >= 1.0 && y_ratio < 16.0 && y_diff < 10.0))
+				t_mode->result.weight |= R_RES_STRETCH;
+		}
+	}
+
+	// otherwise, check if we're allowed to apply fractional scaling
+	else if (t_mode->type & Y_RES_EDITABLE)
+		t_mode->result.weight |= R_RES_STRETCH;
+
+	// if there's nothing we can do, we're out of range
+	else
+	{
+		t_mode->result.weight |= R_OUT_OF_RANGE;
+		return -1;
+	}
+
+	// иии Horizontal resolution иии
+	// make the best possible adjustment of xres depending on what happened in the previous steps
+	// let's start with the SCALED case
+	if (!(t_mode->result.weight & R_RES_STRETCH))
+	{
+		// if we can, let's apply the same scaling to both directions
+		if (t_mode->type & X_RES_EDITABLE)
+		{
+			if (t_mode->type & Y_RES_EDITABLE) yres *= y_scale;
+			x_scale = y_scale;
+			xres = normalize(float(xres * x_scale) * (cs->effective_orientation?STANDARD_CRT_ASPECT:1.0/(STANDARD_CRT_ASPECT)) * cs->monitor_aspect, 8);
+		}
+
+		// otherwise, try to get the best out of our current xres
+		else
+		{
+			x_scale = xres / s_mode->hactive;
+			// if the source width fits our xres, try applying integer scaling
+			if (x_scale)
+			{
+				x_scale = scale_into_aspect(s_mode->hactive, xres, cs->effective_orientation?1.0/(STANDARD_CRT_ASPECT):STANDARD_CRT_ASPECT, cs->monitor_aspect, &x_diff);
+				if (x_diff > 15.0)
+						t_mode->result.weight |= R_RES_STRETCH;
+			}
+			// otherwise apply fractional scaling
+			else
+				t_mode->result.weight |= R_RES_STRETCH;
+		}
+	}
+
+	// if the resulted was fractional scaling in any of the previous steps, deal with it
+	if (t_mode->result.weight & R_RES_STRETCH)
+	{
+		if (t_mode->type & Y_RES_EDITABLE && cs->cleanstretch != 2)
+		{
+			// always try to use the interlaced range first if it exists, for better resolution
+			yres = stretch_into_range(vfreq, range, cs->interlace, &interlace);
+
+			// check in case we couldn't achieve the desired refresh
+			vfreq_real = min(vfreq, max_vfreq_for_yres(yres, range, interlace));
+		}
+
+		// check if we can create a normal aspect resolution
+		if (t_mode->type & X_RES_EDITABLE)
+			xres = max(xres, normalize(STANDARD_CRT_ASPECT * yres, 8));
+
+		// calculate integer scale for prescaling
+		x_scale = max(1, floor(float(xres) / s_mode->hactive));
+		y_scale = max(1, floor(float(yres) / s_mode->vactive));
+
+		scan_factor = interlace;
+		doublescan = 1;
+	}
+
+	x_ratio = float(xres) / s_mode->hactive;
+	y_ratio = float(yres) / s_mode->vactive;
+	v_scale = max(round_near(vfreq_real / s_mode->vfreq), 1);
+	v_diff = (vfreq_real / v_scale) -  s_mode->vfreq;
+	if (fabs(v_diff) > cs->sync_refresh_tolerance)
+		t_mode->result.weight |= R_V_FREQ_OFF;
+
+	// иии Modeline generation иии
+	// compute new modeline if we are allowed to
+	if (cs->modeline_generation && (t_mode->type & V_FREQ_EDITABLE))
+	{
+		float margin = 0;
+		float vblank_lines = 0;
+		float vvt_ini = 0;
+
+		// Get games basic resolution
+		t_mode->hactive = xres;
+		t_mode->vactive = yres;
+		t_mode->vfreq = vfreq_real;
+
+		// Get total vertical lines
+		vvt_ini = total_lines_for_yres(t_mode->vactive, t_mode->vfreq, range, scan_factor) + (interlace == 2?0.5:0);
+
+		// Calculate horizontal frequency
+		t_mode->hfreq = t_mode->vfreq * vvt_ini;
+
+		horizontal_values:
+
+		// Fill horizontal part of modeline
+		modeline_get_line_params(t_mode, range);
+
+		// Calculate pixel clock
+		t_mode->pclock = t_mode->htotal * t_mode->hfreq;
+		if (t_mode->pclock <= cs->pclock_min)
+		{
+			if (t_mode->type & X_RES_EDITABLE)
+			{
+				x_scale *= 2;
+				t_mode->hactive *= 2;
+				goto horizontal_values;
+			}
+			else
+			{
+				t_mode->result.weight |= R_OUT_OF_RANGE;
+				return -1;
+			}
+		}
+
+		// Vertical blanking
+		t_mode->vtotal = vvt_ini * scan_factor;
+		vblank_lines = int(t_mode->hfreq * range->vertical_blank) + (interlace == 2?0.5:0);
+		margin = (t_mode->vtotal - t_mode->vactive - vblank_lines * scan_factor) / 2;
+		t_mode->vbegin = t_mode->vactive + max(round_near(t_mode->hfreq * range->vfront_porch * scan_factor + margin), 1);
+		t_mode->vend = t_mode->vbegin + max(round_near(t_mode->hfreq * range->vsync_pulse * scan_factor), 1);
+
+		// Recalculate final vfreq
+		t_mode->vfreq = (t_mode->hfreq / t_mode->vtotal) * scan_factor;
+
+		t_mode->hsync = range->hsync_polarity;
+		t_mode->vsync = range->vsync_polarity;
+		t_mode->interlace = interlace == 2?1:0;
+		t_mode->doublescan = doublescan == 1?0:1;
+	}
+
+	// finally, store result
+	t_mode->result.x_scale = x_scale;
+	t_mode->result.y_scale = y_scale;
+	t_mode->result.v_scale = v_scale;
+	t_mode->result.x_diff = x_diff;
+	t_mode->result.y_diff = y_diff;
+	t_mode->result.v_diff = v_diff;
+	t_mode->result.x_ratio = x_ratio;
+	t_mode->result.y_ratio = y_ratio;
+	t_mode->result.v_ratio = 0;
+	t_mode->result.rotated = cs->effective_orientation;
+
+	return 0;
+}
+
+//============================================================
+//  modeline_get_line_params
+//============================================================
+
+int modeline_get_line_params(modeline *mode, monitor_range *range)
+{
+	int hhi, hhf, hht;
+	int hh, hs, he, ht;
+	float line_time, char_time, new_char_time;
+	float hfront_porch_min, hsync_pulse_min, hback_porch_min;
+
+	hfront_porch_min = range->hfront_porch * .90;
+	hsync_pulse_min  = range->hsync_pulse  * .90;
+	hback_porch_min  = range->hback_porch  * .90;
+
+	line_time = 1 / mode->hfreq * 1000000;
+
+	hh = round(mode->hactive / 8);
+	hs = he = ht = 1;
+
+	do {
+		char_time = line_time / (hh + hs + he + ht);
+		if (hs * char_time < hfront_porch_min ||
+			fabs((hs + 1) * char_time - range->hfront_porch) < fabs(hs * char_time - range->hfront_porch))
+			hs++;
+
+		if (he * char_time < hsync_pulse_min ||
+		    fabs((he + 1) * char_time - range->hsync_pulse) < fabs(he * char_time - range->hsync_pulse))
+			he++;
+
+		if (ht * char_time < hback_porch_min ||
+		    fabs((ht + 1) * char_time - range->hback_porch) < fabs(ht * char_time - range->hback_porch))
+			ht++;
+
+		new_char_time = line_time / (hh + hs + he + ht);
+	} while (new_char_time != char_time);
+
+	hhi = (hh + hs) * 8;
+	hhf = (hh + hs + he) * 8;
+	hht = (hh + hs + he + ht) * 8;
+
+	mode->hbegin  = hhi;
+	mode->hend    = hhf;
+	mode->htotal  = hht;
+
+	return 0;
+}
+
+//============================================================
+//  scale_into_range
+//============================================================
+
+int scale_into_range (int value, int lower_limit, int higher_limit)
+{
+	int scale = 1;
+	while (value * scale < lower_limit) scale ++;
+	if (value * scale <= higher_limit)
+		return scale;
+	else
+		return 0;
+}
+
+//============================================================
+//  scale_into_range
+//============================================================
+
+int scale_into_range (float value, float lower_limit, float higher_limit)
+{
+	int scale = 1;
+	while (value * scale < lower_limit) scale ++;
+	if (value * scale <= higher_limit)
+		return scale;
+	else
+		return 0;
+}
+
+
+//============================================================
+//  scale_into_aspect
+//============================================================
+
+int scale_into_aspect (int source_res, int tot_res, float original_monitor_aspect, float users_monitor_aspect, float *best_diff)
+{
+	int scale = 1, best_scale = 1;
+	float diff = 0;
+	*best_diff = 0;
+
+	while (source_res * scale <= tot_res)
+	{
+		diff = fabs(1 - fabs(users_monitor_aspect / (float(tot_res) / float(source_res * scale) * original_monitor_aspect))) * 100;
+		if (diff < *best_diff || *best_diff == 0)
+		{
+			*best_diff = diff;
+			best_scale = scale;
+		}
+		scale ++;
+	}
+	return best_scale;
+
+}
+
+//============================================================
+//  stretch_into_range
+//============================================================
+
+int stretch_into_range(float vfreq, monitor_range *range, bool interlace_allowed, float *interlace)
+{
+	int yres, lower_limit;
+
+	if (range->interlaced_lines_min && interlace_allowed)
+	{
+		yres = range->interlaced_lines_max;
+		lower_limit = range->interlaced_lines_min;
+		*interlace = 2;
+	}
+	else
+	{
+		yres = range->progressive_lines_max;
+		lower_limit = range->progressive_lines_min;
+	}
+
+	while (yres > lower_limit && max_vfreq_for_yres(yres, range, *interlace) < vfreq)
+		yres -= 8;
+
+	return yres;
+}
+
+
+//============================================================
+//  total_lines_for_yres
+//============================================================
+
+int total_lines_for_yres(int yres, float vfreq, monitor_range *range, float interlace)
+{
+	int vvt = max(yres / interlace + round_near(vfreq * yres / (interlace * (1.0 - vfreq * range->vertical_blank)) * range->vertical_blank), 1);
+	while ((vfreq * vvt < range->hfreq_min) && (vfreq * (vvt + 1) < range->hfreq_max)) vvt++;
+	return vvt;
+}
+
+//============================================================
+//  max_vfreq_for_yres
+//============================================================
+
+float max_vfreq_for_yres (int yres, monitor_range *range, float interlace)
+{
+	return range->hfreq_max / (yres / interlace + round_near(range->hfreq_max * range->vertical_blank));
+}
+
+//============================================================
+//  modeline_print
+//============================================================
+
+char * modeline_print(modeline *mode, char *modeline, int flags)
+{
+	char label[32]={'\x00'};
+	char params[192]={'\x00'};
+
+	if (flags & MS_LABEL)
+		sprintf(label, "\"%dx%d_%d %.2fKHz %.2fHz\"", mode->hactive, mode->vactive, mode->refresh, mode->hfreq/1000, mode->vfreq);
+
+	if (flags & MS_LABEL_SDL)
+		sprintf(label, "\"%dx%d_%.2f\"", mode->hactive, mode->vactive, mode->vfreq);
+
+	if (flags & MS_PARAMS)
+		sprintf(params, " %.2f %d %d %d %d %d %d %d %d %s %s %s %s", float(mode->pclock)/1000000.0, mode->hactive, mode->hbegin, mode->hend, mode->htotal, mode->vactive, mode->vbegin, mode->vend, mode->vtotal,
+			mode->interlace?"interlace":"", mode->doublescan?"doublescan":"", mode->hsync?"+hsync":"-hsync", mode->vsync?"+vsync":"-vsync");
+
+	sprintf(modeline, "%s%s", label, params);
+
+	return modeline;
+}
+
+//============================================================
+//  modeline_result
+//============================================================
+
+char * modeline_result(modeline *mode, char *result)
+{
+	osd_printf_verbose("   rng(%d): ", mode->range);
+
+	if (mode->result.weight & R_OUT_OF_RANGE)
+		sprintf(result, " out of range");
+
+	else
+		sprintf(result, "%4d x%4d_%3.3f%s%s %3.3f [%s] scale(%d, %d, %d) diff(%.2f, %.2f, %.4f) ratio(%.3f, %.3f)",
+			mode->hactive, mode->vactive, mode->vfreq, mode->interlace?"i":"p", mode->doublescan?"d":"", mode->hfreq/1000, mode->result.weight & R_RES_STRETCH?"fract":"integ",
+			mode->result.x_scale, mode->result.y_scale, mode->result.v_scale, mode->result.x_diff, mode->result.y_diff, mode->result.v_diff, mode->result.x_ratio, mode->result.y_ratio);
+	return result;
+}
+
+//============================================================
+//  modeline_compare
+//============================================================
+
+int modeline_compare(modeline *t, modeline *best)
+{
+	bool vector = (t->hactive == (int)t->result.x_ratio);
+
+	if (t->result.weight < best->result.weight)
+		return 1;
+
+	else if (t->result.weight <= best->result.weight)
+	{
+		float t_v_diff = fabs(t->result.v_diff);
+		float b_v_diff = fabs(best->result.v_diff);
+
+		if (t->result.weight & R_RES_STRETCH || vector)
+		{
+			float t_y_score = t->result.y_ratio * (t->interlace?(2.0/3.0):1.0);
+			float b_y_score = best->result.y_ratio * (best->interlace?(2.0/3.0):1.0);
+
+			if	((t_v_diff <  b_v_diff) ||
+				((t_v_diff == b_v_diff) && (t_y_score > b_y_score)) ||
+				((t_v_diff == b_v_diff) && (t_y_score == b_y_score) && (t->result.x_ratio > best->result.x_ratio)))
+					return 1;
+		}
+		else
+		{
+			int t_y_score = t->result.y_scale + t->interlace + t->doublescan;
+			int b_y_score = best->result.y_scale + best->interlace + best->doublescan;
+			float xy_diff = t->result.x_diff + t->result.y_diff;
+			float best_xy_diff = best->result.x_diff + best->result.y_diff;
+
+			if	((t_y_score < b_y_score) ||
+				((t_y_score == b_y_score) && (xy_diff < best_xy_diff)) ||
+				((t_y_score == b_y_score) && (xy_diff == best_xy_diff) && (t->result.x_scale < best->result.x_scale)) ||
+				((t_y_score == b_y_score) && (xy_diff == best_xy_diff) && (t->result.x_scale == best->result.x_scale) && (t_v_diff <  b_v_diff)))
+					return 1;
+		}
+	}
+	return 0;
+}
+
+//============================================================
+//  modeline_vesa_gtf
+//  Based on the VESA GTF spreadsheet by Andy Morrish 1/5/97
+//============================================================
+
+int modeline_vesa_gtf(modeline *m)
+{
+	int C, M;
+	int v_sync_lines, v_porch_lines_min, v_front_porch_lines, v_back_porch_lines, v_sync_v_back_porch_lines, v_total_lines;
+	int h_sync_width_percent, h_sync_width_pixels, h_blanking_pixels, h_front_porch_pixels, h_total_pixels;
+	float v_freq, v_freq_est, v_freq_real, v_sync_v_back_porch;
+	float h_freq, h_period, h_period_real, h_ideal_blanking;
+	float pixel_freq, interlace;
+
+	// Check if there's a value defined for vfreq. We're assuming input vfreq is the total field vfreq regardless interlace
+	v_freq = m->vfreq? m->vfreq:float(m->refresh);
+
+	// These values are GTF defined defaults
+	v_sync_lines = 3;
+	v_porch_lines_min = 1;
+	v_front_porch_lines = v_porch_lines_min;
+	v_sync_v_back_porch = 550;
+	h_sync_width_percent = 8;
+	M = 128.0 / 256 * 600;
+	C = ((40 - 20) * 128.0 / 256) + 20;
+
+	// GTF calculation
+	interlace = m->interlace?0.5:0;
+	h_period = ((1.0 / v_freq) - (v_sync_v_back_porch / 1000000)) / ((float)m->height + v_front_porch_lines + interlace) * 1000000;
+	v_sync_v_back_porch_lines = round_near(v_sync_v_back_porch / h_period);
+	v_back_porch_lines = v_sync_v_back_porch_lines - v_sync_lines;
+	v_total_lines = m->height + v_front_porch_lines + v_sync_lines + v_back_porch_lines;
+	v_freq_est = (1.0 / h_period) / v_total_lines * 1000000;
+	h_period_real = h_period / (v_freq / v_freq_est);
+	v_freq_real = (1.0 / h_period_real) / v_total_lines * 1000000;
+	h_ideal_blanking = float(C - (M * h_period_real / 1000));
+	h_blanking_pixels = round_near(m->width * h_ideal_blanking /(100 - h_ideal_blanking) / (2 * 8)) * (2 * 8);
+	h_total_pixels = m->width + h_blanking_pixels;
+	pixel_freq = h_total_pixels / h_period_real * 1000000;
+	h_freq = 1000000 / h_period_real;
+	h_sync_width_pixels = round_near(h_sync_width_percent * h_total_pixels / 100 / 8) * 8;
+	h_front_porch_pixels = (h_blanking_pixels / 2) - h_sync_width_pixels;
+
+	// Results
+	m->hactive = m->width;
+	m->hbegin = m->hactive + h_front_porch_pixels;
+	m->hend = m->hbegin + h_sync_width_pixels;
+	m->htotal = h_total_pixels;
+	m->vactive = m->height;
+	m->vbegin = m->vactive + v_front_porch_lines;
+	m->vend = m->vbegin + v_sync_lines;
+	m->vtotal = v_total_lines;
+	m->hfreq = h_freq;
+	m->vfreq = v_freq_real;
+	m->pclock = pixel_freq;
+	m->hsync = 0;
+	m->vsync = 1;
+
+	return true;
+}
+
+//============================================================
+//  modeline_parse
+//============================================================
+
+int modeline_parse(const char *user_modeline, modeline *mode)
+{
+	char modeline_txt[256]={'\x00'};
+
+	if (strcmp(user_modeline, "auto"))
+	{
+		// Remove quotes
+		char *quote_start, *quote_end;
+		quote_start = strstr((char*)user_modeline, "\"");
+		if (quote_start)
+		{
+			quote_start++;
+			quote_end = strstr(quote_start, "\"");
+			if (!quote_end || *quote_end++ == 0)
+				return false;
+			user_modeline = quote_end;
+		}
+
+		// Get timing flags
+		mode->interlace = strstr(user_modeline, "interlace")?1:0;
+		mode->doublescan = strstr(user_modeline, "doublescan")?1:0;
+		mode->hsync = strstr(user_modeline, "+hsync")?1:0;
+		mode->vsync = strstr(user_modeline, "+vsync")?1:0;
+
+		// Get timing values
+		float pclock;
+		int e = sscanf(user_modeline, " %f %d %d %d %d %d %d %d %d",
+			&pclock,
+			&mode->hactive, &mode->hbegin, &mode->hend, &mode->htotal,
+			&mode->vactive, &mode->vbegin, &mode->vend, &mode->vtotal);
+
+		if (e != 9)
+		{
+			osd_printf_error("SwitchRes: missing parameter in user modeline\n  %s\n", user_modeline);
+			memset(mode, 0, sizeof(struct modeline));
+			return false;
+		}
+
+		// Calculate timings
+		mode->pclock = pclock * 1000000.0;
+		mode->hfreq = mode->pclock / mode->htotal;
+		mode->vfreq = mode->hfreq / mode->vtotal * (mode->interlace?2:1);
+		mode->refresh = mode->vfreq;
+		osd_printf_verbose("SwitchRes: user modeline %s\n", modeline_print(mode, modeline_txt, MS_FULL));
+	}
+	return true;
+}
+
+//============================================================
+//  round_near
+//============================================================
+
+int round_near(double number)
+{
+    return number < 0.0 ? ceil(number - 0.5) : floor(number + 0.5);
+}
diff -Nru ./src_0.154_hi/emu/switchres/monitor.c ./src/emu/switchres/monitor.c
--- ./src_0.154_hi/emu/switchres/monitor.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/emu/switchres/monitor.c	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,558 @@
+/**************************************************************
+
+   monitor.c - Monitor presets and custom monitor definition
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2013 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+#include "emu.h"
+#include "emuopts.h"
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+#define HFREQ_MIN  14000
+#define HFREQ_MAX  100000
+#define VFREQ_MIN  40
+#define VFREQ_MAX  200
+#define PROGRESSIVE_LINES_MIN 128
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int get_monitor_specs(running_machine &machine);
+int fill_monitor_range(monitor_range *range, const char *specs_line);
+int show_monitor_range(monitor_range *range);
+int set_monitor_preset(char *type, monitor_range *range);
+int fill_lcd_range(monitor_range *range, const char *specs_line);
+int fill_vesa_gtf(monitor_range *range, const char *max_lines);
+int fill_vesa_range(monitor_range *range, int lines_min, int lines_max);
+int evaluate_monitor_range(monitor_range *range);
+int monitor_range_from_modeline(monitor_range *range, modeline *mode);
+
+//============================================================
+//  get_monitor_specs
+//============================================================
+
+int get_monitor_specs(running_machine &machine)
+{
+	switchres_manager *switchres = &machine.switchres;
+	char default_monitor[] = "generic_15";
+
+	memset(&switchres->range[0], 0, sizeof(struct monitor_range) * MAX_RANGES);
+
+	if (!strcmp(switchres->cs.monitor, "custom"))
+	{
+		fill_monitor_range(&switchres->range[0],machine.options().crt_range0());
+		fill_monitor_range(&switchres->range[1],machine.options().crt_range1());
+		fill_monitor_range(&switchres->range[2],machine.options().crt_range2());
+		fill_monitor_range(&switchres->range[3],machine.options().crt_range3());
+		fill_monitor_range(&switchres->range[4],machine.options().crt_range4());
+		fill_monitor_range(&switchres->range[5],machine.options().crt_range5());
+		fill_monitor_range(&switchres->range[6],machine.options().crt_range6());
+		fill_monitor_range(&switchres->range[7],machine.options().crt_range7());
+		fill_monitor_range(&switchres->range[8],machine.options().crt_range8());
+		fill_monitor_range(&switchres->range[9],machine.options().crt_range9());
+	}
+	else if (!strcmp(switchres->cs.monitor, "lcd"))
+		fill_lcd_range(&switchres->range[0],machine.options().lcd_range());
+
+	else if (set_monitor_preset(switchres->cs.monitor, switchres->range) == 0)
+		set_monitor_preset(default_monitor, switchres->range);
+
+	return 0;
+}
+
+//============================================================
+//  fill_monitor_range
+//============================================================
+
+int fill_monitor_range(monitor_range *range, const char *specs_line)
+{
+	monitor_range new_range;
+
+	if (strcmp(specs_line, "auto")) {
+		int e = sscanf(specs_line, "%lf-%lf,%lf-%lf,%lf,%lf,%lf,%lf,%lf,%lf,%d,%d,%d,%d,%d,%d",
+			&new_range.hfreq_min, &new_range.hfreq_max,
+			&new_range.vfreq_min, &new_range.vfreq_max,
+			&new_range.hfront_porch, &new_range.hsync_pulse, &new_range.hback_porch,
+			&new_range.vfront_porch, &new_range.vsync_pulse, &new_range.vback_porch,
+			&new_range.hsync_polarity, &new_range.vsync_polarity,
+			&new_range.progressive_lines_min, &new_range.progressive_lines_max,
+			&new_range.interlaced_lines_min, &new_range.interlaced_lines_max);
+
+		if (e != 16) {
+			osd_printf_error("SwitchRes: Error trying to fill monitor range with\n  %s\n", specs_line);
+			return -1;
+		}
+
+		new_range.vfront_porch /= 1000;
+		new_range.vsync_pulse /= 1000;
+		new_range.vback_porch /= 1000;
+		new_range.vertical_blank = (new_range.vfront_porch + new_range.vsync_pulse + new_range.vback_porch);
+
+		if (evaluate_monitor_range(&new_range))
+		{
+			osd_printf_error("SwitchRes: Error in monitor range (ignoring): %s\n", specs_line);
+			return -1;
+		}
+		else
+		{
+			memcpy(range, &new_range, sizeof(struct monitor_range));
+			show_monitor_range(range);
+		}
+	}
+	return 0;
+}
+
+//============================================================
+//  fill_lcd_range
+//============================================================
+
+int fill_lcd_range(monitor_range *range, const char *specs_line)
+{
+	if (strcmp(specs_line, "auto"))
+	{
+		if (sscanf(specs_line, "%lf-%lf", &range->vfreq_min, &range->vfreq_max) == 2)
+		{
+			osd_printf_verbose("SwitchRes: LCD vfreq range set by user as %f-%f\n", range->vfreq_min, range->vfreq_max);
+			return true;
+		}
+		else
+			osd_printf_error("SwitchRes: Error trying to fill LCD range with\n  %s\n", specs_line);
+	}
+	// Use default values
+	range->vfreq_min = range->vfreq_max = 60;
+	osd_printf_verbose("SwitchRes: Using default vfreq range for LCD %f-%f\n", range->vfreq_min, range->vfreq_max);
+
+	return 0;
+}
+
+//============================================================
+//  fill_vesa_gtf
+//============================================================
+
+int fill_vesa_gtf(monitor_range *range, const char *max_lines)
+{
+	int lines = 0;
+	sscanf(max_lines, "vesa_%d", &lines);
+
+	if (!lines)
+		return 0;
+
+	int i = 0;
+	if (lines >= 480)
+		i += fill_vesa_range(&range[i], 384, 480);
+	if (lines >= 600)
+		i += fill_vesa_range(&range[i], 480, 600);
+	if (lines >= 768)
+		i += fill_vesa_range(&range[i], 600, 768);
+	if (lines >= 1024)
+		i += fill_vesa_range(&range[i], 768, 1024);
+
+	return i;
+}
+
+//============================================================
+//  fill_vesa_range
+//============================================================
+
+int fill_vesa_range(monitor_range *range, int lines_min, int lines_max)
+{
+	modeline mode;
+	memset(&mode, 0, sizeof(modeline));
+
+	mode.width = real_res(STANDARD_CRT_ASPECT * lines_max);
+	mode.height = lines_max;
+	mode.refresh = 60;
+	range->vfreq_min = 50;
+	range->vfreq_max = 65;
+
+	modeline_vesa_gtf(&mode);
+	monitor_range_from_modeline(range, &mode);
+
+	range->progressive_lines_min = lines_min;
+	range->hfreq_min = mode.hfreq - 500;
+	range->hfreq_max = mode.hfreq + 500;
+	show_monitor_range(range);
+
+	return 1;
+}
+
+//============================================================
+//  show_monitor_range
+//============================================================
+
+int show_monitor_range(monitor_range *range)
+{
+	osd_printf_verbose("SwitchRes: Monitor range %.2f-%.2f,%.2f-%.2f,%.3f,%.3f,%.3f,%.3f,%.3f,%.3f,%d,%d,%d,%d,%d,%d\n",
+		range->hfreq_min, range->hfreq_max,
+		range->vfreq_min, range->vfreq_max,
+		range->hfront_porch, range->hsync_pulse, range->hback_porch,
+		range->vfront_porch * 1000, range->vsync_pulse * 1000, range->vback_porch * 1000,
+		range->hsync_polarity, range->vsync_polarity,
+		range->progressive_lines_min, range->progressive_lines_max,
+		range->interlaced_lines_min, range->interlaced_lines_max);
+
+	return 0;
+}
+
+//============================================================
+//  set_monitor_preset
+//============================================================
+
+int set_monitor_preset(char *type, monitor_range *range)
+{
+	// PAL TV - 50 Hz/625
+	if (!strcmp(type, "pal"))
+	{
+		fill_monitor_range(&range[0], "15625.00-15625.00, 50.00-50.00, 1.500, 4.700, 5.800, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// NTSC TV - 60 Hz/525
+	else if (!strcmp(type, "ntsc"))
+	{
+		fill_monitor_range(&range[0], "15734.26-15734.26, 59.94-59.94, 1.500, 4.700, 4.700, 0.191, 0.191, 0.953, 0, 0, 192, 240, 448, 480");
+		return 1;
+	}
+	// Generic 15.7 kHz
+	else if (!strcmp(type, "generic_15"))
+	{
+		fill_monitor_range(&range[0], "15625-15750, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Arcade 15.7 kHz - standard resolution
+	else if (!strcmp(type, "arcade_15"))
+	{
+		fill_monitor_range(&range[0], "15625-16200, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Arcade 15.7-16.5 kHz - extended resolution
+	else if (!strcmp(type, "arcade_15ex"))
+	{
+		fill_monitor_range(&range[0], "15625-16500, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Arcade 25.0 kHz - medium resolution
+	else if (!strcmp(type, "arcade_25"))
+	{
+		fill_monitor_range(&range[0], "24960-24960, 49.50-65.00, 0.800, 4.000, 3.200, 0.080, 0.200, 1.000, 0, 0, 384, 400, 768, 800");
+		return 1;
+	}
+	// Arcade 31.5 kHz - medium resolution
+	else if (!strcmp(type, "arcade_31"))
+	{
+		fill_monitor_range(&range[0], "31400-31500, 49.50-65.00, 0.940, 3.770, 1.890, 0.349, 0.064, 1.017, 0, 0, 400, 512, 0, 0");
+		return 1;
+	}
+	// Arcade 15.7/25.0 kHz - dual-sync
+	else if (!strcmp(type, "arcade_15_25"))
+	{
+		fill_monitor_range(&range[0], "15625-16200, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		fill_monitor_range(&range[1], "24960-24960, 49.50-65.00, 0.800, 4.000, 3.200, 0.080, 0.200, 1.000, 0, 0, 384, 400, 768, 800");
+		return 2;
+	}
+	// Arcade 15.7/25.0/31.5 kHz - tri-sync
+	else if (!strcmp(type, "arcade_15_25_31"))
+	{
+		fill_monitor_range(&range[0], "15625-16200, 49.50-65.00, 2.000, 4.700, 8.000, 0.064, 0.192, 1.024, 0, 0, 192, 288, 448, 576");
+		fill_monitor_range(&range[1], "24960-24960, 49.50-65.00, 0.800, 4.000, 3.200, 0.080, 0.200, 1.000, 0, 0, 384, 400, 768, 800");
+		fill_monitor_range(&range[2], "31400-31500, 49.50-65.00, 0.940, 3.770, 1.890, 0.349, 0.064, 1.017, 0, 0, 400, 512, 0, 0");
+		return 3;
+	}
+	// Makvision 2929D
+	else if (!strcmp(type, "m2929"))
+	{
+		fill_monitor_range(&range[0], "30000-40000, 47.00-90.00, 0.600, 2.500, 2.800, 0.032, 0.096, 0.448, 0, 0, 384, 640, 0, 0");
+		return 1;
+	}
+	// Wells Gardner D9800, D9400
+	else if (!strcmp(type, "d9800") || !strcmp(type, "d9400"))
+	{
+		fill_monitor_range(&range[0], "15250-18000, 40-80, 2.187, 4.688, 6.719, 0.190, 0.191, 1.018, 0, 0, 224, 288, 448, 576");
+		fill_monitor_range(&range[1], "18001-19000, 40-80, 2.187, 4.688, 6.719, 0.140, 0.191, 0.950, 0, 0, 288, 320, 0, 0");
+		fill_monitor_range(&range[2], "20501-29000, 40-80, 2.910, 3.000, 4.440, 0.451, 0.164, 1.048, 0, 0, 320, 384, 0, 0");
+		fill_monitor_range(&range[3], "29001-32000, 40-80, 0.636, 3.813, 1.906, 0.318, 0.064, 1.048, 0, 0, 384, 480, 0, 0");
+		fill_monitor_range(&range[4], "32001-34000, 40-80, 0.636, 3.813, 1.906, 0.020, 0.106, 0.607, 0, 0, 480, 576, 0, 0");
+		fill_monitor_range(&range[5], "34001-38000, 40-80, 1.000, 3.200, 2.200, 0.020, 0.106, 0.607, 0, 0, 576, 600, 0, 0");
+		return 6;
+	}
+	// Wells Gardner D9200
+	else if (!strcmp(type, "d9200"))
+	{
+		fill_monitor_range(&range[0], "15250-16500, 40-80, 2.187, 4.688, 6.719, 0.190, 0.191, 1.018, 0, 0, 224, 288, 448, 576");
+		fill_monitor_range(&range[1], "23900-24420, 40-80, 2.910, 3.000, 4.440, 0.451, 0.164, 1.148, 0, 0, 384, 400, 0, 0");
+		fill_monitor_range(&range[2], "31000-32000, 40-80, 0.636, 3.813, 1.906, 0.318, 0.064, 1.048, 0, 0, 400, 512, 0, 0");
+		fill_monitor_range(&range[3], "37000-38000, 40-80, 1.000, 3.200, 2.200, 0.020, 0.106, 0.607, 0, 0, 512, 600, 0, 0");
+		return 4;
+	}
+	// Wells Gardner K7000
+	else if (!strcmp(type, "k7000"))
+	{
+		fill_monitor_range(&range[0], "15625-15800, 49.50-63.00, 2.000, 4.700, 8.000, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Wells Gardner 25K7131
+	else if (!strcmp(type, "k7131"))
+	{
+		fill_monitor_range(&range[0], "15625-16670, 49.5-65, 2.000, 4.700, 8.000, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Wei-Ya M3129
+	else if (!strcmp(type, "m3129"))
+	{
+		fill_monitor_range(&range[0], "15250-16500, 40-80, 2.187, 4.688, 6.719, 0.190, 0.191, 1.018, 1, 1, 192, 288, 448, 576");
+		fill_monitor_range(&range[1], "23900-24420, 40-80, 2.910, 3.000, 4.440, 0.451, 0.164, 1.048, 1, 1, 384, 400, 0, 0");
+		fill_monitor_range(&range[2], "31000-32000, 40-80, 0.636, 3.813, 1.906, 0.318, 0.064, 1.048, 1, 1, 400, 512, 0, 0");
+		return 3;
+	}
+	// Hantarex MTC 9110
+	else if (!strcmp(type, "h9110") || !strcmp(type, "polo"))
+	{
+		fill_monitor_range(&range[0], "15625-16670, 49.5-65, 2.000, 4.700, 8.000, 0.064, 0.160, 1.056, 0, 0, 192, 288, 448, 576");
+		return 1;
+	}
+	// Hantarex Polostar 25
+	else if (!strcmp(type, "pstar"))
+	{
+		fill_monitor_range(&range[0], "15700-15800, 50-65, 1.800, 0.400, 7.400, 0.064, 0.160, 1.056, 0, 0, 192, 256, 0, 0");
+		fill_monitor_range(&range[1], "16200-16300, 50-65, 0.200, 0.400, 8.000, 0.040, 0.040, 0.640, 0, 0, 256, 264, 512, 528");
+		fill_monitor_range(&range[2], "25300-25400, 50-65, 0.200, 0.400, 8.000, 0.040, 0.040, 0.640, 0, 0, 384, 400, 768, 800");
+		fill_monitor_range(&range[3], "31500-31600, 50-65, 0.170, 0.350, 5.500, 0.040, 0.040, 0.640, 0, 0, 400, 512, 0, 0");
+		return 4;
+	}
+	// Nanao MS-2930, MS-2931
+	else if (!strcmp(type, "ms2930"))
+	{
+		fill_monitor_range(&range[0], "15450-16050, 50-65, 3.190, 4.750, 6.450, 0.191, 0.191, 1.164, 0, 0, 192, 288, 448, 576");
+		fill_monitor_range(&range[1], "23900-24900, 50-65, 2.870, 3.000, 4.440, 0.451, 0.164, 1.148, 0, 0, 384, 400, 0, 0");
+    	fill_monitor_range(&range[2], "31000-32000, 50-65, 0.330, 3.580, 1.750, 0.316, 0.063, 1.137, 0, 0, 480, 512, 0, 0");
+		return 3;
+	}
+	// Nanao MS9-29
+	else if (!strcmp(type, "ms929"))
+	{
+		fill_monitor_range(&range[0], "15450-16050, 50-65, 3.910, 4.700, 6.850, 0.190, 0.191, 1.018, 0, 0, 192, 288, 448, 576");
+		fill_monitor_range(&range[1], "23900-24900, 50-65, 2.910, 3.000, 4.440, 0.451, 0.164, 1.048, 0, 0, 384, 400, 0, 0");
+		return 2;
+	}
+	// Rodotron 666B-29
+	else if (!strcmp(type, "r666b"))
+	{
+		fill_monitor_range(&range[0], "15450-16050, 50-65, 3.190, 4.750, 6.450, 0.191, 0.191, 1.164, 0, 0, 192, 288, 448, 576");
+		fill_monitor_range(&range[1], "23900-24900, 50-65, 2.870, 3.000, 4.440, 0.451, 0.164, 1.148, 0, 0, 384, 400, 0, 0");
+		fill_monitor_range(&range[2], "31000-32500, 50-65, 0.330, 3.580, 1.750, 0.316, 0.063, 1.137, 0, 0, 400, 512, 0, 0");
+		return 3;
+	}
+	// PC CRT 70kHz/120Hz
+	else if (!strcmp(type, "pc_31_120"))
+	{
+		fill_monitor_range(&range[0], "31400-31600, 100-130, 0.671, 2.683, 3.353, 0.034, 0.101, 0.436, 0, 0, 200, 256, 0, 0");
+		fill_monitor_range(&range[1], "31400-31600, 50-65, 0.671, 2.683, 3.353, 0.034, 0.101, 0.436, 0, 0, 400, 512, 0, 0");
+		return 2;
+	}
+	// PC CRT 70kHz/120Hz
+	else if (!strcmp(type, "pc_70_120"))
+	{
+		fill_monitor_range(&range[0], "30000-70000, 100-130, 2.201, 0.275, 4.678, 0.063, 0.032, 0.633, 0, 0, 192, 320, 0, 0");
+		fill_monitor_range(&range[1], "30000-70000, 50-65, 2.201, 0.275, 4.678, 0.063, 0.032, 0.633, 0, 0, 400, 1024, 0, 0");
+		return 2;
+	}
+	// VESA GTF
+	else if (!strcmp(type, "vesa_480") || !strcmp(type, "vesa_600") || !strcmp(type, "vesa_768") || !strcmp(type, "vesa_1024"))
+	{
+		return fill_vesa_gtf(&range[0], type);
+	}
+
+	osd_printf_error("SwitchRes: Monitor type unknown: %s\n", type);
+	return 0;
+}
+
+//============================================================
+//  evaluate_monitor_range
+//============================================================
+
+int evaluate_monitor_range(monitor_range *range)
+{
+	// First we check that all frequency ranges are reasonable
+	if (range->hfreq_min < HFREQ_MIN || range->hfreq_min > HFREQ_MAX)
+	{
+		osd_printf_error("SwitchRes: hfreq_min %.2f out of range\n", range->hfreq_min);
+		return 1;
+	}
+	if (range->hfreq_max < HFREQ_MIN || range->hfreq_max < range->hfreq_min || range->hfreq_max > HFREQ_MAX)
+	{
+		osd_printf_error("SwitchRes: hfreq_max %.2f out of range\n", range->hfreq_max);
+		return 1;
+	}
+	if (range->vfreq_min < VFREQ_MIN || range->vfreq_min > VFREQ_MAX)
+	{
+		osd_printf_error("SwitchRes: vfreq_min %.2f out of range\n", range->vfreq_min);
+		return 1;
+	}
+	if (range->vfreq_max < VFREQ_MIN || range->vfreq_max < range->vfreq_min || range->vfreq_max > VFREQ_MAX)
+	{
+		osd_printf_error("SwitchRes: vfreq_max %.2f out of range\n", range->vfreq_max);
+		return 1;
+	}
+
+	// line_time in хs. We check that no horizontal value is longer than a whole line
+	double line_time = 1 / range->hfreq_max * 1000000;
+
+	if (range->hfront_porch <= 0 || range->hfront_porch > line_time)
+	{
+		osd_printf_error("SwitchRes: hfront_porch %.3f out of range\n", range->hfront_porch);
+		return 1;
+	}
+	if (range->hsync_pulse <= 0 || range->hsync_pulse > line_time)
+	{
+		osd_printf_error("SwitchRes: hsync_pulse %.3f out of range\n", range->hsync_pulse);
+		return 1;
+	}
+	if (range->hback_porch <= 0 || range->hback_porch > line_time)
+	{
+		osd_printf_error("SwitchRes: hback_porch %.3f out of range\n", range->hback_porch);
+		return 1;
+	}
+
+	// frame_time in ms. We check that no vertical value is longer than a whole frame
+	double frame_time = 1 / range->vfreq_max * 1000;
+
+	if (range->vfront_porch <= 0 || range->vfront_porch > frame_time)
+	{
+		osd_printf_error("SwitchRes: vfront_porch %.3f out of range\n", range->vfront_porch);
+		return 1;
+	}
+	if (range->vsync_pulse <= 0 || range->vsync_pulse > frame_time)
+	{
+		osd_printf_error("SwitchRes: vsync_pulse %.3f out of range\n", range->vsync_pulse);
+		return 1;
+	}
+	if (range->vback_porch <= 0 || range->vback_porch > frame_time)
+	{
+		osd_printf_error("SwitchRes: vback_porch %.3f out of range\n", range->vback_porch);
+		return 1;
+	}
+
+	// Now we check sync polarities
+	if (range->hsync_polarity != 0 && range->hsync_polarity != 1)
+	{
+		osd_printf_error("SwitchRes: Hsync polarity can be only 0 or 1\n");
+		return 1;
+	}
+	if (range->vsync_polarity != 0 && range->vsync_polarity != 1)
+	{
+		osd_printf_error("SwitchRes: Vsync polarity can be only 0 or 1\n");
+		return 1;
+	}
+
+	// Finally we check that the line limiters are reasonable
+	// Progressive range:
+	if (range->progressive_lines_min > 0 && range->progressive_lines_min < PROGRESSIVE_LINES_MIN)
+	{
+		osd_printf_error("SwitchRes: progressive_lines_min must be greater than %d\n", PROGRESSIVE_LINES_MIN);
+		return 1;
+	}
+	if ((range->progressive_lines_min + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+	{
+		osd_printf_error("SwitchRes: progressive_lines_min %d out of range\n", range->progressive_lines_min);
+		return 1;
+	}
+	if (range->progressive_lines_max < range->progressive_lines_min)
+	{
+		osd_printf_error("SwitchRes: progressive_lines_max must greater than progressive_lines_min\n");
+		return 1;
+	}
+	if ((range->progressive_lines_max + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+	{
+		osd_printf_error("SwitchRes: progressive_lines_max %d out of range\n", range->progressive_lines_max);
+		return 1;
+	}
+
+	// Interlaced range:
+	if (range->interlaced_lines_min != 0)
+	{
+		if (range->interlaced_lines_min < range->progressive_lines_max)
+		{
+			osd_printf_error("SwitchRes: interlaced_lines_min must greater than progressive_lines_max\n");
+			return 1;
+		}
+		if (range->interlaced_lines_min < PROGRESSIVE_LINES_MIN * 2)
+		{
+			osd_printf_error("SwitchRes: interlaced_lines_min must be greater than %d\n", PROGRESSIVE_LINES_MIN * 2);
+			return 1;
+		}
+		if ((range->interlaced_lines_min / 2 + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+		{
+			osd_printf_error("SwitchRes: interlaced_lines_min %d out of range\n", range->interlaced_lines_min);
+			return 1;
+		}
+		if (range->interlaced_lines_max < range->interlaced_lines_min)
+		{
+			osd_printf_error("SwitchRes: interlaced_lines_max must greater than interlaced_lines_min\n");
+			return 1;
+		}
+		if ((range->interlaced_lines_max / 2 + range->hfreq_max * range->vertical_blank) * range->vfreq_min > range->hfreq_max)
+		{
+			osd_printf_error("SwitchRes: interlaced_lines_max %d out of range\n", range->interlaced_lines_max);
+			return 1;
+		}
+	}
+	else
+	{
+		if (range->interlaced_lines_max != 0)
+		{
+			osd_printf_error("SwitchRes: interlaced_lines_max must be zero if interlaced_lines_min is not defined\n");
+			return 1;
+		}
+	}
+	return 0;
+}
+
+//============================================================
+//  monitor_range_from_modeline
+//============================================================
+
+int monitor_range_from_modeline(monitor_range *range, modeline *mode)
+{
+	if (range->vfreq_min == 0)
+	{
+		range->vfreq_min = mode->vfreq - 0.2;
+		range->vfreq_max = mode->vfreq + 0.2;
+	}
+
+	float line_time = 1 / mode->hfreq;
+	float pixel_time = line_time / mode->htotal * 1000000;
+
+	range->hfront_porch = pixel_time * (mode->hbegin - mode->hactive);
+	range->hsync_pulse = pixel_time * (mode->hend - mode->hbegin);
+	range->hback_porch = pixel_time * (mode->htotal - mode->hend);
+
+	range->vfront_porch = line_time * (mode->vbegin - mode->vactive);
+	range->vsync_pulse = line_time * (mode->vend - mode->vbegin);
+	range->vback_porch = line_time * (mode->vtotal - mode->vend);
+	range->vertical_blank = range->vfront_porch + range->vsync_pulse + range->vback_porch;
+
+	range->hsync_polarity = mode->hsync;
+	range->vsync_polarity = mode->vsync;
+
+	range->progressive_lines_min = mode->interlace?0:mode->vactive;
+	range->progressive_lines_max = mode->interlace?0:mode->vactive;
+	range->interlaced_lines_min = mode->interlace?mode->vactive:0;
+	range->interlaced_lines_max= mode->interlace?mode->vactive:0;
+
+	range->hfreq_min = range->vfreq_min * mode->vtotal;
+	range->hfreq_max = range->vfreq_max * mode->vtotal;
+
+	return 1;
+}
\ No newline at end of file
diff -Nru ./src_0.154_hi/emu/switchres/switchres.c ./src/emu/switchres/switchres.c
--- ./src_0.154_hi/emu/switchres/switchres.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/emu/switchres/switchres.c	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,355 @@
+/**************************************************************
+
+   switchres.c - SwichRes core routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2013 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+#include "emu.h"
+#include "emuopts.h"
+#include "config.h"
+#include "rendutil.h"
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+void set_option(running_machine &machine, const char *option_ID, bool state);
+bool switchres_init_osd(running_machine &machine);
+static void switchres_load(running_machine &machine, int config_type, xml_data_node *parentnode);
+static void switchres_save(running_machine &machine, int config_type, xml_data_node *parentnode);
+
+//============================================================
+//  switchres_get_video_mode
+//============================================================
+
+bool switchres_get_video_mode(running_machine &machine)
+{
+	switchres_manager *switchres = &machine.switchres;
+	config_settings *cs = &switchres->cs;
+	game_info *game = &switchres->game;
+	monitor_range *range = switchres->range;
+	modeline *mode;
+	modeline *mode_table = switchres->video_modes;
+	modeline *best_mode = &switchres->best_mode;
+	modeline *user_mode = &switchres->user_mode;
+	modeline source_mode, *s_mode = &source_mode;
+	modeline target_mode, *t_mode = &target_mode;
+	char modeline[256]={'\x00'};
+	char result[256]={'\x00'};
+	int i = 0, j = 0, table_size = 0;
+
+	cs->effective_orientation = effective_orientation(machine);
+
+	osd_printf_verbose("SwitchRes: v%s:[%s] Calculating best video mode for %dx%d@%.6f orientation: %s\n",
+						SWITCHRES_VERSION, game->name, game->width, game->height, game->refresh,
+						cs->effective_orientation?"rotated":"normal");
+
+	memset(best_mode, 0, sizeof(struct modeline));
+	best_mode->result.weight |= R_OUT_OF_RANGE;
+	s_mode->hactive = game->vector?1:normalize(game->width, 8);
+	s_mode->vactive = game->vector?1:game->height;
+	s_mode->vfreq = game->refresh;
+
+	if (user_mode->hactive)
+	{
+		table_size = 1;
+		mode = user_mode;
+	}
+	else
+	{
+		i = 1;
+		table_size = MAX_MODELINES;
+		mode = &mode_table[i];
+	}
+
+	while (mode->width && i < table_size)
+	{
+		osd_printf_verbose("\nSwitchRes: %s%4d%sx%s%4d%s_%s%d=%.4fHz%s%s\n",
+			mode->type & X_RES_EDITABLE?"(":"[", mode->width, mode->type & X_RES_EDITABLE?")":"]",
+			mode->type & Y_RES_EDITABLE?"(":"[", mode->height, mode->type & Y_RES_EDITABLE?")":"]",
+			mode->type & V_FREQ_EDITABLE?"(":"[", mode->refresh, mode->vfreq, mode->type & V_FREQ_EDITABLE?")":"]",
+			mode->type & MODE_LOCKED?" - locked":"");
+
+		if (!(mode->type & MODE_LOCKED))
+		{
+			for (j = 0 ; j < MAX_RANGES ; j++)
+			{
+				if (range[j].hfreq_min)
+				{
+					memcpy(t_mode, mode, sizeof(struct modeline));
+					modeline_create(s_mode, t_mode, &range[j], cs);
+					t_mode->range = j;
+
+					osd_printf_verbose("%s\n", modeline_result(t_mode, result));
+
+					if (modeline_compare(t_mode, best_mode))
+						memcpy(best_mode, t_mode, sizeof(struct modeline));
+				}
+			}
+		}
+		mode++;
+		i++;
+	}
+
+	if (best_mode->result.weight & R_OUT_OF_RANGE)
+	{
+		osd_printf_error("SwitchRes: could not find a video mode that meets your specs\n");
+		return false;
+	}
+
+	osd_printf_info("\nSwitchRes: [%s] (%d) %s (%dx%d@%.2f)->(%dx%d@%.2f)\n", game->name, game->screens, game->orientation?"vertical":"horizontal",
+		game->width, game->height, game->refresh, best_mode->hactive, best_mode->vactive, best_mode->vfreq);
+
+	osd_printf_verbose("%s\n", modeline_result(best_mode, result));
+	if (cs->modeline_generation)
+		osd_printf_verbose("SwitchRes: Modeline %s\n", modeline_print(best_mode, modeline, MS_FULL));
+
+	return true;
+}
+
+//============================================================
+//  switchres_init
+//============================================================
+
+void switchres_init(running_machine &machine)
+{
+	config_settings *cs = &machine.switchres.cs;
+	game_info *game = &machine.switchres.game;
+	modeline *user_mode = &machine.switchres.user_mode;
+	const game_driver *game_drv = &machine.system();
+	const screen_device *devconfig;
+
+	// Reset config settings
+	memset(cs, 0, sizeof(struct config_settings));
+	memset(game, 0, sizeof(struct game_info));
+
+	// Get user defined modeline
+	if (machine.options().modeline_generation())
+		modeline_parse(machine.options().modeline(), user_mode);
+
+	// Register for configuration
+	config_register(machine, "switchres", config_saveload_delegate(FUNC(switchres_load), &machine), config_saveload_delegate(FUNC(switchres_save), &machine));
+
+	// Get monitor specs
+	sprintf(cs->monitor, "%s", machine.options().monitor());
+	sprintf(cs->connector, "%s", machine.options().connector());
+	for (int i = 0; cs->monitor[i]; i++) cs->monitor[i] = tolower(cs->monitor[i]);
+	if (user_mode->hactive)
+	{
+		monitor_range_from_modeline(machine.switchres.range, user_mode);
+		show_monitor_range(machine.switchres.range);
+	}
+	else
+		get_monitor_specs(machine);
+
+	// Get rest of config options
+	cs->modeline_generation = machine.options().modeline_generation();
+	cs->doublescan = machine.options().doublescan();
+	cs->interlace = machine.options().interlace();
+	cs->lock_system_modes = machine.options().lock_system_modes();
+	cs->lock_unsupported_modes = machine.options().lock_unsupported_modes();
+	cs->refresh_dont_care = machine.options().refresh_dont_care();
+	cs->cleanstretch = machine.options().cleanstretch();
+	sscanf(machine.options().sync_refresh_tolerance(), "%f", &cs->sync_refresh_tolerance);
+	float pclock_min;
+	sscanf(machine.options().dotclock_min(), "%f", &pclock_min);
+	cs->pclock_min = pclock_min * 1000000;
+
+	// Get game information
+	sprintf(game->name, "%s", machine.options().system_name());
+	if (game->name[0] == 0) sprintf(game->name, "empty");
+
+	machine_config config(*game_drv, machine.options());
+	devconfig = config.first_screen();
+
+	// Fill in current video mode settings
+	game->orientation = effective_orientation(machine);
+
+	if (devconfig->screen_type() == SCREEN_TYPE_VECTOR)
+	{
+		game->vector = 1;
+		game->width = 640;
+		game->height = 480;
+	}
+
+	// Output width and height only for games that are not vector
+	else
+	{
+		const rectangle &visarea = devconfig->visible_area();
+		int w = visarea.max_x - visarea.min_x + 1;
+		int h = visarea.max_y - visarea.min_y + 1;
+		game->width = game->orientation?h:w;
+		game->height = game->orientation?w:h;
+	}
+
+	game->refresh = ATTOSECONDS_TO_HZ(devconfig->refresh_attoseconds());
+
+	// Check for multiple screens
+	screen_device_iterator iter(config.root_device());
+	for (devconfig = iter.first(); devconfig != NULL; devconfig = iter.next())
+		game->screens++;
+
+	osd_printf_verbose("SwitchRes: Monitor: %s Orientation: %s Modeline generation: %s\n",
+		cs->monitor, game->orientation?"vertical":"horizontal", cs->modeline_generation?"enabled":"disabled");
+
+	// Init OSD
+	switchres_init_osd(machine);
+}
+
+//============================================================
+//  effective_orientation
+//============================================================
+
+bool effective_orientation(running_machine &machine)
+{
+	game_info *game_info = &machine.switchres.game;
+	config_settings *cs = &machine.switchres.cs;
+	const game_driver *game = &machine.system();
+	emu_options &options = machine.options();
+	render_target *target = machine.render().first_target();
+
+	game_info->orientation = ((game->flags & ORIENTATION_MASK) & ORIENTATION_SWAP_XY);
+
+	if (target)
+		cs->monitor_orientation = ((target->orientation() & ORIENTATION_MASK) & ORIENTATION_SWAP_XY);
+	else if (!strcmp(options.orientation(), "horizontal"))
+		cs->monitor_orientation = 0;
+	else if (!strcmp(options.orientation(), "vertical"))
+		cs->monitor_orientation = 1;
+	else if (!strcmp(options.orientation(), "rotate") || !strcmp(options.orientation(), "rotate_r"))
+	{
+		cs->monitor_orientation = game_info->orientation;
+		cs->monitor_rotates_cw = 0;
+	}
+	else if (!strcmp(options.orientation(), "rotate_l"))
+	{
+		cs->monitor_orientation = game_info->orientation;
+		cs->monitor_rotates_cw = 1;
+	}
+
+	return game_info->orientation ^ cs->monitor_orientation;
+}
+
+//============================================================
+//  switchres_check_resolution_change
+//============================================================
+
+void switchres_check_resolution_change(running_machine &machine, int curr_width, int curr_height)
+{
+	game_info *game = &machine.switchres.game;
+	config_settings *cs = &machine.switchres.cs;
+	bool curr_orientation = effective_orientation(machine);
+
+	float curr_vfreq = game->refresh;
+
+	screen_device_iterator scriter(machine.root_device());
+	if (scriter.count())
+	{
+		screen_device *screen = scriter.first();
+		if (screen-> frame_number())
+			curr_vfreq = ATTOSECONDS_TO_HZ(screen->frame_period().attoseconds);
+	}
+
+	if (game->width != curr_width || game->height != curr_height || curr_vfreq != game->refresh || cs->effective_orientation != curr_orientation)
+	{
+		osd_printf_verbose("SwitchRes: Resolution change from %dx%d@%f to %dx%d@%f\n",
+			game->width, game->height, game->refresh, curr_width, curr_height, curr_vfreq);
+
+		game->width = curr_width;
+		game->height = curr_height;
+		game->refresh = curr_vfreq;
+		game->changeres = 1;
+	}
+}
+
+//============================================================
+//  switchres_set_options
+//============================================================
+
+void switchres_set_options(running_machine &machine)
+{
+	config_settings *cs = &machine.switchres.cs;
+	bool native_orientation = ((machine.system().flags & ORIENTATION_MASK) & ORIENTATION_SWAP_XY);
+
+	// Set rotation options
+	set_option(machine, OPTION_ROTATE, true);
+	if (cs->monitor_rotates_cw)
+	{
+		set_option(machine, OPTION_ROL, (!native_orientation & effective_orientation(machine)));
+		set_option(machine, OPTION_AUTOROL, !effective_orientation(machine));
+		set_option(machine, OPTION_ROR, false);
+		set_option(machine, OPTION_AUTOROR, false);
+	}
+	else
+	{
+		set_option(machine, OPTION_ROR, (!native_orientation & effective_orientation(machine)));
+		set_option(machine, OPTION_AUTOROR, !effective_orientation(machine));
+		set_option(machine, OPTION_ROL, false);
+		set_option(machine, OPTION_AUTOROL, false);
+	}
+}
+
+//============================================================
+//  switchres_reset_options
+//============================================================
+
+void switchres_reset_options(running_machine &machine)
+{
+	// Reset MAME common options
+	machine.options().revert(OPTION_PRIORITY_SWITCHRES);
+}
+
+//============================================================
+// set_option - option setting wrapper
+//============================================================
+
+void set_option(running_machine &machine, const char *option_ID, bool state)
+{
+	emu_options &options = machine.options();
+	astring error_string;
+
+	options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES, error_string);
+	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", state?"":"no", option_ID);
+}
+
+//============================================================
+// switchres_load
+//============================================================
+
+static void switchres_load(running_machine &machine, int config_type, xml_data_node *parentnode)
+{
+	// We don't do anything here yet.
+}
+
+//============================================================
+// switchres_save
+//============================================================
+
+static void switchres_save(running_machine &machine, int config_type, xml_data_node *parentnode)
+{
+	modeline *mode = &machine.switchres.best_mode;
+	char modeline_txt[256]={'\x00'};
+
+	// only care about game-specific data
+	if (config_type != CONFIG_TYPE_GAME)
+		return;
+
+	xml_data_node *switchresnode = xml_add_child(parentnode, "switchres", NULL);
+	if (switchresnode != NULL)
+	{
+		if (mode && mode->htotal)
+		{
+			modeline_print(mode, modeline_txt, MS_PARAMS);
+			xml_set_attribute(switchresnode, "modeline", modeline_txt);
+		}
+	}
+}
diff -Nru ./src_0.154_hi/emu/switchres/switchres.h ./src/emu/switchres/switchres.h
--- ./src_0.154_hi/emu/switchres/switchres.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/emu/switchres/switchres.h	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,205 @@
+/**************************************************************
+
+   switchres.h - SwichRes general header
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2013 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+#ifndef __SWITCHRES_H__
+#define __SWITCHRES_H__
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+#define SWITCHRES_VERSION "0.015b"
+
+#define MAX_RANGES 10
+#define MAX_MODELINES 256
+#define MONITOR_CRT 0
+#define MONITOR_LCD 1
+#define STANDARD_CRT_ASPECT 4.0/3.0
+
+#define R_V_FREQ_OFF    0x00000001
+#define R_RES_STRETCH   0x00000002
+#define R_OUT_OF_RANGE  0x00000004
+
+#define MODE_OK         0x00000000
+#define MODE_DESKTOP    0x10000000
+#define MODE_LOCKED     0x80000000
+#define V_FREQ_EDITABLE 0x00000001
+#define X_RES_EDITABLE  0x00000002
+#define Y_RES_EDITABLE  0x00000004
+#define XYV_EDITABLE   (X_RES_EDITABLE | Y_RES_EDITABLE | V_FREQ_EDITABLE )
+#define SYSTEM_TIMING   0x00000008
+#define XRANDR_TIMING   0x00000010
+#define PSTRIP_TIMING   0x00000020
+#define ATI_REG_TIMING  0x00000040
+
+#define MS_LABEL      0x00000001
+#define MS_LABEL_SDL  0x00000002
+#define MS_PARAMS     0x00000004
+#define MS_FULL       MS_LABEL | MS_PARAMS
+
+#define DUMMY_WIDTH 1234
+
+//============================================================
+//  TYPE DEFINITIONS
+//============================================================
+
+typedef struct mode_result
+{
+	int    weight;
+	int    x_scale;
+	int    y_scale;
+	int    v_scale;
+	float  x_diff;
+	float  y_diff;
+	float  v_diff;
+	float  x_ratio;
+	float  y_ratio;
+	float  v_ratio;
+	bool   rotated;
+} mode_result;
+
+typedef struct modeline
+{
+	int    pclock;
+	int    hactive;
+	int    hbegin;
+	int    hend;
+	int    htotal;
+	int    vactive;
+	int    vbegin;
+	int    vend;
+	int    vtotal;
+	int    interlace;
+	int    doublescan;
+	int    hsync;
+	int    vsync;
+	//
+	double vfreq;
+	double hfreq;
+	//
+	int    width;
+	int    height;
+	int    refresh;
+	//
+	int    type;
+	int    range;
+	//
+	mode_result result;
+} modeline;
+
+typedef struct monitor_range
+{
+	double hfreq_min;
+	double hfreq_max;
+	double vfreq_min;
+	double vfreq_max;
+	double hfront_porch;
+	double hsync_pulse;
+	double hback_porch;
+	double vfront_porch;
+	double vsync_pulse;
+	double vback_porch;
+	int    hsync_polarity;
+	int    vsync_polarity;
+	int    progressive_lines_min;
+	int    progressive_lines_max;
+	int    interlaced_lines_min;
+	int    interlaced_lines_max;
+	double vertical_blank;
+} monitor_range;
+
+typedef struct game_info
+{
+	char   name[32];
+	int    width;
+	int    height;
+	float  refresh;
+	bool   orientation;
+	bool   vector;
+	bool   changeres;
+	int    screens;
+} game_info;
+
+typedef struct config_settings
+{
+	char   connector[32];
+	char   monitor[32];
+	bool   modeline_generation;
+	bool   monitor_orientation;
+	bool   effective_orientation;
+	bool   monitor_rotates_cw;
+	float  monitor_aspect;
+	int    monitor_count;
+	int    pclock_min;
+	int    pclock_align;
+	int    interlace;
+	int    doublescan;
+	int    width;
+	int    height;
+	int    refresh;
+	int    cleanstretch;
+	bool   lock_unsupported_modes;
+	bool   lock_system_modes;
+	bool   refresh_dont_care;
+	float  sync_refresh_tolerance;
+} config_settings;
+
+typedef struct switchres_manager
+{
+	struct config_settings cs;
+	struct game_info game;
+	struct modeline best_mode;
+	struct modeline user_mode;
+	struct monitor_range range[MAX_RANGES];
+	struct modeline video_modes[MAX_MODELINES];
+} switchres;
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+// modeline.c
+int modeline_create(modeline *s_mode, modeline *t_mode, monitor_range *range, config_settings *cs);
+int modeline_compare(modeline *t_mode, modeline *best_mode);
+char * modeline_print(modeline *mode, char *modeline, int flags);
+char * modeline_result(modeline *mode, char *result);
+int modeline_vesa_gtf(modeline *m);
+int modeline_parse(const char *user_modeline, modeline *mode);
+
+// monitor.c
+int get_monitor_specs(running_machine &machine);
+int fill_monitor_range(monitor_range *range, const char *specs_line);
+int show_monitor_range(monitor_range *range);
+int set_monitor_preset(char *type, monitor_range *range);
+int monitor_range_from_modeline(monitor_range *range, modeline *mode);
+
+// util.c
+int normalize(int a, int b);
+int real_res(int x);
+
+// switchres.c
+bool switchres_get_video_mode(running_machine &machine);
+void switchres_init(running_machine &machine);
+void switchres_check_resolution_change(running_machine &machine, int width, int height);
+void switchres_set_options(running_machine &machine);
+void switchres_reset_options(running_machine &machine);
+bool effective_orientation(running_machine &machine);
+
+// OSD - switchres.c
+bool switchres_init_osd(running_machine &machine);
+bool switchres_modeline_setup(running_machine &machine);
+bool switchres_modeline_remove(running_machine &machine);
+
+#endif
diff -Nru ./src_0.154_hi/emu/switchres/util.c ./src/emu/switchres/util.c
--- ./src_0.154_hi/emu/switchres/util.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/emu/switchres/util.c	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,33 @@
+/**************************************************************
+
+   util.c - Utility functions
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2013 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+//============================================================
+//  normalize
+//============================================================
+
+int normalize(int a, int b)
+{
+	int c, d;
+	c = a % b;
+	d = a / b;
+	if (c) d++;
+	return d * b;
+}
+
+//============================================================
+//  real_res
+//============================================================
+
+int real_res(int x) {return (int) (x / 8) * 8;}
diff -Nru ./src_0.154_hi/emu/ui/selgame.h ./src/emu/ui/selgame.h
--- ./src_0.154_hi/emu/ui/selgame.h	2014-04-07 08:04:18.000000000 +0200
+++ ./src/emu/ui/selgame.h	2014-07-29 10:29:57.000000000 +0200
@@ -30,7 +30,7 @@
 
 private:
 	// internal state
-	enum { VISIBLE_GAMES_IN_LIST = 15 };
+	enum { VISIBLE_GAMES_IN_LIST = 99999 };
 	UINT8                   m_error;
 	UINT8                   m_rerandomize;
 	char                    m_search[40];
diff -Nru ./src_0.154_hi/emu/ui/ui.c ./src/emu/ui/ui.c
--- ./src_0.154_hi/emu/ui/ui.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/ui/ui.c	2014-07-29 10:29:57.000000000 +0200
@@ -1244,7 +1244,16 @@
 			}
 		}
 	}
-
+	
+	/* display SwitchRes information */
+	modeline *mode = &machine().switchres.best_mode;
+	if (mode->hactive)
+	{
+		string.cat("\nSwitchres:\n");
+		string.catprintf("%d " UTF8_MULTIPLY " %d%s%s %2.3f Hz %2.3f kHz\n",
+			mode->hactive, mode->vactive, mode->interlace?"i":"p", mode->doublescan?"d":"", mode->vfreq, mode->hfreq/1000);
+	}	
+	
 	return string;
 }
 
diff -Nru ./src_0.154_hi/emu/video.c ./src/emu/video.c
--- ./src_0.154_hi/emu/video.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/video.c	2014-07-29 10:29:57.000000000 +0200
@@ -86,6 +86,8 @@
 		m_overall_valid_counter(0),
 		m_throttled(machine.options().throttle()),
 		m_throttle_rate(1.0f),
+ 		m_syncrefresh(machine.options().sync_refresh()),
+ 		m_framedelay(machine.options().frame_delay()),
 		m_fastforward(false),
 		m_seconds_to_run(machine.options().seconds_to_run()),
 		m_auto_frameskip(machine.options().auto_frameskip()),
@@ -213,16 +215,24 @@
 	// draw the user interface
 	machine().ui().update_and_render(&machine().render().ui_container());
 
-	// if we're throttling, synchronize before rendering
-	attotime current_time = machine().time();
-	if (!debug && !skipped_it && effective_throttle())
-		update_throttle(current_time);
-
 	// ask the OSD to update
 	g_profiler.start(PROFILER_BLIT);
 	machine().osd().update(!debug && skipped_it);
 	g_profiler.stop();
 
+	// manage black frame insertion
+	if (machine().options().black_frame_insertion() && machine().options().sync_refresh())
+	{
+		render_container *container = &machine().render().ui_container();
+		container->add_rect(0, 0, 1, 1, ARGB_BLACK, PRIMFLAG_BLENDMODE(BLENDMODE_ALPHA));
+		machine().osd().update(!debug && skipped_it);
+	}
+
+	// if we're throttling, delay after rendering
+	attotime current_time = machine().time();
+	if (!debug && !skipped_it && effective_throttle())
+		update_throttle(current_time);
+
 	machine().manager().lua()->periodic_check();
 
 	// perform tasks for this frame
@@ -244,6 +254,9 @@
 		if (machine().first_screen() != NULL && (machine().paused() || debug || debugger_within_instruction_hook(machine())))
 			machine().first_screen()->reset_partial_updates();
 	}
+
+	// get most recent input now
+	machine().osd().poll_input();
 }
 
 
@@ -786,6 +799,10 @@
 		3,4,4,5,4,5,5,6, 4,5,5,6,5,6,6,7, 4,5,5,6,5,6,6,7, 5,6,6,7,6,7,7,8
 	};
 
+	// if we're only syncing to the refresh, bail now
+	if (m_syncrefresh && m_framedelay == 0)
+		return;
+
 	// outer scope so we can break out in case of a resync
 	while (1)
 	{
@@ -869,7 +886,13 @@
 			return;
 
 		// compute the target real time, in ticks, where we want to be
-		osd_ticks_t target_ticks = m_throttle_last_ticks + real_is_ahead_attoseconds / attoseconds_per_tick;
+		osd_ticks_t target_ticks;
+		modeline *mode = &machine().switchres.best_mode;
+
+		if (m_framedelay != 0 && m_framedelay < 10 && m_syncrefresh && mode->hactive)
+			target_ticks = m_throttle_last_ticks + HZ_TO_ATTOSECONDS(mode->vfreq / mode->result.v_scale ) / attoseconds_per_tick * m_framedelay / 10;
+		else
+			target_ticks = m_throttle_last_ticks + real_is_ahead_attoseconds / attoseconds_per_tick;
 
 		// throttle until we read the target, and update real time to match the final time
 		diff_ticks = throttle_until_ticks(target_ticks) - m_throttle_last_ticks;
@@ -1062,6 +1085,9 @@
 		osd_ticks_t tps = osd_ticks_per_second();
 		m_speed_percent = delta_emutime.as_double() * (double)tps / (double)delta_realtime;
 
+		if (m_syncrefresh && m_throttled && m_framedelay == 0)
+			m_speed = m_speed_percent * 1000;
+
 		// remember the last times
 		m_speed_last_realtime = realtime;
 		m_speed_last_emutime = emutime;
diff -Nru ./src_0.154_hi/emu/video.h ./src/emu/video.h
--- ./src_0.154_hi/emu/video.h	2014-07-29 10:29:17.000000000 +0200
+++ ./src/emu/video.h	2014-07-29 10:29:57.000000000 +0200
@@ -63,6 +63,7 @@
 	int frameskip() const { return m_auto_frameskip ? -1 : m_frameskip_level; }
 	bool throttled() const { return m_throttled; }
 	float throttle_rate() const { return m_throttle_rate; }
+ 	bool sync_refresh() const { return m_syncrefresh; }
 	bool fastforward() const { return m_fastforward; }
 	bool is_recording() const { return (m_mng_file != NULL || m_avi_file != NULL); }
 
@@ -148,6 +149,8 @@
 	// configuration
 	bool                m_throttled;                // flag: TRUE if we're currently throttled
 	float               m_throttle_rate;            // target rate for throttling
+ 	bool                m_syncrefresh;              // flag: TRUE if we're currently refresh-synced
+ 	INT32               m_framedelay;               // tenths of frame to delay emulation start
 	bool                m_fastforward;              // flag: TRUE if we're currently fast-forwarding
 	UINT32              m_seconds_to_run;           // number of seconds to run before quitting
 	bool                m_auto_frameskip;           // flag: TRUE if we're automatically frameskipping
diff -Nru ./src_0.154_hi/mame/drivers/galaxian.c ./src/mame/drivers/galaxian.c
--- ./src_0.154_hi/mame/drivers/galaxian.c	2014-06-16 03:59:53.000000000 +0200
+++ ./src/mame/drivers/galaxian.c	2014-07-29 10:29:57.000000000 +0200
@@ -4991,7 +4991,7 @@
 static MACHINE_CONFIG_START( galaxian_base, galaxian_state )
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("maincpu", Z80, GALAXIAN_PIXEL_CLOCK/3/2)
+	MCFG_CPU_ADD("maincpu", Z80, GALAXIAN_PIXEL_CLOCK/GALAXIAN_XSCALE/2 ) // galaxian fix
 	MCFG_CPU_PROGRAM_MAP(galaxian_map)
 	MCFG_CPU_VBLANK_INT_DRIVER("screen", galaxian_state,  interrupt_gen)
 
@@ -5109,7 +5109,7 @@
 	MCFG_CPU_VBLANK_INT_DRIVER("screen", galaxian_state,  fakechange_interrupt_gen)
 
 	/* basic machine hardware */
-	MCFG_CPU_ADD("selectcpu", Z80, GALAXIAN_PIXEL_CLOCK/3/2) // ?? mhz
+	MCFG_CPU_ADD("selectcpu", Z80, GALAXIAN_PIXEL_CLOCK/GALAXIAN_XSCALE/2) // ?? mhz // galaxian fix
 	MCFG_CPU_PROGRAM_MAP(tenspot_select_map)
 	//MCFG_CPU_VBLANK_INT("screen", nmi_line_pulse)
 
diff -Nru ./src_0.154_hi/mame/includes/galaxian.h ./src/mame/includes/galaxian.h
--- ./src_0.154_hi/mame/includes/galaxian.h	2014-05-19 18:00:42.000000000 +0200
+++ ./src/mame/includes/galaxian.h	2014-07-29 10:29:57.000000000 +0200
@@ -12,7 +12,7 @@
 #include "sound/digitalk.h"
 
 /* we scale horizontally by 3 to render stars correctly */
-#define GALAXIAN_XSCALE         3
+#define GALAXIAN_XSCALE         1 //frogger-galaxian fix
 
 /* master clocks */
 #define GALAXIAN_MASTER_CLOCK   (18432000)
diff -Nru ./src_0.154_hi/osd/modules/sound/direct_sound.c ./src/osd/modules/sound/direct_sound.c
--- ./src_0.154_hi/osd/modules/sound/direct_sound.c	2014-07-22 08:14:55.000000000 +0200
+++ ./src/osd/modules/sound/direct_sound.c	2014-07-29 10:29:57.000000000 +0200
@@ -256,6 +256,7 @@
 		stream_buffer_size = 1024;
 
 	LOG(("stream_buffer_size = %d\n", stream_buffer_size));
+	osd_printf_verbose("stream_buffer_size = %d\n", stream_buffer_size);
 
 	// create the buffers
 	result = dsound_create_buffers();
diff -Nru ./src_0.154_hi/osd/modules/sound/sdl_sound.c ./src/osd/modules/sound/sdl_sound.c
--- ./src_0.154_hi/osd/modules/sound/sdl_sound.c	2014-05-08 09:39:04.000000000 +0200
+++ ./src/osd/modules/sound/sdl_sound.c	2014-07-29 10:29:57.000000000 +0200
@@ -425,7 +425,7 @@
 static int sdl_init(running_machine &machine)
 {
 	int         n_channels = 2;
-	int         audio_latency;
+	float       audio_latency;
 	SDL_AudioSpec   aspec, obtained;
 	char audio_driver[16] = "";
 
diff -Nru ./src_0.154_hi/osd/osdepend.c ./src/osd/osdepend.c
--- ./src_0.154_hi/osd/osdepend.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/osdepend.c	2014-07-29 10:29:57.000000000 +0200
@@ -41,8 +41,8 @@
 	{ OSDOPTION_NUMSCREENS "(1-4)",           "1",        OPTION_INTEGER,    "number of screens to create; usually, you want just one" },
 	{ OSDOPTION_WINDOW ";w",                  "0",        OPTION_BOOLEAN,    "enable window mode; otherwise, full screen mode is assumed" },
 	{ OSDOPTION_MAXIMIZE ";max",              "1",        OPTION_BOOLEAN,    "default to maximized windows; otherwise, windows will be minimized" },
-	{ OSDOPTION_KEEPASPECT ";ka",             "1",        OPTION_BOOLEAN,    "constrain to the proper aspect ratio" },
-	{ OSDOPTION_UNEVENSTRETCH ";ues",         "1",        OPTION_BOOLEAN,    "allow non-integer stretch factors" },
+	{ OSDOPTION_KEEPASPECT ";ka",             "0",        OPTION_BOOLEAN,    "constrain to the proper aspect ratio" },
+	{ OSDOPTION_UNEVENSTRETCH ";ues",         "0",        OPTION_BOOLEAN,    "allow non-integer stretch factors" },
 	{ OSDOPTION_WAITVSYNC ";vs",              "0",        OPTION_BOOLEAN,    "enable waiting for the start of VBLANK before flipping screens; reduces tearing effects" },
 	{ OSDOPTION_SYNCREFRESH ";srf",           "0",        OPTION_BOOLEAN,    "enable using the start of VBLANK for throttling instead of the game time" },
 
@@ -75,12 +75,12 @@
 
 	// full screen options
 	{ NULL,                                   NULL,  OPTION_HEADER,     "OSD FULL SCREEN OPTIONS" },
-	{ OSDOPTION_SWITCHRES,                    "0",   OPTION_BOOLEAN,    "enable resolution switching" },
+	{ OSDOPTION_SWITCHRES,                    "1",   OPTION_BOOLEAN,    "enable resolution switching" },
 
 	// sound options
 	{ NULL,                                   NULL,  OPTION_HEADER,     "OSD SOUND OPTIONS" },
 	{ OSDOPTION_SOUND,                        OSDOPTVAL_AUTO, OPTION_STRING,     "sound output method: " },
-	{ OSDOPTION_AUDIO_LATENCY "(1-5)",        "2",   OPTION_INTEGER,    "set audio latency (increase to reduce glitches, decrease for responsiveness)" },
+	{ OSDOPTION_AUDIO_LATENCY "(0.1-5.0)",    "2.0", OPTION_FLOAT,      "set audio latency (increase to reduce glitches)" },
 
 	// End of list
 	{ NULL }
@@ -236,6 +236,20 @@
 	//
 }
 
+
+//-------------------------------------------------
+//  poll_input
+//-------------------------------------------------
+
+void osd_interface::poll_input(void)
+{
+	//
+	// This method is called right before the emulation of a new frame
+	// to ensure the most recent input is available.
+	//
+}
+
+
 //-------------------------------------------------
 //  MKChamp update_hi - periodic system update
 //-------------------------------------------------
diff -Nru ./src_0.154_hi/osd/osdepend.h ./src/osd/osdepend.h
--- ./src_0.154_hi/osd/osdepend.h	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/osdepend.h	2014-07-29 10:29:57.000000000 +0200
@@ -85,7 +85,6 @@
 	bool keep_aspect() const { return bool_value(OSDOPTION_KEEPASPECT); }
 	bool uneven_stretch() const { return bool_value(OSDOPTION_UNEVENSTRETCH); }
 	bool wait_vsync() const { return bool_value(OSDOPTION_WAITVSYNC); }
-	bool sync_refresh() const { return bool_value(OSDOPTION_SYNCREFRESH); }
 
 	// per-window options
 	const char *screen() const { return value(OSDOPTION_SCREEN); }
@@ -102,7 +101,7 @@
 
 	// sound options
 	const char *sound() const { return value(OSDOPTION_SOUND); }
-	int audio_latency() const { return int_value(OSDOPTION_AUDIO_LATENCY); }
+	float audio_latency() const { return float_value(OSDOPTION_AUDIO_LATENCY); }
 
 	void add_osd_options();
 private:
@@ -144,6 +143,7 @@
 	// general overridables
 	virtual void init(running_machine &machine);
 	virtual void update(bool skip_redraw);
+	virtual void poll_input(void);
 
 	// debugger overridables
 	void init_debugger();
diff -Nru ./src_0.154_hi/osd/sdl/osdsdl.h ./src/osd/sdl/osdsdl.h
--- ./src_0.154_hi/osd/sdl/osdsdl.h	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/sdl/osdsdl.h	2014-07-29 11:58:21.000000000 +0200
@@ -51,7 +51,6 @@
 #define SDLOPTION_SCALEMODE             "scalemode"
 
 #define SDLOPTION_WAITVSYNC             "waitvsync"
-#define SDLOPTION_SYNCREFRESH           "syncrefresh"
 #define SDLOPTION_KEYMAP                "keymap"
 #define SDLOPTION_KEYMAP_FILE           "keymap_file"
 #define SDLOPTION_UIMODEKEY             "uimodekey"
@@ -187,6 +186,7 @@
 	// general overridables
 	virtual void init(running_machine &machine);
 	virtual void update(bool skip_redraw);
+	virtual void poll_input(void);
 
 	// input overridables
 	virtual void customize_input_type_list(simple_list<input_type_entry> &typelist);
diff -Nru ./src_0.154_hi/osd/sdl/sdl.mak ./src/osd/sdl/sdl.mak
--- ./src_0.154_hi/osd/sdl/sdl.mak	2014-07-22 06:51:52.000000000 +0200
+++ ./src/osd/sdl/sdl.mak	2014-07-29 10:29:57.000000000 +0200
@@ -69,7 +69,7 @@
 # SDL_INSTALL_ROOT = /usr/local/sdl20
 
 # uncomment to disable the Qt debugger (on non-OSX this disables all debugging)
-# NO_USE_QTDEBUG = 1
+NO_USE_QTDEBUG = 1
 
 # uncomment to disable MIDI
 # NO_USE_MIDI = 1
@@ -403,6 +403,7 @@
 	$(SDLOBJ)/window.o \
 	$(SDLOBJ)/output.o \
 	$(SDLOBJ)/watchdog.o \
+	$(SDLOBJ)/switchres.o
 
 ifdef NO_USE_MIDI
 DEFS += -DDISABLE_MIDI=1
diff -Nru ./src_0.154_hi/osd/sdl/sdlmain.c ./src/osd/sdl/sdlmain.c
--- ./src_0.154_hi/osd/sdl/sdlmain.c	2014-07-22 08:14:55.000000000 +0200
+++ ./src/osd/sdl/sdlmain.c	2014-07-29 10:29:57.000000000 +0200
@@ -70,6 +70,10 @@
 
 #include "watchdog.h"
 
+extern bool switchres_modeline_setup(running_machine &machine);
+extern bool switchres_modeline_reset(running_machine &machine);
+extern bool switchres_modeline_remove(running_machine &machine);
+
 //============================================================
 //  OPTIONS
 //============================================================
@@ -117,7 +121,7 @@
 #if USE_OPENGL
 	// OpenGL specific options
 	{ NULL,                                   NULL,   OPTION_HEADER,  "OpenGL-SPECIFIC OPTIONS" },
-	{ SDLOPTION_FILTER ";glfilter;flt",       "1",    OPTION_BOOLEAN, "enable bilinear filtering on screen output" },
+	{ SDLOPTION_FILTER ";glfilter;flt",       "0",    OPTION_BOOLEAN, "enable bilinear filtering on screen output" },
 	{ SDLOPTION_PRESCALE,                     "1",    OPTION_INTEGER,                 "scale screen rendering by this amount in software" },
 	{ SDLOPTION_GL_FORCEPOW2TEXTURE,          "0",    OPTION_BOOLEAN, "force power of two textures  (default no)" },
 	{ SDLOPTION_GL_NOTEXTURERECT,             "0",    OPTION_BOOLEAN, "don't use OpenGL GL_ARB_texture_rectangle (default on)" },
@@ -408,6 +412,9 @@
 		SDL_Quit();
 #endif
 	}
+	// SwitchRes modeline removal
+	switchres_modeline_reset(machine());
+	switchres_modeline_remove(machine());
 }
 
 //============================================================
@@ -581,6 +588,9 @@
 	sdl_options &options = downcast<sdl_options &>(machine.options());
 	const char *stemp;
 
+	// Switchres
+	switchres_modeline_setup(machine);
+
 	// determine if we are benchmarking, and adjust options appropriately
 	int bench = options.bench();
 	astring error_string;
diff -Nru ./src_0.154_hi/osd/sdl/switchres.c ./src/osd/sdl/switchres.c
--- ./src_0.154_hi/osd/sdl/switchres.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/osd/sdl/switchres.c	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,402 @@
+/**************************************************************
+
+   switchres.c - SDL OSD SwitchRes core routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2012 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+// MAME headers
+#include "osdepend.h"
+#include "emu.h"
+#include "clifront.h"
+#include "emuopts.h"
+
+// MAMEOS headers
+#include "video.h"
+#include "input.h"
+#include "output.h"
+#include "osdsdl.h"
+#include "sdlos.h"
+
+#define XRANDR_ARGS ""
+#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+bool switchres_init_osd(running_machine &machine);
+bool switchres_modeline_setup(running_machine &machine);
+bool switchres_modeline_remove(running_machine &machine);
+bool switchres_modeline_reset(running_machine &machine);
+bool switchres_resolution_change(sdl_window_info *window);
+static bool add_custom_video_mode(modeline *mode, char *connector);
+static int del_custom_video_mode(modeline *mode, char *connector);
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state);
+static void set_option_int_osd(running_machine &machine, const char *option_ID, int value);
+static bool get_output(char *command, char *output);
+
+//============================================================
+//  LOCAL VARIABLES
+//============================================================
+
+char desktop_res[32]={'\x00'};
+int mode_count = 1;
+
+//============================================================
+//  switchres_init_osd
+//============================================================
+
+bool switchres_init_osd(running_machine &machine)
+{
+	config_settings *cs = &machine.switchres.cs;
+	modeline *mode_table = machine.switchres.video_modes;
+	modeline *user_mode = &machine.switchres.user_mode;
+	monitor_range *range = machine.switchres.range;
+	const char * aspect;
+	char *connector = machine.switchres.cs.connector;
+	char resolution[32]={'\x00'};
+	char current_res[32]={'\x00'};
+
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+
+	strcpy(resolution, options.resolution());
+	cs->monitor_count = options.numscreens();
+
+	// Get current resolution
+	get_output((char*)"xrandr -q | grep '[0-9]\\*'", current_res);
+	sscanf(current_res, " %s ", desktop_res);
+
+	// Get connector name
+	if (!strcmp(cs->connector, "auto"))
+	{
+		if (get_output((char*)"xrandr -q | grep ' connected ' | awk '{print $1}' | head -1", connector))
+			osd_printf_verbose("SwitchRes: Found output connector '%s'\n",	connector);
+		else
+			osd_printf_error("SwitchRes: Error getting connector with xrandr");
+	}
+
+	// Get per window resolution
+	strcpy(resolution, strcmp(options.resolution(0), "auto")? options.resolution(0) : options.resolution());
+
+	// Get monitor aspect
+	aspect = strcmp(options.aspect(0), "auto")? options.aspect(0) : options.aspect();
+	if (strcmp(aspect, "auto"))
+	{
+		double num, den;
+		sscanf(aspect, "%lf:%lf", &num, &den);
+		cs->monitor_aspect = num/den;
+	}
+	else
+		cs->monitor_aspect = STANDARD_CRT_ASPECT;
+
+	// Create dummy mode table
+	mode_table[1].width = mode_table[1].height = 1;
+	mode_table[1].refresh = 60;
+	mode_table[1].hactive = mode_table[1].vactive = 1;
+	mode_table[1].type = XYV_EDITABLE | XRANDR_TIMING;
+
+	if (user_mode->hactive)
+	{
+		user_mode->width = user_mode->hactive;
+		user_mode->height = user_mode->vactive;
+		user_mode->refresh = int(user_mode->refresh);
+		user_mode->type = XRANDR_TIMING;
+	}
+
+	// Create automatic specs and force resolution for LCD monitors
+	if (!strcmp(cs->monitor, "lcd"))
+	{
+		modeline current;
+		memset(&current, 0, sizeof(struct modeline));
+
+		osd_printf_verbose("SwitchRes: Creating automatic specs for LCD based on VESA GTF\n");
+		sscanf(desktop_res, "%dx%d", &current.width, &current.height);
+		current.refresh = 60;
+		modeline_vesa_gtf(&current);
+		monitor_range_from_modeline(range, &current);
+		show_monitor_range(range);
+
+		sprintf(resolution, "%dx%d@%d", current.width, current.height, current.refresh);
+	}
+	// Otherwise (non-LCD), convert the user defined modeline into a -resolution option
+	else if (user_mode->hactive)
+		sprintf(resolution, "%dx%d", user_mode->hactive, user_mode->vactive);
+
+	// Get resolution from ini
+	if (strcmp(resolution, "auto"))
+	{
+		osd_printf_verbose("SwitchRes: -resolution was set at command line or in .ini file as %s\n", resolution);
+
+		if ((sscanf(resolution, "%dx%d@%d", &cs->width, &cs->height, &cs->refresh) < 3) &&
+			((!strstr(resolution, "x") || (sscanf(resolution, "%dx%d", &cs->width, &cs->height) != 2))))
+				osd_printf_info("SwitchRes: illegal -resolution value: %s\n", resolution);
+		else
+		{
+			// Add the user's resolution to our table
+			if (!user_mode->hactive)
+			{
+				mode_table[1].width = mode_table[1].hactive = cs->width? cs->width : 1;
+				mode_table[1].height = mode_table[1].vactive = cs->height? cs->height : 1;
+				mode_table[1].refresh = cs->refresh? int(cs->refresh) : 60;
+				if (cs->width) mode_table[1].type &= ~X_RES_EDITABLE;
+				if (cs->height) mode_table[1].type &= ~Y_RES_EDITABLE;
+			}
+			set_option_osd(machine, OPTION_CHANGERES, false);
+		}
+	}
+	return true;
+}
+
+//============================================================
+//  switchres_modeline_setup
+//============================================================
+
+bool switchres_modeline_setup(running_machine &machine)
+{
+	modeline *best_mode = &machine.switchres.best_mode;
+	modeline *mode_table = machine.switchres.video_modes;
+	config_settings *cs = &machine.switchres.cs;
+	char *connector = machine.switchres.cs.connector;
+
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+	astring error_string;
+
+	osd_printf_verbose("\nSwitchRes: Entering switchres_modeline_setup\n");
+
+	// Find most suitable video mode and generate a modeline for it if we're allowed
+	if (!switchres_get_video_mode(machine))
+	{
+		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
+		return false;
+	}
+
+	// Make the new modeline available to the system
+	if (machine.options().modeline_generation())
+	{
+		// Lock mode before adding it to mode table
+		best_mode->type |= MODE_LOCKED;
+
+		// Check if the same mode had been created already
+		int i;
+		bool found = false;
+		for (i = 2; i <= mode_count; i++)
+			if (!memcmp(&mode_table[i], best_mode, sizeof(modeline) - sizeof(mode_result)))
+				found = true;
+
+		// Create the new mode and store it in our table
+		if (!found)
+		{
+			mode_count++;
+			memcpy(&mode_table[mode_count], best_mode, sizeof(modeline));
+			add_custom_video_mode(best_mode, connector);
+		}
+	}
+
+	// Set MAME common options
+	switchres_set_options(machine);
+
+	// Black frame insertion / multithreading
+	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
+	set_option_osd(machine, OPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
+	set_option_osd(machine, OSDOPTION_MULTITHREADING, options.multithreading() && !(options.numscreens() > 1) && !black_frame_insertion);
+
+	// Set MAME OSD specific options
+	// Vertical synchronization management
+
+	// Disable -syncrefresh if our vfreq is scaled or too off
+	set_option_osd(machine, OPTION_SYNCREFRESH, !(best_mode->result.weight & R_V_FREQ_OFF || best_mode->result.v_scale > 1) || black_frame_insertion);
+
+	// Unless -syncrefresh is forced, only enable v-sync if the obtained refresh is close enough
+	set_option_osd(machine, OSDOPTION_WAITVSYNC, options.sync_refresh());
+
+	// Set scaling/stretching options
+	set_option_osd(machine, OSDOPTION_KEEPASPECT, true);
+	set_option_osd(machine, OSDOPTION_UNEVENSTRETCH, (best_mode->result.weight & R_RES_STRETCH));
+	set_option_osd(machine, SDLOPTION_FILTER, ((best_mode->result.weight & R_RES_STRETCH || best_mode->interlace)));
+	set_option_int_osd(machine, SDLOPTION_PRESCALE, min(best_mode->result.x_scale, best_mode->result.y_scale));
+	cs->cleanstretch = !options.cleanstretch() || cs->effective_orientation? !(best_mode->result.weight & R_RES_STRETCH) : options.cleanstretch();
+
+	// Refresh video options
+	extract_video_config (machine);
+
+	return true;
+}
+
+//============================================================
+//  switchres_modeline_remove
+//============================================================
+
+bool switchres_modeline_remove(running_machine &machine)
+{
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+
+	// Reset SDL options
+	switchres_reset_options(machine);
+	options.revert(OPTION_PRIORITY_SWITCHRES);
+
+	return true;
+}
+
+//============================================================
+//  switchres_modeline_reset
+//============================================================
+
+bool switchres_modeline_reset(running_machine &machine)
+{
+	config_settings *cs = &machine.switchres.cs;
+	modeline *mode_table = machine.switchres.video_modes;
+	char cmd[256]={'\x00'};
+
+	osd_printf_verbose("SwitchRes: Restoring desktop resolution: %s\n", desktop_res);
+	sprintf(cmd, "xrandr --output %s --mode %s", cs->connector,  desktop_res);
+	osd_printf_verbose("SwitchRes: Running '%s'\n", cmd);
+	system(cmd);
+
+	// Remove modelines
+	while (mode_count > 1)
+	{
+		del_custom_video_mode(&mode_table[mode_count], cs->connector);
+		mode_count--;
+	}
+
+	return true;
+}
+
+//============================================================
+//  switchres_resolution_change
+//============================================================
+
+bool switchres_resolution_change(sdl_window_info *window)
+{
+	running_machine &machine = window->machine();
+	game_info *game = &machine.switchres.game;
+	modeline *best_mode = &machine.switchres.best_mode;
+
+	game->changeres = 0;
+
+	osd_printf_verbose("SwitchRes: Resolution change to %dx%d@%f\n", game->width, game->height, game->refresh);
+
+	// Create new modeline
+	switchres_modeline_setup(machine);
+	window->minwidth = best_mode->width;
+	window->minheight = best_mode->height;
+
+	// Switch to new video mode
+	sdlwindow_resize(window, window->minwidth, window->minheight);
+
+	return true;
+}
+
+//============================================================
+//  add_custom_video_mode
+//============================================================
+
+static bool add_custom_video_mode(modeline *mode, char *connector)
+{
+	char modeline[256]={'\x00'};
+	char cmd[512]={'\x00'};
+
+	if (!mode)
+		return false;
+
+	// Add new modeline
+	sprintf(cmd, "xrandr %s --newmode %s", XRANDR_ARGS, modeline_print(mode, modeline, MS_LABEL_SDL | MS_PARAMS));
+	osd_printf_verbose("SwitchRes: Running '%s'\n", cmd);
+	system(cmd);
+
+	// Add modeline to interface
+	sprintf(cmd, "xrandr %s --addmode %s %s", XRANDR_ARGS, connector, modeline_print(mode, modeline, MS_LABEL_SDL));
+	osd_printf_verbose("SwitchRes: Running '%s'\n", cmd);
+	system(cmd);
+
+	// Use xrandr to switch to new mode. SDL_SetVideoMode doesn't work when (new_width, new_height)==(old_width, old_height)
+	sprintf(cmd, "xrandr %s --output %s --mode %s", XRANDR_ARGS, connector, modeline_print(mode, modeline, MS_LABEL_SDL));
+	osd_printf_verbose("SwitchRes: Running '%s'\n", cmd);
+	system(cmd);
+
+	return true;
+}
+
+//============================================================
+//  del_custom_video_mode
+//============================================================
+
+static int del_custom_video_mode(modeline *mode, char *connector)
+{
+	char modeline[256]={'\x00'};
+	char cmd[512]={'\x00'};
+
+	if (!mode)
+		return false;
+
+	// Delete modeline from interface
+	sprintf(cmd, "xrandr %s --delmode %s %s", XRANDR_ARGS, connector, modeline_print(mode, modeline, MS_LABEL_SDL));
+	osd_printf_verbose("SwitchRes: Running '%s'\n", cmd);
+	system(cmd);
+
+	// Remove modeline
+	sprintf(cmd, "xrandr %s --rmmode %s", XRANDR_ARGS, modeline_print(mode, modeline, MS_LABEL_SDL));
+	osd_printf_verbose("SwitchRes: Running '%s'\n", cmd);
+	system(cmd);
+
+	return true;
+}
+
+//============================================================
+//  set_option_osd - option setting wrapper
+//============================================================
+
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state)
+{
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+	astring error_string;
+
+	options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES, error_string);
+	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", state?"":"no", option_ID);
+}
+
+static void set_option_int_osd(running_machine &machine, const char *option_ID, int value)
+{
+	sdl_options &options = downcast<sdl_options &>(machine.options());
+	astring error_string;
+
+	options.set_value(option_ID, value, OPTION_PRIORITY_SWITCHRES, error_string);
+	osd_printf_verbose("SwitchRes: Setting option -%s %d\n", option_ID, value);
+}
+
+//============================================================
+//  get_output
+//============================================================
+
+static bool get_output(char *command, char *output)
+{
+	FILE *pi;
+	pi = popen(command, "r");
+
+	if (pi != NULL)
+	{
+		char c;
+		int i = 0;
+		c = fgetc(pi);
+		while(c != '\n' && i < 255)
+		{
+			output[i++] = c;
+			c = fgetc(pi);
+		}
+		output[i] = '\0';
+		pclose(pi);
+		return true;
+
+	}
+	else
+		return false;
+}
diff -Nru ./src_0.154_hi/osd/sdl/video.c ./src/osd/sdl/video.c
--- ./src_0.154_hi/osd/sdl/video.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/sdl/video.c	2014-07-29 12:01:47.000000000 +0200
@@ -85,7 +85,6 @@
 
 static void check_osd_inputs(running_machine &machine);
 
-static void extract_video_config(running_machine &machine);
 static void extract_window_config(running_machine &machine, int index, sdl_window_config *conf);
 static float get_aspect(const char *defdata, const char *data, int report_error);
 static void get_resolution(const char *defdata, const char *data, sdl_window_config *config, int report_error);
@@ -309,6 +308,18 @@
 
 
 //============================================================
+//  poll_input
+//============================================================
+
+void sdl_osd_interface::poll_input(void)
+{
+	// poll the joystick values here
+	sdlinput_poll(machine());
+	check_osd_inputs(machine());
+}
+
+
+//============================================================
 //  update
 //============================================================
 
@@ -627,7 +638,7 @@
 //  extract_video_config
 //============================================================
 
-static void extract_video_config(running_machine &machine)
+void extract_video_config(running_machine &machine)
 {
 	const char *stemp;
 	sdl_options &options = downcast<sdl_options &>(machine.options());
@@ -692,12 +703,7 @@
 	video_config.centerh       = options.centerh();
 	video_config.centerv       = options.centerv();
 	video_config.waitvsync     = options.wait_vsync();
-	video_config.syncrefresh   = options.sync_refresh();
-	if (!video_config.waitvsync && video_config.syncrefresh)
-	{
-		osd_printf_warning("-syncrefresh specified without -waitsync. Reverting to -nosyncrefresh\n");
-		video_config.syncrefresh = 0;
-	}
+	video_config.syncrefresh   = machine.options().sync_refresh();
 
 	#if (USE_OPENGL || SDLMAME_SDL2)
 		video_config.filter        = options.filter();
diff -Nru ./src_0.154_hi/osd/sdl/video.h ./src/osd/sdl/video.h
--- ./src_0.154_hi/osd/sdl/video.h	2014-04-26 15:35:06.000000000 +0200
+++ ./src/osd/sdl/video.h	2014-07-29 12:01:44.000000000 +0200
@@ -141,6 +141,7 @@
 //  PROTOTYPES
 //============================================================
 
+void extract_video_config(running_machine &machine);
 void sdlvideo_monitor_refresh(sdl_monitor_info *monitor);
 float sdlvideo_monitor_get_aspect(sdl_monitor_info *monitor);
 sdl_monitor_info *sdlvideo_monitor_from_handle(UINT32 monitor); //FIXME: Remove? not referenced
diff -Nru ./src_0.154_hi/osd/sdl/window.c ./src/osd/sdl/window.c
--- ./src_0.154_hi/osd/sdl/window.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/sdl/window.c	2014-07-29 10:29:57.000000000 +0200
@@ -77,6 +77,7 @@
 
 sdl_window_info *sdl_window_list;
 
+extern bool switchres_resolution_change(sdl_window_info *window);
 
 //============================================================
 //  LOCAL VARIABLES
@@ -812,13 +813,22 @@
 //============================================================
 
 #if SDLMAME_SDL2
-static void pick_best_mode(sdl_window_info *window, int *fswidth, int *fsheight)
+void pick_best_mode(sdl_window_info *window, int *fswidth, int *fsheight)
 {
 	int minimum_width, minimum_height, target_width, target_height;
 	int i;
 	int num;
 	float size_score, best_score = 0.0f;
 
+	// check if we already have a best mode
+	modeline *mode = &window->machine().switchres.best_mode;
+	if (mode->hactive)
+	{
+		*fswidth = mode->hactive;
+		*fsheight = mode>vactive;
+		return;
+	}
+
 	// determine the minimum width/height for the selected target
 	window->target->compute_minimum_size(minimum_width, minimum_height);
 
@@ -879,13 +889,22 @@
 	}
 }
 #else
-static void pick_best_mode(sdl_window_info *window, int *fswidth, int *fsheight)
+void pick_best_mode(sdl_window_info *window, int *fswidth, int *fsheight)
 {
 	int minimum_width, minimum_height, target_width, target_height;
 	int i;
 	float size_score, best_score = 0.0f;
 	SDL_Rect **modes;
 
+	// check if we already have a best mode
+	modeline *mode = &window->machine().switchres.best_mode;
+	if (mode->hactive)
+	{
+		*fswidth = mode->hactive;
+		*fsheight = mode->vactive;
+		return;
+	}
+
 	// determine the minimum width/height for the selected target
 	window->target->compute_minimum_size(minimum_width, minimum_height);
 
@@ -974,7 +993,13 @@
 
 		// see if the games video mode has changed
 		window->target->compute_minimum_size(tempwidth, tempheight);
-		if (tempwidth != window->minwidth || tempheight != window->minheight)
+		if (video_config.switchres && window->fullscreen && machine.options().changeres() && machine.switchres.game.changeres)
+		{
+			switchres_resolution_change(window);
+			return;
+		}
+
+		else if (tempwidth != window->minwidth || tempheight != window->minheight)
 		{
 			window->minwidth = tempwidth;
 			window->minheight = tempheight;
@@ -990,7 +1015,7 @@
 			}
 		}
 
-		if (video_config.waitvsync && video_config.syncrefresh)
+		if (video_config.waitvsync || video_config.syncrefresh)
 			event_wait_ticks = osd_ticks_per_second(); // block at most a second
 		else
 			event_wait_ticks = 0;
diff -Nru ./src_0.154_hi/osd/windows/drawd3d.c ./src/osd/windows/drawd3d.c
--- ./src_0.154_hi/osd/windows/drawd3d.c	2014-04-17 08:27:03.000000000 +0200
+++ ./src/osd/windows/drawd3d.c	2014-07-29 10:29:57.000000000 +0200
@@ -99,15 +99,23 @@
 //  INLINES
 //============================================================
 
-INLINE BOOL GetClientRectExceptMenu(HWND hWnd, PRECT pRect, BOOL fullscreen)
+INLINE BOOL GetClientRectExceptMenu(win_window_info *window, PRECT pRect)
 {
 	static HMENU last_menu;
 	static RECT last_rect;
 	static RECT cached_rect;
+	HWND hWnd = window->hwnd;
+	modeline *mode = window->switchres_mode;
 	HMENU menu = GetMenu(hWnd);
 	BOOL result = GetClientRect(hWnd, pRect);
 
-	if (!fullscreen || !menu)
+	if (mode && mode->hactive)
+	{
+		pRect->right = mode->hactive;
+		pRect->bottom = mode->vactive;
+	}
+
+	if (!window->fullscreen || !menu)
 		return result;
 
 	// to avoid flicker use cache if we can use
@@ -268,11 +276,16 @@
 {
 	d3d::renderer *d3d = (d3d::renderer *)window->drawdata;
 	RECT client;
+	modeline *mode = window->switchres_mode;
 
-	GetClientRectExceptMenu(window->hwnd, &client, window->fullscreen);
+	GetClientRectExceptMenu(window, &client);
 	if (rect_width(&client) > 0 && rect_height(&client) > 0)
 	{
-		window->target->set_bounds(rect_width(&client), rect_height(&client), winvideo_monitor_get_aspect(window->monitor));
+		float aspect_corrector = 1.0f;
+		if (mode && mode->hactive) aspect_corrector =
+			((float)mode->width / (float)mode->height) / ((float)mode->hactive / (float)mode->vactive);
+
+		window->target->set_bounds(rect_width(&client), rect_height(&client), winvideo_monitor_get_aspect(window->monitor)*aspect_corrector);
 		window->target->set_max_update_rate((d3d->get_refresh() == 0) ? d3d->get_origmode().RefreshRate : d3d->get_refresh());
 	}
 	return &window->target->get_primitives();
@@ -829,6 +842,19 @@
 	HRESULT result = (*d3dintf->device.end_scene)(m_device);
 	if (result != D3D_OK) osd_printf_verbose("Direct3D: Error %08X during device end_scene call\n", (int)result);
 
+	// sync to VBLANK
+	if (m_window->machine().options().frame_delay() != 0 && m_window->switchres_mode && ((video_config.triplebuf && m_window->fullscreen) || video_config.waitvsync || video_config.syncrefresh))
+	{
+		D3DRASTER_STATUS raster_status;
+		memset (&raster_status, 0, sizeof(D3DRASTER_STATUS));
+	
+		while (!raster_status.InVBlank)
+		{
+			if ((*d3dintf->device.get_raster_status)(m_device, &raster_status) != D3D_OK)
+				break;
+		}
+	}
+
 	// present the current buffers
 	result = (*d3dintf->device.present)(m_device, NULL, NULL, NULL, NULL, 0);
 	if (result != D3D_OK) osd_printf_verbose("Direct3D: Error %08X during device present call\n", (int)result);
@@ -890,7 +916,7 @@
 	m_presentation.BackBufferWidth               = m_width;
 	m_presentation.BackBufferHeight              = m_height;
 	m_presentation.BackBufferFormat              = m_pixformat;
-	m_presentation.BackBufferCount               = video_config.triplebuf ? 2 : 1;
+	m_presentation.BackBufferCount               = 1;
 	m_presentation.MultiSampleType               = D3DMULTISAMPLE_NONE;
 	m_presentation.SwapEffect                    = D3DSWAPEFFECT_DISCARD;
 	m_presentation.hDeviceWindow                 = m_window->hwnd;
@@ -899,9 +925,9 @@
 	m_presentation.AutoDepthStencilFormat        = D3DFMT_D16;
 	m_presentation.Flags                         = 0;
 	m_presentation.FullScreen_RefreshRateInHz    = m_refresh;
-	m_presentation.PresentationInterval          = ((video_config.triplebuf && m_window->fullscreen) ||
-													video_config.waitvsync || video_config.syncrefresh) ?
-													D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
+ 	m_presentation.PresentationInterval          = (m_window->switchres_mode && m_window->machine().options().frame_delay() == 0 &&
+ 													((video_config.triplebuf && m_window->fullscreen) || video_config.waitvsync || video_config.syncrefresh))?
+  													D3DPRESENT_INTERVAL_ONE : D3DPRESENT_INTERVAL_IMMEDIATE;
 
 	// create the D3D device
 	result = (*d3dintf->d3d.create_device)(d3dintf, m_adapter, D3DDEVTYPE_HAL, m_window->focus_hwnd,
@@ -1205,6 +1231,7 @@
 int renderer::config_adapter_mode()
 {
 	adapter_identifier identifier;
+	modeline *mode = m_window->switchres_mode;
 
 	// choose the monitor number
 	m_adapter = get_adapter_for_monitor();
@@ -1232,7 +1259,7 @@
 		RECT client;
 
 		// bounds are from the window client rect
-		GetClientRectExceptMenu(m_window->hwnd, &client, m_window->fullscreen);
+		GetClientRectExceptMenu(m_window, &client);
 		m_width = client.right - client.left;
 		m_height = client.bottom - client.top;
 
@@ -1264,7 +1291,16 @@
 
 		// if we're allowed to switch resolutions, override with something better
 		if (video_config.switchres)
-			pick_best_mode();
+		{
+			if (!mode)
+				pick_best_mode();
+			else
+			{
+				m_width = mode->width;
+				m_height = mode->height;
+				m_refresh = mode->refresh;
+			}
+		}
 	}
 
 	// see if we can handle the device type
@@ -1362,10 +1398,6 @@
 		if (mode.Width < minwidth || mode.Height < minheight)
 			size_score *= 0.01f;
 
-		// if mode is smaller than we'd like, it only scores up to 0.1
-		if (mode.Width < target_width || mode.Height < target_height)
-			size_score *= 0.1f;
-
 		// if we're looking for a particular mode, that's a winner
 		if (mode.Width == m_window->maxwidth && mode.Height == m_window->maxheight)
 			size_score = 2.0f;
@@ -1373,10 +1405,6 @@
 		// compute refresh score
 		float refresh_score = 1.0f / (1.0f + fabs((double)mode.RefreshRate - target_refresh));
 
-		// if refresh is smaller than we'd like, it only scores up to 0.1
-		if ((double)mode.RefreshRate < target_refresh)
-			refresh_score *= 0.1f;
-
 		// if we're looking for a particular refresh, make sure it matches
 		if (mode.RefreshRate == m_window->refresh)
 			refresh_score = 2.0f;
@@ -1408,7 +1436,7 @@
 {
 	// get the current window bounds
 	RECT client;
-	GetClientRectExceptMenu(m_window->hwnd, &client, m_window->fullscreen);
+	GetClientRectExceptMenu(m_window, &client);
 
 	// if we have a device and matching width/height, nothing to do
 	if (m_device != NULL && rect_width(&client) == m_width && rect_height(&client) == m_height)
diff -Nru ./src_0.154_hi/osd/windows/drawdd.c ./src/osd/windows/drawdd.c
--- ./src_0.154_hi/osd/windows/drawdd.c	2014-04-16 10:04:20.000000000 +0200
+++ ./src/osd/windows/drawdd.c	2014-07-29 10:29:57.000000000 +0200
@@ -25,7 +25,10 @@
 #include "window.h"
 #include "config.h"
 
-
+extern int win_version;
+extern int prepare_mode_switch(win_window_info *window, int *interlace_factor);
+extern int restore_desktop_video_mode(win_window_info *window);
+extern int win_interlace_factor(modeline *mode);
 
 //============================================================
 //  TYPE DEFINITIONS
@@ -394,13 +397,6 @@
 	result = IDirectDrawSurface7_Unlock(dd->blit, NULL);
 	if (result != DD_OK) osd_printf_verbose("DirectDraw: Error %08X unlocking blit surface\n", (int)result);
 
-	// sync to VBLANK
-	if ((video_config.waitvsync || video_config.syncrefresh) && window->machine().video().throttled() && (!window->fullscreen || dd->back == NULL))
-	{
-		result = IDirectDraw7_WaitForVerticalBlank(dd->ddraw, DDWAITVB_BLOCKBEGIN, NULL);
-		if (result != DD_OK) osd_printf_verbose("DirectDraw: Error %08X waiting for VBLANK\n", (int)result);
-	}
-
 	// complete the blitting
 	blit_to_primary(window, dd->blitwidth, dd->blitheight);
 	return 0;
@@ -417,11 +413,16 @@
 	dd_info *dd = (dd_info *)window->drawdata;
 	HRESULT result;
 	int verify;
+	int interlace_factor = 1;
 
 	// if a device exists, free it
 	if (dd->ddraw != NULL)
 		ddraw_delete(window);
 
+	// Windows 7 hack to allow progressive/interlace mode switching
+	if (win_version > 5)
+		prepare_mode_switch(window, &interlace_factor);
+
 	// create the DirectDraw object
 	result = (*directdrawcreateex)(dd->adapter_ptr, (LPVOID *)&dd->ddraw, WRAP_REFIID(IID_IDirectDraw7), NULL);
 	if (result != DD_OK)
@@ -458,17 +459,24 @@
 	// full screen mode: set the resolution
 	if (window->fullscreen && video_config.switchres)
 	{
-		result = IDirectDraw7_SetDisplayMode(dd->ddraw, dd->width, dd->height, 32, dd->refresh, 0);
+		result = IDirectDraw7_SetDisplayMode(dd->ddraw, dd->width, dd->height, 32, dd->refresh / interlace_factor, 0);
 		if (result != DD_OK)
 		{
-			osd_printf_verbose("DirectDraw: Error %08X attempting to set video mode %dx%d@%d call\n", (int)result, dd->width, dd->height, dd->refresh);
+			osd_printf_verbose("DirectDraw: Error %08X attempting to set video mode %dx%d@%d call\n", (int)result, dd->width, dd->height, dd->refresh / interlace_factor);
 			goto error;
 		}
 	}
 
+ 	// Windows 7 hack to allow progressive/interlace mode switching
+ 	if (win_version > 5)
+ 		restore_desktop_video_mode(window);
+
 	return ddraw_create_surfaces(window);
 
 error:
+ 	// Windows 7 hack to allow progressive/interlace mode switching
+ 	if (win_version > 5)
+ 		restore_desktop_video_mode(window);
 	ddraw_delete(window);
 	return 1;
 }
@@ -491,11 +499,11 @@
 	dd->primarydesc.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
 
 	// for triple-buffered full screen mode, allocate flipping surfaces
-	if (window->fullscreen && video_config.triplebuf)
+	if (window->fullscreen)
 	{
 		dd->primarydesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
 		dd->primarydesc.ddsCaps.dwCaps |= DDSCAPS_FLIP | DDSCAPS_COMPLEX;
-		dd->primarydesc.dwBackBufferCount = 2;
+		dd->primarydesc.dwBackBufferCount = 1;
 	}
 
 	// create the primary surface and report errors
@@ -504,7 +512,7 @@
 
 	// full screen mode: get the back surface
 	dd->back = NULL;
-	if (window->fullscreen && video_config.triplebuf)
+	if (window->fullscreen)
 	{
 		DDSCAPS2 caps = { DDSCAPS_BACKBUFFER };
 		result = IDirectDrawSurface7_GetAttachedSurface(dd->primary, &caps, &dd->back);
@@ -810,6 +818,7 @@
 	INT32 newwidth, newheight;
 	int xscale, yscale;
 	RECT client;
+	modeline *mode = window->switchres_mode;
 
 	// start with the minimum size
 	window->target->compute_minimum_size(newwidth, newheight);
@@ -817,8 +826,20 @@
 	// get the window's client rectangle
 	GetClientRect(window->hwnd, &client);
 
+	if (mode && mode->hactive)
+	{
+		client.right = mode->hactive;
+		client.bottom = mode->vactive;
+	}
+
+	if (mode && !(mode->result.weight & R_RES_STRETCH))
+	{
+		xscale = mode->result.x_scale;
+		yscale = mode->result.y_scale;
+	}
+
 	// hardware stretch case: apply prescale
-	if (video_config.hwstretch)
+	else if (video_config.hwstretch)
 	{
 		int prescale = (video_config.prescale < 1) ? 1 : video_config.prescale;
 
@@ -842,7 +863,11 @@
 		if (video_config.keepaspect)
 		{
 			win_monitor_info *monitor = winwindow_video_window_monitor(window, NULL);
-			window->target->compute_visible_area(target_width, target_height, winvideo_monitor_get_aspect(monitor), window->target->orientation(), target_width, target_height);
+			float aspect_corrector = 1.0f;
+			if (mode && mode->hactive) aspect_corrector =
+				((float)mode->width / (float)mode->height) / ((float)mode->hactive / (float)mode->vactive);
+
+			window->target->compute_visible_area(target_width, target_height, winvideo_monitor_get_aspect(monitor)*aspect_corrector, window->target->orientation(), target_width, target_height);
 			desired_aspect = (float)target_width / (float)target_height;
 		}
 
@@ -937,7 +962,7 @@
 	RECT clear, outer, dest, source;
 	INT32 dstwidth, dstheight;
 	HRESULT result;
-
+	modeline *mode = window->switchres_mode;
 	// compute source rect
 	source.left = source.top = 0;
 	source.right = srcwidth;
@@ -960,7 +985,11 @@
 	// compute outer rect -- full screen version
 	else
 	{
-		calc_fullscreen_margins(window, dd->primarydesc.dwWidth, dd->primarydesc.dwHeight, &outer);
+		if (mode && mode->hactive)
+			calc_fullscreen_margins(window, mode->hactive, mode->vactive, &outer);
+		else
+			calc_fullscreen_margins(window, dd->primarydesc.dwWidth, dd->primarydesc.dwHeight, &outer);
+
 	}
 
 	// if we're respecting the aspect ratio, we need to adjust to fit
@@ -987,7 +1016,10 @@
 	else if (video_config.keepaspect)
 	{
 		// compute the appropriate visible area
-		window->target->compute_visible_area(rect_width(&outer), rect_height(&outer), winvideo_monitor_get_aspect(monitor), window->target->orientation(), dstwidth, dstheight);
+		float aspect_corrector = 1.0f;
+		if (mode && mode->hactive) aspect_corrector = ((float)mode->width / (float)mode->height) / ((float)mode->hactive / (float)mode->vactive);
+		window->target->compute_visible_area(rect_width(&outer), rect_height(&outer), winvideo_monitor_get_aspect(monitor)*aspect_corrector, window->target->orientation(), dstwidth, dstheight);
+
 	}
 
 	// center within
@@ -1049,10 +1081,24 @@
 	result = IDirectDrawSurface7_Blt(target, &dest, dd->blit, &source, DDBLT_WAIT, NULL);
 	if (result != DD_OK) osd_printf_verbose("DirectDraw: Error %08X blitting to the screen\n", (int)result);
 
-	// page flip if triple buffered
+ 	// sync to VBLANK begin
+ 	if (video_config.waitvsync && window->switchres_mode && window->machine().video().throttled())
+ 	{
+ 		result = IDirectDraw7_WaitForVerticalBlank(dd->ddraw, DDWAITVB_BLOCKBEGIN, NULL);
+ 		if (result != DD_OK) osd_printf_verbose("DirectDraw: Error %08X waiting for VBLANK\n", (int)result);
+ 	}
+
+ 	// page flip
 	if (window->fullscreen && dd->back != NULL)
 	{
-		result = IDirectDrawSurface7_Flip(dd->primary, NULL, DDFLIP_WAIT);
+ 		result = IDirectDrawSurface7_Flip(dd->primary, NULL, video_config.triplebuf?DDFLIP_WAIT:DDFLIP_NOVSYNC);
+ 		if (result != DD_OK) osd_printf_verbose("DirectDraw: Error %08X waiting for VBLANK\n", (int)result);
+ 	}
+
+ 	// sync to VBLANK end
+ 	if (video_config.waitvsync && window->switchres_mode && window->machine().video().throttled())
+ 	{
+ 		result = IDirectDraw7_WaitForVerticalBlank(dd->ddraw, DDWAITVB_BLOCKEND, NULL);
 		if (result != DD_OK) osd_printf_verbose("DirectDraw: Error %08X waiting for VBLANK\n", (int)result);
 	}
 }
@@ -1068,7 +1114,7 @@
 	DDDEVICEIDENTIFIER2 identifier;
 	dd_info *dd = (dd_info *)window->drawdata;
 	HRESULT result;
-
+	modeline *mode = window->switchres_mode;
 	// choose the monitor number
 	get_adapter_for_monitor(dd, window->monitor);
 
@@ -1110,7 +1156,16 @@
 
 		// if we're allowed to switch resolutions, override with something better
 		if (video_config.switchres)
-			pick_best_mode(window);
+		{
+			if (!mode)
+				pick_best_mode(window);
+			else
+			{
+				dd->width = mode->width;
+				dd->height = mode->height;
+				dd->refresh = (int)mode->refresh;
+			}
+		}
 	}
 
 	// release the DirectDraw object
@@ -1219,10 +1274,6 @@
 	// compute refresh score
 	refresh_score = 1.0f / (1.0f + fabs((double)desc->dwRefreshRate - einfo->target_refresh));
 
-	// if refresh is smaller than we'd like, it only scores up to 0.1
-	if ((double)desc->dwRefreshRate < einfo->target_refresh)
-		refresh_score *= 0.1f;
-
 	// if we're looking for a particular refresh, make sure it matches
 	if (desc->dwRefreshRate == einfo->window->refresh)
 		refresh_score = 2.0f;
diff -Nru ./src_0.154_hi/osd/windows/pstrip.c ./src/osd/windows/pstrip.c
--- ./src_0.154_hi/osd/windows/pstrip.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/osd/windows/pstrip.c	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,527 @@
+/**************************************************************
+
+   pstrip.c - PowerStrip interface routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2012 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+/*	http://forums.entechtaiwan.com/index.php?topic=5534.msg20902;topicseen#msg20902
+
+	UM_SETCUSTOMTIMING = WM_USER+200;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure else current pixel clock (integer in Hz)
+	Note: pass full PowerStrip timing string*
+
+	UM_SETREFRESHRATE = WM_USER+201;
+	wparam = monitor number, zero-based
+	lparam = refresh rate (integer in Hz), or 0 for read-only
+	lresult = -1 for failure else current refresh rate (integer in Hz)
+
+	UM_SETPOLARITY = WM_USER+202;
+	wparam = monitor number, zero-based
+	lparam = polarity bits
+	lresult = -1 for failure else current polarity bits+1
+
+	UM_REMOTECONTROL = WM_USER+210;
+	wparam = 99
+	lparam =
+		0 to hide tray icon
+		1 to show tray icon,
+		2 to get build number
+	   10 to show Performance profiles
+	   11 to show Color profiles
+	   12 to show Display profiles
+	   13 to show Application profiles
+	   14 to show Adapter information
+	   15 to show Monitor information
+	   16 to show Hotkey manager
+	   17 to show Resource manager
+	   18 to show Preferences
+	   19 to show Online services
+	   20 to show About screen
+	   21 to show Tip-of-the-day
+	   22 to show Setup wizard
+	   23 to show Screen fonts
+	   24 to show Advanced timing options
+	   25 to show Custom resolutions
+	   99 to close PS
+	lresult = -1 for failure else lparam+1 for success or build number (e.g., 335)
+	if lparam was 2
+
+	UM_SETGAMMARAMP = WM_USER+203;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure, 1 for success
+
+	UM_CREATERESOLUTION = WM_USER+204;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure, 1 for success
+	Note: pass full PowerStrip timing string*; reboot is usually necessary to see if
+	the resolution is accepted by the display driver
+
+	UM_GETTIMING = WM_USER+205;
+	wparam = monitor number, zero-based
+	lresult = -1 for failure else GlobalAtom number identifiying the timing string*
+	Note: be sure to call GlobalDeleteAtom after reading the string associated with
+	the atom
+
+	UM_GETSETCLOCKS = WM_USER+206;
+	wparam = monitor number, zero-based
+	lparam = atom for string pointer
+	lresult = -1 for failure else GlobalAtom number identifiying the performance
+	string**
+	Note: pass full PowerStrip performance string** to set the clocks, and ull to
+	get clocks; be sure to call GlobalDeleteAtom after reading the string associated
+	with the atom
+
+	NegativeHorizontalPolarity = 0x02;
+	NegativeVerticalPolarity = 0x04;
+
+	*Timing string parameter definition:
+	 1 = horizontal active pixels
+	 2 = horizontal front porch
+	 3 = horizontal sync width
+	 4 = horizontal back porch
+	 5 = vertical active pixels
+	 6 = vertical front porch
+	 7 = vertical sync width
+	 8 = vertical back porch
+	 9 = pixel clock in hertz
+	10 = timing flags, where bit:
+		 1 = negative horizontal porlarity
+		 2 = negative vertical polarity
+		 3 = interlaced
+		 5 = composite sync
+		 7 = sync-on-green
+		 all other bits reserved
+
+	**Performance string parameter definition:
+	 1 = memory clock in hertz
+	 2 = engine clock in hertz
+	 3 = reserved
+	 4 = reserved
+	 5 = reserved
+	 6 = reserved
+	 7 = reserved
+	 8 = reserved
+	 9 = 2D memory clock in hertz (if different from 3D)
+	10 = 2D engine clock in hertz (if different from 3D) */
+
+// standard windows headers
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <stdio.h>
+
+// MAME headers
+#include "emu.h"
+
+// PowerStrip header
+#include "pstrip.h"
+
+//============================================================
+//  GLOBALS
+//============================================================
+
+static HWND hPSWnd;
+static MonitorTiming timing_backup;
+
+//============================================================
+//  CONSTANTS
+//============================================================
+
+#define UM_SETCUSTOMTIMING      (WM_USER+200)
+#define UM_SETREFRESHRATE       (WM_USER+201)
+#define UM_SETPOLARITY          (WM_USER+202)
+#define UM_REMOTECONTROL        (WM_USER+210)
+#define UM_SETGAMMARAMP         (WM_USER+203)
+#define UM_CREATERESOLUTION     (WM_USER+204)
+#define UM_GETTIMING            (WM_USER+205)
+#define UM_GETSETCLOCKS         (WM_USER+206)
+#define UM_SETCUSTOMTIMINGFAST  (WM_USER+211) // glitches vertical sync with PS 3.65 build 568
+
+#define NegativeHorizontalPolarity      0x02
+#define NegativeVerticalPolarity        0x04
+#define Interlace                       0x08
+
+#define HideTrayIcon                    0x00
+#define ShowTrayIcon                    0x01
+#define ClosePowerStrip                 0x63
+
+//============================================================
+//  ps_init
+//============================================================
+
+int ps_init(int monitor_index, modeline *modeline)
+{
+	hPSWnd = FindWindowA("TPShidden", NULL);
+
+	if (hPSWnd)
+	{
+		osd_printf_verbose("PStrip: PowerStrip found!\n");
+		if (ps_get_monitor_timing(monitor_index, &timing_backup) && modeline)
+		{
+			ps_pstiming_to_modeline(&timing_backup, modeline);
+			return 1;
+		}
+	}
+	else
+		osd_printf_verbose("PStrip: Could not get PowerStrip API interface\n");
+
+	return 0;
+}
+
+//============================================================
+//  ps_reset
+//============================================================
+
+int ps_reset(int monitor_index)
+{
+	return ps_set_monitor_timing(monitor_index, &timing_backup);
+}
+
+//============================================================
+//  ps_get_modeline
+//============================================================
+
+int ps_get_modeline(int monitor_index, modeline *modeline)
+{
+	MonitorTiming timing = {0};
+
+	if (ps_get_monitor_timing(monitor_index, &timing))
+	{
+		ps_pstiming_to_modeline(&timing, modeline);
+		return 1;
+	}
+	else return 0;
+}
+
+//============================================================
+//  ps_set_modeline
+//============================================================
+
+int ps_set_modeline(int monitor_index, modeline *modeline)
+{
+	MonitorTiming timing = {0};
+
+	ps_modeline_to_pstiming(modeline, &timing);
+
+	timing.PixelClockInKiloHertz = ps_best_pclock(monitor_index, &timing, timing.PixelClockInKiloHertz);
+
+	if (ps_set_monitor_timing(monitor_index, &timing))
+		return 1;
+	else
+		return 0;
+}
+
+//============================================================
+//  ps_get_monitor_timing
+//============================================================
+
+int ps_get_monitor_timing(int monitor_index, MonitorTiming *timing)
+{
+	LRESULT lresult;
+	char in[256];
+
+	if (!hPSWnd) return 0;
+
+	lresult = SendMessage(hPSWnd, UM_GETTIMING, monitor_index, 0);
+
+	if (lresult == -1)
+	{
+		osd_printf_verbose("PStrip: Could not get PowerStrip timing string\n");
+		return 0;
+	}
+
+	if (!GlobalGetAtomNameA(lresult, in, sizeof(in)))
+	{
+		osd_printf_verbose("PStrip: GlobalGetAtomName failed\n");
+		return 0;
+	}
+
+	osd_printf_verbose("PStrip: ps_get_monitor_timing(%d): %s\n", monitor_index, in);
+
+	ps_read_timing_string(in, timing);
+
+	GlobalDeleteAtom(lresult); // delete atom created by PowerStrip
+
+	return 1;
+}
+
+//============================================================
+//  ps_set_monitor_timing
+//============================================================
+
+int ps_set_monitor_timing(int monitor_index, MonitorTiming *timing)
+{
+	LRESULT lresult;
+	ATOM atom;
+	char out[256];
+
+	if (!hPSWnd) return 0;
+
+	ps_fill_timing_string(out, timing);
+	atom = GlobalAddAtomA(out);
+
+	if (atom)
+	{
+		lresult = SendMessage(hPSWnd, UM_SETCUSTOMTIMING, monitor_index, atom);
+
+		if (lresult < 0)
+		{
+			osd_printf_verbose("PStrip: SendMessage failed\n");
+			GlobalDeleteAtom(atom);
+		}
+		else
+		{
+			osd_printf_verbose("PStrip: ps_set_monitor_timing(%d): %s\n", monitor_index, out);
+			return 1;
+		}
+	}
+	else osd_printf_verbose("PStrip: ps_set_monitor_timing atom creation failed\n");
+
+	return 0;
+}
+
+//============================================================
+//  ps_set_monitor_timing_string
+//============================================================
+
+int ps_set_monitor_timing_string(int monitor_index, char *in)
+{
+	MonitorTiming timing;
+
+	ps_read_timing_string(in, &timing);
+	return ps_set_monitor_timing(monitor_index, &timing);
+}
+
+//============================================================
+//  ps_set_refresh
+//============================================================
+
+int ps_set_refresh(int monitor_index, double vfreq)
+{
+	MonitorTiming timing = {0};
+	int hht, vvt, new_vvt;
+	int desired_pClock;
+	int best_pClock;
+
+	memcpy(&timing, &timing_backup, sizeof(MonitorTiming));
+
+	hht = timing.HorizontalActivePixels
+		+ timing.HorizontalFrontPorch
+		+ timing.HorizontalSyncWidth
+		+ timing.HorizontalBackPorch;
+
+	vvt = timing.VerticalActivePixels
+		+ timing.VerticalFrontPorch
+		+ timing.VerticalSyncWidth
+		+ timing.VerticalBackPorch;
+
+	desired_pClock = hht * vvt * vfreq / 1000;
+	best_pClock = ps_best_pclock(monitor_index, &timing, desired_pClock);
+
+	new_vvt = best_pClock * 1000 / (vfreq * hht);
+
+	timing.VerticalBackPorch += (new_vvt - vvt);
+	timing.PixelClockInKiloHertz = best_pClock;
+
+	ps_set_monitor_timing(monitor_index, &timing);
+	ps_get_monitor_timing(monitor_index, &timing);
+
+	return 1;
+}
+
+//============================================================
+//  ps_best_pclock
+//============================================================
+
+int ps_best_pclock(int monitor_index, MonitorTiming *timing, int desired_pclock)
+{
+	MonitorTiming timing_read;
+	int best_pclock = 0;
+
+	osd_printf_verbose("PStrip: ps_best_pclock(%d), getting stable dotclocks for %d...\n", monitor_index, desired_pclock);
+
+	for (int i = -50; i <= 50; i += 25)
+	{
+		timing->PixelClockInKiloHertz = desired_pclock + i;
+
+		ps_set_monitor_timing(monitor_index, timing);
+		ps_get_monitor_timing(monitor_index, &timing_read);
+
+		if (abs(timing_read.PixelClockInKiloHertz - desired_pclock) < abs(desired_pclock - best_pclock))
+			best_pclock = timing_read.PixelClockInKiloHertz;
+	}
+
+	osd_printf_verbose("PStrip: ps_best_pclock(%d), new dotclock: %d\n", monitor_index, best_pclock);
+
+	return best_pclock;
+}
+
+//============================================================
+//  ps_create_resolution
+//============================================================
+
+int ps_create_resolution(int monitor_index, modeline *modeline)
+{
+	LRESULT     lresult;
+	ATOM        atom;
+	char        out[256];
+	MonitorTiming timing = {0};
+
+	if (!hPSWnd) return 0;
+
+	ps_modeline_to_pstiming(modeline, &timing);
+
+	ps_fill_timing_string(out, &timing);
+	atom = GlobalAddAtomA(out);
+
+	if (atom)
+	{
+		lresult = SendMessage(hPSWnd, UM_CREATERESOLUTION, monitor_index, atom);
+
+		if (lresult < 0)
+        	{
+        		osd_printf_verbose("PStrip: SendMessage failed\n");
+        		GlobalDeleteAtom(atom);
+        	}
+        	else
+        	{
+        		osd_printf_verbose("PStrip: ps_create_resolution(%d): %dx%d succeded \n",
+        			modeline->width, modeline->height, monitor_index);
+        		return 1;
+        	}
+        }
+        else osd_printf_verbose("PStrip: ps_create_resolution atom creation failed\n");
+
+	return 0;
+}
+
+//============================================================
+//  ps_read_timing_string
+//============================================================
+
+void ps_read_timing_string(char *in, MonitorTiming *timing)
+{
+	sscanf(in,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
+		&timing->HorizontalActivePixels,
+		&timing->HorizontalFrontPorch,
+		&timing->HorizontalSyncWidth,
+		&timing->HorizontalBackPorch,
+		&timing->VerticalActivePixels,
+		&timing->VerticalFrontPorch,
+		&timing->VerticalSyncWidth,
+		&timing->VerticalBackPorch,
+		&timing->PixelClockInKiloHertz,
+		&timing->TimingFlags.w);
+}
+
+//============================================================
+//  ps_fill_timing_string
+//============================================================
+
+void ps_fill_timing_string(char *out, MonitorTiming *timing)
+{
+	sprintf(out, "%d,%d,%d,%d,%d,%d,%d,%d,%d,%d",
+		timing->HorizontalActivePixels,
+		timing->HorizontalFrontPorch,
+		timing->HorizontalSyncWidth,
+		timing->HorizontalBackPorch,
+		timing->VerticalActivePixels,
+		timing->VerticalFrontPorch,
+		timing->VerticalSyncWidth,
+		timing->VerticalBackPorch,
+		timing->PixelClockInKiloHertz,
+		timing->TimingFlags.w);
+}
+
+//============================================================
+//  ps_modeline_to_pstiming
+//============================================================
+
+int ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing)
+{
+	timing->HorizontalActivePixels = modeline->hactive;
+	timing->HorizontalFrontPorch = modeline->hbegin - modeline->hactive;
+	timing->HorizontalSyncWidth = modeline->hend - modeline->hbegin;
+	timing->HorizontalBackPorch = modeline->htotal - modeline->hend;
+
+	timing->VerticalActivePixels = modeline->vactive;
+	timing->VerticalFrontPorch = modeline->vbegin - modeline->vactive;
+	timing->VerticalSyncWidth = modeline->vend - modeline->vbegin;
+	timing->VerticalBackPorch = modeline->vtotal - modeline->vend;
+
+	timing->PixelClockInKiloHertz = modeline->pclock / 1000;
+
+	if (modeline->hsync == 0)
+		timing->TimingFlags.w |= NegativeHorizontalPolarity;
+	if (modeline->vsync == 0)
+		timing->TimingFlags.w |= NegativeVerticalPolarity;
+	if (modeline->interlace)
+		timing->TimingFlags.w |= Interlace;
+
+	return 0;
+}
+
+//============================================================
+//  ps_pstiming_to_modeline
+//============================================================
+
+int ps_pstiming_to_modeline(MonitorTiming *timing, modeline *modeline)
+{
+	modeline->hactive = timing->HorizontalActivePixels;
+	modeline->hbegin = modeline->hactive + timing->HorizontalFrontPorch;
+	modeline->hend = modeline->hbegin + timing->HorizontalSyncWidth;
+	modeline->htotal = modeline->hend + timing->HorizontalBackPorch;
+
+	modeline->vactive = timing->VerticalActivePixels;
+	modeline->vbegin = modeline->vactive + timing->VerticalFrontPorch;
+	modeline->vend = modeline->vbegin + timing->VerticalSyncWidth;
+	modeline->vtotal = modeline->vend + timing->VerticalBackPorch;
+
+	modeline->width = modeline->hactive;
+	modeline->height = modeline->vactive;
+
+	modeline->pclock = timing->PixelClockInKiloHertz * 1000;
+
+	if (!(timing->TimingFlags.w & NegativeHorizontalPolarity))
+		modeline->hsync = 1;
+
+	if (!(timing->TimingFlags.w & NegativeVerticalPolarity))
+		modeline->vsync = 1;
+
+	if ((timing->TimingFlags.w & Interlace))
+		modeline->interlace = 1;
+
+	modeline->hfreq = modeline->pclock / modeline->htotal;
+	modeline->vfreq = modeline->hfreq / modeline->vtotal * (modeline->interlace?2:1);
+
+	return 0;
+}
+
+//============================================================
+//  ps_monitor_index
+//============================================================
+
+int ps_monitor_index (const char *display_name)
+{
+	int monitor_index = 0;
+	char sub_index[2];
+
+	sub_index[0] = display_name[strlen(display_name)-1];
+	sub_index[1] = 0;
+	if (sscanf(sub_index,"%d", &monitor_index) == 1)
+		monitor_index --;
+
+	return monitor_index;
+}
\ No newline at end of file
diff -Nru ./src_0.154_hi/osd/windows/pstrip.h ./src/osd/windows/pstrip.h
--- ./src_0.154_hi/osd/windows/pstrip.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/osd/windows/pstrip.h	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,62 @@
+/**************************************************************
+ 
+   powerstrip.h - PowerStrip interface routines
+   
+   ---------------------------------------------------------
+ 
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2013 Antonio Giner          
+    
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+ 
+ **************************************************************/
+
+//============================================================
+//  TYPE DEFINITIONS
+//============================================================
+
+typedef struct
+{
+    int HorizontalActivePixels;
+    int HorizontalFrontPorch;
+    int HorizontalSyncWidth;
+    int HorizontalBackPorch;
+    int VerticalActivePixels;
+    int VerticalFrontPorch;
+    int VerticalSyncWidth;
+    int VerticalBackPorch;
+    int PixelClockInKiloHertz;
+    union
+    {
+        int w;
+        struct
+        {
+            unsigned :1;
+            unsigned HorizontalPolarityNegative:1;
+            unsigned VerticalPolarityNegative:1;
+            unsigned :29;
+        } b;
+    } TimingFlags;
+} MonitorTiming;
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+int ps_init(int monitor_index, modeline *modeline);
+int ps_reset(int monitor_index);
+int ps_get_modeline(int monitor_index, modeline *modeline);
+int ps_set_modeline(int monitor_index, modeline *modeline);
+int ps_get_monitor_timing(int monitor_index, MonitorTiming *timing);
+int ps_set_monitor_timing(int monitor_index, MonitorTiming *timing);
+int ps_set_monitor_timing_string(int monitor_index, char *in);
+int ps_set_refresh(int monitor_index, double vfreq);
+int ps_best_pclock(int monitor_index, MonitorTiming *timing, int desired_pclock);
+int ps_create_resolution(int monitor_index, modeline *modeline);
+void ps_read_timing_string(char *in, MonitorTiming *timing);
+void ps_fill_timing_string(char *out, MonitorTiming *timing);
+int ps_modeline_to_pstiming(modeline *modeline, MonitorTiming *timing);
+int ps_pstiming_to_modeline(MonitorTiming *timing, modeline *modeline);
+int ps_monitor_index (const char *display_name);
diff -Nru ./src_0.154_hi/osd/windows/switchres.c ./src/osd/windows/switchres.c
--- ./src_0.154_hi/osd/windows/switchres.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/osd/windows/switchres.c	2014-07-29 10:29:57.000000000 +0200
@@ -0,0 +1,883 @@
+/**************************************************************
+
+   switchres.c - Windows OSD SwitchRes core routines
+
+   ---------------------------------------------------------
+
+   SwitchRes   Modeline generation engine for emulation
+               (C) 2010 Chris Kennedy
+               (C) 2013 Antonio Giner
+
+   GroovyMAME  Integration of SwitchRes into the MAME project
+               Some reworked patches from SailorSat's CabMAME
+
+ **************************************************************/
+
+// standard windows headers
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+// MAME headers
+#include "emu.h"
+#include "emuopts.h"
+
+// MAMEOS headers
+#include "winmain.h"
+#include "window.h"
+#include "pstrip.h"
+
+#define min(a,b)({ __typeof__ (a) _a = (a);__typeof__ (b) _b = (b);_a < _b ? _a : _b; })
+
+//============================================================
+//  PROTOTYPES
+//============================================================
+
+bool switchres_init_osd(running_machine &machine);
+bool switchres_modeline_setup(running_machine &machine);
+bool switchres_modeline_remove(running_machine &machine);
+bool switchres_resolution_change(win_window_info *window);
+
+static void reset_video_modes(void);
+static int get_desktop_video_mode(const char *device_name, modeline *current);
+static int get_available_video_modes(const char *device_name, modeline mode[MAX_MODELINES], modeline *current, config_settings *cs);
+
+static bool get_custom_video_timing_ati(modeline *mode);
+static bool set_custom_video_timing_ati(modeline *mode);
+static bool update_custom_video_timing_ati(modeline *mode);
+
+static int get_device_name_and_key(const char *screen_option, char *device_name, char *DeviceKey);
+
+static int get_custom_mode_DWORD(int i, char *lp_data);
+static int get_custom_mode_DWORD_BCD(int i, char *lp_data);
+static void set_custom_mode_DWORD (char *data_string, UINT32 data_word, int offset);
+static void set_custom_mode_DWORD_BCD (char *data_string, UINT32 data_word, int offset);
+
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state);
+static void set_option_int_osd(running_machine &machine, const char *option_ID, int value);
+static void set_option_str_osd(running_machine &machine, const char *option_ID, const char *value);
+
+static int os_version(void);
+int win_interlace_factor(modeline *mode);
+static int copy_to_clipboard(char *txt);
+
+//============================================================
+//  PARAMETERS
+//============================================================
+
+// display modes
+#define DM_INTERLACED 0x00000002
+// custom window messages
+#define WM_USER_CHANGERES (WM_USER + 8)
+#define DISPLAY_MAX 16
+
+//============================================================
+//  GLOBAL VARIABLES
+//============================================================
+
+int win_version;
+
+//============================================================
+//  LOCAL VARIABLES
+//============================================================
+
+static BOOL powerstrip_found;
+char default_device_key[256];
+char default_device_name[32];
+DEVMODEA desktop_devmode;
+modeline backup_mode;
+
+//============================================================
+// switchres_init_osd
+//============================================================
+
+bool switchres_init_osd(running_machine &machine)
+{
+	config_settings *cs = &machine.switchres.cs;
+	modeline *mode_table = machine.switchres.video_modes;
+	modeline *user_mode = &machine.switchres.user_mode;
+	monitor_range *range = machine.switchres.range;
+	const char * screen, * aspect;
+	char resolution[32]={'\x00'};
+	char modeline_txt[256]={'\x00'};
+	modeline current;
+
+	windows_options &options = downcast<windows_options &>(machine.options());
+
+	memset(&current, 0, sizeof(struct modeline));
+	memset(&backup_mode, 0, sizeof(struct modeline));
+	cs->monitor_count = options.numscreens();
+	cs->doublescan = 0;
+
+	// Get Windows version
+	win_version = os_version();
+
+	// Get device info
+	screen = strcmp(options.screen(0), "auto")? options.screen(0) : options.screen();
+	get_device_name_and_key(screen, default_device_name, default_device_key);
+
+	// Get current desktop resolution
+	get_desktop_video_mode(default_device_name, &current);
+
+	// Get per window resolution
+	strcpy(resolution, strcmp(options.resolution(0), "auto")? options.resolution(0) : options.resolution());
+
+	// Get per window aspect
+	aspect = strcmp(options.aspect(0), "auto")? options.aspect(0) : options.aspect();
+	if (strcmp(aspect, "auto"))
+	{
+		double num, den;
+		sscanf(aspect, "%lf:%lf", &num, &den);
+		cs->monitor_aspect = num/den;
+	}
+	else
+		cs->monitor_aspect = STANDARD_CRT_ASPECT;
+
+	// Initialize Powerstrip
+	if (machine.options().powerstrip() && machine.options().modeline_generation() && ps_init(ps_monitor_index(default_device_name), &current))
+	{
+		powerstrip_found = true;
+		memcpy(&backup_mode, &current, sizeof(modeline));
+		backup_mode.type |= PSTRIP_TIMING;
+
+		// Check if we have a -ps_timing string defined, if so, use it as user defined modeline
+		if (strcmp(machine.options().ps_timing(), "auto"))
+		{
+			MonitorTiming timing;
+			ps_read_timing_string((char*)options.ps_timing(), &timing);
+			ps_pstiming_to_modeline(&timing, user_mode);
+			user_mode->type |= PSTRIP_TIMING;
+			osd_printf_verbose("SwitchRes: ps_string: %s (%s)\n", machine.options().ps_timing(), modeline_print(user_mode, modeline_txt, MS_PARAMS));
+		}
+	}
+
+	// Get list of available video modes
+	if (!get_available_video_modes(default_device_name, mode_table, &current, cs))
+	{
+		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
+		return false;
+	}
+
+	// If monitor is LCD, create automatic specs and force resolution
+	if (!strcmp(cs->monitor, "lcd"))
+	{
+		osd_printf_verbose("SwitchRes: Creating automatic specs for LCD based on ");
+		if (!powerstrip_found)
+		{
+			osd_printf_verbose("VESA GTF\n");
+			modeline_vesa_gtf(&current);
+		}
+		else
+			osd_printf_verbose("PowerStrip\n");
+
+		monitor_range_from_modeline(range, &current);
+		show_monitor_range(range);
+		sprintf(resolution, "%dx%d@%d", current.width, current.height, current.refresh);
+	}
+	// Otherwise (non-LCD), convert the user defined modeline into a -resolution option
+	else if (user_mode->hactive)
+		sprintf(resolution, "%dx%d", user_mode->hactive, user_mode->vactive);
+
+	// Filter the mode table according the -resolution option
+	if (strcmp(resolution, "auto"))
+	{
+		int i = 1;
+		bool found = false;
+		osd_printf_verbose("SwitchRes: -resolution was forced as %s\n", resolution);
+
+		if ((sscanf(resolution, "%dx%d@%d", &cs->width, &cs->height, &cs->refresh) < 3) &&
+			((!strstr(resolution, "x") || (sscanf(resolution, "%dx%d", &cs->width, &cs->height) != 2))))
+				osd_printf_info("SwitchRes: illegal -resolution value: %s\n", resolution);
+
+		else while (mode_table[i].width && i < MAX_MODELINES)
+		{
+			// Lock all modes that don't match the user's -resolution rules
+			if (!( (mode_table[i].width == cs->width || (mode_table[i].type & X_RES_EDITABLE && cs->width <= DUMMY_WIDTH) || cs->width == 0)
+				&& (mode_table[i].height == cs->height || cs->height == 0)
+				&& (mode_table[i].refresh == cs->refresh || cs->refresh == 0) ))
+				mode_table[i].type |= MODE_LOCKED;
+
+			else
+			{
+				// If we have an user defined modeline, link its label to current item in mode table
+				if (user_mode->hactive && !found)
+				{
+					user_mode->width = mode_table[i].width;
+					user_mode->height = mode_table[i].height;
+					user_mode->refresh = mode_table[i].refresh;
+					user_mode->type = mode_table[i].type & ~V_FREQ_EDITABLE & ~X_RES_EDITABLE;
+				}
+				mode_table[i].type &= ~MODE_LOCKED;
+				found = true;
+			}
+			i++;
+		}
+		if (!found)
+			osd_printf_info("SwitchRes: -resolution value not available: %s\n", resolution);
+	}
+
+	return true;
+}
+
+//============================================================
+// switchres_modeline_setup
+//============================================================
+
+bool switchres_modeline_setup(running_machine &machine)
+{
+	modeline *best_mode = &machine.switchres.best_mode;
+	modeline *user_mode = &machine.switchres.user_mode;
+	config_settings *cs = &machine.switchres.cs;
+	windows_options &options = downcast<windows_options &>(machine.options());
+	char modeline_txt[256]={'\x00'};
+
+	osd_printf_verbose("\nSwitchRes: Entering switchres_modeline_setup\n");
+
+	// Find most suitable video mode and generate a modeline for it if we're allowed
+	if (!switchres_get_video_mode(machine))
+	{
+		set_option_osd(machine, OSDOPTION_SWITCHRES, false);
+		return false;
+	}
+
+	// Make the new video timings available to the system
+	if (options.modeline_generation())
+	{
+		if (best_mode->type & PSTRIP_TIMING)
+		{
+			osd_printf_verbose("SwitchRes: Modeline %s\n", modeline_print(best_mode, modeline_txt, MS_FULL));
+			// In case -ps_timing is provided, pass it as raw string
+			if (user_mode->type & PSTRIP_TIMING)
+				ps_set_monitor_timing_string(ps_monitor_index(default_device_name), (char*)options.ps_timing());
+			// Otherwise pass it as modeline
+			else
+				ps_set_modeline(ps_monitor_index(default_device_name), best_mode);
+			Sleep(100);
+		}
+		else if (best_mode->type & ATI_REG_TIMING)
+			update_custom_video_timing_ati(best_mode);
+
+		if (options.verbose())
+		{
+			modeline_print(best_mode, modeline_txt, MS_FULL);
+			copy_to_clipboard(modeline_txt);
+		}
+	}
+
+	// Set MAME common options
+	switchres_set_options(machine);
+
+	// Set MAME OSD specific options
+
+	// Deal with W7 & interlace
+	if (win_version > 5 && best_mode->interlace) set_option_str_osd(machine, OSDOPTION_VIDEO, "ddraw");
+
+	// Black frame insertion / multithreading
+	bool black_frame_insertion = options.black_frame_insertion() && best_mode->result.v_scale > 1 && best_mode->vfreq > 100;
+	set_option_osd(machine, OPTION_BLACK_FRAME_INSERTION, black_frame_insertion);
+	set_option_osd(machine, OSDOPTION_MULTITHREADING, options.multithreading() && !(options.numscreens() > 1) && !black_frame_insertion);
+
+	// Vertical synchronization management
+	// Unless -syncrefresh is forced, we only enable v-sync if the refresh difference is below the value specified by -sync_refresh_tolerance.
+	// Otherwise -triplebuffer is used, provided we run multithreaded
+	// Forcing -triplebuffer will override the -syncrefresh setting
+	bool triple_buffer_effective = options.triple_buffer() && options.multithreading() && !(options.sync_refresh() && machine.options().priority(WINOPTION_TRIPLEBUFFER) < machine.options().priority(OPTION_SYNCREFRESH));
+	set_option_osd(machine, WINOPTION_TRIPLEBUFFER, triple_buffer_effective || (!options.sync_refresh() && !black_frame_insertion && ((best_mode->result.weight & R_V_FREQ_OFF) || best_mode->result.v_scale > 1)));
+	set_option_osd(machine, OSDOPTION_SYNCREFRESH, !options.triple_buffer());
+	set_option_osd(machine, OSDOPTION_WAITVSYNC, options.sync_refresh());
+
+	// Set scaling/stretching options
+	// set_option_osd(machine, WINOPTION_HWSTRETCH, (best_mode->result.weight & R_RES_STRETCH && !strcmp(options.video(), "ddraw")));
+	set_option_osd(machine, OSDOPTION_KEEPASPECT, true);
+	set_option_osd(machine, WINOPTION_HWSTRETCH, true);
+	set_option_osd(machine, WINOPTION_FILTER, ((best_mode->result.weight & R_RES_STRETCH || best_mode->interlace) && !strcmp(options.video(), "d3d")));
+	set_option_int_osd(machine, WINOPTION_PRESCALE, options.d3d_hlsl_enable()? 0 : min(best_mode->result.x_scale, best_mode->result.y_scale));
+	cs->cleanstretch = !options.cleanstretch() || cs->effective_orientation? !(best_mode->result.weight & R_RES_STRETCH) : options.cleanstretch();
+
+	// Refresh video options
+	extract_video_config (machine);
+
+	return true;
+}
+
+//============================================================
+// switchres_modeline_remove
+//============================================================
+
+bool switchres_modeline_remove(running_machine &machine)
+{
+	windows_options &options = downcast<windows_options &>(machine.options());
+
+	// Restore original video timings
+	if (machine.options().modeline_generation())
+	{
+		if (backup_mode.type & PSTRIP_TIMING)
+			ps_reset(ps_monitor_index(default_device_name));
+
+		else if (backup_mode.type & ATI_REG_TIMING)
+			update_custom_video_timing_ati(0);
+	}
+
+	// Reset Windows options
+	switchres_reset_options(machine);
+	options.revert(OPTION_PRIORITY_SWITCHRES);
+
+	return true;
+}
+
+//============================================================
+// switchres_resolution_change
+//============================================================
+
+bool switchres_resolution_change(win_window_info *window)
+{
+	running_machine &machine = window->machine();
+	game_info *game = &machine.switchres.game;
+	modeline *best_mode = &machine.switchres.best_mode;
+	modeline previous_mode;
+	emu_options &options = machine.options();
+
+	game->changeres = 0;
+
+	if (options.changeres())
+	{
+		osd_printf_verbose("SwitchRes: Resolution change to %dx%d@%d\n", game->width, game->height, (int)game->refresh);
+
+		// Get the new resolution
+		memcpy(&previous_mode, best_mode, sizeof(modeline));
+		switchres_modeline_setup(machine);
+		window->maxwidth = best_mode->width;
+		window->maxheight = best_mode->height;
+
+		// Only change resolution if the new one is actually different
+		if (memcmp(&previous_mode, best_mode, sizeof(modeline) - sizeof(mode_result)))
+			SendMessage(window->hwnd, WM_USER_CHANGERES, 0, 0);
+	}
+	else
+	{
+		window->maxwidth = game->width;
+		window->maxheight = game->height;
+	}
+
+	return true;
+}
+
+//============================================================
+//  reset_video_modes
+//============================================================
+
+static void reset_video_modes(void)
+{
+	int iModeNum = 0;
+	DEVMODEA lpDevMode;
+
+	memset(&lpDevMode, 0, sizeof(DEVMODEA));
+	lpDevMode.dmSize = sizeof(DEVMODEA);
+
+	while (EnumDisplaySettingsExA(default_device_name, iModeNum, &lpDevMode, 0) != 0)
+		iModeNum++;
+}
+
+//============================================================
+//  get_desktop_video_mode
+//============================================================
+
+static int get_desktop_video_mode(const char *device_name, modeline *current)
+{
+	memset(&desktop_devmode, 0, sizeof(DEVMODEA));
+	desktop_devmode.dmSize = sizeof(DEVMODEA);
+
+	if (EnumDisplaySettingsExA(!strcmp(device_name, "auto")?NULL:device_name, ENUM_CURRENT_SETTINGS, &desktop_devmode, 0))
+	{
+		if (current)
+		{
+			current->width = desktop_devmode.dmPelsWidth;
+			current->height = desktop_devmode.dmPelsHeight;
+			current->refresh = desktop_devmode.dmDisplayFrequency;
+			current->interlace = (desktop_devmode.dmDisplayFlags & DM_INTERLACED)?1:0;
+		}
+		return true;
+	}
+	return false;
+}
+
+//============================================================
+//  restore_desktop_video_mode
+//============================================================
+
+int restore_desktop_video_mode(win_window_info *window)
+{
+	if (ChangeDisplaySettingsExA(default_device_name, &desktop_devmode, NULL, CDS_TEST | CDS_UPDATEREGISTRY, 0) == DISP_CHANGE_SUCCESSFUL)
+		return true;
+
+	return false;
+}
+
+//============================================================
+//  prepare_mode_switch
+//============================================================
+
+int prepare_mode_switch(win_window_info *window, int *interlace_factor)
+{
+	running_machine &machine = window->machine();
+	modeline *best_mode = &machine.switchres.best_mode;
+	modeline *mode_to_check_interlace = backup_mode.hactive? &backup_mode : best_mode;
+	DEVMODEA lpDevMode;
+
+	get_desktop_video_mode(default_device_name, NULL);
+
+	if(interlace_factor)
+		*interlace_factor = win_interlace_factor(mode_to_check_interlace);
+
+	if (best_mode)
+	{
+		memset(&lpDevMode, 0, sizeof(DEVMODEA));
+		lpDevMode.dmSize = sizeof(DEVMODEA);
+		lpDevMode.dmPelsWidth = best_mode->width;
+		lpDevMode.dmPelsHeight = best_mode->height;
+		lpDevMode.dmDisplayFrequency = (int)best_mode->refresh / win_interlace_factor(mode_to_check_interlace);
+		lpDevMode.dmDisplayFlags = mode_to_check_interlace->interlace?DM_INTERLACED:0;
+		lpDevMode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_DISPLAYFREQUENCY | DM_DISPLAYFLAGS;
+
+		if (ChangeDisplaySettingsExA(default_device_name, &lpDevMode, NULL, CDS_TEST | CDS_UPDATEREGISTRY, 0) == DISP_CHANGE_SUCCESSFUL)
+			return true;
+	}
+
+	return false;
+}
+
+//============================================================
+//  get_available_video_modes
+//============================================================
+
+static int get_available_video_modes(const char *device_name, modeline mode[MAX_MODELINES], modeline *current, config_settings *cs)
+{
+	int iModeNum = 0, j = 0, k = 1;
+	DEVMODEA lpDevMode;
+
+	if (!strcmp(device_name, "auto"))
+		device_name = NULL;
+
+	memset(&lpDevMode, 0, sizeof(DEVMODEA));
+	lpDevMode.dmSize = sizeof(DEVMODEA);
+
+	osd_printf_verbose("Switchres: Searching for custom video modes...\n");
+
+	while (EnumDisplaySettingsExA(device_name, iModeNum, &lpDevMode, cs->lock_unsupported_modes?0:EDS_RAWMODE) != 0)
+	{
+		if (k == MAX_MODELINES)
+		{
+			osd_printf_verbose("SwitchRes: Warning, too many active modelines for storage %d\n", k);
+			break;
+		}
+		else if (lpDevMode.dmBitsPerPel == 32 && lpDevMode.dmDisplayOrientation == DMDO_DEFAULT && lpDevMode.dmDisplayFixedOutput == DMDFO_DEFAULT)
+		{
+			memset(&mode[k], 0, sizeof(struct modeline));
+			mode[k].interlace = (lpDevMode.dmDisplayFlags & DM_INTERLACED)?1:0;
+			mode[k].width = lpDevMode.dmPelsWidth;
+			mode[k].height = lpDevMode.dmPelsHeight;
+			mode[k].refresh = lpDevMode.dmDisplayFrequency * win_interlace_factor(&mode[k]);
+			mode[k].hactive = mode[k].width;
+			mode[k].vactive = mode[k].height;
+			mode[k].vfreq = mode[k].refresh;
+
+			if (current && mode[k].width == current->width && mode[k].height == current->height && mode[k].refresh / win_interlace_factor(&mode[k]) == current->refresh)
+				mode[k].type |= MODE_DESKTOP;
+
+			osd_printf_verbose("Switchres: [%3d] %4dx%4d @%3d%s: ", k, mode[k].width, mode[k].height, mode[k].refresh, mode[k].type & MODE_DESKTOP?"*":"");
+
+			if (get_custom_video_timing_ati(&mode[k]))
+			{
+				mode[k].type |= cs->modeline_generation?
+							(!(mode[k].type & MODE_DESKTOP)? V_FREQ_EDITABLE | (mode[k].width == DUMMY_WIDTH? X_RES_EDITABLE:0):0):0;
+				j++;
+			}
+			else if (powerstrip_found)
+			{
+				osd_printf_verbose("Powerstrip timing\n");
+				mode[k].type |= PSTRIP_TIMING | (cs->modeline_generation? V_FREQ_EDITABLE:0);
+			}
+			else
+			{
+				osd_printf_verbose("system mode\n");
+				mode[k].type |= SYSTEM_TIMING | (cs->lock_system_modes && !(mode[k].type & MODE_DESKTOP)? MODE_LOCKED:0);
+				if (mode[k].type & MODE_LOCKED) osd_printf_verbose("mode_locked\n");
+			}
+
+			if (cs->refresh_dont_care)
+				mode[k].type |= V_FREQ_EDITABLE;
+			k++;
+		}
+		iModeNum++;
+	}
+	k--;
+	osd_printf_verbose("SwitchRes: Found %d custom of %d active video modes\n", j, k);
+	return k;
+}
+
+//============================================================
+//  get_custom_video_timing_ati
+//============================================================
+
+static bool get_custom_video_timing_ati(modeline *mode)
+{
+	HKEY hKey;
+	char lp_name[1024];
+	char lp_data[68];
+	char lp_data2[32];
+	char modeline_txt[256]={'\x00'};
+	DWORD length;
+	bool found = false;
+	int vfreq_incr = 0;
+
+	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, default_device_key, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
+	{
+		sprintf (lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, mode->refresh);
+		length = sizeof(lp_data);
+
+		if (RegQueryValueExA(hKey, lp_name, NULL, NULL, (LPBYTE)lp_data, &length) == ERROR_SUCCESS && length == sizeof(lp_data))
+			found = true;
+		else if (win_version > 5 && mode->interlace)
+		{
+			vfreq_incr = 1;
+			sprintf(lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, mode->refresh + vfreq_incr);
+			if (RegQueryValueExA(hKey, lp_name, NULL, NULL, (LPBYTE)lp_data, &length) == ERROR_SUCCESS && length == sizeof(lp_data))
+				found = true;
+		}
+		if (found)
+		{
+			mode->type   |= ATI_REG_TIMING;
+			mode->pclock  = get_custom_mode_DWORD_BCD(36, lp_data) * 10000;
+			mode->hactive = get_custom_mode_DWORD_BCD(8, lp_data);
+			mode->hbegin  = get_custom_mode_DWORD_BCD(12, lp_data);
+			mode->hend    = get_custom_mode_DWORD_BCD(16, lp_data) + mode->hbegin;
+			mode->htotal  = get_custom_mode_DWORD_BCD(4, lp_data);
+			mode->vactive = get_custom_mode_DWORD_BCD(24, lp_data);
+			mode->vbegin  = get_custom_mode_DWORD_BCD(28, lp_data);
+			mode->vend    = get_custom_mode_DWORD_BCD(32, lp_data) + mode->vbegin;
+			mode->vtotal  = get_custom_mode_DWORD_BCD(20, lp_data);
+			mode->interlace = (get_custom_mode_DWORD(0, lp_data) == 0x0e)?1:0;
+			mode->hfreq = mode->pclock / mode->htotal;
+			mode->vfreq = mode->hfreq / mode->vtotal * (mode->interlace?2:1);
+
+			int checksum = 65535 - ((mode->interlace)?0x0e:0x0c) - mode->htotal - mode->hactive - mode->hend
+						- mode->vtotal - mode->vactive - mode->vend - mode->pclock/10000;
+			if (checksum != get_custom_mode_DWORD(64, lp_data))
+				osd_printf_verbose("bad checksum! ");
+
+			osd_printf_verbose("%s - Modeline %s\n", lp_name, modeline_print(mode, modeline_txt, MS_FULL));
+			sprintf (lp_name, "DALR6 CRT%dx%dx0x%d", mode->width, mode->height, mode->refresh + vfreq_incr);
+			length = sizeof(lp_data2);
+
+			if (RegQueryValueExA(hKey, lp_name, NULL, NULL, (LPBYTE)lp_data2, &length) == ERROR_SUCCESS && length == sizeof(lp_data2))
+			{
+				mode->hsync = lp_data2[20]?0:1;
+				mode->vsync = lp_data2[24]?0:1;
+			}
+		}
+		RegCloseKey(hKey);
+	}
+	else
+		osd_printf_info("SwitchRes: Failed opening %s registry entry\n", default_device_key);
+
+	return (found);
+}
+
+//============================================================
+//  set_custom_video_timing_ati
+//============================================================
+
+static bool set_custom_video_timing_ati(modeline *mode)
+{
+	HKEY hKey;
+	char lp_name[1024];
+	char lp_data[68];
+	char lp_data2[32];
+	char modeline_txt[256]={'\x00'};
+	DWORD length;
+	long checksum;
+	bool found = false;
+	int vfreq_incr = 0;
+
+	if (!mode->type & ATI_REG_TIMING)
+		return 0;
+
+	memset(lp_data, 0, sizeof(lp_data));
+	set_custom_mode_DWORD_BCD(lp_data, (int)mode->pclock/10000, 36);
+	set_custom_mode_DWORD_BCD(lp_data, mode->hactive, 8);
+	set_custom_mode_DWORD_BCD(lp_data, mode->hbegin, 12);
+	set_custom_mode_DWORD_BCD(lp_data, mode->hend - mode->hbegin, 16);
+	set_custom_mode_DWORD_BCD(lp_data, mode->htotal, 4);
+	set_custom_mode_DWORD_BCD(lp_data, mode->vactive, 24);
+	set_custom_mode_DWORD_BCD(lp_data, mode->vbegin, 28);
+	set_custom_mode_DWORD_BCD(lp_data, mode->vend - mode->vbegin, 32);
+	set_custom_mode_DWORD_BCD(lp_data, mode->vtotal, 20);
+	set_custom_mode_DWORD(lp_data, (mode->interlace)?0x0e:0x0c, 0);
+
+	checksum = 65535 - ((mode->interlace)?0x0e:0x0c) - mode->htotal - mode->hactive - mode->hend
+			- mode->vtotal - mode->vactive - mode->vend - mode->pclock/10000;
+	set_custom_mode_DWORD(lp_data, checksum, 64);
+
+	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, default_device_key, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
+	{
+		sprintf (lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, mode->refresh);
+
+		if (RegQueryValueExA(hKey, lp_name, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
+			found = true;
+		else if (win_version > 5 && mode->interlace)
+		{
+			vfreq_incr = 1;
+			sprintf(lp_name, "DALDTMCRTBCD%dx%dx0x%d", mode->width, mode->height, mode->refresh + vfreq_incr);
+			if (RegQueryValueExA(hKey, lp_name, NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
+				found = true;
+		}
+		if (found && RegSetValueExA(hKey, lp_name, 0, REG_BINARY, (LPBYTE)lp_data, 68) == ERROR_SUCCESS)
+		{
+			osd_printf_verbose("%s - Modeline %s\n", lp_name, modeline_print(mode, modeline_txt, MS_FULL));
+			sprintf (lp_name, "DALR6 CRT%dx%dx0x%d", mode->width, mode->height, mode->refresh + vfreq_incr);
+			length = sizeof(lp_data2);
+
+			if (RegQueryValueExA(hKey, lp_name, NULL, NULL, (LPBYTE)lp_data2, &length) == ERROR_SUCCESS && length == sizeof(lp_data2))
+			{
+				lp_data2[20] = mode->hsync?0:1;
+				lp_data2[24] = mode->vsync?0:1;
+				if (RegSetValueExA(hKey, lp_name, 0, REG_BINARY, (LPBYTE)lp_data2, 32) != ERROR_SUCCESS)
+					osd_printf_verbose("Switchres: Failed saving registry entry for polarity information\n");
+			}
+		}
+		else
+			osd_printf_info("SwitchRes: Failed saving registry entry for %s modeline\n", lp_name);
+
+		RegCloseKey(hKey);
+	}
+	else
+		osd_printf_info("SwitchRes: Failed updating %s registry entry\n", default_device_key);
+
+	return 0;
+}
+
+//============================================================
+//  update_custom_video_timing_ati
+//============================================================
+
+static bool update_custom_video_timing_ati(modeline *mode)
+{
+	// Restore old video timing
+	if (backup_mode.hactive)
+	{
+		osd_printf_verbose("Switchres: restoring ");
+		set_custom_video_timing_ati(&backup_mode);
+	}
+
+	// Update with new video timing
+	if (mode)
+	{
+		backup_mode.width = mode->width;
+		backup_mode.height = mode->height;
+		backup_mode.refresh = mode->refresh;
+		backup_mode.interlace = mode->interlace;
+		osd_printf_verbose("Switchres: saving    ");
+		get_custom_video_timing_ati(&backup_mode);
+		osd_printf_verbose("Switchres: updating  ");
+		set_custom_video_timing_ati(mode);
+	}
+	reset_video_modes();
+	return 0;
+}
+
+//============================================================
+//  get_device_name_and_key
+//============================================================
+
+static int get_device_name_and_key(const char *screen_option, char *device_name, char *DeviceKey)
+{
+	DISPLAY_DEVICEA lpDisplayDevice[DISPLAY_MAX];
+	int idev = 0;
+	int found = -1;
+
+	while (idev < DISPLAY_MAX)
+	{
+		memset(&lpDisplayDevice[idev], 0, sizeof(DISPLAY_DEVICEA));
+		lpDisplayDevice[idev].cb = sizeof(DISPLAY_DEVICEA);
+
+		if (EnumDisplayDevicesA(NULL, idev, &lpDisplayDevice[idev], 0) == FALSE)
+			break;
+
+		if ((!strcmp(screen_option, "auto") && (lpDisplayDevice[idev].StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE))
+			|| !strcmp(screen_option, lpDisplayDevice[idev].DeviceName))
+			found = idev;
+
+		idev++;
+	}
+	if (found != -1)
+	{
+		strncpy(device_name, lpDisplayDevice[found].DeviceName, sizeof(default_device_name));
+		osd_printf_verbose("SwitchRes: %s: %s\n", device_name, lpDisplayDevice[found].DeviceString);
+
+		char *pch;
+		int i;
+		for (i = 0; i < idev; i++)
+		{
+			pch = strstr(lpDisplayDevice[i].DeviceString, lpDisplayDevice[found].DeviceString);
+			if (pch)
+			{
+				found = i;
+				break;
+			}
+		}
+
+		char *chsrc, *chdst;
+		chdst = DeviceKey;
+
+		for (chsrc = lpDisplayDevice[i].DeviceKey + 18; *chsrc != 0; chsrc++)
+			*chdst++ = *chsrc;
+
+		*chdst = 0;
+	}
+	else
+	{
+		osd_printf_verbose("SwitchRes: Failed obtaining default video registry key\n");
+		return -1;
+	}
+
+	osd_printf_verbose("SwitchRes: DeviceKey: %s\n", DeviceKey);
+	return 0;
+}
+
+
+//============================================================
+// get_custom_mode_DWORD
+//============================================================
+
+static int get_custom_mode_DWORD(int i, char *lp_data)
+{
+	char out[32] = "";
+	UINT32 x;
+
+	sprintf(out, "%02X%02X%02X%02X", lp_data[i]&0xFF, lp_data[i+1]&0xFF, lp_data[i+2]&0xFF, lp_data[i+3]&0xFF);
+	sscanf(out, "%08X", &x);
+	return x;
+}
+
+//============================================================
+// get_custom_mode_DWORD_BCD
+//============================================================
+
+static int get_custom_mode_DWORD_BCD(int i, char *lp_data)
+{
+	char out[32] = "";
+	UINT32 x;
+
+	sprintf(out, "%02X%02X%02X%02X", lp_data[i]&0xFF, lp_data[i+1]&0xFF, lp_data[i+2]&0xFF, lp_data[i+3]&0xFF);
+	sscanf(out, "%d", &x);
+	return x;
+}
+
+//============================================================
+// set_custom_mode_DWORD
+//============================================================
+
+static void set_custom_mode_DWORD (char *data_string, UINT32 data_dword, int offset)
+{
+	char *p_dword = (char*)&data_dword;
+
+	data_string[offset]   = p_dword[3]&0xFF;
+	data_string[offset+1] = p_dword[2]&0xFF;
+	data_string[offset+2] = p_dword[1]&0xFF;
+	data_string[offset+3] = p_dword[0]&0xFF;
+}
+
+//============================================================
+// set_custom_mode_DWORD_BCD
+//============================================================
+
+static void set_custom_mode_DWORD_BCD (char *data_string, UINT32 data_dword, int offset)
+{
+	if (data_dword < 100000000)
+	{
+		int low_word, high_word;
+		int a, b, c, d;
+		char out[32] = "";
+
+		low_word = data_dword % 10000;
+		high_word = data_dword / 10000;
+
+		sprintf(out, "%d %d %d %d", high_word / 100, high_word % 100 , low_word / 100, low_word % 100);
+		sscanf(out, "%02X %02X %02X %02X", &a, &b, &c, &d);
+
+		data_string[offset]   = a;
+		data_string[offset+1] = b;
+		data_string[offset+2] = c;
+		data_string[offset+3] = d;
+	}
+}
+
+//============================================================
+// set_option_osd - option setting wrapper
+//============================================================
+
+static void set_option_osd(running_machine &machine, const char *option_ID, bool state)
+{
+	windows_options &options = downcast<windows_options &>(machine.options());
+	astring error_string;
+
+	options.set_value(option_ID, state, OPTION_PRIORITY_SWITCHRES, error_string);
+	osd_printf_verbose("SwitchRes: Setting option -%s%s\n", machine.options().bool_value(option_ID)?"":"no", option_ID);
+}
+
+static void set_option_int_osd(running_machine &machine, const char *option_ID, int value)
+{
+	windows_options &options = downcast<windows_options &>(machine.options());
+	astring error_string;
+
+	options.set_value(option_ID, value, OPTION_PRIORITY_SWITCHRES, error_string);
+	osd_printf_verbose("SwitchRes: Setting option -%s %d\n", option_ID, machine.options().int_value(option_ID));
+}
+
+static void set_option_str_osd(running_machine &machine, const char *option_ID, const char *value)
+{
+	windows_options &options = downcast<windows_options &>(machine.options());
+	astring error_string;
+
+	options.set_value(option_ID, value, OPTION_PRIORITY_SWITCHRES, error_string);
+	osd_printf_verbose("SwitchRes: Setting option -%s %s\n", option_ID, machine.options().value(option_ID));
+}
+
+//============================================================
+// os_version
+//============================================================
+
+static int os_version(void)
+{
+	OSVERSIONINFOA lpVersionInfo;
+
+	memset(&lpVersionInfo, 0, sizeof(OSVERSIONINFOA));
+	lpVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
+	GetVersionExA (&lpVersionInfo);
+
+	return lpVersionInfo.dwMajorVersion;
+}
+
+//============================================================
+// win_interlace_factor
+//============================================================
+
+int win_interlace_factor(modeline *mode)
+{
+	if (win_version > 5 && mode->interlace)
+		return 2;
+
+	return 1;
+}
+
+static int copy_to_clipboard(char *txt)
+{
+	HGLOBAL hglb;
+	hglb = GlobalAlloc(GMEM_MOVEABLE, 256);
+	memcpy(GlobalLock(hglb), txt, strlen(txt) + 1);
+	GlobalUnlock(hglb);
+	OpenClipboard(NULL);
+	EmptyClipboard();
+	SetClipboardData(CF_TEXT, hglb);
+	CloseClipboard();
+	return 1;
+}
diff -Nru ./src_0.154_hi/osd/windows/video.c ./src/osd/windows/video.c
--- ./src_0.154_hi/osd/windows/video.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/windows/video.c	2014-07-29 10:29:57.000000000 +0200
@@ -56,7 +56,6 @@
 
 static void check_osd_inputs(running_machine &machine);
 
-static void extract_video_config(running_machine &machine);
 static float get_aspect(const char *defdata, const char *data, int report_error);
 static void get_resolution(const char *defdata, const char *data, win_window_config *config, int report_error);
 
@@ -175,10 +174,6 @@
 		for (win_window_info *window = win_window_list; window != NULL; window = window->next)
 			winwindow_video_window_update(window);
 
-	// poll the joystick values here
-	winwindow_process_events(machine(), TRUE, FALSE);
-	wininput_poll(machine());
-	check_osd_inputs(machine());
 	// if we're running, disable some parts of the debugger
 	if ((machine().debug_flags & DEBUG_FLAG_OSD_ENABLED) != 0)
 		debugger_update();
@@ -209,6 +204,20 @@
 
 
 //============================================================
+//  poll_input
+//============================================================
+
+void windows_osd_interface::poll_input(void)
+{
+	// poll the joystick values here
+	winwindow_process_events(machine(), TRUE, FALSE);
+	wininput_poll(machine());
+	check_osd_inputs(machine());
+}
+
+
+
+//============================================================
 //  init_monitors
 //============================================================
 
@@ -366,7 +375,7 @@
 //  extract_video_config
 //============================================================
 
-static void extract_video_config(running_machine &machine)
+void extract_video_config(running_machine &machine)
 {
 	windows_options &options = downcast<windows_options &>(machine.options());
 	const char *stemp;
@@ -410,7 +419,7 @@
 		video_config.mode = VIDEO_MODE_GDI;
 	}
 	video_config.waitvsync     = options.wait_vsync();
-	video_config.syncrefresh   = options.sync_refresh();
+	video_config.syncrefresh   = machine.options().sync_refresh();
 	video_config.triplebuf     = options.triple_buffer();
 	video_config.switchres     = options.switch_res();
 
diff -Nru ./src_0.154_hi/osd/windows/video.h ./src/osd/windows/video.h
--- ./src_0.154_hi/osd/windows/video.h	2014-04-26 15:35:06.000000000 +0200
+++ ./src/osd/windows/video.h	2014-07-29 10:29:57.000000000 +0200
@@ -89,6 +89,7 @@
 //  PROTOTYPES
 //============================================================
 
+void extract_video_config(running_machine &machine);
 void winvideo_monitor_refresh(win_monitor_info *monitor);
 float winvideo_monitor_get_aspect(win_monitor_info *monitor);
 win_monitor_info *winvideo_monitor_from_handle(HMONITOR monitor);
diff -Nru ./src_0.154_hi/osd/windows/window.c ./src/osd/windows/window.c
--- ./src_0.154_hi/osd/windows/window.c	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/windows/window.c	2014-07-29 10:29:57.000000000 +0200
@@ -39,7 +39,7 @@
 extern int drawgdi_init(running_machine &machine, win_draw_callbacks *callbacks);
 extern int drawdd_init(running_machine &machine, win_draw_callbacks *callbacks);
 extern int drawd3d_init(running_machine &machine, win_draw_callbacks *callbacks);
-
+extern bool switchres_resolution_change(win_window_info *window);
 
 //============================================================
 //  PARAMETERS
@@ -69,6 +69,7 @@
 #define WM_USER_SET_MINSIZE             (WM_USER + 5)
 #define WM_USER_UI_TEMP_PAUSE           (WM_USER + 6)
 #define WM_USER_EXEC_FUNC               (WM_USER + 7)
+#define WM_USER_CHANGERES               (WM_USER + 8)
 
 
 
@@ -110,7 +111,12 @@
 
 static HANDLE ui_pause_event;
 static HANDLE window_thread_ready_event;
-
+static HANDLE blit_pending;
+static HANDLE blit_done;
+static DWORD blit_threadid;
+static int blitting_active;
+static BOOL blit_lock;
+static BOOL blit_unlock;
 
 
 //============================================================
@@ -135,7 +141,7 @@
 
 static void adjust_window_position_after_major_change(win_window_info *window);
 static void set_fullscreen(win_window_info *window, int fullscreen);
-
+static DWORD WINAPI blit_loop(LPVOID lpParameter);
 
 // temporary hacks
 #if LOG_THREADS
@@ -273,6 +279,18 @@
 	// kill the drawers
 	(*draw.exit)();
 
+	// end blitting thread
+	if (multithreading_enabled)
+	{
+		blitting_active = FALSE;
+		WaitForSingleObject(blit_done, 100);
+		if (blit_done)
+			CloseHandle (blit_done);
+		if (blit_pending)
+			CloseHandle (blit_pending);
+		osd_printf_verbose("Blitting thread destroyed\n");
+	}
+
 	// if we're multithreaded, clean up the window thread
 	if (multithreading_enabled)
 	{
@@ -680,6 +698,25 @@
 	// set the initial maximized state
 	window->startmaximized = options.maximize();
 
+	// only link window #0 to SwitchRes
+	if (index == 0)
+	{
+		window->switchres_mode = &machine.switchres.best_mode;
+		// create blitting thread
+		if (multithreading_enabled)
+		{
+			osd_printf_verbose("Blitting thread created\n");
+			blitting_active = TRUE;
+			blit_lock = TRUE;
+			osd_printf_verbose("winwindow_video_window_create: blit_lock = TRUE\n");
+			blit_pending = CreateEvent(NULL, FALSE, FALSE, NULL);
+			blit_done = CreateEvent(NULL, FALSE, FALSE, NULL);
+			CreateThread (NULL, 0, blit_loop, (LPVOID)window, 0, &blit_threadid);
+		}
+	}
+	else
+		window->switchres_mode = 0;
+
 	// finish the window creation on the window thread
 	if (multithreading_enabled)
 	{
@@ -736,7 +773,67 @@
 	global_free(window);
 }
 
+//============================================================
+//  blit_loop
+//  (blitting thread)
+//============================================================
+
+static DWORD WINAPI blit_loop(LPVOID lpParameter)
+{
+	win_window_info *window = (win_window_info *)lpParameter;
+	bool m_throttled;
+
+	osd_printf_verbose("Blitting thread started\n");
+
+	do {
+		WaitForSingleObject(blit_pending, INFINITE);
+		m_throttled = window->machine().video().throttled();
+		if (!blit_lock) draw_video_contents(window, NULL, FALSE);
+		if (m_throttled) SetEvent(blit_done);
+
+	} while (blitting_active);
+
+	osd_printf_verbose("Blitting thread ended\n");
+
+	return -1;
+
+}
+
+//============================================================
+//  blit_lock_set
+//  (window thread)
+//============================================================
+
+void blit_lock_set ()
+{
+	blit_lock = TRUE;
+	osd_printf_verbose("blit_lock = TRUE\n");
+	Sleep(20);
+}
+
+//============================================================
+//  blit_lock_reset
+//  (window thread)
+//============================================================
+
+void blit_lock_reset ()
+{
+	blit_unlock = TRUE;
+	osd_printf_verbose("blit_unlock = TRUE\n");
+}
+
+//============================================================
+//  blit_lock_release
+//  (window thread)
+//============================================================
 
+void blit_lock_release ()
+{
+	Sleep(20);
+	blit_unlock = FALSE;
+	blit_lock = FALSE;
+	osd_printf_verbose("blit_lock = FALSE\n");
+}
 
 //============================================================
 //  winwindow_video_window_update
@@ -773,17 +870,13 @@
 	}
 
 	// if we're visible and running and not in the middle of a resize, draw
-	if (window->hwnd != NULL && window->target != NULL && window->drawdata != NULL)
+	if ((!multithreading_enabled || !blit_lock) && window->hwnd != NULL && window->target != NULL && window->drawdata != NULL)
 	{
 		int got_lock = TRUE;
 
 		mtlog_add("winwindow_video_window_update: try lock");
 
-		// only block if we're throttled
-		if (window->machine().video().throttled() || timeGetTime() - last_update_time > 250)
-			osd_lock_acquire(window->render_lock);
-		else
-			got_lock = osd_lock_try(window->render_lock);
+		got_lock = osd_lock_try(window->render_lock);
 
 		// only render if we were able to get the lock
 		if (got_lock)
@@ -795,14 +888,27 @@
 			// don't hold the lock; we just used it to see if rendering was still happening
 			osd_lock_release(window->render_lock);
 
+			// check resolution change
+			if (window->switchres_mode && video_config.switchres && window->machine().options().changeres() && window->machine().switchres.game.changeres)
+			{
+				switchres_resolution_change(window);
+				return;
+			}
+
 			// ensure the target bounds are up-to-date, and then get the primitives
 			primlist = (*draw.window_get_primitives)(window);
 
 			// post a redraw request with the primitive list as a parameter
 			last_update_time = timeGetTime();
 			mtlog_add("winwindow_video_window_update: PostMessage start");
-			if (multithreading_enabled)
-				PostMessage(window->hwnd, WM_USER_REDRAW, 0, (LPARAM)primlist);
+			if (window->switchres_mode && multithreading_enabled && video_config.mode != VIDEO_MODE_GDI)
+			{
+				window->primlist = primlist;
+				SetEvent(blit_pending);
+
+				if ((video_config.waitvsync && window->machine().video().throttled()))
+					WaitForSingleObject(blit_done, 1000);
+			}
 			else
 				SendMessage(window->hwnd, WM_USER_REDRAW, 0, (LPARAM)primlist);
 			mtlog_add("winwindow_video_window_update: PostMessage end");
@@ -1283,6 +1389,7 @@
 		// finish off by trying to initialize DirectX; if we fail, ignore it
 		if ((*draw.window_init)(window))
 			return 1;
+			else blit_lock_reset();
 		ShowWindow(window->hwnd, SW_SHOW);
 	}
 
@@ -1319,12 +1426,15 @@
 		// paint: redraw the last bitmap
 		case WM_PAINT:
 		{
+			osd_printf_verbose("window_proc: WM_PAINT\n");
 			PAINTSTRUCT pstruct;
 			HDC hdc = BeginPaint(wnd, &pstruct);
 			draw_video_contents(window, hdc, TRUE);
 			if (win_has_menu(window))
 				DrawMenuBar(window->hwnd);
 			EndPaint(wnd, &pstruct);
+			if (blit_unlock) blit_lock_release();
+			osd_printf_verbose("window_proc: WM_PAINT:END\n");
 			break;
 		}
 
@@ -1421,6 +1531,7 @@
 		case WM_SYSCOMMAND:
 		{
 			UINT16 cmd = wparam & 0xfff0;
+			osd_printf_verbose("window_proc: WM_SYSCOMMAND %d\n", (UINT32)cmd);
 
 			// prevent screensaver or monitor power events
 			if (cmd == SC_MONITORPOWER || cmd == SC_SCREENSAVE)
@@ -1439,6 +1550,9 @@
 					maximize_window(window);
 				break;
 			}
+			else if (cmd == SC_MINIMIZE) blit_lock_set();
+			else if (cmd == SC_RESTORE) blit_lock_reset();
+
 			return DefWindowProc(wnd, message, wparam, lparam);
 		}
 
@@ -1457,6 +1571,8 @@
 
 		// destroy: clean up all attached rendering bits and NULL out our hwnd
 		case WM_DESTROY:
+			osd_printf_verbose("window_proc: WM_DESTROY\n");
+			blit_lock_set();
 			(*draw.window_destroy)(window);
 			window->hwnd = NULL;
 			return DefWindowProc(wnd, message, wparam, lparam);
@@ -1482,7 +1598,18 @@
 
 		// fullscreen set
 		case WM_USER_SET_FULLSCREEN:
+			osd_printf_verbose("window_proc: WM_USER_SET_FULLSCREEN\n");
+			blit_lock_set();
 			set_fullscreen(window, wparam);
+			osd_printf_verbose("window_proc: WM_USER_SET_FULLSCREEN_END\n");
+			break;
+
+		// Resolution change
+		case WM_USER_CHANGERES:
+			osd_printf_verbose("window_proc: WM_USER_CHANGERES\n");
+			blit_lock_set();
+			(*draw.window_destroy)(window);
+			if (!(*draw.window_init)(window)) blit_lock_reset();
 			break;
 
 		// minimum size set
@@ -1495,6 +1622,11 @@
 			maximize_window(window);
 			break;
 
+		case WM_NCACTIVATE:
+			osd_printf_verbose("window_proc: WM_NCACTIVATE\n");
+			if (window->fullscreen && !blit_lock && !IsIconic(window->hwnd)) blit_lock_set();
+			return DefWindowProc(wnd, message, wparam, lparam);
+
 		// set focus: if we're not the primary window, switch back
 		// commented out ATM because this prevents us from resizing secondary windows
 //      case WM_SETFOCUS:
@@ -1969,6 +2101,7 @@
 			ShowWindow(window->hwnd, SW_SHOW);
 		if ((*draw.window_init)(window))
 			exit(1);
+			else blit_lock_reset();
 	}
 
 	// ensure we're still adjusted correctly
diff -Nru ./src_0.154_hi/osd/windows/window.h ./src/osd/windows/window.h
--- ./src_0.154_hi/osd/windows/window.h	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/windows/window.h	2014-07-29 10:29:57.000000000 +0200
@@ -77,6 +77,9 @@
 	// drawing data
 	void *              drawdata;
 
+	// SwitchRes mode
+ 	modeline *			switchres_mode;
+ 
 private:
 	running_machine &   m_machine;
 };
diff -Nru ./src_0.154_hi/osd/windows/windows.mak ./src/osd/windows/windows.mak
--- ./src_0.154_hi/osd/windows/windows.mak	2014-05-08 09:39:04.000000000 +0200
+++ ./src/osd/windows/windows.mak	2014-07-29 10:29:57.000000000 +0200
@@ -359,7 +359,9 @@
 	$(WINOBJ)/video.o \
 	$(WINOBJ)/window.o \
 	$(WINOBJ)/winmenu.o \
-	$(WINOBJ)/winmain.o
+	$(WINOBJ)/winmain.o \
+	$(WINOBJ)/switchres.o \
+	$(WINOBJ)/pstrip.o
 
 ifdef USE_SDL
 OSDOBJS += \
diff -Nru ./src_0.154_hi/osd/windows/winmain.c ./src/osd/windows/winmain.c
--- ./src_0.154_hi/osd/windows/winmain.c	2014-07-22 08:14:55.000000000 +0200
+++ ./src/osd/windows/winmain.c	2014-07-29 10:29:57.000000000 +0200
@@ -51,6 +51,8 @@
 #endif
 #define DEBUG_SLOW_LOCKS    0
 
+extern bool switchres_modeline_setup(running_machine &machine);
+extern bool switchres_modeline_remove(running_machine &machine);
 
 //**************************************************************************
 //  MACROS
@@ -278,11 +280,11 @@
 
 	// DirectDraw-specific options
 	{ NULL,                                           NULL,       OPTION_HEADER,     "DIRECTDRAW-SPECIFIC OPTIONS" },
-	{ WINOPTION_HWSTRETCH ";hws",                     "1",        OPTION_BOOLEAN,    "enable hardware stretching" },
+	{ WINOPTION_HWSTRETCH ";hws",                     "0",        OPTION_BOOLEAN,    "enable hardware stretching" },
 
 	// Direct3D-specific options
 	{ NULL,                                           NULL,       OPTION_HEADER,     "DIRECT3D-SPECIFIC OPTIONS" },
-	{ WINOPTION_FILTER ";d3dfilter;flt",              "1",        OPTION_BOOLEAN,    "enable bilinear filtering on screen output" },
+	{ WINOPTION_FILTER ";d3dfilter;flt",              "0",        OPTION_BOOLEAN,    "enable bilinear filtering on screen output" },
 
 	// post-processing options
 	{ NULL,                                                     NULL,        OPTION_HEADER,     "DIRECT3D POST-PROCESSING OPTIONS" },
@@ -579,6 +581,9 @@
 	const char *stemp;
 	windows_options &options = downcast<windows_options &>(machine.options());
 
+	// Switchres
+	switchres_modeline_setup(machine);
+
 	// determine if we are benchmarking, and adjust options appropriately
 	int bench = options.bench();
 	astring error_string;
@@ -676,6 +681,9 @@
 
 void windows_osd_interface::osd_exit()
 {
+	// Remove Switchres
+	switchres_modeline_remove(machine());
+
 	// no longer have a machine
 	g_current_machine = NULL;
 
diff -Nru ./src_0.154_hi/osd/windows/winmain.h ./src/osd/windows/winmain.h
--- ./src_0.154_hi/osd/windows/winmain.h	2014-07-29 10:29:17.000000000 +0200
+++ ./src/osd/windows/winmain.h	2014-07-29 10:29:57.000000000 +0200
@@ -244,6 +244,7 @@
 	// general overridables
 	virtual void init(running_machine &machine);
 	virtual void update(bool skip_redraw);
+	virtual void poll_input(void);
 
 	// video overridables
 	virtual void *get_slider_list();
