#!/bin/bash

#                         _                _                	 
#      ___ _____      __ | |__   __ _  ___| | ___   _ _ __  	 
#     / __/ _ \ \ /\ / / | '_ \ / _` |/ __| |/ / | | | '_ \ 	 
#    | (_| (_) \ V  V /  | |_) | (_| | (__|   <| |_| | |_) |	 
#     \___\___/ \_/\_/___|_.__/ \__,_|\___|_|\_\\__,_| .__/ 	 
#                   |_____|                          |_|  	 
#								 		        
#                        cow_backup-2.1.8
#
#  create and restore gzip-compressed and gpg-encrypted full
#  backups of partitions and directories using tar and gpg
#
#  Copyright (C) 2012 edloaa <edloaa at googlemail dot com>
#  License GPL-3 <http://www.gnu.org/licenses/gpl-3.0.txt>

version="cow_backup-2.1.8"	# cow_backup version

cowdate=$(date +"%Y-%m-%d")	# YYYY-mm-dd

logfn="cb-errors-$cowdate.log"	# log file name

# colors used for dialogues and messages

c0=$(echo -e '\e[1;33m')	# yellow   => cow_say and warnings
c1=$(echo -e '\e[1;32m')	# green    => dialogs and messages
c2=$(echo -e '\e[1;31m')	# red      => errors
c3=$(echo -e '\e[1;34m')	# blue     => user input
c4=$(echo -e '\033[0m')		# no color => shouldn't be changed!

usage() {
	echo "$c1$version: backups and recoveries with tar and gpg$c4"
	echo
	echo "$c1 usage $c0[interactive]:$c3 '$0' (start without parameters)$c4"
	echo
	echo "$c1 usage $c0[non-interactive]:$c3 '$0 <src> <dest> <pwd>'$c4"
	echo
	echo "$c1 - src:   partition or an absolute path you want to backup$c4"
	echo "$c1 - dest:  /absolute/path/to/your/destination-folder$c4"
	echo "$c1 - pwd:   you can specify a password for encryption here$c4"
	echo
	echo " $c3-> example: ./cow_backup /dev/sda3 /media/backups 'MyPa55w0rd'$c4"
	echo
	echo " ${c0}note: backups can only be restored in interactive mode$c4"
	echo
	exit 0
}

function cow_say() {
	char=$(echo "$@" | wc -m)

	t_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "_" ; done)
	b_l=$(for ((x = 0 ; x <= $char ; x++)) ; do echo -n "-" ; done)

	echo "  $t_l"
	echo " < $c0"$@"$c4 >"
	echo "  $b_l"
	echo '         \   ^__^				'
	echo '          \  (oo)\_______			'
	echo '             (__)\       )\/\		'
	echo '                 ||----w |		'
	echo '                 ||     ||		'
	echo
}

function heading() {
	char=$(echo -n "$*" | wc -m)

	echo $c0"$*"$c4
	echo $c0$(for ((x = 1 ; x <= $char ; x++)) ; do echo -n "=" ; done)$c4
}

# error messages; variables for messages m1 - m3, because they are used more than once

m1="failed to mount the partition to /mnt."
m2="errors might have occurred."
m3="unable to unmount the partition, please unmount manually."

function cowerr() {
	# $1 => "$Mx"         -> error message
	# $2 => "true/ false" -> if true: echo "OK" or "FAILED" 
	# $3 => "true/ false" -> if true: exit
	# $4 => "true/ false" -> if true: proceed? (y/n)

	# program exits without any errors

	if [ $? -eq 0 ]; then

		if [ $2 = true ]; then
			echo "${c1}ok$c4"
			echo
		fi

	# program exits with errors

	elif [ $? -gt 0 ]; then

		if [ $2 = true ]; then
			echo "${c2}failed$c4"
			echo
		fi

	echo "$c2$1$c4"
	echo

	echo "${c2}check $log for error messages.$c4"

		if [ $3 = true ]; then
			cow_say 'unable to proceed. aborting!'
			exit 1
		fi

		if [ $4 = true ]; then
			echo
			echo -n "${c0}proceed anyway? (y/n) $c3"
			read ans
			echo $c4

			case $ans in
			y)
				echo "${c1}proceeding...$c4"
				;;
			*)
				cow_say 'aborting!'
				exit 1
				;;
			esac

		fi

	echo

	fi
}

function password() {
	pwd1=a
	pwd2=b

	y=0

	while [ "$pwd1" != "$pwd2" ] || [ -z "$pwd1" ]; do

		if [ $y -gt 0 ]; then
			if [ "$pwd1" != "$pwd2" ]; then
				echo "${c2}the passwords differ. please try again.$c4"
				echo
			elif [ -z "$pwd1" ]; then
				echo "${c2}the password must not be empty. please try again.$c4"
				echo
			fi
		fi

		echo -n "${c1}please enter a password for $1: $c4"
		read -s 'pwd1'
		echo
		echo
		echo -n "${c1}repeat the password: $c4"
		read -s 'pwd2'
		echo
		echo

		((y++))

	done
}

function gpgquest() {
	filecheck() {
		if [ -f $backup ]; then
			echo "$c0$backup does already exsist. please rename this file or choose an other path.$c4"
			cow_say 'aborting!'
			exit 0
		fi
	}
	srcname=$(basename $src)

	# GPG encryption dialogue

	echo -n "${c1}would you like to encrypt your backup files with GPG? (y/n) $c3"
	read GPG
	echo $c4
			   
	case $GPG in
	y|Y|yes|Yes|"")
		GPG="y"
		backup=$(echo $dest/backup_${srcname}_$cowdate.tgz.gpg | sed "s!//!/!g")
		filecheck
		password "encryption"
		;;

	*)
		GPG="n"
		backup=$(echo $dest/backup_${srcname}_$cowdate.tgz | sed "s!//!/!g")
		filecheck
		echo "${c0}backup file will not be encrypted with GPG.$c4"
		echo
		;;
	esac
}

function summary() {
	bline="$c1$(for ((x = 0 ; x <= 70 ; x++)) ; do echo -n "-" ; done)$c4"

	echo
	echo $bline
	echo
	heading "[   summary   ]"
	echo
	echo "${c1}task started:  $c0$sdate$c4"
	echo "${c1}task finished: $c0$(date +%Y-%m-%d_%T)$c4"
	echo

	if [ -n "$ERR" ]; then
		echo "$ERR"
		echo
	fi

	if [ $fileinf = true ] && [ -f "$backup" ]; then
		echo "${c1}archive file information:$c4"
		echo
		cd $(dirname $backup)
		echo "$c0$(ls -lh $(basename $backup))$c4"
		cd /
		echo
	fi

	echo $bline
	echo
}

shopt -s expand_aliases

alias pstart='read -p "${c1}press enter start the $task...$c4"'
alias bakinf='echo "$c1$src will be backuped to $backup$c4"'
alias recinf='echo "$c1$dest will be recovered to $src.$c4"'

#------------------------- SCRIPT START -------------------------#

case $1 in
-h|--help)
	usage
	;;
esac

# interactive mode

if [ -z "$*" ]; then

	# check for root privileges

	if [ $UID != 0 ]; then
		clear
		cow_say "please run script as root."
		exit 1
	fi

	clear
	echo -n $c4
	cow_say $version

	# infinite loop; script always returns to main menu

	while true; do

		# main menu

		heading "[ cow_backup - $cowdate ]"
		echo "# -> partition backup   (1)"
		echo "# -> partition recovery (2)"
		echo "# -> dir backup         (3)"
		echo "# -> dir recovery       (4)"
		echo "# -> exit               (5)"
		echo
		echo -n "${c1}please enter an option: $c3"
		read opt
		echo $c4

		# some specific variables depending on the chosen option

		if [ "$opt" = "1" ] || [ "$opt" = "3" ]; then
			a_cow="backuped"
			green_cow="backup directory (absolute path)"
			task="backup"
			fileinf=true

		elif [ "$opt" = "2" ] || [ "$opt" = "4" ]; then
			a_cow="recovered"
			green_cow="archive file (/Path/to/backup.tgz.[gpg])"
			task="recovery"
			fileinf=false
		fi

		# ===> option 1 and 2 ===>

		if [ "$opt" = "1" ] || [ "$opt" = "2" ]; then

			clear
			heading "[ cow_backup - $cowdate ]"
			echo
			heading "[  available partitions   ]"

			if [ $(type fdisk >/dev/null 2>&1; echo $?) -eq "0" ]; then
				fdisk -l
			else
				echo
				for block_dev in $(ls -lR /dev/ | grep ^b | awk '{print $NF}'); do 
					echo " /dev/$block_dev"
				done
			fi

			echo
			echo -n "${c1}specify the partition that shall be $a_cow (e.g. /dev/sda3): $c3"
			read -e src
			echo $c4

			# check if partition exists

			while [ ! -b "$src" ]; do
				echo -n "${c2}\"$src\" is no valid partition. please choose an existing partition: $c3"
				read -e src
				echo $c4
			done

			echo -n "${c1}specify the $green_cow: $c3"
			read -e dest
			echo $c4

			# check if $green_cow exists

			# ===> option 1 ===>

			if [ "$opt" = "1" ]; then

				# check if dir exists and if it is an absolute path

				until [ -d "$dest" ] && [ $(echo $dest | grep "^/" &>/dev/null ; echo $?) -eq "0" ]; do
					echo -n "$c2\"$dest\" is not a valid absolute path. please choose an other path: $c3"
					read -e dest
					echo $c4
				done

			gpgquest

			# ===> option 2 ===>

			elif [ "$opt" = "2" ]; then

				# check if file exists and is a gzip compressed archive (and gpg encrypted)

				until [ -f "$dest" ] && [ $(file $dest | grep -e "gzip" -e "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; do
					echo -n "$c2\"$dest\" is not a valid archive file. please choose an other file: $c3"
					read -e dest
					echo $c4
				done

			fi

			# variable for log file

			if [ -f "$dest" ]; then
				log=$(dirname $dest)/$logfn
			else
				log=$(echo $dest | sed 's/\/$//')/$logfn
			fi

			# check if partition is mounted

			if [ $(mount | grep "$src" &>/dev/null ; echo $?) -eq "0" ]; then
				echo "$c2$src is already mounted...$c4"
				echo
				echo -n "${c0}trying to proceed anyway? (y/n) $c3"
				read ans
				echo -n $c4

				case $ans in
				y)
					echo
					umount $src

					if [ $? -gt "0" ]; then
						cow_say "unable to proceed. aborting."
						echo "${c2}please unmount $src manually and try again.$c4"
						echo
						exit 1
					fi
					;;

				*)
					cow_say 'aborting!'
					exit 1
					;;
				esac
			fi

			# check if /mnt is used as mkount point

			if [ $(mount | grep "/mnt" &>/dev/null ; echo $?) -eq "0" ]; then
				echo "${c2}/mnt is already used as mount point...$c4"
				echo
				echo -n "$c1=> trying to proceed anyway? (y/n) $c3"
				read ans
				echo -n $c4

				case $ans in
				y|yes)
					echo
					umount /mnt

					if [ $? -gt "0" ]; then
						cow_say "unable to proceed. aborting."
						echo "${c2}please unmount $(mount | grep "/mnt" | awk '{print $1}') manually and try again.$c4"
						echo
						exit 1
					fi

					;;
				*)
					cow_say 'aborting!'
					exit 1
					;;
				esac
			fi

			# MD5 hash will be checked (if *.md5-file exists)

			if [ "$opt" = "2" ]; then

				if [ -e $dest.md5 ]; then
					cd $(dirname $dest)
					echo -n "${c1}checking MD5 hash... $c4"  
					md5sum -c "$dest.md5" >/dev/null 2>>$log
					cowerr "wrong MD5 hash. file could be compromised." true false true
					cd /
				fi

			fi

			echo -n "$c1$src will be mounted to /mnt... $c4"

			# ===> option 1 ===>

			if [ "$opt" = "1" ]; then

				# mounting partition read-only

				mount -o ro $src /mnt 2>>$log
				cowerr "$m1" true true false
				cd /mnt
				bakinf
				echo
				pstart
				echo

				sdate=$(date +%Y-%m-%d_%T)

				#----- tar backup command -----#
			   
				if [ "$GPG" == "y" ]; then
					tar -cvz . | gpg --batch -c --force-mdc --passphrase "$pwd1" -o $backup 2>>$log && echo
				else
					tar -cvzf $backup . 2>>$log
				fi

				ERR=$(cowerr "$m2" false false false)

				#------------------------------#

				summary

				# create MD5 hashes

				if [ -f $backup ]; then
					cd $(dirname $backup)
					echo -n "${c1}creating MD5 hash... $c4"
					md5sum ./$(basename $backup) > $(basename $backup).md5 2>>$log
					cowerr "failed to create a md5 hash." true false false
					cd /
				fi
			fi

			# ===> 1 ===>

			# ===> option 2 ===>

			if [ "$opt" = "2" ]; then

				mount $src /mnt 2>>$log
				cowerr "$m1" true true false

				if [ $(file $dest | grep "gzip" &>/dev/null ; echo $?) -eq "0" ]; then
					GPG="n"
					echo "${c1}file seems no to be encrypted.$c4"
					echo
				elif [ $(file $dest | grep "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; then
					GPG="y"	
					echo "${c1}file seems to be encrypted.$c4"
					echo
					password "decryption"
					echo
				fi

				heading "[ content of /mnt ]"
				echo
				cd /mnt
				ls -a --color=auto .
				echo
				echo -n "${c1}delet these files? (yes/no)$c3 "
				read delete
				echo $c4

				case $delete in
				yes)
					echo -n "${c1}files will be deleted... $c4" 
					rm -rf /mnt/* 2>>$log
					cowerr "unable to delete files." true false false
					recinf
					echo
					pstart
					echo

					sdate=$(date +%Y-%m-%d_%T)

					#---- tar recovery command ----#

					if [ "$GPG" == "y" ]; then
						{ gpg --batch -d --passphrase "$pwd1" $dest | tar -xzv -C /mnt; } 2>>$log && echo
					elif [ "$GPG" == "n" ]; then
						tar -xvf $dest -C /mnt 2>>$log
					fi

					ERR=$(cowerr "$m2" false false false)

					#------------------------------#

					summary

					# ===> 2 ===>

					;;

				*)
					echo -n "${c1}trying to unmount $src... $c4"
					cd /
					umount $src 2>>$log
					cowerr "$m3" true false false
					cow_say "files were not deleted. aborting..."
					exit 0
					;;
				esac
			fi

			# ===> option 1 and 2 ===>

			cd /
			echo -n "${c1}trying to unmount $src... $c4"
			umount $src 2>>$log
			cowerr "$m3" true false false

		fi

		# ===> option 3 and 4 ===>

		if [ "$opt" = "3" ] || [ "$opt" = "4" ]; then

			clear
			heading "[ cow_backup - $cowdate ]"
			echo
			echo -n "${c1}specify the directory that shall be $a_cow: $c3"
			read -e src
			echo $c4

			# check if src exists

			until [ -d "$src" ] && [ $(echo "$src" | grep "^/" &>/dev/null ; echo $?) -eq "0" ]; do
				echo -n "${c2}\"$src\" is no valid absolute path. please try again: $c3"
				read -e src
				echo $c4
			done

			echo -n "${c1}specify the $green_cow: $c3"
			read -e dest
			echo $c4

			# ===> 3 ===>



			if [ "$opt" = "3"  ]; then

				# check if dest exists

				until [ -d "$dest" ] && [ $(echo $dest | grep "^/" &>/dev/null ; echo $?) -eq "0" ]; do
					echo -n "${c2}\"$src\" is no valid absolute path. please try again: $c3"
					read -e dest
					echo $c4
				done

				# variable for log file

				log=$(echo $dest | sed 's/\/$//')/$logfn

				if [ $(echo "$dest" | grep "$src" &>/dev/null ; echo $?) -eq "0" ]; then
					echo "${c2}the backup path must not be in your source path.$c4"
					cow_say 'aborting!'
					exit 1
				fi

				gpgquest

				bakinf
				echo
				pstart
				echo

				sdate=$(date +%Y-%m-%d_%T)

				#----- tar backup command -----#

				if [ "$GPG" == "y" ]; then
					tar -cvz $src | gpg --batch -c --force-mdc --passphrase "$pwd1" -o $backup 2>>$log && echo
				else
					tar -cvzf $backup $src 2>>$log
				fi

				ERR=$(cowerr "$m2" false false false)

				#------------------------------#

				summary

				# create MD5 hashes

				if [ -f $backup ]; then
					cd $(dirname $backup)
					echo -n "${c1}creating MD5 hash... $c4"
					md5sum ./$(basename $backup) > $(basename $backup).md5 2>>$log
					cowerr "failed to create a md5 hash." true false false
					cd /
				fi

			# ===> 4 ===>

			elif [ "$opt" = "4"  ]; then

				# check if file exists and is a gzip compressed archive (and gpg encrypted)

				until [ -f "$dest" ] && [ $(file $dest | grep -e "gzip" -e "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; do
					echo -n "$c2\"$dest\" is no valid archive file. please enter a valid file: $c3"
					read -e dest
					echo $c4
				done

				# variable for log file

				log=$(dirname $dest)/$logfn

				if [ $(file $dest | grep "gzip" &>/dev/null ; echo $?) -eq "0" ]; then
					GPG="n"
					echo "${c1}file seems no to be encrypted.$c4"
					echo
				elif [ $(file $dest | grep "DOS executable" &>/dev/null ; echo $?) -eq "0" ]; then
					GPG="y"	
					echo "${c1}file seems to be encrypted.$c4"
					echo
					password "decryption"
				fi

				echo    "${c0}existing files with same name will be overwritten and newer files$c4"
				echo -n	"${c0}not included in the backup file won't be deleted. confirm (y/n):$c3 "
				read ok
				echo $c4

				case $ok in
				y|yes)
					recinf
					echo
					pstart
					echo

					sdate=$(date +%Y-%m-%d_%T)

					#---- tar recovery command ----#

					if [ "$GPG" == "y" ]; then
						(gpg --batch -d --passphrase "$pwd1" $dest | tar -xzv -C $src) 2>>$log && echo
					elif [ "$GPG" == "n" ]; then
						tar -xvf $dest -C $src 2>>$log
					fi

					ERR=$(cowerr "$m2" false false false)

					#------------------------------#

					summary

					;;

				*)
					cow_say 'aborting!'
					exit 0
					;;
				esac


			fi

		fi

		# =====> option 1 - 4

		if [ "$opt" -le "4" ]; then

			# if log file is empty, it will be removed

			if [ -f "$log" ] && [ ! -s "$log" ]; then
				rm $log
			fi

			read -p "${c1}press enter...$c4"
			clear
			cow_say $version

		# other options

		elif [ "$opt" = "5" ]; then
			clear
			cow_say "goodbye! ;-)"
			exit 0
		elif [ "$opt" = "moo" ] || [ -z "$opt" ]; then
			clear
			cow_say "mooooo...!?"
		else
			clear
			cow_say "invalid option \"$opt\""
		fi

	done

# non-interactive mode

elif [ -n "$*" ]; then

	# no colors in non-interactive mode

	c0=''
	c1=''
	c2=''
	c3=''
	c4=''

	fileinf=true

	echo $version
	echo

	# some tests at the beginning...

	if [ $UID != 0 ]; then
		EXIT="yes"
		echo "error: root privileges needed."
	fi

	if [ -b "$1" ]; then
		opt=1

	elif [ -d "$1" -o -f "$1" ] && [ $(echo "$1" | grep "^/" &>/dev/null ; echo $?) -eq "0" ]; then
		opt=2

	else
		EXIT="yes"
		echo "error: no valid source (block device or directory)"
	fi

	if [ ! -d "$2" -o $(echo "$2" | grep "^/" &>/dev/null ; echo $?) -ne "0" ]; then
		EXIT="yes"
		echo "error: no valid destination (absolute path)"
	fi

	if [ -z "$3" ]; then
		echo "warning: file will not be encrypted"
		if [ -z $EXIT ]; then echo; fi
	fi

	if [ "$EXIT" == "yes" ]; then
		echo
		echo "try '$0 -h' for more information."
		exit 1
	fi

	# variable for log file destination

	log="$(echo $2 | sed 's/\/$//')/$logfn"

	# backup file name

	srcname=$(basename $1)

	if [ -n "$3" ]; then
		backup=$(echo $2/backup_${srcname}_$cowdate.tgz.gpg | sed "s!//!/!g")
	else
		backup=$(echo $2/backup_${srcname}_$cowdate.tgz | sed "s!//!/!g")
	fi

	if [ -f $backup ]; then
		echo "error: $backup does already exsist."
		echo "       please rename this file or choose an other path. aborting."
		exit 1
	fi

	# partition backup

	if [ "$opt" = "1" ]; then

		# check if partition is mounted or /mnt is used

		if [ $(mount | grep -e "$1" -e "/mnt" &>/dev/null ; echo $?) -eq "0" ]; then
			echo "error: "$1" is mounted or /mnt is already used as mount point."
			echo "       please unmount manually and try again."
			exit 1
		fi

		echo -n "$2 will be mounted to /mnt... "

		# mounting partition read-only

		mount -o ro $1 /mnt 2>>$log
		cowerr "$m1" true true false
		cd /mnt
		echo "$1 will be backuped to $backup"
		echo

		sdate=$(date +%Y-%m-%d_%T)
	
		#----- tar backup command -----#

		if [ -n "$3" ]; then
			tar -cvz . | gpg --batch -c --force-mdc --passphrase "$3" > $backup 2>>$log && echo
		else
			tar -cvzf $backup . 2>>$log
		fi

		ERR=$(cowerr "$m2" false false false)

		#------------------------------#

		summary

		echo -n "trying to unmount $1... "
		umount $1 2>>$log
		cowerr "$m3" true false false

	# directory or file backup

	elif [ "$opt" = "2" ]; then

		if [ $(echo "$2" | grep "$1" &>/dev/null ; echo $?) -eq "0" ]; then
			echo "error: the backup path must not be in your source path. please try again."
			exit 1
		fi

		echo "$1 will be backuped to $backup"
		echo

		sdate=$(date +%Y-%m-%d_%T)
	
		#----- tar backup command -----#

		if [ -n "$3" ]; then
			tar -cvz $1 | gpg --batch -c --force-mdc --passphrase "$3" -o $backup 2>>$log && echo
		else
			tar -cvzf $backup $1 2>>$log
		fi

		ERR=$(cowerr "$m2" false false false)

		#------------------------------#

		summary

	fi

	# create MD5 hashes

	if [ -f $backup ]; then
		cd $(dirname $backup)
		echo -n "creating MD5 hash... "
		md5sum ./$(basename "$backup") > $(basename $backup).md5 2>>$log
		cowerr "error: failed to create a md5 hash." true false false
		cd /
	fi

	# if log file is empty, it will be removed
	
	if [ -f "$log" ] && [ ! -s "$log" ]; then
		rm $log
	fi

	echo "finished..."
	exit 0
fi
