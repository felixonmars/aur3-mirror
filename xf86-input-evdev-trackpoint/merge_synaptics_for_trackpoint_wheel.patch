diff -urN xf86-input-evdev-2.8.2.old/include/synaptics-properties.h xf86-input-evdev-2.8.2/include/synaptics-properties.h
--- xf86-input-evdev-2.8.2.old/include/synaptics-properties.h	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/include/synaptics-properties.h	2013-12-06 19:11:54.529368608 +0900
@@ -0,0 +1,155 @@
+/*
+ * Copyright © 2008 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Red Hat
+ * not be used in advertising or publicity pertaining to distribution
+ * of the software without specific, written prior permission.  Red
+ * Hat makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ */
+
+#ifndef _SYNAPTICS_PROPERTIES_H_
+#define _SYNAPTICS_PROPERTIES_H_
+
+/**
+ * Properties exported by the synaptics driver. These properties are
+ * recognized by the driver and will change its behavior when modified.
+ * For a description of what each property does, see synaptics.h.
+ */
+
+/* 32 bit, 4 values, left, right, top, bottom */
+#define SYNAPTICS_PROP_EDGES "Synaptics Edges"
+
+/* 32 bit, 3 values, low, high, <deprecated> */
+#define SYNAPTICS_PROP_FINGER "Synaptics Finger"
+
+/* 32 bit */
+#define SYNAPTICS_PROP_TAP_TIME "Synaptics Tap Time"
+
+/* 32 bit */
+#define SYNAPTICS_PROP_TAP_MOVE "Synaptics Tap Move"
+
+/* 32 bit, 3 values, single touch timeout, max tapping time for double
+ * taps, duration of a single click  */
+#define SYNAPTICS_PROP_TAP_DURATIONS "Synaptics Tap Durations"
+
+/* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_CLICKPAD "Synaptics ClickPad"
+
+/* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_TAP_FAST "Synaptics Tap FastTap"
+
+/* 32 bit */
+#define SYNAPTICS_PROP_MIDDLE_TIMEOUT "Synaptics Middle Button Timeout"
+
+/* 32 bit */
+#define SYNAPTICS_PROP_TWOFINGER_PRESSURE "Synaptics Two-Finger Pressure"
+
+/* 32 bit */
+#define SYNAPTICS_PROP_TWOFINGER_WIDTH "Synaptics Two-Finger Width"
+
+/* 32 bit, 2 values, vert, horiz */
+#define SYNAPTICS_PROP_SCROLL_DISTANCE "Synaptics Scrolling Distance"
+
+/* 8 bit (BOOL), 3 values, vertical, horizontal, corner */
+#define SYNAPTICS_PROP_SCROLL_EDGE "Synaptics Edge Scrolling"
+
+/* 8 bit (BOOL), 2 values, vertical, horizontal */
+#define SYNAPTICS_PROP_SCROLL_TWOFINGER "Synaptics Two-Finger Scrolling"
+
+/* FLOAT, 4 values, min, max, accel, <deprecated> */
+#define SYNAPTICS_PROP_SPEED "Synaptics Move Speed"
+
+/* 8 bit (BOOL), 2 values, updown, leftright */
+#define SYNAPTICS_PROP_BUTTONSCROLLING "Synaptics Button Scrolling"
+
+/* 8 bit (BOOL), 2 values, updown, leftright */
+#define SYNAPTICS_PROP_BUTTONSCROLLING_REPEAT "Synaptics Button Scrolling Repeat"
+
+/* 32 bit */
+#define SYNAPTICS_PROP_BUTTONSCROLLING_TIME "Synaptics Button Scrolling Time"
+
+/* 8 bit, valid values (0, 1, 2) */
+#define SYNAPTICS_PROP_OFF "Synaptics Off"
+
+/* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_GUESTMOUSE "Synaptics Guestmouse Off"
+
+/* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_LOCKED_DRAGS "Synaptics Locked Drags"
+
+/* 32 bit */
+#define SYNAPTICS_PROP_LOCKED_DRAGS_TIMEOUT "Synaptics Locked Drags Timeout"
+
+/* 8 bit, up to MAX_TAP values (see synaptics.h), 0 disables an
+ * element. order: RT, RB, LT, LB, F1, F2, F3 */
+#define SYNAPTICS_PROP_TAP_ACTION "Synaptics Tap Action"
+
+/* 8 bit, up to MAX_CLICK values (see synaptics.h), 0 disables an
+ * element. order: Finger 1, 2, 3 */
+#define SYNAPTICS_PROP_CLICK_ACTION "Synaptics Click Action"
+
+/* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_CIRCULAR_SCROLLING "Synaptics Circular Scrolling"
+
+/* FLOAT */
+#define SYNAPTICS_PROP_CIRCULAR_SCROLLING_DIST "Synaptics Circular Scrolling Distance"
+
+/* 8 bit, valid values 0..8 (inclusive)
+ * order: any edge, top, top + right, right, right + bottom, bottom, bottom +
+ * left, left, left  + top */
+#define SYNAPTICS_PROP_CIRCULAR_SCROLLING_TRIGGER "Synaptics Circular Scrolling Trigger"
+
+/* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_PALM_DETECT "Synaptics Palm Detection"
+
+/* 32 bit, 2 values, width, z */
+#define SYNAPTICS_PROP_PALM_DIMENSIONS "Synaptics Palm Dimensions"
+
+/* FLOAT, 2 values, speed, friction */
+#define SYNAPTICS_PROP_COASTING_SPEED "Synaptics Coasting Speed"
+
+/* CARD32, 2 values, min, max */
+#define SYNAPTICS_PROP_PRESSURE_MOTION "Synaptics Pressure Motion"
+
+/* FLOAT, 2 values, min, max */
+#define SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR "Synaptics Pressure Motion Factor"
+
+/* 8 bit (BOOL) */
+#define SYNAPTICS_PROP_GRAB "Synaptics Grab Event Device"
+
+/* 8 bit (BOOL), 1 value, tap-and-drag */
+#define SYNAPTICS_PROP_GESTURES "Synaptics Gestures"
+
+/* 8 bit (BOOL), 7 values (read-only), has_left, has_middle, has_right,
+ * has_double, has_triple, has_pressure, has_width */
+#define SYNAPTICS_PROP_CAPABILITIES "Synaptics Capabilities"
+
+/* 32 bit unsigned, 2 values, vertical, horizontal in units/millimeter */
+#define SYNAPTICS_PROP_RESOLUTION "Synaptics Pad Resolution"
+
+/* 32 bit, 4 values, left, right, top, bottom */
+#define SYNAPTICS_PROP_AREA "Synaptics Area"
+
+/* 32 bit, 4 values, left, right, top, buttom */
+#define SYNAPTICS_PROP_SOFTBUTTON_AREAS "Synaptics Soft Button Areas"
+
+/* 32 Bit Integer, 2 values, horizontal hysteresis, vertical hysteresis */
+#define SYNAPTICS_PROP_NOISE_CANCELLATION "Synaptics Noise Cancellation"
+
+#endif                          /* _SYNAPTICS_PROPERTIES_H_ */
diff -urN xf86-input-evdev-2.8.2.old/src/Makefile.in xf86-input-evdev-2.8.2/src/Makefile.in
--- xf86-input-evdev-2.8.2.old/src/Makefile.in	2013-10-07 08:05:31.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/Makefile.in	2013-12-06 19:11:54.529368608 +0900
@@ -148,7 +148,8 @@
 @DRIVER_NAME@_drv_la_DEPENDENCIES = $(am__DEPENDENCIES_1) \
 	$(am__DEPENDENCIES_1)
 am_@DRIVER_NAME@_drv_la_OBJECTS = @DRIVER_NAME@.lo emuMB.lo \
-	emuThird.lo emuWheel.lo draglock.lo apple.lo
+	emuThird.lo emuWheel.lo draglock.lo apple.lo synaptics.lo \
+	eventcomm.lo synproto.lo properties.lo
 @DRIVER_NAME@_drv_la_OBJECTS = $(am_@DRIVER_NAME@_drv_la_OBJECTS)
 AM_V_lt = $(am__v_lt_@AM_V@)
 am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
@@ -361,7 +362,14 @@
                                emuWheel.c \
                                draglock.c \
                                apple.c \
-                               axis_labels.h
+                               axis_labels.h \
+			       synaptics.c \
+			       eventcomm.c \
+			       eventcomm.h \
+			       synproto.c \
+			       synproto.h \
+			       synapticsstr.h \
+			       properties.c
 
 all: all-am
 
@@ -448,6 +456,10 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emuMB.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emuThird.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/emuWheel.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eventcomm.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/properties.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/synaptics.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/synproto.Plo@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
diff -urN xf86-input-evdev-2.8.2.old/src/evdev.c xf86-input-evdev-2.8.2/src/evdev.c
--- xf86-input-evdev-2.8.2.old/src/evdev.c	2013-10-07 08:04:32.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/evdev.c	2013-12-06 19:11:54.532701961 +0900
@@ -113,6 +113,9 @@
         BTN_TOOL_LENS,
 };
 
+int SynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
+void SynapticsUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
+
 static int EvdevOn(DeviceIntPtr);
 static int EvdevCache(InputInfoPtr pInfo);
 static void EvdevKbdCtrl(DeviceIntPtr device, KeybdCtrl *ctrl);
@@ -138,6 +141,8 @@
 static Atom prop_device;
 static Atom prop_virtual;
 
+InputInfoPtr trackpoint = NULL;
+
 /* All devices the evdev driver has allocated and knows about.
  * MAXDEVICES is safe as null-terminated array, as two devices (VCP and VCK)
  * cannot be used by evdev, leaving us with a space of 2 at the end. */
@@ -1007,7 +1012,7 @@
  * Take the synchronization input event and process it accordingly; the motion
  * notify events are sent first, then any button/key press/release events.
  */
-static void
+void
 EvdevProcessSyncEvent(InputInfoPtr pInfo, struct input_event *ev)
 {
     int i;
@@ -1430,6 +1435,7 @@
         if (pEvdev->mtdev->caps.slot.maximum > 0)
             num_touches = pEvdev->mtdev->caps.slot.maximum -
                           pEvdev->mtdev->caps.slot.minimum + 1;
+        xf86IDrvMsg(pInfo, X_INFO, "num_touches = %d\n", num_touches);
 
         if (!InitTouchClassDeviceStruct(device, num_touches, mode,
                                         num_mt_axes_total)) {
@@ -2538,6 +2544,11 @@
 EvdevUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
 {
     EvdevPtr pEvdev = pInfo ? pInfo->private : NULL;
+    
+    /* Synaptics */
+    if (pEvdev->isSynaptics)
+        return SynapticsUnInit(drv, pInfo, flags);
+
     if (pEvdev)
     {
         /* Release string allocated in EvdevOpenDevice. */
@@ -2547,6 +2558,12 @@
         free(pEvdev->type_name);
         pEvdev->type_name = NULL;
     }
+
+    /* TrackPoint */
+    if (strstr(pInfo->name, "TrackPoint")) {
+        trackpoint = NULL;
+    }
+
     xf86DeleteInput(pInfo, flags);
 }
 
@@ -2578,6 +2595,9 @@
     pEvdev->rel_axis_map[1] = 1;
 
     pEvdev->type_name = NULL;
+    
+    /* Synaptics */
+    pEvdev->isSynaptics = 0;
 
     return pEvdev;
 }
@@ -2596,6 +2616,11 @@
     pInfo->device_control = EvdevProc;
     pInfo->read_input = EvdevReadInput;
     pInfo->switch_mode = EvdevSwitchMode;
+    
+    /* TrackPoint */
+    if (strstr(pInfo->name, "TrackPoint")) {
+        trackpoint = pInfo;
+    }
 
     rc = EvdevOpenDevice(pInfo);
     if (rc != Success)
@@ -2622,6 +2647,13 @@
         rc = BadMatch;
         goto error;
     }
+    
+    /* Synaptics */
+    if (pEvdev->flags & EVDEV_TOUCHPAD) {
+        free(pInfo->private);
+        pInfo->private = NULL;
+        return SynapticsPreInit(drv, pInfo, flags);
+    }
 
     /* Overwrite type_name with custom-defined one (#62831).
        Note: pInfo->type_name isn't freed so we need to manually do this
diff -urN xf86-input-evdev-2.8.2.old/src/evdev.h xf86-input-evdev-2.8.2/src/evdev.h
--- xf86-input-evdev-2.8.2.old/src/evdev.h	2013-10-07 08:04:32.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/evdev.h	2013-12-06 19:11:54.532701961 +0900
@@ -150,6 +150,7 @@
 } EventQueueRec, *EventQueuePtr;
 
 typedef struct {
+    int isSynaptics;
     unsigned short id_vendor;
     unsigned short id_product;
 
diff -urN xf86-input-evdev-2.8.2.old/src/eventcomm.c xf86-input-evdev-2.8.2/src/eventcomm.c
--- xf86-input-evdev-2.8.2.old/src/eventcomm.c	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/eventcomm.c	2013-12-06 19:11:54.536035314 +0900
@@ -0,0 +1,962 @@
+/*
+ * Copyright © 2004-2007 Peter Osterlund
+ * Copyright © 2008-2012 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Red Hat
+ * not be used in advertising or publicity pertaining to distribution
+ * of the software without specific, written prior permission.  Red
+ * Hat makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Peter Osterlund (petero2@telia.com)
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <xorg-server.h>
+#include <xserver-properties.h>
+#include "eventcomm.h"
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <string.h>
+#include <stdio.h>
+#include "synproto.h"
+#include "synapticsstr.h"
+#include <xf86.h>
+#include <mtdev.h>
+
+#ifndef INPUT_PROP_BUTTONPAD
+#define INPUT_PROP_BUTTONPAD 0x02
+#endif
+#ifndef INPUT_PROP_SEMI_MT
+#define INPUT_PROP_SEMI_MT 0x03
+#endif
+
+#define SYSCALL(call) while (((call) == -1) && (errno == EINTR))
+
+#define LONG_BITS (sizeof(long) * 8)
+#define NBITS(x) (((x) + LONG_BITS - 1) / LONG_BITS)
+#define OFF(x)   ((x) % LONG_BITS)
+#define LONG(x)  ((x) / LONG_BITS)
+#define TEST_BIT(bit, array) ((array[LONG(bit)] >> OFF(bit)) & 1)
+
+/**
+ * Protocol-specific data.
+ */
+struct eventcomm_proto_data {
+    /**
+     * Do we need to grab the event device?
+     * Note that in the current flow, this variable is always false and
+     * exists for readability of the code.
+     */
+    BOOL need_grab;
+    int st_to_mt_offset[2];
+    double st_to_mt_scale[2];
+    struct mtdev *mtdev;
+    int axis_map[MT_ABS_SIZE];
+    int cur_slot;
+    ValuatorMask **last_mt_vals;
+    int num_touches;
+};
+
+struct eventcomm_proto_data *
+EventProtoDataAlloc(void)
+{
+    struct eventcomm_proto_data *proto_data;
+
+    proto_data = calloc(1, sizeof(struct eventcomm_proto_data));
+    if (!proto_data)
+        return NULL;
+
+    proto_data->st_to_mt_scale[0] = 1;
+    proto_data->st_to_mt_scale[1] = 1;
+
+    return proto_data;
+}
+
+static int
+last_mt_vals_slot(const SynapticsPrivate * priv)
+{
+    struct eventcomm_proto_data *proto_data =
+        (struct eventcomm_proto_data *) priv->proto_data;
+    int value = proto_data->cur_slot - proto_data->mtdev->caps.slot.minimum;
+
+    return value < priv->num_slots ? value : -1;
+}
+
+static void
+UninitializeTouch(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data =
+        (struct eventcomm_proto_data *) priv->proto_data;
+
+    if (!priv->has_touch)
+        return;
+
+    if (proto_data->last_mt_vals) {
+        int i;
+
+        for (i = 0; i < priv->num_slots; i++)
+            valuator_mask_free(&proto_data->last_mt_vals[i]);
+        free(proto_data->last_mt_vals);
+        proto_data->last_mt_vals = NULL;
+    }
+
+    mtdev_close_delete(proto_data->mtdev);
+    proto_data->mtdev = NULL;
+    proto_data->num_touches = 0;
+}
+
+static void
+InitializeTouch(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data =
+        (struct eventcomm_proto_data *) priv->proto_data;
+    int i;
+
+    if (!priv->has_touch)
+        return;
+
+    proto_data->mtdev = mtdev_new_open(pInfo->fd);
+    if (!proto_data->mtdev) {
+        xf86IDrvMsg(pInfo, X_WARNING,
+                    "failed to create mtdev instance, ignoring touch events\n");
+        return;
+    }
+
+    proto_data->cur_slot = proto_data->mtdev->caps.slot.value;
+    proto_data->num_touches = 0;
+
+    proto_data->last_mt_vals = calloc(priv->num_slots, sizeof(ValuatorMask *));
+    if (!proto_data->last_mt_vals) {
+        xf86IDrvMsg(pInfo, X_WARNING,
+                    "failed to allocate MT last values mask array\n");
+        UninitializeTouch(pInfo);
+        return;
+    }
+
+    for (i = 0; i < priv->num_slots; i++) {
+        int j;
+
+        proto_data->last_mt_vals[i] = valuator_mask_new(4 + priv->num_mt_axes);
+        if (!proto_data->last_mt_vals[i]) {
+            xf86IDrvMsg(pInfo, X_WARNING,
+                        "failed to allocate MT last values mask\n");
+            UninitializeTouch(pInfo);
+            return;
+        }
+
+        /* Axes 0-4 are for X, Y, and scrolling. num_mt_axes does not include X
+         * and Y. */
+        valuator_mask_set(proto_data->last_mt_vals[i], 0, 0);
+        valuator_mask_set(proto_data->last_mt_vals[i], 1, 0);
+        for (j = 0; j < priv->num_mt_axes; j++)
+            valuator_mask_set(proto_data->last_mt_vals[i], 4 + j, 0);
+    }
+}
+
+static Bool
+EventDeviceOnHook(InputInfoPtr pInfo, SynapticsParameters * para)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data =
+        (struct eventcomm_proto_data *) priv->proto_data;
+
+    if (para->grab_event_device) {
+        /* Try to grab the event device so that data don't leak to /dev/input/mice */
+        int ret;
+
+        SYSCALL(ret = ioctl(pInfo->fd, EVIOCGRAB, (pointer) 1));
+        if (ret < 0) {
+            xf86IDrvMsg(pInfo, X_WARNING, "can't grab event device, errno=%d\n",
+                        errno);
+            return FALSE;
+        }
+    }
+
+    proto_data->need_grab = FALSE;
+
+    InitializeTouch(pInfo);
+
+    return TRUE;
+}
+
+static Bool
+EventDeviceOffHook(InputInfoPtr pInfo)
+{
+    UninitializeTouch(pInfo);
+
+    return Success;
+}
+
+/**
+ * Test if the device on the file descriptior is recognized as touchpad
+ * device. Required bits for touchpad recognition are:
+ * - ABS_X + ABS_Y for absolute axes
+ * - ABS_PRESSURE or BTN_TOUCH
+ * - BTN_TOOL_FINGER
+ * - BTN_TOOL_PEN is _not_ set
+ *
+ * @param fd The file descriptor to an event device.
+ * @param test_grab If true, test whether an EVIOCGRAB is possible on the
+ * device. A failure to grab the event device returns in a failure.
+ *
+ * @return TRUE if the device is a touchpad or FALSE otherwise.
+ */
+static Bool
+event_query_is_touchpad(int fd, BOOL test_grab)
+{
+    int ret = FALSE, rc;
+    unsigned long evbits[NBITS(EV_MAX)] = { 0 };
+    unsigned long absbits[NBITS(ABS_MAX)] = { 0 };
+    unsigned long keybits[NBITS(KEY_MAX)] = { 0 };
+
+    if (test_grab) {
+        SYSCALL(rc = ioctl(fd, EVIOCGRAB, (pointer) 1));
+        if (rc < 0)
+            return FALSE;
+    }
+
+    /* Check for ABS_X, ABS_Y, ABS_PRESSURE and BTN_TOOL_FINGER */
+
+    SYSCALL(rc = ioctl(fd, EVIOCGBIT(0, sizeof(evbits)), evbits));
+    if (rc < 0)
+        goto unwind;
+    if (!TEST_BIT(EV_SYN, evbits) ||
+        !TEST_BIT(EV_ABS, evbits) || !TEST_BIT(EV_KEY, evbits))
+        goto unwind;
+
+    SYSCALL(rc = ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits));
+    if (rc < 0)
+        goto unwind;
+    if (!TEST_BIT(ABS_X, absbits) || !TEST_BIT(ABS_Y, absbits))
+        goto unwind;
+
+    SYSCALL(rc = ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits));
+    if (rc < 0)
+        goto unwind;
+
+    /* we expect touchpad either report raw pressure or touches */
+    if (!TEST_BIT(ABS_PRESSURE, absbits) && !TEST_BIT(BTN_TOUCH, keybits))
+        goto unwind;
+    /* all Synaptics-like touchpad report BTN_TOOL_FINGER */
+    if (!TEST_BIT(BTN_TOOL_FINGER, keybits))
+        goto unwind;
+    if (TEST_BIT(BTN_TOOL_PEN, keybits))
+        goto unwind;            /* Don't match wacom tablets */
+
+    ret = TRUE;
+
+ unwind:
+    if (test_grab)
+        SYSCALL(ioctl(fd, EVIOCGRAB, (pointer) 0));
+
+    return (ret == TRUE);
+}
+
+#define PRODUCT_ANY 0x0000
+
+struct model_lookup_t {
+    short vendor;
+    short product_start;
+    short product_end;
+    enum TouchpadModel model;
+};
+
+
+static struct model_lookup_t model_lookup_table[] = {
+    {0x0002, 0x0007, 0x0007, MODEL_SYNAPTICS},
+    {0x0002, 0x0008, 0x0008, MODEL_ALPS},
+    {0x05ac, PRODUCT_ANY, 0x222, MODEL_APPLETOUCH},
+    {0x05ac, 0x223, PRODUCT_ANY, MODEL_UNIBODY_MACBOOK},
+    {0x0002, 0x000e, 0x000e, MODEL_ELANTECH},
+    {0x0, 0x0, 0x0, 0x0}
+};
+
+/**
+ * Check for the vendor/product id on the file descriptor and compare
+ * with the built-in model LUT. This information is used in synaptics.c to
+ * initialize model-specific dimensions.
+ *
+ * @param fd The file descriptor to a event device.
+ * @param[out] model_out The type of touchpad model detected.
+ *
+ * @return TRUE on success or FALSE otherwise.
+ */
+static Bool
+event_query_model(int fd, enum TouchpadModel *model_out,
+                  unsigned short *vendor_id, unsigned short *product_id)
+{
+    struct input_id id;
+    int rc;
+    struct model_lookup_t *model_lookup;
+
+    SYSCALL(rc = ioctl(fd, EVIOCGID, &id));
+    if (rc < 0)
+        return FALSE;
+
+    for (model_lookup = model_lookup_table; model_lookup->vendor;
+         model_lookup++) {
+        if (model_lookup->vendor == id.vendor &&
+            (model_lookup->product_start == PRODUCT_ANY ||
+             model_lookup->product_start <= id.product) &&
+            (model_lookup->product_end == PRODUCT_ANY ||
+             model_lookup->product_end >= id.product))
+            *model_out = model_lookup->model;
+    }
+
+    *vendor_id = id.vendor;
+    *product_id = id.product;
+
+    return TRUE;
+}
+
+/**
+ * Get absinfo information from the given file descriptor for the given
+ * ABS_FOO code and store the information in min, max, fuzz and res.
+ *
+ * @param fd File descriptor to an event device
+ * @param code Event code (e.g. ABS_X)
+ * @param[out] min Minimum axis range
+ * @param[out] max Maximum axis range
+ * @param[out] fuzz Fuzz of this axis. If NULL, fuzz is ignored.
+ * @param[out] res Axis resolution. If NULL or the current kernel does not
+ * support the resolution field, res is ignored
+ *
+ * @return Zero on success, or errno otherwise.
+ */
+static int
+event_get_abs(InputInfoPtr pInfo, int fd, int code,
+              int *min, int *max, int *fuzz, int *res)
+{
+    int rc;
+    struct input_absinfo abs = { 0 };
+
+    SYSCALL(rc = ioctl(fd, EVIOCGABS(code), &abs));
+    if (rc < 0) {
+        xf86IDrvMsg(pInfo, X_ERROR, "%s EVIOCGABS error on %d (%s)\n",
+                    __func__, code, strerror(errno));
+        return errno;
+    }
+
+    *min = abs.minimum;
+    *max = abs.maximum;
+    /* We dont trust a zero fuzz as it probably is just a lazy value */
+    if (fuzz && abs.fuzz > 0)
+        *fuzz = abs.fuzz;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,30)
+    if (res)
+        *res = abs.resolution;
+#endif
+
+    return 0;
+}
+
+/* Query device for axis ranges */
+static void
+event_query_axis_ranges(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+    unsigned long absbits[NBITS(ABS_MAX)] = { 0 };
+    unsigned long keybits[NBITS(KEY_MAX)] = { 0 };
+    char buf[256] = { 0 };
+    int rc;
+
+    /* The kernel's fuzziness concept seems a bit weird, but it can more or
+     * less be applied as hysteresis directly, i.e. no factor here. */
+    event_get_abs(pInfo, pInfo->fd, ABS_X, &priv->minx, &priv->maxx,
+                  &priv->synpara.hyst_x, &priv->resx);
+
+    event_get_abs(pInfo, pInfo->fd, ABS_Y, &priv->miny, &priv->maxy,
+                  &priv->synpara.hyst_y, &priv->resy);
+
+    priv->has_pressure = FALSE;
+    priv->has_width = FALSE;
+    SYSCALL(rc = ioctl(pInfo->fd, EVIOCGBIT(EV_ABS, sizeof(absbits)), absbits));
+    if (rc >= 0) {
+        priv->has_pressure = (TEST_BIT(ABS_PRESSURE, absbits) != 0);
+        priv->has_width = (TEST_BIT(ABS_TOOL_WIDTH, absbits) != 0);
+    }
+    else
+        xf86IDrvMsg(pInfo, X_ERROR, "failed to query ABS bits (%s)\n",
+                    strerror(errno));
+
+    if (priv->has_pressure)
+        event_get_abs(pInfo, pInfo->fd, ABS_PRESSURE, &priv->minp, &priv->maxp,
+                      NULL, NULL);
+
+    if (priv->has_width)
+        event_get_abs(pInfo, pInfo->fd, ABS_TOOL_WIDTH,
+                      &priv->minw, &priv->maxw, NULL, NULL);
+
+    if (priv->has_touch) {
+        int st_minx = priv->minx;
+        int st_maxx = priv->maxx;
+        int st_miny = priv->miny;
+        int st_maxy = priv->maxy;
+
+        event_get_abs(pInfo, pInfo->fd, ABS_MT_POSITION_X, &priv->minx,
+                      &priv->maxx, &priv->synpara.hyst_x, &priv->resx);
+        event_get_abs(pInfo, pInfo->fd, ABS_MT_POSITION_Y, &priv->miny,
+                      &priv->maxy, &priv->synpara.hyst_y, &priv->resy);
+
+        proto_data->st_to_mt_offset[0] = priv->minx - st_minx;
+        proto_data->st_to_mt_scale[0] =
+            (priv->maxx - priv->minx) / (st_maxx - st_minx);
+        proto_data->st_to_mt_offset[1] = priv->miny - st_miny;
+        proto_data->st_to_mt_scale[1] =
+            (priv->maxy - priv->miny) / (st_maxy - st_miny);
+    }
+
+    SYSCALL(rc = ioctl(pInfo->fd, EVIOCGBIT(EV_KEY, sizeof(keybits)), keybits));
+    if (rc >= 0) {
+        priv->has_left = (TEST_BIT(BTN_LEFT, keybits) != 0);
+        priv->has_right = (TEST_BIT(BTN_RIGHT, keybits) != 0);
+        priv->has_middle = (TEST_BIT(BTN_MIDDLE, keybits) != 0);
+        priv->has_double = (TEST_BIT(BTN_TOOL_DOUBLETAP, keybits) != 0);
+        priv->has_triple = (TEST_BIT(BTN_TOOL_TRIPLETAP, keybits) != 0);
+
+        if ((TEST_BIT(BTN_0, keybits) != 0) ||
+            (TEST_BIT(BTN_1, keybits) != 0) ||
+            (TEST_BIT(BTN_2, keybits) != 0) || (TEST_BIT(BTN_3, keybits) != 0))
+            priv->has_scrollbuttons = 1;
+    }
+
+    /* Now print the device information */
+    xf86IDrvMsg(pInfo, X_PROBED, "x-axis range %d - %d (res %d)\n",
+                priv->minx, priv->maxx, priv->resx);
+    xf86IDrvMsg(pInfo, X_PROBED, "y-axis range %d - %d (res %d)\n",
+                priv->miny, priv->maxy, priv->resy);
+    if (priv->has_pressure)
+        xf86IDrvMsg(pInfo, X_PROBED, "pressure range %d - %d\n",
+                    priv->minp, priv->maxp);
+    else
+        xf86IDrvMsg(pInfo, X_INFO,
+                    "device does not report pressure, will use touch data.\n");
+    if (priv->has_width)
+        xf86IDrvMsg(pInfo, X_PROBED, "finger width range %d - %d\n",
+                    priv->minw, priv->maxw);
+    else
+        xf86IDrvMsg(pInfo, X_INFO, "device does not report finger width.\n");
+
+    if (priv->has_left)
+        strcat(buf, " left");
+    if (priv->has_right)
+        strcat(buf, " right");
+    if (priv->has_middle)
+        strcat(buf, " middle");
+    if (priv->has_double)
+        strcat(buf, " double");
+    if (priv->has_triple)
+        strcat(buf, " triple");
+    if (priv->has_scrollbuttons)
+        strcat(buf, " scroll-buttons");
+
+    xf86IDrvMsg(pInfo, X_PROBED, "buttons:%s\n", buf);
+}
+
+static Bool
+EventQueryHardware(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+
+    if (!event_query_is_touchpad
+        (pInfo->fd, (proto_data) ? proto_data->need_grab : TRUE))
+        return FALSE;
+
+    xf86IDrvMsg(pInfo, X_PROBED, "touchpad found\n");
+
+    return TRUE;
+}
+
+static Bool
+SynapticsReadEvent(InputInfoPtr pInfo, struct input_event *ev)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+    int rc = TRUE;
+    ssize_t len;
+
+    if (proto_data->mtdev)
+        len = mtdev_get(proto_data->mtdev, pInfo->fd, ev, 1) *
+            sizeof(struct input_event);
+    else
+        len = read(pInfo->fd, ev, sizeof(*ev));
+    if (len <= 0) {
+        /* We use X_NONE here because it doesn't alloc */
+        if (errno != EAGAIN)
+            LogMessageVerbSigSafe(X_ERROR, 0, "%s: Read error %d\n", pInfo->name,
+                                  errno);
+        rc = FALSE;
+    }
+    else if (len % sizeof(*ev)) {
+        LogMessageVerbSigSafe(X_ERROR, 0, "%s: Read error, invalid number of bytes.",
+                              pInfo->name);
+        rc = FALSE;
+    }
+    return rc;
+}
+
+static Bool
+EventTouchSlotPreviouslyOpen(SynapticsPrivate * priv, int slot)
+{
+    int i;
+
+    for (i = 0; i < priv->num_active_touches; i++)
+        if (priv->open_slots[i] == slot)
+            return TRUE;
+
+    return FALSE;
+}
+
+static void
+EventProcessTouchEvent(InputInfoPtr pInfo, struct SynapticsHwState *hw,
+                       struct input_event *ev)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+
+    if (!priv->has_touch)
+        return;
+
+    if (ev->code == ABS_MT_SLOT) {
+        proto_data->cur_slot = ev->value;
+    }
+    else {
+        int slot_index = last_mt_vals_slot(priv);
+
+        if (slot_index < 0)
+            return;
+
+        if (hw->slot_state[slot_index] == SLOTSTATE_OPEN_EMPTY)
+            hw->slot_state[slot_index] = SLOTSTATE_UPDATE;
+        if (ev->code == ABS_MT_TRACKING_ID) {
+            if (ev->value >= 0) {
+                hw->slot_state[slot_index] = SLOTSTATE_OPEN;
+                proto_data->num_touches++;
+                valuator_mask_copy(hw->mt_mask[slot_index],
+                                   proto_data->last_mt_vals[slot_index]);
+            }
+            else if (hw->slot_state[slot_index] != SLOTSTATE_EMPTY) {
+                hw->slot_state[slot_index] = SLOTSTATE_CLOSE;
+                proto_data->num_touches--;
+            }
+        }
+        else {
+            ValuatorMask *mask = proto_data->last_mt_vals[slot_index];
+            int map = proto_data->axis_map[ev->code - ABS_MT_TOUCH_MAJOR];
+            int last_val = valuator_mask_get(mask, map);
+
+            valuator_mask_set(hw->mt_mask[slot_index], map, ev->value);
+            if (EventTouchSlotPreviouslyOpen(priv, slot_index)) {
+                if (ev->code == ABS_MT_POSITION_X)
+                    hw->cumulative_dx += ev->value - last_val;
+                else if (ev->code == ABS_MT_POSITION_Y)
+                    hw->cumulative_dy += ev->value - last_val;
+            }
+
+            valuator_mask_set(mask, map, ev->value);
+        }
+    }
+}
+
+/**
+ * Count the number of fingers based on the CommData information.
+ * The CommData struct contains the event information based on previous
+ * struct input_events, now we're just counting based on that.
+ *
+ * @param comm Assembled information from previous events.
+ * @return The number of fingers currently set.
+ */
+static int
+count_fingers(InputInfoPtr pInfo, const struct CommData *comm)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+    int fingers = 0;
+
+    if (comm->oneFinger)
+        fingers = 1;
+    else if (comm->twoFingers)
+        fingers = 2;
+    else if (comm->threeFingers)
+        fingers = 3;
+
+    if (priv->has_touch && proto_data->num_touches > fingers)
+        fingers = proto_data->num_touches;
+
+    return fingers;
+}
+
+static inline double
+apply_st_scaling(struct eventcomm_proto_data *proto_data, int value, int axis)
+{
+    return value * proto_data->st_to_mt_scale[axis] +
+        proto_data->st_to_mt_offset[axis];
+}
+
+Bool
+EventReadHwState(InputInfoPtr pInfo,
+                 struct CommData *comm, struct SynapticsHwState *hwRet)
+{
+    struct input_event ev;
+    Bool v;
+    struct SynapticsHwState *hw = comm->hwState;
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+
+    SynapticsResetTouchHwState(hw, FALSE);
+
+    /* Reset cumulative values if buttons were not previously pressed */
+    if (!hw->left && !hw->right && !hw->middle) {
+        hw->cumulative_dx = hw->x;
+        hw->cumulative_dy = hw->y;
+    }
+
+    while (SynapticsReadEvent(pInfo, &ev)) {
+        switch (ev.type) {
+        case EV_SYN:
+            switch (ev.code) {
+            case SYN_REPORT:
+                hw->numFingers = count_fingers(pInfo, comm);
+                hw->millis = 1000 * ev.time.tv_sec + ev.time.tv_usec / 1000;
+                SynapticsCopyHwState(hwRet, hw);
+                return TRUE;
+            }
+            break;
+        case EV_KEY:
+            v = (ev.value ? TRUE : FALSE);
+            switch (ev.code) {
+            case BTN_LEFT:
+                hw->left = v;
+                break;
+            case BTN_RIGHT:
+                hw->right = v;
+                break;
+            case BTN_MIDDLE:
+                hw->middle = v;
+                break;
+            case BTN_FORWARD:
+                hw->up = v;
+                break;
+            case BTN_BACK:
+                hw->down = v;
+                break;
+            case BTN_0:
+                hw->multi[0] = v;
+                break;
+            case BTN_1:
+                hw->multi[1] = v;
+                break;
+            case BTN_2:
+                hw->multi[2] = v;
+                break;
+            case BTN_3:
+                hw->multi[3] = v;
+                break;
+            case BTN_4:
+                hw->multi[4] = v;
+                break;
+            case BTN_5:
+                hw->multi[5] = v;
+                break;
+            case BTN_6:
+                hw->multi[6] = v;
+                break;
+            case BTN_7:
+                hw->multi[7] = v;
+                break;
+            case BTN_TOOL_FINGER:
+                comm->oneFinger = v;
+                break;
+            case BTN_TOOL_DOUBLETAP:
+                comm->twoFingers = v;
+                break;
+            case BTN_TOOL_TRIPLETAP:
+                comm->threeFingers = v;
+                break;
+            case BTN_TOUCH:
+                if (!priv->has_pressure)
+                    hw->z = v ? para->finger_high + 1 : 0;
+                break;
+            }
+            break;
+        case EV_ABS:
+            if (ev.code < ABS_MT_SLOT) {
+                switch (ev.code) {
+                case ABS_X:
+                    hw->x = apply_st_scaling(proto_data, ev.value, 0);
+                    break;
+                case ABS_Y:
+                    hw->y = apply_st_scaling(proto_data, ev.value, 1);
+                    break;
+                case ABS_PRESSURE:
+                    hw->z = ev.value;
+                    break;
+                case ABS_TOOL_WIDTH:
+                    hw->fingerWidth = ev.value;
+                    break;
+                }
+            }
+            else
+                EventProcessTouchEvent(pInfo, hw, &ev);
+            break;
+        }
+    }
+    return FALSE;
+}
+
+/* filter for the AutoDevProbe scandir on /dev/input */
+static int
+EventDevOnly(const struct dirent *dir)
+{
+    return strncmp(EVENT_DEV_NAME, dir->d_name, 5) == 0;
+}
+
+static void
+event_query_touch(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+    struct mtdev *mtdev;
+    int i;
+    int rc;
+    uint8_t prop;
+
+    priv->max_touches = 0;
+    priv->num_mt_axes = 0;
+
+#ifdef EVIOCGPROP
+    SYSCALL(rc = ioctl(pInfo->fd, EVIOCGPROP(sizeof(prop)), &prop));
+    if (rc >= 0 && BitIsOn(&prop, INPUT_PROP_SEMI_MT)) {
+        xf86IDrvMsg(pInfo, X_INFO,
+                    "ignoring touch events for semi-multitouch device\n");
+        priv->has_semi_mt = TRUE;
+    }
+
+    if (rc >= 0 && BitIsOn(&prop, INPUT_PROP_BUTTONPAD)) {
+        xf86IDrvMsg(pInfo, X_INFO, "found clickpad property\n");
+        para->clickpad = TRUE;
+    }
+#endif
+
+    mtdev = mtdev_new_open(pInfo->fd);
+    if (!mtdev) {
+        xf86IDrvMsg(pInfo, X_WARNING,
+                    "failed to open mtdev when querying touch capabilities\n");
+        return;
+    }
+
+    for (i = 0; i < MT_ABS_SIZE; i++) {
+        if (mtdev->caps.has_abs[i]) {
+            switch (i) {
+                /* X and Y axis info is handed by synaptics already */
+            case ABS_MT_POSITION_X - ABS_MT_TOUCH_MAJOR:
+            case ABS_MT_POSITION_Y - ABS_MT_TOUCH_MAJOR:
+                /* Skip tracking ID info */
+            case ABS_MT_TRACKING_ID - ABS_MT_TOUCH_MAJOR:
+                break;
+            default:
+                priv->num_mt_axes++;
+                break;
+            }
+            priv->has_touch = TRUE;
+        }
+    }
+
+    if (priv->has_touch) {
+        int axnum;
+
+        static const char *labels[] = {
+            AXIS_LABEL_PROP_ABS_MT_TOUCH_MAJOR,
+            AXIS_LABEL_PROP_ABS_MT_TOUCH_MINOR,
+            AXIS_LABEL_PROP_ABS_MT_WIDTH_MAJOR,
+            AXIS_LABEL_PROP_ABS_MT_WIDTH_MINOR,
+            AXIS_LABEL_PROP_ABS_MT_ORIENTATION,
+            AXIS_LABEL_PROP_ABS_MT_POSITION_X,
+            AXIS_LABEL_PROP_ABS_MT_POSITION_Y,
+            AXIS_LABEL_PROP_ABS_MT_TOOL_TYPE,
+            AXIS_LABEL_PROP_ABS_MT_BLOB_ID,
+            AXIS_LABEL_PROP_ABS_MT_TRACKING_ID,
+            AXIS_LABEL_PROP_ABS_MT_PRESSURE,
+        };
+
+        if (mtdev->caps.slot.maximum > 0)
+            priv->max_touches = mtdev->caps.slot.maximum -
+                mtdev->caps.slot.minimum + 1;
+
+        priv->touch_axes = malloc(priv->num_mt_axes *
+                                  sizeof(SynapticsTouchAxisRec));
+        if (!priv->touch_axes) {
+            priv->has_touch = FALSE;
+            goto out;
+        }
+
+        axnum = 0;
+        for (i = 0; i < MT_ABS_SIZE; i++) {
+            if (mtdev->caps.has_abs[i]) {
+                switch (i) {
+                    /* X and Y axis info is handed by synaptics already, we just
+                     * need to map the evdev codes to the valuator numbers */
+                case ABS_MT_POSITION_X - ABS_MT_TOUCH_MAJOR:
+                    proto_data->axis_map[i] = 0;
+                    break;
+
+                case ABS_MT_POSITION_Y - ABS_MT_TOUCH_MAJOR:
+                    proto_data->axis_map[i] = 1;
+                    break;
+
+                    /* Skip tracking ID info */
+                case ABS_MT_TRACKING_ID - ABS_MT_TOUCH_MAJOR:
+                    break;
+
+                default:
+                    priv->touch_axes[axnum].label = labels[i];
+                    priv->touch_axes[axnum].min = mtdev->caps.abs[i].minimum;
+                    priv->touch_axes[axnum].max = mtdev->caps.abs[i].maximum;
+                    /* Kernel provides units/mm, X wants units/m */
+                    priv->touch_axes[axnum].res =
+                        mtdev->caps.abs[i].resolution * 1000;
+                    /* Valuators 0-3 are used for X, Y, and scrolling */
+                    proto_data->axis_map[i] = 4 + axnum;
+                    axnum++;
+                    break;
+                }
+            }
+        }
+    }
+
+ out:
+    mtdev_close_delete(mtdev);
+}
+
+/**
+ * Probe the open device for dimensions.
+ */
+static void
+EventReadDevDimensions(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    struct eventcomm_proto_data *proto_data = priv->proto_data;
+    int i;
+
+    proto_data = EventProtoDataAlloc();
+    priv->proto_data = proto_data;
+
+    for (i = 0; i < MT_ABS_SIZE; i++)
+        proto_data->axis_map[i] = -1;
+    proto_data->cur_slot = -1;
+
+    if (event_query_is_touchpad(pInfo->fd, proto_data->need_grab)) {
+        event_query_touch(pInfo);
+        event_query_axis_ranges(pInfo);
+    }
+    event_query_model(pInfo->fd, &priv->model, &priv->id_vendor,
+                      &priv->id_product);
+
+    xf86IDrvMsg(pInfo, X_PROBED, "Vendor %#hx Product %#hx\n",
+                priv->id_vendor, priv->id_product);
+}
+
+static Bool
+EventAutoDevProbe(InputInfoPtr pInfo, const char *device)
+{
+    /* We are trying to find the right eventX device or fall back to
+       the psaux protocol and the given device from XF86Config */
+    int i;
+    Bool touchpad_found = FALSE;
+    struct dirent **namelist;
+
+    if (device) {
+        int fd = -1;
+
+        SYSCALL(fd = open(device, O_RDONLY));
+        if (fd >= 0) {
+            touchpad_found = event_query_is_touchpad(fd, TRUE);
+
+            SYSCALL(close(fd));
+            /* if a device is set and not a touchpad (or already grabbed),
+             * we must return FALSE.  Otherwise, we'll add a device that
+             * wasn't requested for and repeat
+             * f5687a6741a19ef3081e7fd83ac55f6df8bcd5c2. */
+            return touchpad_found;
+        }
+    }
+
+    i = scandir(DEV_INPUT_EVENT, &namelist, EventDevOnly, alphasort);
+    if (i < 0) {
+        xf86IDrvMsg(pInfo, X_ERROR, "Couldn't open %s\n", DEV_INPUT_EVENT);
+        return FALSE;
+    }
+    else if (i == 0) {
+        xf86IDrvMsg(pInfo, X_ERROR,
+                    "The /dev/input/event* device nodes seem to be missing\n");
+        free(namelist);
+        return FALSE;
+    }
+
+    while (i--) {
+        char fname[64];
+        int fd = -1;
+
+        if (!touchpad_found) {
+            sprintf(fname, "%s/%s", DEV_INPUT_EVENT, namelist[i]->d_name);
+            SYSCALL(fd = open(fname, O_RDONLY));
+            if (fd < 0)
+                continue;
+
+            if (event_query_is_touchpad(fd, TRUE)) {
+                touchpad_found = TRUE;
+                xf86IDrvMsg(pInfo, X_PROBED, "auto-dev sets device to %s\n",
+                            fname);
+                pInfo->options =
+                    xf86ReplaceStrOption(pInfo->options, "Device", fname);
+            }
+            SYSCALL(close(fd));
+        }
+        free(namelist[i]);
+    }
+
+    free(namelist);
+
+    if (!touchpad_found) {
+        xf86IDrvMsg(pInfo, X_ERROR, "no synaptics event device found\n");
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+struct SynapticsProtocolOperations event_proto_operations = {
+    EventDeviceOnHook,
+    EventDeviceOffHook,
+    EventQueryHardware,
+    EventReadHwState,
+    EventAutoDevProbe,
+    EventReadDevDimensions
+};
diff -urN xf86-input-evdev-2.8.2.old/src/eventcomm.h xf86-input-evdev-2.8.2/src/eventcomm.h
--- xf86-input-evdev-2.8.2.old/src/eventcomm.h	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/eventcomm.h	2013-12-06 19:11:54.536035314 +0900
@@ -0,0 +1,47 @@
+/*
+ * Copyright © 2004 Peter Osterlund
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Red Hat
+ * not be used in advertising or publicity pertaining to distribution
+ * of the software without specific, written prior permission.  Red
+ * Hat makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Peter Osterlund (petero2@telia.com)
+ */
+
+#ifndef _EVENTCOMM_H_
+#define _EVENTCOMM_H_
+
+#include <linux/input.h>
+#include <linux/version.h>
+#include <xf86Xinput.h>
+#include "synproto.h"
+
+/* for auto-dev: */
+#define DEV_INPUT_EVENT "/dev/input"
+#define EVENT_DEV_NAME "event"
+
+struct eventcomm_proto_data;
+
+extern struct eventcomm_proto_data *EventProtoDataAlloc(void);
+
+extern Bool
+EventReadHwState(InputInfoPtr pInfo,
+                 struct CommData *comm, struct SynapticsHwState *hwRet);
+
+#endif                          /* _EVENTCOMM_H_ */
diff -urN xf86-input-evdev-2.8.2.old/src/properties.c xf86-input-evdev-2.8.2/src/properties.c
--- xf86-input-evdev-2.8.2.old/src/properties.c	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/properties.c	2013-12-06 19:11:54.536035314 +0900
@@ -0,0 +1,722 @@
+/*
+ * Copyright © 2008-2012 Red Hat, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Red Hat
+ * not be used in advertising or publicity pertaining to distribution
+ * of the software without specific, written prior permission.  Red
+ * Hat makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors: Peter Hutterer
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <xorg-server.h>
+#include "xf86Module.h"
+
+#include <X11/Xatom.h>
+#include <xf86.h>
+#include <xf86Xinput.h>
+#include <exevents.h>
+
+#include "synapticsstr.h"
+#include "synaptics-properties.h"
+
+#ifndef XATOM_FLOAT
+#define XATOM_FLOAT "FLOAT"
+#endif
+
+#ifndef XI_PROP_PRODUCT_ID
+#define XI_PROP_PRODUCT_ID "Device Product ID"
+#endif
+
+#ifndef XI_PROP_DEVICE_NODE
+#define XI_PROP_DEVICE_NODE "Device Node"
+#endif
+
+static Atom float_type;
+
+Atom prop_edges = 0;
+Atom prop_finger = 0;
+Atom prop_tap_time = 0;
+Atom prop_tap_move = 0;
+Atom prop_tap_durations = 0;
+Atom prop_clickpad = 0;
+Atom prop_middle_timeout = 0;
+Atom prop_twofinger_pressure = 0;
+Atom prop_twofinger_width = 0;
+Atom prop_scrolldist = 0;
+Atom prop_scrolledge = 0;
+Atom prop_scrolltwofinger = 0;
+Atom prop_speed = 0;
+Atom prop_edgemotion_pressure = 0;
+Atom prop_edgemotion_speed = 0;
+Atom prop_edgemotion_always = 0;
+Atom prop_off = 0;
+Atom prop_lockdrags = 0;
+Atom prop_lockdrags_time = 0;
+Atom prop_tapaction = 0;
+Atom prop_clickaction = 0;
+Atom prop_circscroll = 0;
+Atom prop_circscroll_dist = 0;
+Atom prop_circscroll_trigger = 0;
+Atom prop_circpad = 0;
+Atom prop_palm = 0;
+Atom prop_palm_dim = 0;
+Atom prop_coastspeed = 0;
+Atom prop_pressuremotion = 0;
+Atom prop_pressuremotion_factor = 0;
+Atom prop_grab = 0;
+Atom prop_gestures = 0;
+Atom prop_capabilities = 0;
+Atom prop_resolution = 0;
+Atom prop_area = 0;
+Atom prop_softbutton_areas = 0;
+Atom prop_noise_cancellation = 0;
+Atom prop_product_id = 0;
+Atom prop_device_node = 0;
+
+static Atom
+InitTypedAtom(DeviceIntPtr dev, char *name, Atom type, int format, int nvalues,
+              int *values)
+{
+    int i;
+    Atom atom;
+    uint8_t val_8[9];           /* we never have more than 9 values in an atom */
+    uint16_t val_16[9];
+    uint32_t val_32[9];
+    pointer converted;
+
+    for (i = 0; i < nvalues; i++) {
+        switch (format) {
+        case 8:
+            val_8[i] = values[i];
+            break;
+        case 16:
+            val_16[i] = values[i];
+            break;
+        case 32:
+            val_32[i] = values[i];
+            break;
+        }
+    }
+
+    switch (format) {
+    case 8:
+        converted = val_8;
+        break;
+    case 16:
+        converted = val_16;
+        break;
+    case 32:
+        converted = val_32;
+        break;
+    }
+
+    atom = MakeAtom(name, strlen(name), TRUE);
+    XIChangeDeviceProperty(dev, atom, type, format, PropModeReplace, nvalues,
+                           converted, FALSE);
+    XISetDevicePropertyDeletable(dev, atom, FALSE);
+    return atom;
+}
+
+static Atom
+InitAtom(DeviceIntPtr dev, char *name, int format, int nvalues, int *values)
+{
+    return InitTypedAtom(dev, name, XA_INTEGER, format, nvalues, values);
+}
+
+static Atom
+InitFloatAtom(DeviceIntPtr dev, char *name, int nvalues, float *values)
+{
+    Atom atom;
+
+    atom = MakeAtom(name, strlen(name), TRUE);
+    XIChangeDeviceProperty(dev, atom, float_type, 32, PropModeReplace,
+                           nvalues, values, FALSE);
+    XISetDevicePropertyDeletable(dev, atom, FALSE);
+    return atom;
+}
+
+static void
+InitSoftButtonProperty(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
+    int values[8];
+
+    values[0] = para->softbutton_areas[0][0];
+    values[1] = para->softbutton_areas[0][1];
+    values[2] = para->softbutton_areas[0][2];
+    values[3] = para->softbutton_areas[0][3];
+    values[4] = para->softbutton_areas[1][0];
+    values[5] = para->softbutton_areas[1][1];
+    values[6] = para->softbutton_areas[1][2];
+    values[7] = para->softbutton_areas[1][3];
+    prop_softbutton_areas =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_SOFTBUTTON_AREAS, 32, 8, values);
+}
+
+void
+InitDeviceProperties(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
+    int values[9];              /* we never have more than 9 values in an atom */
+    float fvalues[4];           /* never have more than 4 float values */
+
+    float_type = XIGetKnownProperty(XATOM_FLOAT);
+    if (!float_type) {
+        float_type = MakeAtom(XATOM_FLOAT, strlen(XATOM_FLOAT), TRUE);
+        if (!float_type) {
+            xf86IDrvMsg(pInfo, X_ERROR, "Failed to init float atom. "
+                        "Disabling property support.\n");
+            return;
+        }
+    }
+
+    values[0] = para->left_edge;
+    values[1] = para->right_edge;
+    values[2] = para->top_edge;
+    values[3] = para->bottom_edge;
+
+    prop_edges = InitAtom(pInfo->dev, SYNAPTICS_PROP_EDGES, 32, 4, values);
+
+    values[0] = para->finger_low;
+    values[1] = para->finger_high;
+    values[2] = 0;
+
+    prop_finger = InitAtom(pInfo->dev, SYNAPTICS_PROP_FINGER, 32, 3, values);
+    prop_tap_time =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_TIME, 32, 1, &para->tap_time);
+    prop_tap_move =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_MOVE, 32, 1, &para->tap_move);
+
+    values[0] = para->single_tap_timeout;
+    values[1] = para->tap_time_2;
+    values[2] = para->click_time;
+
+    prop_tap_durations =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_DURATIONS, 32, 3, values);
+    prop_clickpad =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_CLICKPAD, 8, 1, &para->clickpad);
+    prop_middle_timeout =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_MIDDLE_TIMEOUT, 32, 1,
+                 &para->emulate_mid_button_time);
+    prop_twofinger_pressure =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_PRESSURE, 32, 1,
+                 &para->emulate_twofinger_z);
+    prop_twofinger_width =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_TWOFINGER_WIDTH, 32, 1,
+                 &para->emulate_twofinger_w);
+
+    values[0] = para->scroll_dist_vert;
+    values[1] = para->scroll_dist_horiz;
+    prop_scrolldist =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_DISTANCE, 32, 2, values);
+
+    values[0] = para->scroll_edge_vert;
+    values[1] = para->scroll_edge_horiz;
+    values[2] = para->scroll_edge_corner;
+    prop_scrolledge =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_EDGE, 8, 3, values);
+    values[0] = para->scroll_twofinger_vert;
+    values[1] = para->scroll_twofinger_horiz;
+    prop_scrolltwofinger =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_SCROLL_TWOFINGER, 8, 2, values);
+
+    fvalues[0] = para->min_speed;
+    fvalues[1] = para->max_speed;
+    fvalues[2] = para->accl;
+    fvalues[3] = 0;
+    prop_speed = InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_SPEED, 4, fvalues);
+
+    prop_off =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_OFF, 8, 1, &para->touchpad_off);
+    prop_lockdrags =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS, 8, 1,
+                 &para->locked_drags);
+    prop_lockdrags_time =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_LOCKED_DRAGS_TIMEOUT, 32, 1,
+                 &para->locked_drag_time);
+
+    memcpy(values, para->tap_action, MAX_TAP * sizeof(int));
+    prop_tapaction =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_TAP_ACTION, 8, MAX_TAP, values);
+
+    memcpy(values, para->click_action, MAX_CLICK * sizeof(int));
+    prop_clickaction =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_CLICK_ACTION, 8, MAX_CLICK, values);
+
+    prop_circscroll =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING, 8, 1,
+                 &para->circular_scrolling);
+
+    fvalues[0] = para->scroll_dist_circ;
+    prop_circscroll_dist =
+        InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_DIST, 1,
+                      fvalues);
+
+    prop_circscroll_trigger =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_CIRCULAR_SCROLLING_TRIGGER, 8, 1,
+                 &para->circular_trigger);
+    prop_palm =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DETECT, 8, 1,
+                 &para->palm_detect);
+
+    values[0] = para->palm_min_width;
+    values[1] = para->palm_min_z;
+
+    prop_palm_dim =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_PALM_DIMENSIONS, 32, 2, values);
+
+    fvalues[0] = para->coasting_speed;
+    fvalues[1] = para->coasting_friction;
+    prop_coastspeed =
+        InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_COASTING_SPEED, 2, fvalues);
+
+    values[0] = para->press_motion_min_z;
+    values[1] = para->press_motion_max_z;
+    prop_pressuremotion =
+        InitTypedAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION, XA_CARDINAL,
+                      32, 2, values);
+
+    fvalues[0] = para->press_motion_min_factor;
+    fvalues[1] = para->press_motion_max_factor;
+
+    prop_pressuremotion_factor =
+        InitFloatAtom(pInfo->dev, SYNAPTICS_PROP_PRESSURE_MOTION_FACTOR, 2,
+                      fvalues);
+
+    prop_grab =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_GRAB, 8, 1,
+                 &para->grab_event_device);
+
+    values[0] = para->tap_and_drag_gesture;
+    prop_gestures = InitAtom(pInfo->dev, SYNAPTICS_PROP_GESTURES, 8, 1, values);
+
+    values[0] = priv->has_left;
+    values[1] = priv->has_middle;
+    values[2] = priv->has_right;
+    values[3] = priv->has_double;
+    values[4] = priv->has_triple;
+    values[5] = priv->has_pressure;
+    values[6] = priv->has_width;
+    prop_capabilities =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_CAPABILITIES, 8, 7, values);
+
+    values[0] = para->resolution_vert;
+    values[1] = para->resolution_horiz;
+    prop_resolution =
+        InitAtom(pInfo->dev, SYNAPTICS_PROP_RESOLUTION, 32, 2, values);
+
+    values[0] = para->area_left_edge;
+    values[1] = para->area_right_edge;
+    values[2] = para->area_top_edge;
+    values[3] = para->area_bottom_edge;
+    prop_area = InitAtom(pInfo->dev, SYNAPTICS_PROP_AREA, 32, 4, values);
+
+    if (para->clickpad)
+        InitSoftButtonProperty(pInfo);
+
+    values[0] = para->hyst_x;
+    values[1] = para->hyst_y;
+    prop_noise_cancellation = InitAtom(pInfo->dev,
+                                       SYNAPTICS_PROP_NOISE_CANCELLATION, 32, 2,
+                                       values);
+
+    /* only init product_id property if we actually know them */
+    if (priv->id_vendor || priv->id_product) {
+        values[0] = priv->id_vendor;
+        values[1] = priv->id_product;
+        prop_product_id =
+            InitAtom(pInfo->dev, XI_PROP_PRODUCT_ID, 32, 2, values);
+    }
+
+    if (priv->device) {
+        prop_device_node =
+            MakeAtom(XI_PROP_DEVICE_NODE, strlen(XI_PROP_DEVICE_NODE), TRUE);
+        XIChangeDeviceProperty(pInfo->dev, prop_device_node, XA_STRING, 8,
+                               PropModeReplace, strlen(priv->device),
+                               (pointer) priv->device, FALSE);
+        XISetDevicePropertyDeletable(pInfo->dev, prop_device_node, FALSE);
+    }
+
+}
+
+int
+SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
+            BOOL checkonly)
+{
+    InputInfoPtr pInfo = dev->public.devicePrivate;
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
+    SynapticsParameters tmp;
+
+    /* If checkonly is set, no parameters may be changed. So just let the code
+     * change temporary variables and forget about it. */
+    if (checkonly) {
+        tmp = *para;
+        para = &tmp;
+    }
+
+    if (property == prop_edges) {
+        INT32 *edges;
+
+        if (prop->size != 4 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        edges = (INT32 *) prop->data;
+        if (edges[0] > edges[1] || edges[2] > edges[3])
+            return BadValue;
+
+        para->left_edge = edges[0];
+        para->right_edge = edges[1];
+        para->top_edge = edges[2];
+        para->bottom_edge = edges[3];
+
+    }
+    else if (property == prop_finger) {
+        INT32 *finger;
+
+        if (prop->size != 3 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        finger = (INT32 *) prop->data;
+        if (finger[0] > finger[1])
+            return BadValue;
+
+        para->finger_low = finger[0];
+        para->finger_high = finger[1];
+    }
+    else if (property == prop_tap_time) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->tap_time = *(INT32 *) prop->data;
+
+    }
+    else if (property == prop_tap_move) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->tap_move = *(INT32 *) prop->data;
+    }
+    else if (property == prop_tap_durations) {
+        INT32 *timeouts;
+
+        if (prop->size != 3 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        timeouts = (INT32 *) prop->data;
+
+        para->single_tap_timeout = timeouts[0];
+        para->tap_time_2 = timeouts[1];
+        para->click_time = timeouts[2];
+    }
+    else if (property == prop_clickpad) {
+        BOOL value;
+
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        value = *(BOOL *) prop->data;
+        if (!para->clickpad && value && !prop_softbutton_areas)
+            InitSoftButtonProperty(pInfo);
+        else if (para->clickpad && !value && prop_softbutton_areas) {
+            XIDeleteDeviceProperty(dev, prop_softbutton_areas, FALSE);
+            prop_softbutton_areas = 0;
+        }
+
+        para->clickpad = *(BOOL *) prop->data;
+    }
+    else if (property == prop_middle_timeout) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->emulate_mid_button_time = *(INT32 *) prop->data;
+    }
+    else if (property == prop_twofinger_pressure) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->emulate_twofinger_z = *(INT32 *) prop->data;
+    }
+    else if (property == prop_twofinger_width) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->emulate_twofinger_w = *(INT32 *) prop->data;
+    }
+    else if (property == prop_scrolldist) {
+        INT32 *dist;
+
+        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        dist = (INT32 *) prop->data;
+        if (dist[0] == 0 || dist[1] == 0)
+            return BadValue;
+
+        if (para->scroll_dist_vert != dist[0]) {
+            para->scroll_dist_vert = dist[0];
+            SetScrollValuator(dev, priv->scroll_axis_vert, SCROLL_TYPE_VERTICAL,
+                              para->scroll_dist_vert, 0);
+        }
+        if (para->scroll_dist_horiz != dist[1]) {
+            para->scroll_dist_horiz = dist[1];
+            SetScrollValuator(dev, priv->scroll_axis_horiz,
+                              SCROLL_TYPE_HORIZONTAL, para->scroll_dist_horiz,
+                              0);
+        }
+    }
+    else if (property == prop_scrolledge) {
+        CARD8 *edge;
+
+        if (prop->size != 3 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        edge = (BOOL *) prop->data;
+        para->scroll_edge_vert = edge[0];
+        para->scroll_edge_horiz = edge[1];
+        para->scroll_edge_corner = edge[2];
+    }
+    else if (property == prop_scrolltwofinger) {
+        CARD8 *twofinger;
+
+        if (prop->size != 2 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        twofinger = (BOOL *) prop->data;
+        para->scroll_twofinger_vert = twofinger[0];
+        para->scroll_twofinger_horiz = twofinger[1];
+    }
+    else if (property == prop_speed) {
+        float *speed;
+
+        if (prop->size != 4 || prop->format != 32 || prop->type != float_type)
+            return BadMatch;
+
+        speed = (float *) prop->data;
+        para->min_speed = speed[0];
+        para->max_speed = speed[1];
+        para->accl = speed[2];
+    }
+    else if (property == prop_off) {
+        CARD8 off;
+
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        off = *(CARD8 *) prop->data;
+
+        if (off > 2)
+            return BadValue;
+
+        para->touchpad_off = off;
+    }
+    else if (property == prop_gestures) {
+        BOOL *gestures;
+
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        gestures = (BOOL *) prop->data;
+        para->tap_and_drag_gesture = gestures[0];
+    }
+    else if (property == prop_lockdrags) {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->locked_drags = *(BOOL *) prop->data;
+    }
+    else if (property == prop_lockdrags_time) {
+        if (prop->size != 1 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->locked_drag_time = *(INT32 *) prop->data;
+    }
+    else if (property == prop_tapaction) {
+        int i;
+        CARD8 *action;
+
+        if (prop->size > MAX_TAP || prop->format != 8 ||
+            prop->type != XA_INTEGER)
+            return BadMatch;
+
+        action = (CARD8 *) prop->data;
+
+        for (i = 0; i < MAX_TAP; i++)
+            para->tap_action[i] = action[i];
+    }
+    else if (property == prop_clickaction) {
+        int i;
+        CARD8 *action;
+
+        if (prop->size > MAX_CLICK || prop->format != 8 ||
+            prop->type != XA_INTEGER)
+            return BadMatch;
+
+        action = (CARD8 *) prop->data;
+
+        for (i = 0; i < MAX_CLICK; i++)
+            para->click_action[i] = action[i];
+    }
+    else if (property == prop_circscroll) {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->circular_scrolling = *(BOOL *) prop->data;
+
+    }
+    else if (property == prop_circscroll_dist) {
+        float circdist;
+
+        if (prop->size != 1 || prop->format != 32 || prop->type != float_type)
+            return BadMatch;
+
+        circdist = *(float *) prop->data;
+        if (circdist == 0)
+            return BadValue;
+
+        para->scroll_dist_circ = circdist;
+    }
+    else if (property == prop_circscroll_trigger) {
+        int trigger;
+
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        trigger = *(CARD8 *) prop->data;
+        if (trigger > 8)
+            return BadValue;
+
+        para->circular_trigger = trigger;
+
+    }
+    else if (property == prop_palm) {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->palm_detect = *(BOOL *) prop->data;
+    }
+    else if (property == prop_palm_dim) {
+        INT32 *dim;
+
+        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        dim = (INT32 *) prop->data;
+
+        para->palm_min_width = dim[0];
+        para->palm_min_z = dim[1];
+    }
+    else if (property == prop_coastspeed) {
+        float *coast_speeds;
+
+        if (prop->size != 2 || prop->format != 32 || prop->type != float_type)
+            return BadMatch;
+
+        coast_speeds = (float *) prop->data;
+        para->coasting_speed = coast_speeds[0];
+        para->coasting_friction = coast_speeds[1];
+    }
+    else if (property == prop_pressuremotion) {
+        CARD32 *press;
+
+        if (prop->size != 2 || prop->format != 32 || prop->type != XA_CARDINAL)
+            return BadMatch;
+
+        press = (CARD32 *) prop->data;
+        if (press[0] > press[1])
+            return BadValue;
+
+        para->press_motion_min_z = press[0];
+        para->press_motion_max_z = press[1];
+    }
+    else if (property == prop_grab) {
+        if (prop->size != 1 || prop->format != 8 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        para->grab_event_device = *(BOOL *) prop->data;
+    }
+    else if (property == prop_capabilities) {
+        /* read-only */
+        return BadValue;
+    }
+    else if (property == prop_resolution) {
+        /* read-only */
+        return BadValue;
+    }
+    else if (property == prop_area) {
+        INT32 *area;
+
+        if (prop->size != 4 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        area = (INT32 *) prop->data;
+        if ((((area[0] != 0) && (area[1] != 0)) && (area[0] > area[1])) ||
+            (((area[2] != 0) && (area[3] != 0)) && (area[2] > area[3])))
+            return BadValue;
+
+        para->area_left_edge = area[0];
+        para->area_right_edge = area[1];
+        para->area_top_edge = area[2];
+        para->area_bottom_edge = area[3];
+    }
+    else if (property == prop_softbutton_areas) {
+        int *areas;
+
+        if (prop->size != 8 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        areas = (int *) prop->data;
+        if (!SynapticsIsSoftButtonAreasValid(areas))
+            return BadValue;
+
+        memcpy(para->softbutton_areas[0], areas, 4 * sizeof(int));
+        memcpy(para->softbutton_areas[1], areas + 4, 4 * sizeof(int));
+    }
+    else if (property == prop_noise_cancellation) {
+        INT32 *hyst;
+
+        if (prop->size != 2 || prop->format != 32 || prop->type != XA_INTEGER)
+            return BadMatch;
+
+        hyst = (INT32 *) prop->data;
+        if (hyst[0] < 0 || hyst[1] < 0)
+            return BadValue;
+        para->hyst_x = hyst[0];
+        para->hyst_y = hyst[1];
+    }
+    else if (property == prop_product_id || property == prop_device_node)
+        return BadValue;        /* read-only */
+    else { /* unknown property */
+        if (strcmp(SYNAPTICS_PROP_SOFTBUTTON_AREAS, NameForAtom(property)) == 0)
+        {
+            prop_softbutton_areas = property;
+            if (SetProperty(dev, property, prop, checkonly) != Success)
+                prop_softbutton_areas = 0;
+            else if (!checkonly)
+                XISetDevicePropertyDeletable(dev, property, FALSE);
+        }
+    }
+
+    return Success;
+}
diff -urN xf86-input-evdev-2.8.2.old/src/synaptics.c xf86-input-evdev-2.8.2/src/synaptics.c
--- xf86-input-evdev-2.8.2.old/src/synaptics.c	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/synaptics.c	2013-12-06 19:17:08.211204369 +0900
@@ -0,0 +1,3038 @@
+/*
+ * Copyright © 1999 Henry Davies
+ * Copyright © 2001 Stefan Gmeiner
+ * Copyright © 2002 S. Lehner
+ * Copyright © 2002 Peter Osterlund
+ * Copyright © 2002 Linuxcare Inc. David Kennedy
+ * Copyright © 2003 Hartwig Felger
+ * Copyright © 2003 Jörg Bösner
+ * Copyright © 2003 Fred Hucht
+ * Copyright © 2004 Alexei Gilchrist
+ * Copyright © 2004 Matthias Ihmig
+ * Copyright © 2006 Stefan Bethge
+ * Copyright © 2006 Christian Thaeter
+ * Copyright © 2007 Joseph P. Skudlarek
+ * Copyright © 2008 Fedor P. Goncharov
+ * Copyright © 2008-2012 Red Hat, Inc.
+ * Copyright © 2011 The Chromium OS Authors
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Red Hat
+ * not be used in advertising or publicity pertaining to distribution
+ * of the software without specific, written prior permission.  Red
+ * Hat makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Joseph P. Skudlarek <Jskud@Jskud.com>
+ *      Christian Thaeter <chth@gmx.net>
+ *      Stefan Bethge <stefan.bethge@web.de>
+ *      Matthias Ihmig <m.ihmig@gmx.net>
+ *      Alexei Gilchrist <alexei@physics.uq.edu.au>
+ *      Jörg Bösner <ich@joerg-boesner.de>
+ *      Hartwig Felger <hgfelger@hgfelger.de>
+ *      Peter Osterlund <petero2@telia.com>
+ *      S. Lehner <sam_x@bluemail.ch>
+ *      Stefan Gmeiner <riddlebox@freesurf.ch>
+ *      Henry Davies <hdavies@ameritech.net> for the
+ *      Linuxcare Inc. David Kennedy <dkennedy@linuxcare.com>
+ *      Fred Hucht <fred@thp.Uni-Duisburg.de>
+ *      Fedor P. Goncharov <fedgo@gorodok.net>
+ *      Simon Thum <simon.thum@gmx.de>
+ *
+ * Trademarks are the property of their respective owners.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#define BUILD_EVENTCOMM 1
+
+#include <xorg-server.h>
+#include <unistd.h>
+#include <misc.h>
+#include <xf86.h>
+#include <math.h>
+#include <stdio.h>
+#include <xf86_OSproc.h>
+#include <xf86Xinput.h>
+#include <exevents.h>
+
+#include <X11/Xatom.h>
+#include <X11/extensions/XI2.h>
+#include <xserver-properties.h>
+#include <ptrveloc.h>
+
+#include "synapticsstr.h"
+#include "synaptics-properties.h"
+
+extern InputInfoPtr trackpoint;
+extern BOOL
+EvdevWheelEmuFilterButton(InputInfoPtr pInfo, unsigned int button, int value);
+void
+EvdevProcessSyncEvent(InputInfoPtr pInfo, struct input_event *ev);
+
+enum EdgeType {
+    NO_EDGE = 0,
+    BOTTOM_EDGE = 1,
+    TOP_EDGE = 2,
+    LEFT_EDGE = 4,
+    RIGHT_EDGE = 8,
+    LEFT_BOTTOM_EDGE = BOTTOM_EDGE | LEFT_EDGE,
+    RIGHT_BOTTOM_EDGE = BOTTOM_EDGE | RIGHT_EDGE,
+    RIGHT_TOP_EDGE = TOP_EDGE | RIGHT_EDGE,
+    LEFT_TOP_EDGE = TOP_EDGE | LEFT_EDGE
+};
+
+/*
+ * We expect to be receiving a steady 80 packets/sec (which gives 40
+ * reports/sec with more than one finger on the pad, as Advanced Gesture Mode
+ * requires two PS/2 packets per report).  Instead of a random scattering of
+ * magic 13 and 20ms numbers scattered throughout the driver, introduce
+ * POLL_MS as 14ms, which is slightly less than 80Hz.  13ms is closer to
+ * 80Hz, but if the kernel event reporting was even slightly delayed,
+ * we would produce synthetic motion followed immediately by genuine
+ * motion, so use 14.
+ *
+ * We use this to call back at a constant rate to at least produce the
+ * illusion of smooth motion.  It works a lot better than you'd expect.
+*/
+#define POLL_MS 14
+
+#define MAX(a, b) (((a)>(b))?(a):(b))
+#define MIN(a, b) (((a)<(b))?(a):(b))
+#define TIME_DIFF(a, b) ((int)((a)-(b)))
+
+#define SQR(x) ((x) * (x))
+
+#ifndef M_PI
+#define M_PI 3.14159265358979323846
+#endif
+
+#define INPUT_BUFFER_SIZE 200
+
+/*****************************************************************************
+ * Forward declaration
+ ****************************************************************************/
+int SynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
+void SynapticsUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags);
+static Bool DeviceControl(DeviceIntPtr, int);
+static void ReadInput(InputInfoPtr);
+static int HandleState(InputInfoPtr, struct SynapticsHwState *, CARD32 now,
+                       Bool from_timer);
+static int ControlProc(InputInfoPtr, xDeviceCtl *);
+static int SwitchMode(ClientPtr, DeviceIntPtr, int);
+static int DeviceInit(DeviceIntPtr);
+static int DeviceOn(DeviceIntPtr);
+static int DeviceOff(DeviceIntPtr);
+static int DeviceClose(DeviceIntPtr);
+static Bool QueryHardware(InputInfoPtr);
+static void ReadDevDimensions(InputInfoPtr);
+static void ScaleCoordinates(SynapticsPrivate * priv,
+                             struct SynapticsHwState *hw);
+static void CalculateScalingCoeffs(SynapticsPrivate * priv);
+static void SanitizeDimensions(InputInfoPtr pInfo);
+
+void InitDeviceProperties(InputInfoPtr pInfo);
+int SetProperty(DeviceIntPtr dev, Atom property, XIPropertyValuePtr prop,
+                BOOL checkonly);
+
+const static struct {
+    const char *name;
+    struct SynapticsProtocolOperations *proto_ops;
+} protocols[] = {
+#ifdef BUILD_EVENTCOMM
+    { "event", &event_proto_operations },
+#endif
+#ifdef BUILD_PSMCOMM
+    { "psm", &psm_proto_operations },
+#endif
+#ifdef BUILD_PS2COMM
+    { "psaux", &psaux_proto_operations },
+    { "alps", &alps_proto_operations },
+#endif
+    { NULL, NULL }
+};
+
+InputDriverRec SYNAPTICS = {
+    1,
+    "synaptics",
+    NULL,
+    SynapticsPreInit,
+    SynapticsUnInit,
+    NULL,
+};
+
+static XF86ModuleVersionInfo VersionRec = {
+    "synaptics",
+    MODULEVENDORSTRING,
+    MODINFOSTRING1,
+    MODINFOSTRING2,
+    XORG_VERSION_CURRENT,
+    PACKAGE_VERSION_MAJOR, PACKAGE_VERSION_MINOR, PACKAGE_VERSION_PATCHLEVEL,
+    ABI_CLASS_XINPUT,
+    ABI_XINPUT_VERSION,
+    MOD_CLASS_XINPUT,
+    {0, 0, 0, 0}
+};
+
+static pointer
+SetupProc(pointer module, pointer options, int *errmaj, int *errmin)
+{
+    xf86AddInputDriver(&SYNAPTICS, module, 0);
+    return module;
+}
+
+_X_EXPORT XF86ModuleData synapticsModuleData = {
+    &VersionRec,
+    &SetupProc,
+    NULL
+};
+
+/*****************************************************************************
+ *	Function Definitions
+ ****************************************************************************/
+/**
+ * Fill in default dimensions for backends that cannot query the hardware.
+ * Eventually, we want the edges to be 1900/5400 for x, 1900/4000 for y.
+ * These values are based so that calculate_edge_widths() will give us the
+ * right values.
+ *
+ * The default values 1900, etc. come from the dawn of time, when men where
+ * men, or possibly apes.
+ */
+static void
+SanitizeDimensions(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+
+    if (priv->minx >= priv->maxx) {
+        priv->minx = 1615;
+        priv->maxx = 5685;
+        priv->resx = 0;
+
+        xf86IDrvMsg(pInfo, X_PROBED,
+                    "invalid x-axis range.  defaulting to %d - %d\n",
+                    priv->minx, priv->maxx);
+    }
+
+    if (priv->miny >= priv->maxy) {
+        priv->miny = 1729;
+        priv->maxy = 4171;
+        priv->resy = 0;
+
+        xf86IDrvMsg(pInfo, X_PROBED,
+                    "invalid y-axis range.  defaulting to %d - %d\n",
+                    priv->miny, priv->maxy);
+    }
+
+    if (priv->minp >= priv->maxp) {
+        priv->minp = 0;
+        priv->maxp = 255;
+
+        xf86IDrvMsg(pInfo, X_PROBED,
+                    "invalid pressure range.  defaulting to %d - %d\n",
+                    priv->minp, priv->maxp);
+    }
+
+    if (priv->minw >= priv->maxw) {
+        priv->minw = 0;
+        priv->maxw = 15;
+
+        xf86IDrvMsg(pInfo, X_PROBED,
+                    "invalid finger width range.  defaulting to %d - %d\n",
+                    priv->minw, priv->maxw);
+    }
+}
+
+static Bool
+SetDeviceAndProtocol(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = pInfo->private;
+    char *proto, *device;
+    int i;
+
+    proto = xf86SetStrOption(pInfo->options, "Protocol", NULL);
+    device = xf86SetStrOption(pInfo->options, "Device", NULL);
+
+    /* If proto is auto-dev, unset and let the code do the rest */
+    if (proto && !strcmp(proto, "auto-dev")) {
+        free(proto);
+        proto = NULL;
+    }
+
+    for (i = 0; protocols[i].name; i++) {
+        if ((!device || !proto) &&
+            protocols[i].proto_ops->AutoDevProbe &&
+            protocols[i].proto_ops->AutoDevProbe(pInfo, device))
+            break;
+        else if (proto && !strcmp(proto, protocols[i].name))
+            break;
+    }
+    free(proto);
+    free(device);
+
+    priv->proto_ops = protocols[i].proto_ops;
+
+    return (priv->proto_ops != NULL);
+}
+
+static void
+calculate_edge_widths(SynapticsPrivate * priv, int *l, int *r, int *t, int *b)
+{
+    int width, height;
+    int ewidth, eheight;        /* edge width/height */
+
+    width = abs(priv->maxx - priv->minx);
+    height = abs(priv->maxy - priv->miny);
+
+    if (priv->model == MODEL_SYNAPTICS) {
+        ewidth = width * .07;
+        eheight = height * .07;
+    }
+    else if (priv->model == MODEL_ALPS) {
+        ewidth = width * .15;
+        eheight = height * .15;
+    }
+    else if (priv->model == MODEL_APPLETOUCH ||
+             priv->model == MODEL_UNIBODY_MACBOOK) {
+        ewidth = width * .085;
+        eheight = height * .085;
+    }
+    else {
+        ewidth = width * .04;
+        eheight = height * .054;
+    }
+
+    *l = priv->minx + ewidth;
+    *r = priv->maxx - ewidth;
+    *t = priv->miny + eheight;
+    *b = priv->maxy - eheight;
+}
+
+static void
+calculate_tap_hysteresis(SynapticsPrivate * priv, int range,
+                         int *fingerLow, int *fingerHigh)
+{
+    switch (priv->model) {
+    case MODEL_ELANTECH:
+        /* All Elantech touchpads don't need the Z filtering to get the
+         * number of fingers correctly. See Documentation/elantech.txt
+         * in the kernel.
+         */
+        *fingerLow = priv->minp + 1;
+        *fingerHigh = priv->minp + 1;
+        break;
+    case MODEL_UNIBODY_MACBOOK:
+        *fingerLow = 70;
+        *fingerHigh = 75;
+        break;
+    default:
+        *fingerLow = priv->minp + range * (25.0 / 256);
+        *fingerHigh = priv->minp + range * (30.0 / 256);
+        break;
+    }
+}
+
+/* Area options support both percent values and absolute values. This is
+ * awkward. The xf86Set* calls will print to the log, but they'll
+ * also print an error if we request a percent value but only have an
+ * int. So - check first for percent, then call xf86Set* again to get
+ * the log message.
+ */
+static int
+set_percent_option(pointer options, const char *optname,
+                   const int range, const int offset, const int default_value)
+{
+    int result;
+    double percent = xf86CheckPercentOption(options, optname, -1);
+
+    if (percent >= 0.0) {
+        percent = xf86SetPercentOption(options, optname, -1);
+        result = percent / 100.0 * range + offset;
+    } else
+        result = xf86SetIntOption(options, optname, default_value);
+
+    return result;
+}
+
+Bool
+SynapticsIsSoftButtonAreasValid(int *values)
+{
+    Bool right_disabled = FALSE;
+    Bool middle_disabled = FALSE;
+
+    enum {
+        /* right button left, right, top, bottom */
+        RBL = 0,
+        RBR = 1,
+        RBT = 2,
+        RBB = 3,
+        /* middle button left, right, top, bottom */
+        MBL = 4,
+        MBR = 5,
+        MBT = 6,
+        MBB = 7,
+    };
+
+    /* Check right button area */
+    if ((((values[RBL] != 0) && (values[RBR] != 0)) && (values[RBL] > values[RBR])) ||
+        (((values[RBT] != 0) && (values[RBB] != 0)) && (values[RBT] > values[RBB])))
+        return FALSE;
+
+    /* Check middle button area */
+    if ((((values[MBL] != 0) && (values[MBR] != 0)) && (values[MBL] > values[MBR])) ||
+        (((values[MBT] != 0) && (values[MBB] != 0)) && (values[MBT] > values[MBB])))
+        return FALSE;
+
+    if (values[RBL] == 0 && values[RBR] == 0 && values[RBT] == 0 && values[RBB] == 0)
+        right_disabled = TRUE;
+
+    if (values[MBL] == 0 && values[MBR] == 0 && values[MBT] == 0 && values[MBB] == 0)
+        middle_disabled = TRUE;
+
+    if (!right_disabled &&
+        ((values[RBL] && values[RBL] == values[RBR]) ||
+         (values[RBT] && values[RBT] == values[RBB])))
+        return FALSE;
+
+    if (!middle_disabled &&
+        ((values[MBL] && values[MBL] == values[MBR]) ||
+         (values[MBT] && values[MBT] == values[MBB])))
+        return FALSE;
+
+    /* Check for overlapping button areas */
+    if (!right_disabled && !middle_disabled) {
+        int right_left = values[RBL] ? values[RBL] : INT_MIN;
+        int right_right = values[RBR] ? values[RBR] : INT_MAX;
+        int right_top = values[RBT] ? values[RBT] : INT_MIN;
+        int right_bottom = values[RBB] ? values[RBB] : INT_MAX;
+        int middle_left = values[MBL] ? values[MBL] : INT_MIN;
+        int middle_right = values[MBR] ? values[MBR] : INT_MAX;
+        int middle_top = values[MBT] ? values[MBT] : INT_MIN;
+        int middle_bottom = values[MBB] ? values[MBB] : INT_MAX;
+
+        /* If areas overlap in the Y axis */
+        if ((right_bottom <= middle_bottom && right_bottom >= middle_top) ||
+            (right_top <= middle_bottom && right_top >= middle_top)) {
+            /* Check for overlapping left edges */
+            if ((right_left < middle_left && right_right > middle_left) ||
+                (middle_left < right_left && middle_right > right_left))
+                return FALSE;
+
+            /* Check for overlapping right edges */
+            if ((right_right > middle_right && right_left < middle_right) ||
+                (middle_right > right_right && middle_left < right_right))
+                return FALSE;
+        }
+
+        /* If areas overlap in the X axis */
+        if ((right_left >= middle_left && right_left <= middle_right) ||
+            (right_right >= middle_left && right_right <= middle_right)) {
+            /* Check for overlapping top edges */
+            if ((right_top < middle_top && right_bottom > middle_top) ||
+                (middle_top < right_top && middle_bottom > right_top))
+                return FALSE;
+
+            /* Check for overlapping bottom edges */
+            if ((right_bottom > middle_bottom && right_top < middle_bottom) ||
+                (middle_bottom > right_bottom && middle_top < right_bottom))
+                return FALSE;
+        }
+    }
+
+    return TRUE;
+}
+
+static void
+set_softbutton_areas_option(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = pInfo->private;
+    SynapticsParameters *pars = &priv->synpara;
+    int values[8];
+    int in_percent = 0;         /* bitmask for which ones are in % */
+    char *option_string;
+    char *next_num;
+    char *end_str;
+    int i;
+    int width, height;
+
+    if (!pars->clickpad)
+        return;
+
+    option_string = xf86SetStrOption(pInfo->options, "SoftButtonAreas", NULL);
+    if (!option_string)
+        return;
+
+    next_num = option_string;
+
+    for (i = 0; i < 8 && *next_num != '\0'; i++) {
+        long int value = strtol(next_num, &end_str, 0);
+
+        if (value > INT_MAX || value < -INT_MAX)
+            goto fail;
+
+        values[i] = value;
+
+        if (next_num != end_str) {
+            if (end_str && *end_str == '%') {
+                in_percent |= 1 << i;
+                end_str++;
+            }
+            next_num = end_str;
+        }
+        else
+            goto fail;
+    }
+
+    if (i < 8 || *next_num != '\0')
+        goto fail;
+
+    width = priv->maxx - priv->minx;
+    height = priv->maxy - priv->miny;
+
+    for (i = 0; in_percent && i < 8; i++) {
+        int base, size;
+
+        if ((in_percent & (1 << i)) == 0 || values[i] == 0)
+            continue;
+
+        size = ((i % 4) < 2) ? width : height;
+        base = ((i % 4) < 2) ? priv->minx : priv->miny;
+        values[i] = base + size * values[i] / 100.0;
+    }
+
+    if (!SynapticsIsSoftButtonAreasValid(values))
+        goto fail;
+
+    memcpy(pars->softbutton_areas[0], values, 4 * sizeof(int));
+    memcpy(pars->softbutton_areas[1], values + 4, 4 * sizeof(int));
+
+    free(option_string);
+
+    return;
+
+ fail:
+    xf86IDrvMsg(pInfo, X_ERROR,
+                "invalid SoftButtonAreas value '%s', keeping defaults\n",
+                option_string);
+    free(option_string);
+}
+
+static void
+set_default_parameters(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = pInfo->private;    /* read-only */
+    pointer opts = pInfo->options;      /* read-only */
+    SynapticsParameters *pars = &priv->synpara; /* modified */
+
+    int horizScrollDelta, vertScrollDelta;      /* pixels */
+    int tapMove;                /* pixels */
+    int l, r, t, b;             /* left, right, top, bottom */
+    double accelFactor;         /* 1/pixels */
+    int fingerLow, fingerHigh;  /* pressure */
+    int emulateTwoFingerMinZ;   /* pressure */
+    int emulateTwoFingerMinW;   /* width */
+    int pressureMotionMinZ, pressureMotionMaxZ; /* pressure */
+    int palmMinWidth, palmMinZ; /* pressure */
+    int tapButton1, tapButton2, tapButton3;
+    int clickFinger1, clickFinger2, clickFinger3;
+    Bool vertEdgeScroll, horizEdgeScroll;
+    Bool vertTwoFingerScroll, horizTwoFingerScroll;
+    int horizResolution = 1;
+    int vertResolution = 1;
+    int width, height, diag, range;
+    int horizHyst, vertHyst;
+    int middle_button_timeout;
+
+    /* The synaptics specs specify typical edge widths of 4% on x, and 5.4% on
+     * y (page 7) [Synaptics TouchPad Interfacing Guide, 510-000080 - A
+     * Second Edition, http://www.synaptics.com/support/dev_support.cfm, 8 Sep
+     * 2008]. We use 7% for both instead for synaptics devices, and 15% for
+     * ALPS models.
+     * http://bugs.freedesktop.org/show_bug.cgi?id=21214
+     *
+     * If the range was autodetected, apply these edge widths to all four
+     * sides.
+     */
+
+    width = abs(priv->maxx - priv->minx);
+    height = abs(priv->maxy - priv->miny);
+    diag = sqrt(width * width + height * height);
+
+    calculate_edge_widths(priv, &l, &r, &t, &b);
+
+    /* Again, based on typical x/y range and defaults */
+    horizScrollDelta = diag * .020;
+    vertScrollDelta = diag * .020;
+    tapMove = diag * .044;
+    accelFactor = 200.0 / diag; /* trial-and-error */
+
+    /* hysteresis, assume >= 0 is a detected value (e.g. evdev fuzz) */
+    horizHyst = pars->hyst_x >= 0 ? pars->hyst_x : diag * 0.005;
+    vertHyst = pars->hyst_y >= 0 ? pars->hyst_y : diag * 0.005;
+
+    range = priv->maxp - priv->minp + 1;
+
+    calculate_tap_hysteresis(priv, range, &fingerLow, &fingerHigh);
+
+    /* scaling based on defaults and a pressure of 256 */
+    emulateTwoFingerMinZ = priv->minp + range * (282.0 / 256);
+    pressureMotionMinZ = priv->minp + range * (30.0 / 256);
+    pressureMotionMaxZ = priv->minp + range * (160.0 / 256);
+    palmMinZ = priv->minp + range * (200.0 / 256);
+
+    range = priv->maxw - priv->minw + 1;
+
+    /* scaling based on defaults below and a tool width of 16 */
+    palmMinWidth = priv->minw + range * (10.0 / 16);
+    emulateTwoFingerMinW = priv->minw + range * (7.0 / 16);
+
+    /* Enable tap if we don't have a phys left button */
+    tapButton1 = priv->has_left ? 0 : 1;
+    tapButton2 = priv->has_left ? 0 : 3;
+    tapButton3 = priv->has_left ? 0 : 2;
+
+    /* Enable multifinger-click if only have one physical button,
+       otherwise clickFinger is always button 1. */
+    clickFinger1 = 1;
+    clickFinger2 = (priv->has_right || priv->has_middle) ? 1 : 3;
+    clickFinger3 = (priv->has_right || priv->has_middle) ? 1 : 2;
+
+    /* Enable vert edge scroll if we can't detect doubletap */
+    vertEdgeScroll = priv->has_double ? FALSE : TRUE;
+    horizEdgeScroll = FALSE;
+
+    /* Enable twofinger scroll if we can detect doubletap */
+    vertTwoFingerScroll = priv->has_double ? TRUE : FALSE;
+    horizTwoFingerScroll = FALSE;
+
+    /* Use resolution reported by hardware if available */
+    if ((priv->resx > 0) && (priv->resy > 0)) {
+        horizResolution = priv->resx;
+        vertResolution = priv->resy;
+    }
+
+    /* set the parameters */
+    pars->left_edge = xf86SetIntOption(opts, "LeftEdge", l);
+    pars->right_edge = xf86SetIntOption(opts, "RightEdge", r);
+    pars->top_edge = xf86SetIntOption(opts, "TopEdge", t);
+    pars->bottom_edge = xf86SetIntOption(opts, "BottomEdge", b);
+
+    pars->area_top_edge =
+        set_percent_option(opts, "AreaTopEdge", height, priv->miny, 0);
+    pars->area_bottom_edge =
+        set_percent_option(opts, "AreaBottomEdge", height, priv->miny, 0);
+    pars->area_left_edge =
+        set_percent_option(opts, "AreaLeftEdge", width, priv->minx, 0);
+    pars->area_right_edge =
+        set_percent_option(opts, "AreaRightEdge", width, priv->minx, 0);
+
+    pars->hyst_x =
+        set_percent_option(opts, "HorizHysteresis", width, 0, horizHyst);
+    pars->hyst_y =
+        set_percent_option(opts, "VertHysteresis", height, 0, vertHyst);
+
+    pars->finger_low = xf86SetIntOption(opts, "FingerLow", fingerLow);
+    pars->finger_high = xf86SetIntOption(opts, "FingerHigh", fingerHigh);
+    pars->tap_time = xf86SetIntOption(opts, "MaxTapTime", 180);
+    pars->tap_move = xf86SetIntOption(opts, "MaxTapMove", tapMove);
+    pars->tap_time_2 = xf86SetIntOption(opts, "MaxDoubleTapTime", 180);
+    pars->click_time = xf86SetIntOption(opts, "ClickTime", 100);
+    pars->clickpad = xf86SetBoolOption(opts, "ClickPad", pars->clickpad);       /* Probed */
+    /* middle mouse button emulation on a clickpad? nah, you're joking */
+    middle_button_timeout = pars->clickpad ? 0 : 75;
+    pars->emulate_mid_button_time =
+        xf86SetIntOption(opts, "EmulateMidButtonTime", middle_button_timeout);
+    pars->emulate_twofinger_z =
+        xf86SetIntOption(opts, "EmulateTwoFingerMinZ", emulateTwoFingerMinZ);
+    pars->emulate_twofinger_w =
+        xf86SetIntOption(opts, "EmulateTwoFingerMinW", emulateTwoFingerMinW);
+    pars->scroll_dist_vert =
+        xf86SetIntOption(opts, "VertScrollDelta", vertScrollDelta);
+    pars->scroll_dist_horiz =
+        xf86SetIntOption(opts, "HorizScrollDelta", horizScrollDelta);
+    pars->scroll_edge_vert =
+        xf86SetBoolOption(opts, "VertEdgeScroll", vertEdgeScroll);
+    pars->scroll_edge_horiz =
+        xf86SetBoolOption(opts, "HorizEdgeScroll", horizEdgeScroll);
+    pars->scroll_edge_corner = xf86SetBoolOption(opts, "CornerCoasting", FALSE);
+    pars->scroll_twofinger_vert =
+        xf86SetBoolOption(opts, "VertTwoFingerScroll", vertTwoFingerScroll);
+    pars->scroll_twofinger_horiz =
+        xf86SetBoolOption(opts, "HorizTwoFingerScroll", horizTwoFingerScroll);
+    pars->touchpad_off = xf86SetIntOption(opts, "TouchpadOff", TOUCHPAD_ON);
+    pars->locked_drags = xf86SetBoolOption(opts, "LockedDrags", FALSE);
+    pars->locked_drag_time = xf86SetIntOption(opts, "LockedDragTimeout", 5000);
+    pars->tap_action[RT_TAP] = xf86SetIntOption(opts, "RTCornerButton", 0);
+    pars->tap_action[RB_TAP] = xf86SetIntOption(opts, "RBCornerButton", 0);
+    pars->tap_action[LT_TAP] = xf86SetIntOption(opts, "LTCornerButton", 0);
+    pars->tap_action[LB_TAP] = xf86SetIntOption(opts, "LBCornerButton", 0);
+    pars->tap_action[F1_TAP] = xf86SetIntOption(opts, "TapButton1", tapButton1);
+    pars->tap_action[F2_TAP] = xf86SetIntOption(opts, "TapButton2", tapButton2);
+    pars->tap_action[F3_TAP] = xf86SetIntOption(opts, "TapButton3", tapButton3);
+    pars->click_action[F1_CLICK1] =
+        xf86SetIntOption(opts, "ClickFinger1", clickFinger1);
+    pars->click_action[F2_CLICK1] =
+        xf86SetIntOption(opts, "ClickFinger2", clickFinger2);
+    pars->click_action[F3_CLICK1] =
+        xf86SetIntOption(opts, "ClickFinger3", clickFinger3);
+    pars->circular_scrolling =
+        xf86SetBoolOption(opts, "CircularScrolling", FALSE);
+    pars->circular_trigger = xf86SetIntOption(opts, "CircScrollTrigger", 0);
+    pars->palm_detect = xf86SetBoolOption(opts, "PalmDetect", FALSE);
+    pars->palm_min_width = xf86SetIntOption(opts, "PalmMinWidth", palmMinWidth);
+    pars->palm_min_z = xf86SetIntOption(opts, "PalmMinZ", palmMinZ);
+    pars->single_tap_timeout = xf86SetIntOption(opts, "SingleTapTimeout", 180);
+    pars->press_motion_min_z =
+        xf86SetIntOption(opts, "PressureMotionMinZ", pressureMotionMinZ);
+    pars->press_motion_max_z =
+        xf86SetIntOption(opts, "PressureMotionMaxZ", pressureMotionMaxZ);
+
+    pars->min_speed = xf86SetRealOption(opts, "MinSpeed", 0.4);
+    pars->max_speed = xf86SetRealOption(opts, "MaxSpeed", 0.7);
+    pars->accl = xf86SetRealOption(opts, "AccelFactor", accelFactor);
+    pars->scroll_dist_circ = xf86SetRealOption(opts, "CircScrollDelta", 0.1);
+    pars->coasting_speed = xf86SetRealOption(opts, "CoastingSpeed", 20.0);
+    pars->coasting_friction = xf86SetRealOption(opts, "CoastingFriction", 50);
+    pars->press_motion_min_factor =
+        xf86SetRealOption(opts, "PressureMotionMinFactor", 1.0);
+    pars->press_motion_max_factor =
+        xf86SetRealOption(opts, "PressureMotionMaxFactor", 1.0);
+    pars->grab_event_device = xf86SetBoolOption(opts, "GrabEventDevice", TRUE);
+    pars->tap_and_drag_gesture =
+        xf86SetBoolOption(opts, "TapAndDragGesture", TRUE);
+    pars->resolution_horiz =
+        xf86SetIntOption(opts, "HorizResolution", horizResolution);
+    pars->resolution_vert =
+        xf86SetIntOption(opts, "VertResolution", vertResolution);
+
+    /* Warn about (and fix) incorrectly configured TopEdge/BottomEdge parameters */
+    if (pars->top_edge > pars->bottom_edge) {
+        int tmp = pars->top_edge;
+
+        pars->top_edge = pars->bottom_edge;
+        pars->bottom_edge = tmp;
+        xf86IDrvMsg(pInfo, X_WARNING,
+                    "TopEdge is bigger than BottomEdge. Fixing.\n");
+    }
+
+    set_softbutton_areas_option(pInfo);
+}
+
+static double
+SynapticsAccelerationProfile(DeviceIntPtr dev,
+                             DeviceVelocityPtr vel,
+                             double velocity, double thr, double acc)
+{
+    InputInfoPtr pInfo = dev->public.devicePrivate;
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    SynapticsParameters *para = &priv->synpara;
+
+    double accelfct;
+
+    /*
+     * synaptics accel was originally base on device coordinate based
+     * velocity, which we recover this way so para->accl retains its scale.
+     */
+    velocity /= vel->const_acceleration;
+
+    /* speed up linear with finger velocity */
+    accelfct = velocity * para->accl;
+
+    /* clip acceleration factor */
+    if (accelfct > para->max_speed * acc)
+        accelfct = para->max_speed * acc;
+    else if (accelfct < para->min_speed)
+        accelfct = para->min_speed;
+
+    /* modify speed according to pressure */
+    if (priv->moving_state == MS_TOUCHPAD_RELATIVE) {
+        int minZ = para->press_motion_min_z;
+        int maxZ = para->press_motion_max_z;
+        double minFctr = para->press_motion_min_factor;
+        double maxFctr = para->press_motion_max_factor;
+
+        if (priv->hwState->z <= minZ) {
+            accelfct *= minFctr;
+        }
+        else if (priv->hwState->z >= maxZ) {
+            accelfct *= maxFctr;
+        }
+        else {
+            accelfct *=
+                minFctr + (priv->hwState->z - minZ) * (maxFctr -
+                                                       minFctr) / (maxZ - minZ);
+        }
+    }
+
+    return accelfct;
+}
+
+int
+SynapticsPreInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
+{
+    SynapticsPrivate *priv;
+
+    /* allocate memory for SynapticsPrivateRec */
+    priv = calloc(1, sizeof(SynapticsPrivate));
+    if (!priv)
+        return BadAlloc;
+
+    pInfo->type_name = XI_TOUCHPAD;
+    pInfo->device_control = DeviceControl;
+    pInfo->read_input = ReadInput;
+    pInfo->control_proc = ControlProc;
+    pInfo->switch_mode = SwitchMode;
+    pInfo->private = priv;
+    
+    priv->isSynaptics = 1;
+
+    /* allocate now so we don't allocate in the signal handler */
+    priv->timer = TimerSet(NULL, 0, 0, NULL, NULL);
+    if (!priv->timer) {
+        free(priv);
+        return BadAlloc;
+    }
+
+    /* may change pInfo->options */
+    if (!SetDeviceAndProtocol(pInfo)) {
+        xf86IDrvMsg(pInfo, X_ERROR,
+                    "Synaptics driver unable to detect protocol\n");
+        goto SetupProc_fail;
+    }
+
+    priv->device = xf86FindOptionValue(pInfo->options, "Device");
+
+    /* open the touchpad device */
+    pInfo->fd = xf86OpenSerial(pInfo->options);
+    if (pInfo->fd == -1) {
+        xf86IDrvMsg(pInfo, X_ERROR, "Synaptics driver unable to open device\n");
+        goto SetupProc_fail;
+    }
+    xf86ErrorFVerb(6, "port opened successfully\n");
+
+    /* initialize variables */
+    priv->count_packet_finger = 0;
+    priv->tap_state = TS_START;
+    priv->tap_button = 0;
+    priv->tap_button_state = TBS_BUTTON_UP;
+    priv->touch_on.millis = 0;
+    priv->synpara.hyst_x = -1;
+    priv->synpara.hyst_y = -1;
+
+    /* read hardware dimensions */
+    ReadDevDimensions(pInfo);
+
+    set_default_parameters(pInfo);
+
+    CalculateScalingCoeffs(priv);
+
+    priv->comm.buffer = XisbNew(pInfo->fd, INPUT_BUFFER_SIZE);
+
+    if (!QueryHardware(pInfo)) {
+        xf86IDrvMsg(pInfo, X_ERROR,
+                    "Unable to query/initialize Synaptics hardware.\n");
+        goto SetupProc_fail;
+    }
+
+    xf86ProcessCommonOptions(pInfo, pInfo->options);
+
+    if (pInfo->fd != -1) {
+        if (priv->comm.buffer) {
+            XisbFree(priv->comm.buffer);
+            priv->comm.buffer = NULL;
+        }
+        xf86CloseSerial(pInfo->fd);
+    }
+    pInfo->fd = -1;
+
+    return Success;
+
+ SetupProc_fail:
+    if (pInfo->fd >= 0) {
+        xf86CloseSerial(pInfo->fd);
+        pInfo->fd = -1;
+    }
+
+    if (priv->comm.buffer)
+        XisbFree(priv->comm.buffer);
+    free(priv->proto_data);
+    free(priv->timer);
+    free(priv);
+    pInfo->private = NULL;
+    return BadAlloc;
+}
+
+/*
+ *  Uninitialize the device.
+ */
+void
+SynapticsUnInit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
+{
+    SynapticsPrivate *priv = ((SynapticsPrivate *) pInfo->private);
+
+    if (priv && priv->timer)
+        free(priv->timer);
+    if (priv && priv->proto_data)
+        free(priv->proto_data);
+    if (priv && priv->scroll_events_mask)
+        valuator_mask_free(&priv->scroll_events_mask);
+    if (priv && priv->open_slots)
+        free(priv->open_slots);
+    free(pInfo->private);
+    pInfo->private = NULL;
+    xf86DeleteInput(pInfo, 0);
+}
+
+/*
+ *  Alter the control parameters for the mouse. Note that all special
+ *  protocol values are handled by dix.
+ */
+static void
+SynapticsCtrl(DeviceIntPtr device, PtrCtrl * ctrl)
+{
+}
+
+static int
+DeviceControl(DeviceIntPtr dev, int mode)
+{
+    Bool RetValue;
+
+    switch (mode) {
+    case DEVICE_INIT:
+        RetValue = DeviceInit(dev);
+        break;
+    case DEVICE_ON:
+        RetValue = DeviceOn(dev);
+        break;
+    case DEVICE_OFF:
+        RetValue = DeviceOff(dev);
+        break;
+    case DEVICE_CLOSE:
+        RetValue = DeviceClose(dev);
+        break;
+    default:
+        RetValue = BadValue;
+    }
+
+    return RetValue;
+}
+
+static int
+DeviceOn(DeviceIntPtr dev)
+{
+    InputInfoPtr pInfo = dev->public.devicePrivate;
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+
+    DBG(3, "Synaptics DeviceOn called\n");
+
+    pInfo->fd = xf86OpenSerial(pInfo->options);
+    if (pInfo->fd == -1) {
+        xf86IDrvMsg(pInfo, X_WARNING, "cannot open input device\n");
+        return !Success;
+    }
+
+    if (priv->proto_ops->DeviceOnHook &&
+        !priv->proto_ops->DeviceOnHook(pInfo, &priv->synpara))
+        return !Success;
+
+    priv->comm.buffer = XisbNew(pInfo->fd, INPUT_BUFFER_SIZE);
+    if (!priv->comm.buffer) {
+        xf86CloseSerial(pInfo->fd);
+        pInfo->fd = -1;
+        return !Success;
+    }
+
+    xf86FlushInput(pInfo->fd);
+
+    /* reinit the pad */
+    if (!QueryHardware(pInfo)) {
+        XisbFree(priv->comm.buffer);
+        priv->comm.buffer = NULL;
+        xf86CloseSerial(pInfo->fd);
+        pInfo->fd = -1;
+        return !Success;
+    }
+
+    xf86AddEnabledDevice(pInfo);
+    dev->public.on = TRUE;
+
+    return Success;
+}
+
+static void
+SynapticsReset(SynapticsPrivate * priv)
+{
+    SynapticsResetHwState(priv->hwState);
+    SynapticsResetHwState(priv->local_hw_state);
+    SynapticsResetHwState(priv->old_hw_state);
+    SynapticsResetHwState(priv->comm.hwState);
+
+    memset(priv->move_hist, 0, sizeof(priv->move_hist));
+    priv->hyst_center_x = 0;
+    priv->hyst_center_y = 0;
+    memset(&priv->scroll, 0, sizeof(priv->scroll));
+    priv->count_packet_finger = 0;
+    priv->finger_state = FS_UNTOUCHED;
+    priv->last_motion_millis = 0;
+    priv->tap_state = TS_START;
+    priv->tap_button = 0;
+    priv->tap_button_state = TBS_BUTTON_UP;
+    priv->moving_state = MS_FALSE;
+    priv->vert_scroll_edge_on = FALSE;
+    priv->horiz_scroll_edge_on = FALSE;
+    priv->vert_scroll_twofinger_on = FALSE;
+    priv->horiz_scroll_twofinger_on = FALSE;
+    priv->circ_scroll_on = FALSE;
+    priv->circ_scroll_vert = FALSE;
+    priv->mid_emu_state = MBE_OFF;
+    priv->lastButtons = 0;
+    priv->prev_z = 0;
+    priv->prevFingers = 0;
+    priv->num_active_touches = 0;
+    memset(priv->open_slots, 0, priv->num_slots * sizeof(int));
+}
+
+static int
+DeviceOff(DeviceIntPtr dev)
+{
+    InputInfoPtr pInfo = dev->public.devicePrivate;
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    Bool rc = Success;
+
+    DBG(3, "Synaptics DeviceOff called\n");
+
+    if (pInfo->fd != -1) {
+        TimerCancel(priv->timer);
+        xf86RemoveEnabledDevice(pInfo);
+        SynapticsReset(priv);
+
+        if (priv->proto_ops->DeviceOffHook &&
+            !priv->proto_ops->DeviceOffHook(pInfo))
+            rc = !Success;
+        if (priv->comm.buffer) {
+            XisbFree(priv->comm.buffer);
+            priv->comm.buffer = NULL;
+        }
+        xf86CloseSerial(pInfo->fd);
+        pInfo->fd = -1;
+    }
+    dev->public.on = FALSE;
+    return rc;
+}
+
+static int
+DeviceClose(DeviceIntPtr dev)
+{
+    Bool RetValue;
+    InputInfoPtr pInfo = dev->public.devicePrivate;
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+
+    RetValue = DeviceOff(dev);
+    TimerFree(priv->timer);
+    priv->timer = NULL;
+    free(priv->touch_axes);
+    priv->touch_axes = NULL;
+    SynapticsHwStateFree(&priv->hwState);
+    SynapticsHwStateFree(&priv->old_hw_state);
+    SynapticsHwStateFree(&priv->local_hw_state);
+    SynapticsHwStateFree(&priv->comm.hwState);
+    return RetValue;
+}
+
+static void
+InitAxesLabels(Atom *labels, int nlabels, const SynapticsPrivate * priv)
+{
+    int i;
+
+    memset(labels, 0, nlabels * sizeof(Atom));
+    switch (nlabels) {
+    default:
+    case 4:
+        labels[3] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_VSCROLL);
+    case 3:
+        labels[2] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_HSCROLL);
+    case 2:
+        labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_Y);
+    case 1:
+        labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_REL_X);
+        break;
+    }
+
+    for (i = 0; i < priv->num_mt_axes; i++) {
+        SynapticsTouchAxisRec *axis = &priv->touch_axes[i];
+        int axnum = nlabels - priv->num_mt_axes + i;
+
+        labels[axnum] = XIGetKnownProperty(axis->label);
+    }
+}
+
+static void
+InitButtonLabels(Atom *labels, int nlabels)
+{
+    memset(labels, 0, nlabels * sizeof(Atom));
+    switch (nlabels) {
+    default:
+    case 7:
+        labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
+    case 6:
+        labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
+    case 5:
+        labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
+    case 4:
+        labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
+    case 3:
+        labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
+    case 2:
+        labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
+    case 1:
+        labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
+        break;
+    }
+}
+
+static void
+DeviceInitTouch(DeviceIntPtr dev, Atom *axes_labels)
+{
+    InputInfoPtr pInfo = dev->public.devicePrivate;
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    int i;
+
+    if (priv->has_touch) {
+        priv->num_slots =
+            priv->max_touches ? priv->max_touches : SYNAPTICS_MAX_TOUCHES;
+
+        priv->open_slots = malloc(priv->num_slots * sizeof(int));
+        if (!priv->open_slots) {
+            xf86IDrvMsg(pInfo, X_ERROR,
+                        "failed to allocate open touch slots array\n");
+            priv->has_touch = 0;
+            priv->num_slots = 0;
+            return;
+        }
+
+        /* x/y + whatever other MT axes we found */
+        if (!InitTouchClassDeviceStruct(dev, priv->max_touches,
+                                        XIDependentTouch,
+                                        2 + priv->num_mt_axes)) {
+            xf86IDrvMsg(pInfo, X_ERROR,
+                        "failed to initialize touch class device\n");
+            priv->has_touch = 0;
+            priv->num_slots = 0;
+            free(priv->open_slots);
+            priv->open_slots = NULL;
+            return;
+        }
+
+        for (i = 0; i < priv->num_mt_axes; i++) {
+            SynapticsTouchAxisRec *axis = &priv->touch_axes[i];
+            int axnum = 4 + i;  /* Skip x, y, and scroll axes */
+
+            if (!xf86InitValuatorAxisStruct(dev, axnum, axes_labels[axnum],
+                                            axis->min, axis->max, axis->res, 0,
+                                            axis->res, Absolute)) {
+                xf86IDrvMsg(pInfo, X_WARNING,
+                            "failed to initialize axis %s, skipping\n",
+                            axis->label);
+                continue;
+            }
+
+            xf86InitValuatorDefaults(dev, axnum);
+        }
+    }
+}
+
+static int
+DeviceInit(DeviceIntPtr dev)
+{
+    InputInfoPtr pInfo = dev->public.devicePrivate;
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    Atom float_type, prop;
+    float tmpf;
+    unsigned char map[SYN_MAX_BUTTONS + 1];
+    int i;
+    int min, max;
+    int num_axes = 2;
+    Atom btn_labels[SYN_MAX_BUTTONS] = { 0 };
+    Atom *axes_labels;
+    DeviceVelocityPtr pVel;
+
+    num_axes += 2;
+
+    num_axes += priv->num_mt_axes;
+
+    axes_labels = calloc(num_axes, sizeof(Atom));
+    if (!axes_labels) {
+        xf86IDrvMsg(pInfo, X_ERROR, "failed to allocate axis labels\n");
+        return !Success;
+    }
+
+    InitAxesLabels(axes_labels, num_axes, priv);
+    InitButtonLabels(btn_labels, SYN_MAX_BUTTONS);
+
+    DBG(3, "Synaptics DeviceInit called\n");
+
+    for (i = 0; i <= SYN_MAX_BUTTONS; i++)
+        map[i] = i;
+
+    dev->public.on = FALSE;
+
+    InitPointerDeviceStruct((DevicePtr) dev, map,
+                            SYN_MAX_BUTTONS,
+                            btn_labels,
+                            SynapticsCtrl,
+                            GetMotionHistorySize(), num_axes, axes_labels);
+
+    /*
+     * setup dix acceleration to match legacy synaptics settings, and
+     * etablish a device-specific profile to do stuff like pressure-related
+     * acceleration.
+     */
+    if (NULL != (pVel = GetDevicePredictableAccelData(dev))) {
+        SetDeviceSpecificAccelerationProfile(pVel,
+                                             SynapticsAccelerationProfile);
+
+        /* float property type */
+        float_type = XIGetKnownProperty(XATOM_FLOAT);
+
+        /* translate MinAcc to constant deceleration.
+         * May be overridden in xf86InitValuatorDefaults */
+        tmpf = 1.0 / priv->synpara.min_speed;
+
+        xf86IDrvMsg(pInfo, X_CONFIG,
+                    "(accel) MinSpeed is now constant deceleration " "%.1f\n",
+                    tmpf);
+        prop = XIGetKnownProperty(ACCEL_PROP_CONSTANT_DECELERATION);
+        XIChangeDeviceProperty(dev, prop, float_type, 32,
+                               PropModeReplace, 1, &tmpf, FALSE);
+
+        /* adjust accordingly */
+        priv->synpara.max_speed /= priv->synpara.min_speed;
+        priv->synpara.min_speed = 1.0;
+
+        /* synaptics seems to report 80 packet/s, but dix scales for
+         * 100 packet/s by default. */
+        pVel->corr_mul = 12.5f; /*1000[ms]/80[/s] = 12.5 */
+
+        xf86IDrvMsg(pInfo, X_CONFIG, "(accel) MaxSpeed is now %.2f\n",
+                    priv->synpara.max_speed);
+        xf86IDrvMsg(pInfo, X_CONFIG, "(accel) AccelFactor is now %.3f\n",
+                    priv->synpara.accl);
+
+        prop = XIGetKnownProperty(ACCEL_PROP_PROFILE_NUMBER);
+        i = AccelProfileDeviceSpecific;
+        XIChangeDeviceProperty(dev, prop, XA_INTEGER, 32,
+                               PropModeReplace, 1, &i, FALSE);
+    }
+
+    /* X valuator */
+    if (priv->minx < priv->maxx) {
+        min = priv->minx;
+        max = priv->maxx;
+    }
+    else {
+        min = 0;
+        max = -1;
+    }
+
+    xf86InitValuatorAxisStruct(dev, 0, axes_labels[0], min, max,
+			       priv->resx * 1000, 0, priv->resx * 1000,
+			       Relative);
+    xf86InitValuatorDefaults(dev, 0);
+
+    /* Y valuator */
+    if (priv->miny < priv->maxy) {
+        min = priv->miny;
+        max = priv->maxy;
+    }
+    else {
+        min = 0;
+        max = -1;
+    }
+
+    xf86InitValuatorAxisStruct(dev, 1, axes_labels[1], min, max,
+			       priv->resy * 1000, 0, priv->resy * 1000,
+			       Relative);
+    xf86InitValuatorDefaults(dev, 1);
+
+    xf86InitValuatorAxisStruct(dev, 2, axes_labels[2], 0, -1, 0, 0, 0,
+                               Relative);
+    priv->scroll_axis_horiz = 2;
+    xf86InitValuatorAxisStruct(dev, 3, axes_labels[3], 0, -1, 0, 0, 0,
+                               Relative);
+    priv->scroll_axis_vert = 3;
+    priv->scroll_events_mask = valuator_mask_new(MAX_VALUATORS);
+    if (!priv->scroll_events_mask) {
+        free(axes_labels);
+        return !Success;
+    }
+
+    SetScrollValuator(dev, priv->scroll_axis_horiz, SCROLL_TYPE_HORIZONTAL,
+                      priv->synpara.scroll_dist_horiz, 0);
+    SetScrollValuator(dev, priv->scroll_axis_vert, SCROLL_TYPE_VERTICAL,
+                      priv->synpara.scroll_dist_vert, 0);
+
+    DeviceInitTouch(dev, axes_labels);
+
+    free(axes_labels);
+
+    priv->hwState = SynapticsHwStateAlloc(priv);
+    if (!priv->hwState)
+        goto fail;
+
+    priv->old_hw_state = SynapticsHwStateAlloc(priv);
+    if (!priv->old_hw_state)
+        goto fail;
+
+    priv->local_hw_state = SynapticsHwStateAlloc(priv);
+    if (!priv->local_hw_state)
+        goto fail;
+
+    priv->comm.hwState = SynapticsHwStateAlloc(priv);
+
+    InitDeviceProperties(pInfo);
+    XIRegisterPropertyHandler(pInfo->dev, SetProperty, NULL, NULL);
+
+    return Success;
+
+ fail:
+    free(priv->local_hw_state);
+    free(priv->hwState);
+    free(priv->open_slots);
+    return !Success;
+}
+
+/* return angle of point relative to center */
+static double
+angle(SynapticsPrivate * priv, int x, int y)
+{
+    double xCenter = (priv->synpara.left_edge + priv->synpara.right_edge) / 2.0;
+    double yCenter = (priv->synpara.top_edge + priv->synpara.bottom_edge) / 2.0;
+
+    return atan2(-(y - yCenter), x - xCenter);
+}
+
+/* return angle difference */
+static double
+diffa(double a1, double a2)
+{
+    double da = fmod(a2 - a1, 2 * M_PI);
+
+    if (da < 0)
+        da += 2 * M_PI;
+    if (da > M_PI)
+        da -= 2 * M_PI;
+    return da;
+}
+
+static enum EdgeType
+edge_detection(SynapticsPrivate * priv, int x, int y)
+{
+    enum EdgeType edge = NO_EDGE;
+
+    if (x > priv->synpara.right_edge)
+        edge |= RIGHT_EDGE;
+    else if (x < priv->synpara.left_edge)
+        edge |= LEFT_EDGE;
+
+    if (y < priv->synpara.top_edge)
+        edge |= TOP_EDGE;
+    else if (y > priv->synpara.bottom_edge)
+        edge |= BOTTOM_EDGE;
+
+    return edge;
+}
+
+/* Checks whether coordinates are in the Synaptics Area
+ * or not. If no Synaptics Area is defined (i.e. if
+ * priv->synpara.area_{left|right|top|bottom}_edge are
+ * all set to zero), the function returns TRUE.
+ */
+static Bool
+is_inside_active_area(SynapticsPrivate * priv, int x, int y)
+{
+    Bool inside_area = TRUE;
+
+    if ((priv->synpara.area_left_edge != 0) &&
+        (x < priv->synpara.area_left_edge))
+        inside_area = FALSE;
+    else if ((priv->synpara.area_right_edge != 0) &&
+             (x > priv->synpara.area_right_edge))
+        inside_area = FALSE;
+
+    if ((priv->synpara.area_top_edge != 0) && (y < priv->synpara.area_top_edge))
+        inside_area = FALSE;
+    else if ((priv->synpara.area_bottom_edge != 0) &&
+             (y > priv->synpara.area_bottom_edge))
+        inside_area = FALSE;
+
+    return inside_area;
+}
+
+static Bool
+is_inside_button_area(SynapticsParameters * para, int which, int x, int y)
+{
+    Bool inside_area = TRUE;
+
+    enum {
+        LEFT = 0,
+        RIGHT = 1,
+        TOP = 2,
+        BOTTOM = 3
+    };
+
+    if (para->softbutton_areas[which][LEFT] == 0 &&
+        para->softbutton_areas[which][RIGHT] == 0 &&
+        para->softbutton_areas[which][TOP] == 0 &&
+        para->softbutton_areas[which][BOTTOM] == 0)
+        return FALSE;
+
+    if (para->softbutton_areas[which][LEFT] &&
+        x < para->softbutton_areas[which][LEFT])
+        inside_area = FALSE;
+    else if (para->softbutton_areas[which][RIGHT] &&
+             x > para->softbutton_areas[which][RIGHT])
+        inside_area = FALSE;
+    else if (para->softbutton_areas[which][TOP] &&
+             y < para->softbutton_areas[which][TOP])
+        inside_area = FALSE;
+    else if (para->softbutton_areas[which][BOTTOM] &&
+             y > para->softbutton_areas[which][BOTTOM])
+        inside_area = FALSE;
+
+    return inside_area;
+}
+
+static Bool
+is_inside_rightbutton_area(SynapticsParameters * para, int x, int y)
+{
+    return is_inside_button_area(para, 0, x, y);
+}
+
+static Bool
+is_inside_middlebutton_area(SynapticsParameters * para, int x, int y)
+{
+    return is_inside_button_area(para, 1, x, y);
+}
+
+static CARD32
+timerFunc(OsTimerPtr timer, CARD32 now, pointer arg)
+{
+    InputInfoPtr pInfo = arg;
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    struct SynapticsHwState *hw = priv->local_hw_state;
+    int delay;
+    int sigstate;
+
+    sigstate = xf86BlockSIGIO();
+
+    priv->hwState->millis += now - priv->timer_time;
+    SynapticsCopyHwState(hw, priv->hwState);
+    SynapticsResetTouchHwState(hw, FALSE);
+    delay = HandleState(pInfo, hw, hw->millis, TRUE);
+
+    priv->timer_time = now;
+    priv->timer = TimerSet(priv->timer, 0, delay, timerFunc, pInfo);
+
+    xf86UnblockSIGIO(sigstate);
+
+    return 0;
+}
+
+static int
+clamp(int val, int min, int max)
+{
+    if (val < min)
+        return min;
+    else if (val < max)
+        return val;
+    else
+        return max;
+}
+
+static Bool
+SynapticsGetHwState(InputInfoPtr pInfo, SynapticsPrivate * priv,
+                    struct SynapticsHwState *hw)
+{
+    return priv->proto_ops->ReadHwState(pInfo, &priv->comm, hw);
+}
+
+/*
+ *  called for each full received packet from the touchpad
+ */
+static void
+ReadInput(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    struct SynapticsHwState *hw = priv->local_hw_state;
+    int delay = 0;
+    Bool newDelay = FALSE;
+
+    SynapticsResetTouchHwState(hw, FALSE);
+
+    while (SynapticsGetHwState(pInfo, priv, hw)) {
+        /* Semi-mt device touch slots do not track touches. When there is a
+         * change in the number of touches, we must disregard the temporary
+         * motion changes. */
+        if (priv->has_semi_mt && hw->numFingers != priv->hwState->numFingers) {
+            hw->cumulative_dx = priv->hwState->cumulative_dx;
+            hw->cumulative_dy = priv->hwState->cumulative_dy;
+        }
+
+        /* timer may cause actual events to lag behind (#48777) */
+        if (priv->hwState->millis > hw->millis)
+            hw->millis = priv->hwState->millis;
+
+        SynapticsCopyHwState(priv->hwState, hw);
+        delay = HandleState(pInfo, hw, hw->millis, FALSE);
+        newDelay = TRUE;
+    }
+
+    if (newDelay) {
+        priv->timer_time = GetTimeInMillis();
+        priv->timer = TimerSet(priv->timer, 0, delay, timerFunc, pInfo);
+    }
+}
+
+static int
+HandleMidButtonEmulation(SynapticsPrivate * priv, struct SynapticsHwState *hw,
+                         CARD32 now, int *delay)
+{
+    SynapticsParameters *para = &priv->synpara;
+    Bool done = FALSE;
+    int timeleft;
+    int mid = 0;
+
+    if (para->emulate_mid_button_time <= 0)
+        return mid;
+
+    while (!done) {
+        switch (priv->mid_emu_state) {
+        case MBE_LEFT_CLICK:
+        case MBE_RIGHT_CLICK:
+        case MBE_OFF:
+            priv->button_delay_millis = now;
+            if (hw->left) {
+                priv->mid_emu_state = MBE_LEFT;
+            }
+            else if (hw->right) {
+                priv->mid_emu_state = MBE_RIGHT;
+            }
+            else {
+                done = TRUE;
+            }
+            break;
+        case MBE_LEFT:
+            timeleft =
+                TIME_DIFF(priv->button_delay_millis +
+                          para->emulate_mid_button_time, now);
+            if (timeleft > 0)
+                *delay = MIN(*delay, timeleft);
+
+            /* timeout, but within the same ReadInput cycle! */
+            if ((timeleft <= 0) && !hw->left) {
+                priv->mid_emu_state = MBE_LEFT_CLICK;
+                done = TRUE;
+            }
+            else if ((!hw->left) || (timeleft <= 0)) {
+                hw->left = TRUE;
+                priv->mid_emu_state = MBE_TIMEOUT;
+                done = TRUE;
+            }
+            else if (hw->right) {
+                priv->mid_emu_state = MBE_MID;
+            }
+            else {
+                hw->left = FALSE;
+                done = TRUE;
+            }
+            break;
+        case MBE_RIGHT:
+            timeleft =
+                TIME_DIFF(priv->button_delay_millis +
+                          para->emulate_mid_button_time, now);
+            if (timeleft > 0)
+                *delay = MIN(*delay, timeleft);
+
+            /* timeout, but within the same ReadInput cycle! */
+            if ((timeleft <= 0) && !hw->right) {
+                priv->mid_emu_state = MBE_RIGHT_CLICK;
+                done = TRUE;
+            }
+            else if (!hw->right || (timeleft <= 0)) {
+                hw->right = TRUE;
+                priv->mid_emu_state = MBE_TIMEOUT;
+                done = TRUE;
+            }
+            else if (hw->left) {
+                priv->mid_emu_state = MBE_MID;
+            }
+            else {
+                hw->right = FALSE;
+                done = TRUE;
+            }
+            break;
+        case MBE_MID:
+            if (!hw->left && !hw->right) {
+                priv->mid_emu_state = MBE_OFF;
+            }
+            else {
+                mid = TRUE;
+                hw->left = hw->right = FALSE;
+                done = TRUE;
+            }
+            break;
+        case MBE_TIMEOUT:
+            if (!hw->left && !hw->right) {
+                priv->mid_emu_state = MBE_OFF;
+            }
+            else {
+                done = TRUE;
+            }
+        }
+    }
+    return mid;
+}
+
+static enum FingerState
+SynapticsDetectFinger(SynapticsPrivate * priv, struct SynapticsHwState *hw)
+{
+    SynapticsParameters *para = &priv->synpara;
+    enum FingerState finger;
+
+    /* finger detection thru pressure and threshold */
+    if (hw->z < para->finger_low)
+        return FS_UNTOUCHED;
+
+    if (priv->finger_state == FS_BLOCKED)
+        return FS_BLOCKED;
+
+    if (hw->z > para->finger_high && priv->finger_state == FS_UNTOUCHED)
+        finger = FS_TOUCHED;
+    else
+        finger = priv->finger_state;
+
+    if (!para->palm_detect)
+        return finger;
+
+    /* palm detection */
+
+    if ((hw->z > para->palm_min_z) && (hw->fingerWidth > para->palm_min_width))
+        return FS_BLOCKED;
+
+    if (hw->x == 0 || priv->finger_state == FS_UNTOUCHED)
+        priv->avg_width = 0;
+    else
+        priv->avg_width += (hw->fingerWidth - priv->avg_width + 1) / 2;
+
+    if (finger != FS_UNTOUCHED && priv->finger_state == FS_UNTOUCHED) {
+        int safe_width = MAX(hw->fingerWidth, priv->avg_width);
+
+        if (hw->numFingers > 1 ||       /* more than one finger -> not a palm */
+            ((safe_width < 6) && (priv->prev_z < para->finger_high)) || /* thin finger, distinct touch -> not a palm */
+            ((safe_width < 7) && (priv->prev_z < para->finger_high / 2))) {     /* thin finger, distinct touch -> not a palm */
+            /* leave finger value as is */
+        }
+        else if (hw->z > priv->prev_z + 1)      /* z not stable, may be a palm */
+            finger = FS_UNTOUCHED;
+        else if (hw->z < priv->prev_z - 5)      /* z not stable, may be a palm */
+            finger = FS_UNTOUCHED;
+        else if (hw->fingerWidth > para->palm_min_width)        /* finger width too large -> probably palm */
+            finger = FS_UNTOUCHED;
+    }
+    priv->prev_z = hw->z;
+
+    return finger;
+}
+
+static void
+SelectTapButton(SynapticsPrivate * priv, enum EdgeType edge)
+{
+    enum TapEvent tap;
+
+    if (priv->synpara.touchpad_off == TOUCHPAD_TAP_OFF) {
+        priv->tap_button = 0;
+        return;
+    }
+
+    switch (priv->tap_max_fingers) {
+    case 1:
+        switch (edge) {
+        case RIGHT_TOP_EDGE:
+            DBG(7, "right top edge\n");
+            tap = RT_TAP;
+            break;
+        case RIGHT_BOTTOM_EDGE:
+            DBG(7, "right bottom edge\n");
+            tap = RB_TAP;
+            break;
+        case LEFT_TOP_EDGE:
+            DBG(7, "left top edge\n");
+            tap = LT_TAP;
+            break;
+        case LEFT_BOTTOM_EDGE:
+            DBG(7, "left bottom edge\n");
+            tap = LB_TAP;
+            break;
+        default:
+            DBG(7, "no edge\n");
+            tap = F1_TAP;
+            break;
+        }
+        break;
+    case 2:
+        DBG(7, "two finger tap\n");
+        tap = F2_TAP;
+        break;
+    case 3:
+        DBG(7, "three finger tap\n");
+        tap = F3_TAP;
+        break;
+    default:
+        priv->tap_button = 0;
+        return;
+    }
+
+    priv->tap_button = priv->synpara.tap_action[tap];
+    priv->tap_button = clamp(priv->tap_button, 0, SYN_MAX_BUTTONS);
+}
+
+static void
+SetTapState(SynapticsPrivate * priv, enum TapState tap_state, CARD32 millis)
+{
+    DBG(3, "SetTapState - %d -> %d (millis:%u)\n", priv->tap_state, tap_state,
+        millis);
+    switch (tap_state) {
+    case TS_START:
+        priv->tap_button_state = TBS_BUTTON_UP;
+        priv->tap_max_fingers = 0;
+        break;
+    case TS_1:
+        priv->tap_button_state = TBS_BUTTON_UP;
+        break;
+    case TS_2A:
+	priv->tap_button_state = TBS_BUTTON_UP;
+        break;
+    case TS_2B:
+        priv->tap_button_state = TBS_BUTTON_UP;
+        break;
+    case TS_3:
+        priv->tap_button_state = TBS_BUTTON_DOWN;
+        break;
+    case TS_SINGLETAP:
+	priv->tap_button_state = TBS_BUTTON_DOWN;
+        priv->touch_on.millis = millis;
+        break;
+    default:
+        break;
+    }
+    priv->tap_state = tap_state;
+}
+
+static void
+SetMovingState(SynapticsPrivate * priv, enum MovingState moving_state,
+               CARD32 millis)
+{
+    DBG(7, "SetMovingState - %d -> %d center at %d/%d (millis:%u)\n",
+        priv->moving_state, moving_state, priv->hwState->x, priv->hwState->y,
+        millis);
+
+    priv->moving_state = moving_state;
+}
+
+static int
+GetTimeOut(SynapticsPrivate * priv)
+{
+    SynapticsParameters *para = &priv->synpara;
+
+    switch (priv->tap_state) {
+    case TS_1:
+    case TS_3:
+    case TS_5:
+        return para->tap_time;
+    case TS_SINGLETAP:
+        return para->click_time;
+    case TS_2A:
+        return para->single_tap_timeout;
+    case TS_2B:
+        return para->tap_time_2;
+    case TS_4:
+        return para->locked_drag_time;
+    default:
+        return -1;              /* No timeout */
+    }
+}
+
+static int
+HandleTapProcessing(SynapticsPrivate * priv, struct SynapticsHwState *hw,
+                    CARD32 now, enum FingerState finger,
+                    Bool inside_active_area)
+{
+    SynapticsParameters *para = &priv->synpara;
+    Bool touch, release, is_timeout, move, press;
+    int timeleft, timeout;
+    enum EdgeType edge;
+    int delay = 1000000000;
+
+    if (priv->finger_state == FS_BLOCKED)
+        return delay;
+
+    touch = finger >= FS_TOUCHED && priv->finger_state == FS_UNTOUCHED;
+    release = finger == FS_UNTOUCHED && priv->finger_state >= FS_TOUCHED;
+    move = (finger >= FS_TOUCHED &&
+            (priv->tap_max_fingers <=
+             ((priv->horiz_scroll_twofinger_on ||
+               priv->vert_scroll_twofinger_on) ? 2 : 1)) &&
+            ((abs(hw->x - priv->touch_on.x) >= para->tap_move) ||
+             (abs(hw->y - priv->touch_on.y) >= para->tap_move)));
+    press = (hw->left || hw->right || hw->middle);
+
+    if (touch) {
+        priv->touch_on.x = hw->x;
+        priv->touch_on.y = hw->y;
+        priv->touch_on.millis = now;
+    }
+    else if (release) {
+        priv->touch_on.millis = now;
+    }
+    if (hw->z > para->finger_high)
+        if (priv->tap_max_fingers < hw->numFingers)
+            priv->tap_max_fingers = hw->numFingers;
+    timeout = GetTimeOut(priv);
+    timeleft = TIME_DIFF(priv->touch_on.millis + timeout, now);
+    is_timeout = timeleft <= 0;
+
+ restart:
+    switch (priv->tap_state) {
+    case TS_START:
+        if (touch)
+            SetTapState(priv, TS_1, now);
+        break;
+    case TS_1:
+        if (para->clickpad && press) {
+            SetTapState(priv, TS_CLICKPAD_MOVE, now);
+            goto restart;
+        }
+        if (move) {
+            SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
+            SetTapState(priv, TS_MOVE, now);
+            goto restart;
+        }
+        else if (is_timeout) {
+            if (finger == FS_TOUCHED) {
+                SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
+            }
+            SetTapState(priv, TS_MOVE, now);
+            goto restart;
+        }
+        else if (release) {
+            edge = edge_detection(priv, priv->touch_on.x, priv->touch_on.y);
+            SelectTapButton(priv, edge);
+            /* Disable taps outside of the active area */
+            if (!inside_active_area) {
+                priv->tap_button = 0;
+            }
+            SetTapState(priv, TS_2A, now);
+        }
+        break;
+    case TS_MOVE:
+        if (para->clickpad && press) {
+            SetTapState(priv, TS_CLICKPAD_MOVE, now);
+            goto restart;
+        }
+        if (release) {
+            SetMovingState(priv, MS_FALSE, now);
+            SetTapState(priv, TS_START, now);
+        }
+        break;
+    case TS_2A:
+        if (touch)
+            SetTapState(priv, TS_3, now);
+        else if (is_timeout)
+            SetTapState(priv, TS_SINGLETAP, now);
+        break;
+    case TS_2B:
+        if (touch) {
+            SetTapState(priv, TS_3, now);
+        }
+        else if (is_timeout) {
+            SetTapState(priv, TS_START, now);
+            priv->tap_button_state = TBS_BUTTON_DOWN_UP;
+        }
+        break;
+    case TS_SINGLETAP:
+        if (touch)
+            SetTapState(priv, TS_1, now);
+        else if (is_timeout)
+            SetTapState(priv, TS_START, now);
+        break;
+    case TS_3:
+        if (move) {
+            if (para->tap_and_drag_gesture) {
+                SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
+                SetTapState(priv, TS_DRAG, now);
+            }
+            else {
+                SetTapState(priv, TS_1, now);
+            }
+            goto restart;
+        }
+        else if (is_timeout) {
+            if (para->tap_and_drag_gesture) {
+                if (finger == FS_TOUCHED) {
+                    SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
+                }
+                SetTapState(priv, TS_DRAG, now);
+            }
+            else {
+                SetTapState(priv, TS_1, now);
+            }
+            goto restart;
+        }
+        else if (release) {
+            SetTapState(priv, TS_2B, now);
+        }
+        break;
+    case TS_DRAG:
+        if (para->clickpad && press) {
+            SetTapState(priv, TS_CLICKPAD_MOVE, now);
+            goto restart;
+        }
+        if (move)
+            SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
+        if (release) {
+            SetMovingState(priv, MS_FALSE, now);
+            if (para->locked_drags) {
+                SetTapState(priv, TS_4, now);
+            }
+            else {
+                SetTapState(priv, TS_START, now);
+            }
+        }
+        break;
+    case TS_4:
+        if (is_timeout) {
+            SetTapState(priv, TS_START, now);
+            goto restart;
+        }
+        if (touch)
+            SetTapState(priv, TS_5, now);
+        break;
+    case TS_5:
+        if (is_timeout || move) {
+            SetTapState(priv, TS_DRAG, now);
+            goto restart;
+        }
+        else if (release) {
+            SetMovingState(priv, MS_FALSE, now);
+            SetTapState(priv, TS_START, now);
+        }
+        break;
+    case TS_CLICKPAD_MOVE:
+        /* Disable scrolling once a button is pressed on a clickpad */
+        priv->vert_scroll_edge_on = FALSE;
+        priv->horiz_scroll_edge_on = FALSE;
+        priv->vert_scroll_twofinger_on = FALSE;
+        priv->horiz_scroll_twofinger_on = FALSE;
+
+        /* Assume one touch is only for holding the clickpad button down */
+        if (hw->numFingers > 1)
+            hw->numFingers--;
+        SetMovingState(priv, MS_TOUCHPAD_RELATIVE, now);
+        if (!press) {
+            SetMovingState(priv, MS_FALSE, now);
+            SetTapState(priv, TS_MOVE, now);
+            priv->count_packet_finger = 0;
+        }
+        break;
+    }
+
+    timeout = GetTimeOut(priv);
+    if (timeout >= 0) {
+        timeleft = TIME_DIFF(priv->touch_on.millis + timeout, now);
+        delay = clamp(timeleft, 1, delay);
+    }
+    return delay;
+}
+
+#define HIST(a) (priv->move_hist[((priv->hist_index - (a) + SYNAPTICS_MOVE_HISTORY) % SYNAPTICS_MOVE_HISTORY)])
+#define HIST_DELTA(a, b, e) ((HIST((a)).e) - (HIST((b)).e))
+
+static void
+store_history(SynapticsPrivate * priv, int x, int y, CARD32 millis)
+{
+    int idx = (priv->hist_index + 1) % SYNAPTICS_MOVE_HISTORY;
+
+    priv->move_hist[idx].x = x;
+    priv->move_hist[idx].y = y;
+    priv->move_hist[idx].millis = millis;
+    priv->hist_index = idx;
+    if (priv->count_packet_finger < SYNAPTICS_MOVE_HISTORY)
+        priv->count_packet_finger++;
+}
+
+/*
+ * Estimate the slope for the data sequence [x3, x2, x1, x0] by using
+ * linear regression to fit a line to the data and use the slope of the
+ * line.
+ */
+static double
+estimate_delta(double x0, double x1, double x2, double x3)
+{
+    return x0 * 0.3 + x1 * 0.1 - x2 * 0.1 - x3 * 0.3;
+}
+
+/**
+ * Applies hysteresis. center is shifted such that it is in range with
+ * in by the margin again. The new center is returned.
+ * @param in the current value
+ * @param center the current center
+ * @param margin the margin to center in which no change is applied
+ * @return the new center (which might coincide with the previous)
+ */
+static int
+hysteresis(int in, int center, int margin)
+{
+    int diff = in - center;
+
+    if (abs(diff) <= margin) {
+        diff = 0;
+    }
+    else if (diff > margin) {
+        diff -= margin;
+    }
+    else if (diff < -margin) {
+        diff += margin;
+    }
+    return center + diff;
+}
+
+static void
+get_delta(SynapticsPrivate *priv, const struct SynapticsHwState *hw,
+          enum EdgeType edge, double *dx, double *dy)
+{
+    double dtime = (hw->millis - HIST(0).millis) / 1000.0;
+    double integral;
+    double tmpf;
+    int x_edge_speed = 0;
+    int y_edge_speed = 0;
+
+    *dx = hw->x - HIST(0).x;
+    *dy = hw->y - HIST(0).y;
+
+    /* report edge speed as synthetic motion. Of course, it would be
+     * cooler to report floats than to buffer, but anyway. */
+
+    /* FIXME: When these values go NaN, bad things happen. Root cause is unknown
+     * thus far though. */
+    if (isnan(priv->frac_x))
+        priv->frac_x = 0;
+    if (isnan(priv->frac_y))
+        priv->frac_y = 0;
+
+    tmpf = *dx + x_edge_speed * dtime + priv->frac_x;
+    priv->frac_x = modf(tmpf, &integral);
+    *dx = integral;
+    tmpf = *dy + y_edge_speed * dtime + priv->frac_y;
+    priv->frac_y = modf(tmpf, &integral);
+    *dy = integral;
+}
+
+/**
+ * Compute relative motion ('deltas') including edge motion.
+ */
+static int
+ComputeDeltas(SynapticsPrivate * priv, const struct SynapticsHwState *hw,
+              enum EdgeType edge, int *dxP, int *dyP, Bool inside_area)
+{
+    enum MovingState moving_state;
+    double dx, dy;
+    int delay = 1000000000;
+
+    dx = dy = 0;
+
+    moving_state = priv->moving_state;
+    if (moving_state == MS_FALSE) {
+        switch (priv->tap_state) {
+        case TS_MOVE:
+        case TS_DRAG:
+            moving_state = MS_TOUCHPAD_RELATIVE;
+            break;
+        case TS_1:
+        case TS_3:
+        case TS_5:
+            moving_state = MS_TOUCHPAD_RELATIVE;
+            break;
+        default:
+            break;
+        }
+    }
+
+    if (!inside_area || !moving_state || priv->finger_state == FS_BLOCKED ||
+        priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
+        priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
+        priv->circ_scroll_on || priv->prevFingers != hw->numFingers ||
+        (moving_state == MS_TOUCHPAD_RELATIVE && hw->numFingers != 1)) {
+        /* reset packet counter. */
+        priv->count_packet_finger = 0;
+        goto out;
+    }
+
+    /* To create the illusion of fluid motion, call back at roughly the report
+     * rate, even in the absence of new hardware events; see comment above
+     * POLL_MS declaration. */
+    delay = MIN(delay, POLL_MS);
+
+    if (priv->count_packet_finger <= 1)
+        goto out;               /* skip the lot */
+
+    if (moving_state == MS_TOUCHPAD_RELATIVE)
+        get_delta(priv, hw, edge, &dx, &dy);
+
+ out:
+    priv->prevFingers = hw->numFingers;
+
+    *dxP = dx;
+    *dyP = dy;
+
+    return delay;
+}
+
+static double
+estimate_delta_circ(SynapticsPrivate * priv)
+{
+    double a1 = angle(priv, HIST(3).x, HIST(3).y);
+    double a2 = angle(priv, HIST(2).x, HIST(2).y);
+    double a3 = angle(priv, HIST(1).x, HIST(1).y);
+    double a4 = angle(priv, HIST(0).x, HIST(0).y);
+    double d1 = diffa(a2, a1);
+    double d2 = d1 + diffa(a3, a2);
+    double d3 = d2 + diffa(a4, a3);
+
+    return estimate_delta(d3, d2, d1, 0);
+}
+
+/* vert and horiz are to know which direction to start coasting
+ * circ is true if the user had been circular scrolling.
+ */
+static void
+start_coasting(SynapticsPrivate * priv, struct SynapticsHwState *hw,
+               Bool vert, Bool horiz, Bool circ)
+{
+    SynapticsParameters *para = &priv->synpara;
+
+    priv->scroll.coast_delta_y = 0.0;
+    priv->scroll.coast_delta_x = 0.0;
+
+    if ((priv->scroll.packets_this_scroll > 3) && (para->coasting_speed > 0.0)) {
+        double pkt_time = HIST_DELTA(0, 3, millis) / 1000.0;
+
+        if (vert && !circ) {
+            double dy =
+                estimate_delta(HIST(0).y, HIST(1).y, HIST(2).y, HIST(3).y);
+            if (pkt_time > 0) {
+                double scrolls_per_sec = (dy / abs(para->scroll_dist_vert)) / pkt_time;
+
+                if (fabs(scrolls_per_sec) >= para->coasting_speed) {
+                    priv->scroll.coast_speed_y = scrolls_per_sec;
+                    priv->scroll.coast_delta_y = (hw->y - priv->scroll.last_y);
+                }
+            }
+        }
+        if (horiz && !circ) {
+            double dx =
+                estimate_delta(HIST(0).x, HIST(1).x, HIST(2).x, HIST(3).x);
+            if (pkt_time > 0) {
+                double scrolls_per_sec = (dx / abs(para->scroll_dist_vert)) / pkt_time;
+
+                if (fabs(scrolls_per_sec) >= para->coasting_speed) {
+                    priv->scroll.coast_speed_x = scrolls_per_sec;
+                    priv->scroll.coast_delta_x = (hw->x - priv->scroll.last_x);
+                }
+            }
+        }
+        if (circ) {
+            double da = estimate_delta_circ(priv);
+
+            if (pkt_time > 0) {
+                double scrolls_per_sec = (da / para->scroll_dist_circ) / pkt_time;
+
+                if (fabs(scrolls_per_sec) >= para->coasting_speed) {
+                    if (vert) {
+                        priv->scroll.coast_speed_y = scrolls_per_sec;
+                        priv->scroll.coast_delta_y =
+                            diffa(priv->scroll.last_a,
+                                  angle(priv, hw->x, hw->y));
+                    }
+                    else if (horiz) {
+                        priv->scroll.coast_speed_x = scrolls_per_sec;
+                        priv->scroll.coast_delta_x =
+                            diffa(priv->scroll.last_a,
+                                  angle(priv, hw->x, hw->y));
+                    }
+                }
+            }
+        }
+    }
+    priv->scroll.packets_this_scroll = 0;
+}
+
+static void
+stop_coasting(SynapticsPrivate * priv)
+{
+    priv->scroll.coast_speed_x = 0;
+    priv->scroll.coast_speed_y = 0;
+    priv->scroll.packets_this_scroll = 0;
+}
+
+static int
+HandleScrolling(SynapticsPrivate * priv, struct SynapticsHwState *hw,
+                enum EdgeType edge, Bool finger)
+{
+    SynapticsParameters *para = &priv->synpara;
+    int delay = 1000000000;
+
+    if ((priv->synpara.touchpad_off == TOUCHPAD_TAP_OFF) || (priv->finger_state == FS_BLOCKED)) {
+        stop_coasting(priv);
+        priv->circ_scroll_on = FALSE;
+        priv->vert_scroll_edge_on = FALSE;
+        priv->horiz_scroll_edge_on = FALSE;
+        priv->vert_scroll_twofinger_on = FALSE;
+        priv->horiz_scroll_twofinger_on = FALSE;
+        return delay;
+    }
+
+    /* scroll detection */
+    if (finger && priv->finger_state == FS_UNTOUCHED) {
+        stop_coasting(priv);
+        priv->scroll.delta_y = 0;
+        priv->scroll.delta_x = 0;
+        if (para->circular_scrolling) {
+            if ((para->circular_trigger == 0 && edge) ||
+                (para->circular_trigger == 1 && edge & TOP_EDGE) ||
+                (para->circular_trigger == 2 && edge & TOP_EDGE &&
+                 edge & RIGHT_EDGE) || (para->circular_trigger == 3 &&
+                                        edge & RIGHT_EDGE) ||
+                (para->circular_trigger == 4 && edge & RIGHT_EDGE &&
+                 edge & BOTTOM_EDGE) || (para->circular_trigger == 5 &&
+                                         edge & BOTTOM_EDGE) ||
+                (para->circular_trigger == 6 && edge & BOTTOM_EDGE &&
+                 edge & LEFT_EDGE) || (para->circular_trigger == 7 &&
+                                       edge & LEFT_EDGE) ||
+                (para->circular_trigger == 8 && edge & LEFT_EDGE &&
+                 edge & TOP_EDGE)) {
+                priv->circ_scroll_on = TRUE;
+                priv->circ_scroll_vert = TRUE;
+                priv->scroll.last_a = angle(priv, hw->x, hw->y);
+                DBG(7, "circular scroll detected on edge\n");
+            }
+        }
+    }
+    if (!priv->circ_scroll_on) {
+        if (finger) {
+            if (hw->numFingers == 2) {
+                if (!priv->vert_scroll_twofinger_on &&
+                    (para->scroll_twofinger_vert) &&
+                    (para->scroll_dist_vert != 0)) {
+                    stop_coasting(priv);
+                    priv->vert_scroll_twofinger_on = TRUE;
+                    priv->vert_scroll_edge_on = FALSE;
+                    priv->scroll.last_y = hw->y;
+                    DBG(7, "vert two-finger scroll detected\n");
+                }
+                if (!priv->horiz_scroll_twofinger_on &&
+                    (para->scroll_twofinger_horiz) &&
+                    (para->scroll_dist_horiz != 0)) {
+                    stop_coasting(priv);
+                    priv->horiz_scroll_twofinger_on = TRUE;
+                    priv->horiz_scroll_edge_on = FALSE;
+                    priv->scroll.last_x = hw->x;
+                    DBG(7, "horiz two-finger scroll detected\n");
+                }
+            }
+        }
+        if (finger && priv->finger_state == FS_UNTOUCHED) {
+            if (!priv->vert_scroll_twofinger_on &&
+                !priv->horiz_scroll_twofinger_on) {
+                if ((para->scroll_edge_vert) && (para->scroll_dist_vert != 0) &&
+                    (edge & RIGHT_EDGE)) {
+                    priv->vert_scroll_edge_on = TRUE;
+                    priv->scroll.last_y = hw->y;
+                    DBG(7, "vert edge scroll detected on right edge\n");
+                }
+                if ((para->scroll_edge_horiz) && (para->scroll_dist_horiz != 0)
+                    && (edge & BOTTOM_EDGE)) {
+                    priv->horiz_scroll_edge_on = TRUE;
+                    priv->scroll.last_x = hw->x;
+                    DBG(7, "horiz edge scroll detected on bottom edge\n");
+                }
+            }
+        }
+    }
+    {
+        Bool oldv = priv->vert_scroll_twofinger_on || priv->vert_scroll_edge_on
+            || (priv->circ_scroll_on && priv->circ_scroll_vert);
+
+        Bool oldh = priv->horiz_scroll_twofinger_on ||
+            priv->horiz_scroll_edge_on || (priv->circ_scroll_on &&
+                                           !priv->circ_scroll_vert);
+
+        Bool oldc = priv->circ_scroll_on;
+
+        if (priv->circ_scroll_on && !finger) {
+            /* circular scroll locks in until finger is raised */
+            DBG(7, "cicular scroll off\n");
+            priv->circ_scroll_on = FALSE;
+        }
+
+        if (!finger || hw->numFingers != 2) {
+            if (priv->vert_scroll_twofinger_on) {
+                DBG(7, "vert two-finger scroll off\n");
+                priv->vert_scroll_twofinger_on = FALSE;
+            }
+            if (priv->horiz_scroll_twofinger_on) {
+                DBG(7, "horiz two-finger scroll off\n");
+                priv->horiz_scroll_twofinger_on = FALSE;
+            }
+        }
+
+        if (priv->vert_scroll_edge_on && (!(edge & RIGHT_EDGE) || !finger)) {
+            DBG(7, "vert edge scroll off\n");
+            priv->vert_scroll_edge_on = FALSE;
+        }
+        if (priv->horiz_scroll_edge_on && (!(edge & BOTTOM_EDGE) || !finger)) {
+            DBG(7, "horiz edge scroll off\n");
+            priv->horiz_scroll_edge_on = FALSE;
+        }
+        /* If we were corner edge scrolling (coasting),
+         * but no longer in corner or raised a finger, then stop coasting. */
+        if (para->scroll_edge_corner &&
+            (priv->scroll.coast_speed_x || priv->scroll.coast_speed_y)) {
+            Bool is_in_corner = ((edge & RIGHT_EDGE) &&
+                                 (edge & (TOP_EDGE | BOTTOM_EDGE))) ||
+                ((edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE)));
+            if (!is_in_corner || !finger) {
+                DBG(7, "corner edge scroll off\n");
+                stop_coasting(priv);
+            }
+        }
+        /* if we were scrolling, but couldn't corner edge scroll,
+         * and are no longer scrolling, then start coasting */
+        oldv = oldv && !(priv->vert_scroll_twofinger_on ||
+                         priv->vert_scroll_edge_on || (priv->circ_scroll_on &&
+                                                       priv->circ_scroll_vert));
+
+        oldh = oldh && !(priv->horiz_scroll_twofinger_on ||
+                         priv->horiz_scroll_edge_on || (priv->circ_scroll_on &&
+                                                        !priv->
+                                                        circ_scroll_vert));
+
+        oldc = oldc && !priv->circ_scroll_on;
+
+        if ((oldv || oldh) && !para->scroll_edge_corner) {
+            start_coasting(priv, hw, oldv, oldh, oldc);
+        }
+    }
+
+    /* if hitting a corner (top right or bottom right) while vertical
+     * scrolling is active, consider starting corner edge scrolling or
+     * switching over to circular scrolling smoothly */
+    if (priv->vert_scroll_edge_on && !priv->horiz_scroll_edge_on &&
+        (edge & RIGHT_EDGE) && (edge & (TOP_EDGE | BOTTOM_EDGE))) {
+        if (para->scroll_edge_corner) {
+            if (priv->scroll.coast_speed_y == 0) {
+                /* FYI: We can generate multiple start_coasting requests if
+                 * we're in the corner, but we were moving so slowly when we
+                 * got here that we didn't actually start coasting. */
+                DBG(7, "corner edge scroll on\n");
+                start_coasting(priv, hw, TRUE, FALSE, FALSE);
+            }
+        }
+        else if (para->circular_scrolling) {
+            priv->vert_scroll_edge_on = FALSE;
+            priv->circ_scroll_on = TRUE;
+            priv->circ_scroll_vert = TRUE;
+            priv->scroll.last_a = angle(priv, hw->x, hw->y);
+            DBG(7, "switching to circular scrolling\n");
+        }
+    }
+    /* Same treatment for horizontal scrolling */
+    if (priv->horiz_scroll_edge_on && !priv->vert_scroll_edge_on &&
+        (edge & BOTTOM_EDGE) && (edge & (LEFT_EDGE | RIGHT_EDGE))) {
+        if (para->scroll_edge_corner) {
+            if (priv->scroll.coast_speed_x == 0) {
+                /* FYI: We can generate multiple start_coasting requests if
+                 * we're in the corner, but we were moving so slowly when we
+                 * got here that we didn't actually start coasting. */
+                DBG(7, "corner edge scroll on\n");
+                start_coasting(priv, hw, FALSE, TRUE, FALSE);
+            }
+        }
+        else if (para->circular_scrolling) {
+            priv->horiz_scroll_edge_on = FALSE;
+            priv->circ_scroll_on = TRUE;
+            priv->circ_scroll_vert = FALSE;
+            priv->scroll.last_a = angle(priv, hw->x, hw->y);
+            DBG(7, "switching to circular scrolling\n");
+        }
+    }
+
+    if (priv->vert_scroll_edge_on || priv->horiz_scroll_edge_on ||
+        priv->vert_scroll_twofinger_on || priv->horiz_scroll_twofinger_on ||
+        priv->circ_scroll_on) {
+        priv->scroll.packets_this_scroll++;
+    }
+
+    if (priv->vert_scroll_edge_on || priv->vert_scroll_twofinger_on) {
+        /* + = down, - = up */
+        if (para->scroll_dist_vert != 0 && hw->y != priv->scroll.last_y) {
+            priv->scroll.delta_y += (hw->y - priv->scroll.last_y);
+            priv->scroll.last_y = hw->y;
+        }
+    }
+    if (priv->horiz_scroll_edge_on || priv->horiz_scroll_twofinger_on) {
+        /* + = right, - = left */
+        if (para->scroll_dist_horiz != 0 && hw->x != priv->scroll.last_x) {
+            priv->scroll.delta_x += (hw->x - priv->scroll.last_x);
+            priv->scroll.last_x = hw->x;
+        }
+    }
+    if (priv->circ_scroll_on) {
+        /* + = counter clockwise, - = clockwise */
+        double delta = para->scroll_dist_circ;
+        double diff = diffa(priv->scroll.last_a, angle(priv, hw->x, hw->y));
+
+        if (delta >= 0.005 && diff != 0.0) {
+            if (priv->circ_scroll_vert)
+                priv->scroll.delta_y -= diff / delta * para->scroll_dist_vert;
+            else
+                priv->scroll.delta_x -= diff / delta * para->scroll_dist_horiz;
+            priv->scroll.last_a = angle(priv, hw->x, hw->y);
+        }
+    }
+
+    if (priv->scroll.coast_speed_y) {
+        double dtime = (hw->millis - priv->scroll.last_millis) / 1000.0;
+        double ddy = para->coasting_friction * dtime;
+
+        priv->scroll.delta_y += priv->scroll.coast_speed_y * dtime * abs(para->scroll_dist_vert);
+        delay = MIN(delay, POLL_MS);
+        if (abs(priv->scroll.coast_speed_y) < ddy) {
+            priv->scroll.coast_speed_y = 0;
+            priv->scroll.packets_this_scroll = 0;
+        }
+        else {
+            priv->scroll.coast_speed_y +=
+                (priv->scroll.coast_speed_y < 0 ? ddy : -ddy);
+        }
+    }
+
+    if (priv->scroll.coast_speed_x) {
+        double dtime = (hw->millis - priv->scroll.last_millis) / 1000.0;
+        double ddx = para->coasting_friction * dtime;
+        priv->scroll.delta_x += priv->scroll.coast_speed_x * dtime * abs(para->scroll_dist_horiz);
+        delay = MIN(delay, POLL_MS);
+        if (abs(priv->scroll.coast_speed_x) < ddx) {
+            priv->scroll.coast_speed_x = 0;
+            priv->scroll.packets_this_scroll = 0;
+        }
+        else {
+            priv->scroll.coast_speed_x +=
+                (priv->scroll.coast_speed_x < 0 ? ddx : -ddx);
+        }
+    }
+
+    return delay;
+}
+
+/**
+ * Check if any 2+ fingers are close enough together to assume this is a
+ * ClickFinger action.
+ */
+static int
+clickpad_guess_clickfingers(SynapticsPrivate * priv,
+                            struct SynapticsHwState *hw)
+{
+    int nfingers = 0;
+    uint32_t close_point = 0; /* 1 bit for each point close to another one */
+    int i, j;
+
+    BUG_RETURN_VAL(hw->num_mt_mask > sizeof(close_point) * 8, 0);
+
+    for (i = 0; i < hw->num_mt_mask - 1; i++) {
+        ValuatorMask *f1;
+
+        if (hw->slot_state[i] == SLOTSTATE_EMPTY ||
+            hw->slot_state[i] == SLOTSTATE_CLOSE)
+            continue;
+
+        f1 = hw->mt_mask[i];
+
+        for (j = i + 1; j < hw->num_mt_mask; j++) {
+            ValuatorMask *f2;
+            double x1, x2, y1, y2;
+
+            if (hw->slot_state[j] == SLOTSTATE_EMPTY ||
+                hw->slot_state[j] == SLOTSTATE_CLOSE)
+                continue;
+
+            f2 = hw->mt_mask[j];
+
+            x1 = valuator_mask_get_double(f1, 0);
+            y1 = valuator_mask_get_double(f1, 1);
+
+            x2 = valuator_mask_get_double(f2, 0);
+            y2 = valuator_mask_get_double(f2, 1);
+
+            /* FIXME: fingers closer together than 30% of touchpad width, but
+             * really, this should be dependent on the touchpad size. Also,
+             * you'll need to find a touchpad that doesn't lie about it's
+             * size. Good luck. */
+            if (abs(x1 - x2) < (priv->maxx - priv->minx) * .3 &&
+                abs(y1 - y2) < (priv->maxy - priv->miny) * .3) {
+                close_point |= (1 << j);
+                close_point |= (1 << i);
+            }
+        }
+    }
+
+    while (close_point > 0) {
+        nfingers += close_point & 0x1;
+        close_point >>= 1;
+    }
+
+    return nfingers;
+}
+
+static void
+handle_clickfinger(SynapticsPrivate * priv, struct SynapticsHwState *hw)
+{
+    SynapticsParameters *para = &priv->synpara;
+    int action = 0;
+    int nfingers = hw->numFingers;
+
+    /* if this is a clickpad, clickfinger handling is:
+     * one finger down: no action, this is a normal click
+     * two fingers down: F2_CLICK
+     * three fingers down: F3_CLICK
+     */
+
+    if (para->clickpad)
+        nfingers = clickpad_guess_clickfingers(priv, hw);
+
+    switch (nfingers) {
+    case 1:
+        action = para->click_action[F1_CLICK1];
+        break;
+    case 2:
+        action = para->click_action[F2_CLICK1];
+        break;
+    case 3:
+        action = para->click_action[F3_CLICK1];
+        break;
+    }
+    switch (action) {
+    case 1:
+        hw->left = 1 | BTN_EMULATED_FLAG;
+        break;
+    case 2:
+        hw->left = 0;
+        hw->middle = 1 | BTN_EMULATED_FLAG;
+        break;
+    case 3:
+        hw->left = 0;
+        hw->right = 1 | BTN_EMULATED_FLAG;
+        break;
+    }
+}
+
+static void
+update_hw_button_state(const InputInfoPtr pInfo, struct SynapticsHwState *hw,
+                       struct SynapticsHwState *old, CARD32 now, int *delay)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    SynapticsParameters *para = &priv->synpara;
+
+    /* Treat the first two multi buttons as up/down for now. */
+    hw->up |= hw->multi[0];
+    hw->down |= hw->multi[1];
+
+    /* 3rd button emulation */
+    hw->middle |= HandleMidButtonEmulation(priv, hw, now, delay);
+
+    /* If this is a clickpad and the user clicks in a soft button area, press
+     * the soft button instead. */
+    if (para->clickpad) {
+        /* hw->left is down, but no other buttons were already down */
+        if (!old->left && !old->right && !old->middle &&
+            hw->left && !hw->right && !hw->middle && !hw->trackpoint_middle) {
+                if (is_inside_rightbutton_area(para, hw->x, hw->y)) {
+                    hw->left = 0;
+                    hw->right = 1;
+                }
+                else if (is_inside_middlebutton_area(para, hw->x, hw->y)) {
+                    hw->left = 0;
+                    hw->middle = 1;
+                    if (trackpoint) {
+                        hw->middle = 0;
+                        hw->trackpoint_middle = 1;
+                        EvdevWheelEmuFilterButton(trackpoint, 2, 1);
+                    }
+                }
+        }
+        else if (hw->left) {
+            hw->left = old->left;
+            hw->right = old->right;
+            hw->middle = old->middle;
+        }
+        else if (hw->trackpoint_middle) {
+            hw->trackpoint_middle = 0;
+            EvdevWheelEmuFilterButton(trackpoint, 2, 0);
+	    EvdevProcessSyncEvent(trackpoint, NULL);
+        }
+    }
+
+    /* Fingers emulate other buttons. ClickFinger can only be
+       triggered on transition, when left is pressed
+     */
+    if (hw->left && !old->left && !old->middle && !old->right &&
+        hw->numFingers >= 1) {
+        handle_clickfinger(priv, hw);
+    }
+
+    /* Two finger emulation */
+    if (hw->numFingers == 1 && hw->z >= para->emulate_twofinger_z &&
+        hw->fingerWidth >= para->emulate_twofinger_w) {
+        hw->numFingers = 2;
+    }
+}
+
+static void
+post_button_click(const InputInfoPtr pInfo, const int button)
+{
+    xf86PostButtonEvent(pInfo->dev, FALSE, button, TRUE, 0, 0);
+    xf86PostButtonEvent(pInfo->dev, FALSE, button, FALSE, 0, 0);
+}
+
+static void
+post_scroll_events(const InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+
+    valuator_mask_zero(priv->scroll_events_mask);
+
+    if (priv->scroll.delta_y != 0.0) {
+        valuator_mask_set_double(priv->scroll_events_mask,
+                                 priv->scroll_axis_vert, priv->scroll.delta_y);
+        priv->scroll.delta_y = 0;
+    }
+    if (priv->scroll.delta_x != 0.0) {
+        valuator_mask_set_double(priv->scroll_events_mask,
+                                 priv->scroll_axis_horiz, priv->scroll.delta_x);
+        priv->scroll.delta_x = 0;
+    }
+    if (valuator_mask_num_valuators(priv->scroll_events_mask))
+        xf86PostMotionEventM(pInfo->dev, FALSE, priv->scroll_events_mask);
+}
+
+/* Update the open slots and number of active touches */
+static void
+UpdateTouchState(InputInfoPtr pInfo, struct SynapticsHwState *hw)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    int i;
+
+    for (i = 0; i < hw->num_mt_mask; i++) {
+        if (hw->slot_state[i] == SLOTSTATE_OPEN) {
+            priv->open_slots[priv->num_active_touches] = i;
+            priv->num_active_touches++;
+            BUG_WARN(priv->num_active_touches > priv->num_slots);
+        }
+        else if (hw->slot_state[i] == SLOTSTATE_CLOSE) {
+            Bool found = FALSE;
+            int j;
+
+            for (j = 0; j < priv->num_active_touches - 1; j++) {
+                if (priv->open_slots[j] == i)
+                    found = TRUE;
+
+                if (found)
+                    priv->open_slots[j] = priv->open_slots[j + 1];
+            }
+
+            BUG_WARN(priv->num_active_touches == 0);
+            if (priv->num_active_touches > 0)
+                priv->num_active_touches--;
+        }
+    }
+
+    SynapticsResetTouchHwState(hw, FALSE);
+}
+
+static void
+HandleTouches(InputInfoPtr pInfo, struct SynapticsHwState *hw)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+    SynapticsParameters *para = &priv->synpara;
+    int new_active_touches = priv->num_active_touches;
+    int min_touches = 2;
+    Bool restart_touches = FALSE;
+    int i;
+
+    if (para->click_action[F3_CLICK1] || para->tap_action[F3_TAP])
+        min_touches = 4;
+    else if (para->click_action[F2_CLICK1] || para->tap_action[F2_TAP] ||
+             para->scroll_twofinger_vert || para->scroll_twofinger_horiz)
+        min_touches = 3;
+
+    /* Count new number of active touches */
+    for (i = 0; i < hw->num_mt_mask; i++) {
+        if (hw->slot_state[i] == SLOTSTATE_OPEN)
+            new_active_touches++;
+        else if (hw->slot_state[i] == SLOTSTATE_CLOSE)
+            new_active_touches--;
+    }
+
+    if (priv->has_semi_mt)
+        goto out;
+
+    if (priv->num_active_touches < min_touches &&
+        new_active_touches < min_touches) {
+        /* We stayed below number of touches needed to send events */
+        goto out;
+    }
+    else if (priv->num_active_touches >= min_touches &&
+             new_active_touches < min_touches) {
+        /* We are transitioning to less than the number of touches needed to
+         * send events. End all currently open touches. */
+        for (i = 0; i < priv->num_active_touches; i++) {
+            int slot = priv->open_slots[i];
+
+            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchEnd, 0,
+                               hw->mt_mask[slot]);
+        }
+
+        /* Don't send any more events */
+        goto out;
+    }
+    else if (priv->num_active_touches < min_touches &&
+             new_active_touches >= min_touches) {
+        /* We are transitioning to more than the number of touches needed to
+         * send events. Begin all already open touches. */
+        restart_touches = TRUE;
+        for (i = 0; i < priv->num_active_touches; i++) {
+            int slot = priv->open_slots[i];
+
+            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchBegin, 0,
+                               hw->mt_mask[slot]);
+        }
+    }
+
+    /* Send touch begin events for all new touches */
+    for (i = 0; i < hw->num_mt_mask; i++)
+        if (hw->slot_state[i] == SLOTSTATE_OPEN)
+            xf86PostTouchEvent(pInfo->dev, i, XI_TouchBegin, 0, hw->mt_mask[i]);
+
+    /* Send touch update/end events for all the rest */
+    for (i = 0; i < priv->num_active_touches; i++) {
+        int slot = priv->open_slots[i];
+
+        /* Don't send update event if we just reopened the touch above */
+        if (hw->slot_state[slot] == SLOTSTATE_UPDATE && !restart_touches)
+            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchUpdate, 0,
+                               hw->mt_mask[slot]);
+        else if (hw->slot_state[slot] == SLOTSTATE_CLOSE)
+            xf86PostTouchEvent(pInfo->dev, slot, XI_TouchEnd, 0,
+                               hw->mt_mask[slot]);
+    }
+
+ out:
+    UpdateTouchState(pInfo, hw);
+}
+
+static void
+filter_jitter(SynapticsPrivate * priv, int *x, int *y)
+{
+    SynapticsParameters *para = &priv->synpara;
+
+    priv->hyst_center_x = hysteresis(*x, priv->hyst_center_x, para->hyst_x);
+    priv->hyst_center_y = hysteresis(*y, priv->hyst_center_y, para->hyst_y);
+    *x = priv->hyst_center_x;
+    *y = priv->hyst_center_y;
+}
+
+static void
+reset_hw_state(struct SynapticsHwState *hw)
+{
+    hw->x = 0;
+    hw->y = 0;
+    hw->z = 0;
+    hw->numFingers = 0;
+    hw->fingerWidth = 0;
+}
+
+/*
+ * React on changes in the hardware state. This function is called every time
+ * the hardware state changes. The return value is used to specify how many
+ * milliseconds to wait before calling the function again if no state change
+ * occurs.
+ *
+ * from_timer denotes if HandleState was triggered from a timer (e.g. to
+ * generate fake motion events, or for the tap-to-click state machine), rather
+ * than from having received a motion event.
+ */
+static int
+HandleState(InputInfoPtr pInfo, struct SynapticsHwState *hw, CARD32 now,
+            Bool from_timer)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) (pInfo->private);
+    SynapticsParameters *para = &priv->synpara;
+    enum FingerState finger = FS_UNTOUCHED;
+    int dx = 0, dy = 0, buttons, id;
+    enum EdgeType edge = NO_EDGE;
+    int change;
+    int double_click = FALSE;
+    int delay = 1000000000;
+    int timeleft;
+    Bool inside_active_area;
+
+    /* If touchpad is switched off, we skip the whole thing and return delay */
+    if (para->touchpad_off == TOUCHPAD_OFF) {
+        UpdateTouchState(pInfo, hw);
+        return delay;
+    }
+
+    /* We need both and x/y, the driver can't handle just one of the two
+     * yet. But since it's possible to hit a phys button on non-clickpads
+     * without ever getting motion data first, we must continue with 0/0 for
+     * that case. */
+    if (hw->x == INT_MIN || hw->y == INT_MAX) {
+        if (para->clickpad)
+            return delay;
+        else if (hw->left || hw->right || hw->middle) {
+            hw->x = (hw->x == INT_MIN) ? 0 : hw->x;
+            hw->y = (hw->y == INT_MIN) ? 0 : hw->y;
+        }
+    }
+
+    /* If a physical button is pressed on a clickpad, use cumulative relative
+     * touch movements for motion */
+    if (para->clickpad && (hw->left || hw->right || hw->middle)) {
+        hw->x = hw->cumulative_dx;
+        hw->y = hw->cumulative_dy;
+    }
+
+    /* apply hysteresis before doing anything serious. This cancels
+     * out a lot of noise which might surface in strange phenomena
+     * like flicker in scrolling or noise motion. */
+    filter_jitter(priv, &hw->x, &hw->y);
+
+    inside_active_area = is_inside_active_area(priv, hw->x, hw->y);
+
+    /* these two just update hw->left, right, etc. */
+    update_hw_button_state(pInfo, hw, priv->old_hw_state, now, &delay);
+
+    /* now we know that these _coordinates_ aren't in the area.
+       invalid are: x, y, z, numFingers, fingerWidth
+       valid are: millis, left/right/middle/up/down/etc.
+     */
+    if (!inside_active_area) {
+        reset_hw_state(hw);
+
+        /* FIXME: if finger accidentally moves into the area and doesn't
+         * really release, the finger should remain down. */
+    }
+
+    /* no edge or finger detection outside of area */
+    if (inside_active_area) {
+        edge = edge_detection(priv, hw->x, hw->y);
+        if (!from_timer)
+            finger = SynapticsDetectFinger(priv, hw);
+        else
+            finger = priv->finger_state;
+    }
+
+    /* tap and drag detection. Needs to be performed even if the finger is in
+     * the dead area to reset the state. */
+    timeleft = HandleTapProcessing(priv, hw, now, finger, inside_active_area);
+    if (timeleft > 0)
+        delay = MIN(delay, timeleft);
+
+    if (inside_active_area) {
+        /* Don't bother about scrolling in the dead area of the touchpad. */
+        timeleft = HandleScrolling(priv, hw, edge, (finger >= FS_TOUCHED));
+        if (timeleft > 0)
+            delay = MIN(delay, timeleft);
+
+        /*
+         * Compensate for unequal x/y resolution. This needs to be done after
+         * calculations that require unadjusted coordinates, for example edge
+         * detection.
+         */
+        ScaleCoordinates(priv, hw);
+    }
+
+    dx = dy = 0;
+
+    timeleft = ComputeDeltas(priv, hw, edge, &dx, &dy, inside_active_area);
+    delay = MIN(delay, timeleft);
+
+    buttons = ((hw->left ? 0x01 : 0) |
+               (hw->middle ? 0x02 : 0) |
+               (hw->right ? 0x04 : 0) |
+               (hw->up ? 0x08 : 0) |
+               (hw->down ? 0x10 : 0) |
+               (hw->multi[2] ? 0x20 : 0) | (hw->multi[3] ? 0x40 : 0));
+
+    if (priv->tap_button > 0) {
+        int tap_mask = 1 << (priv->tap_button - 1);
+
+        if (priv->tap_button_state == TBS_BUTTON_DOWN_UP) {
+            if (tap_mask != (priv->lastButtons & tap_mask)) {
+                xf86PostButtonEvent(pInfo->dev, FALSE, priv->tap_button, TRUE,
+                                    0, 0);
+                priv->lastButtons |= tap_mask;
+            }
+            priv->tap_button_state = TBS_BUTTON_UP;
+        }
+        if (priv->tap_button_state == TBS_BUTTON_DOWN)
+            buttons |= tap_mask;
+    }
+
+    /* Post events */
+    if (finger >= FS_TOUCHED && (dx || dy))
+        xf86PostMotionEvent(pInfo->dev, 0, 0, 2, dx, dy);
+
+    if (priv->mid_emu_state == MBE_LEFT_CLICK) {
+        post_button_click(pInfo, 1);
+        priv->mid_emu_state = MBE_OFF;
+    }
+    else if (priv->mid_emu_state == MBE_RIGHT_CLICK) {
+        post_button_click(pInfo, 3);
+        priv->mid_emu_state = MBE_OFF;
+    }
+
+    change = buttons ^ priv->lastButtons;
+    while (change) {
+        id = ffs(change);       /* number of first set bit 1..32 is returned */
+        change &= ~(1 << (id - 1));
+        xf86PostButtonEvent(pInfo->dev, FALSE, id, (buttons & (1 << (id - 1))),
+                            0, 0);
+    }
+
+    /* Process scroll events only if coordinates are
+     * in the Synaptics Area
+     */
+    if (inside_active_area &&
+        (priv->scroll.delta_x != 0.0 || priv->scroll.delta_y != 0.0)) {
+        post_scroll_events(pInfo);
+        priv->scroll.last_millis = hw->millis;
+    }
+
+    if (double_click) {
+        post_button_click(pInfo, 1);
+        post_button_click(pInfo, 1);
+    }
+
+    HandleTouches(pInfo, hw);
+
+    /* Save old values of some state variables */
+    priv->finger_state = finger;
+    priv->lastButtons = buttons;
+
+    /* generate a history of the absolute positions */
+    if (inside_active_area)
+        store_history(priv, hw->x, hw->y, hw->millis);
+
+    /* Save logical state for transition comparisons */
+    SynapticsCopyHwState(priv->old_hw_state, hw);
+
+    return delay;
+}
+
+static int
+ControlProc(InputInfoPtr pInfo, xDeviceCtl * control)
+{
+    DBG(3, "Control Proc called\n");
+    return Success;
+}
+
+static int
+SwitchMode(ClientPtr client, DeviceIntPtr dev, int mode)
+{
+    DBG(3, "SwitchMode called\n");
+
+    return XI_BadMode;
+}
+
+static void
+ReadDevDimensions(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+
+    if (priv->proto_ops->ReadDevDimensions)
+        priv->proto_ops->ReadDevDimensions(pInfo);
+
+    SanitizeDimensions(pInfo);
+}
+
+static Bool
+QueryHardware(InputInfoPtr pInfo)
+{
+    SynapticsPrivate *priv = (SynapticsPrivate *) pInfo->private;
+
+    priv->comm.protoBufTail = 0;
+
+    if (!priv->proto_ops->QueryHardware(pInfo)) {
+        xf86IDrvMsg(pInfo, X_PROBED, "no supported touchpad found\n");
+        if (priv->proto_ops->DeviceOffHook)
+            priv->proto_ops->DeviceOffHook(pInfo);
+        return FALSE;
+    }
+
+    return TRUE;
+}
+
+static void
+ScaleCoordinates(SynapticsPrivate * priv, struct SynapticsHwState *hw)
+{
+    int xCenter = (priv->synpara.left_edge + priv->synpara.right_edge) / 2;
+    int yCenter = (priv->synpara.top_edge + priv->synpara.bottom_edge) / 2;
+
+    hw->x = (hw->x - xCenter) * priv->horiz_coeff + xCenter;
+    hw->y = (hw->y - yCenter) * priv->vert_coeff + yCenter;
+}
+
+void
+CalculateScalingCoeffs(SynapticsPrivate * priv)
+{
+    int vertRes = priv->synpara.resolution_vert;
+    int horizRes = priv->synpara.resolution_horiz;
+
+    if ((horizRes > vertRes) && (horizRes > 0)) {
+        priv->horiz_coeff = vertRes / (double) horizRes;
+        priv->vert_coeff = 1;
+    }
+    else if ((horizRes < vertRes) && (vertRes > 0)) {
+        priv->horiz_coeff = 1;
+        priv->vert_coeff = horizRes / (double) vertRes;
+    }
+    else {
+        priv->horiz_coeff = 1;
+        priv->vert_coeff = 1;
+    }
+}
diff -urN xf86-input-evdev-2.8.2.old/src/synapticsstr.h xf86-input-evdev-2.8.2/src/synapticsstr.h
--- xf86-input-evdev-2.8.2.old/src/synapticsstr.h	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/synapticsstr.h	2013-12-06 19:11:54.542702019 +0900
@@ -0,0 +1,287 @@
+/*
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Red Hat
+ * not be used in advertising or publicity pertaining to distribution
+ * of the software without specific, written prior permission.  Red
+ * Hat makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef	_SYNAPTICSSTR_H_
+#define _SYNAPTICSSTR_H_
+
+#include "synproto.h"
+
+#if GET_ABI_MAJOR(ABI_XINPUT_VERSION) < 18
+#define LogMessageVerbSigSafe xf86MsgVerb
+#endif
+
+#ifdef DBG
+#undef DBG
+#endif
+
+#ifdef DEBUG
+#define DBG(verb, ...) \
+    xf86MsgVerb(X_INFO, verb, __VA_ARGS__)
+#else
+#define DBG(verb, msg, ...)     /* */
+#endif
+
+/******************************************************************************
+ *		Definitions
+ *					structs, typedefs, #defines, enums
+ *****************************************************************************/
+#define SYNAPTICS_MOVE_HISTORY	5
+#define SYNAPTICS_MAX_TOUCHES	10
+#define SYN_MAX_BUTTONS 12      /* Max number of mouse buttons */
+
+enum OffState {
+    TOUCHPAD_ON = 0,
+    TOUCHPAD_OFF = 1,
+    TOUCHPAD_TAP_OFF = 2,
+};
+
+enum TapEvent {
+    RT_TAP = 0,                 /* Right top corner */
+    RB_TAP,                     /* Right bottom corner */
+    LT_TAP,                     /* Left top corner */
+    LB_TAP,                     /* Left bottom corner */
+    F1_TAP,                     /* Non-corner tap, one finger */
+    F2_TAP,                     /* Non-corner tap, two fingers */
+    F3_TAP,                     /* Non-corner tap, three fingers */
+    MAX_TAP
+};
+
+enum ClickFingerEvent {
+    F1_CLICK1 = 0,              /* Click left, one finger */
+    F2_CLICK1,                  /* Click left, two fingers */
+    F3_CLICK1,                  /* Click left, three fingers */
+    MAX_CLICK
+};
+
+
+typedef struct _SynapticsMoveHist {
+    int x, y;
+    CARD32 millis;
+} SynapticsMoveHistRec;
+
+typedef struct _SynapticsTouchAxis {
+    const char *label;
+    int min;
+    int max;
+    int res;
+} SynapticsTouchAxisRec;
+
+enum FingerState {              /* Note! The order matters. Compared with < operator. */
+    FS_BLOCKED = -1,
+    FS_UNTOUCHED = 0,           /* this is 0 so it's the initialized value. */
+    FS_TOUCHED = 1,
+    FS_PRESSED = 2,
+};
+
+enum MovingState {
+    MS_FALSE,
+    MS_TOUCHPAD_RELATIVE,
+};
+
+enum MidButtonEmulation {
+    MBE_OFF,                    /* No button pressed */
+    MBE_LEFT,                   /* Left button pressed, waiting for right button or timeout */
+    MBE_RIGHT,                  /* Right button pressed, waiting for left button or timeout */
+    MBE_MID,                    /* Left and right buttons pressed, waiting for both buttons
+                                   to be released */
+    MBE_TIMEOUT,                /* Waiting for both buttons to be released. */
+    MBE_LEFT_CLICK,             /* Emulate left button click. */
+    MBE_RIGHT_CLICK,            /* Emulate right button click. */
+};
+
+/* See docs/tapndrag.dia for a state machine diagram */
+enum TapState {
+    TS_START,                   /* No tap/drag in progress */
+    TS_1,                       /* After first touch */
+    TS_MOVE,                    /* Pointer movement enabled */
+    TS_2A,                      /* After first release */
+    TS_2B,                      /* After second/third/... release */
+    TS_SINGLETAP,               /* After timeout after first release */
+    TS_3,                       /* After second touch */
+    TS_DRAG,                    /* Pointer drag enabled */
+    TS_4,                       /* After release when "locked drags" enabled */
+    TS_5,                       /* After touch when "locked drags" enabled */
+    TS_CLICKPAD_MOVE,           /* After left button press on a clickpad */
+};
+
+enum TapButtonState {
+    TBS_BUTTON_UP,              /* "Virtual tap button" is up */
+    TBS_BUTTON_DOWN,            /* "Virtual tap button" is down */
+    TBS_BUTTON_DOWN_UP          /* Send button down event + set up state */
+};
+
+enum TouchpadModel {
+    MODEL_UNKNOWN = 0,
+    MODEL_SYNAPTICS,
+    MODEL_ALPS,
+    MODEL_APPLETOUCH,
+    MODEL_ELANTECH,
+    MODEL_UNIBODY_MACBOOK
+};
+
+typedef struct _SynapticsParameters {
+    /* Parameter data */
+    int left_edge, right_edge, top_edge, bottom_edge;   /* edge coordinates absolute */
+    int finger_low, finger_high, finger_press;  /* finger detection values in Z-values */
+    int tap_time;
+    int tap_move;               /* max. tapping time and movement in packets and coord. */
+    int single_tap_timeout;     /* timeout to recognize a single tap */
+    int tap_time_2;             /* max. tapping time for double taps */
+    int click_time;             /* The duration of a single click */
+    Bool clickpad;              /* Device is a has integrated buttons */
+    int emulate_mid_button_time;        /* Max time between left and right button presses to
+                                           emulate a middle button press. */
+    int emulate_twofinger_z;    /* pressure threshold to emulate two finger touch (for Alps) */
+    int emulate_twofinger_w;    /* Finger width threshold to emulate two finger touch */
+    int scroll_dist_vert;       /* Scrolling distance in absolute coordinates */
+    int scroll_dist_horiz;      /* Scrolling distance in absolute coordinates */
+    Bool scroll_edge_vert;      /* Enable/disable vertical scrolling on right edge */
+    Bool scroll_edge_horiz;     /* Enable/disable horizontal scrolling on left edge */
+    Bool scroll_edge_corner;    /* Enable/disable continuous edge scrolling when in the corner */
+    Bool scroll_twofinger_vert; /* Enable/disable vertical two-finger scrolling */
+    Bool scroll_twofinger_horiz;        /* Enable/disable horizontal two-finger scrolling */
+    double min_speed, max_speed, accl;  /* movement parameters */
+
+    int touchpad_off;           /* Switches the touchpad off
+                                 * 0 : Not off
+                                 * 1 : Off
+                                 * 2 : Only tapping and scrolling off
+                                 */
+    Bool locked_drags;          /* Enable locked drags */
+    int locked_drag_time;       /* timeout for locked drags */
+    int tap_action[MAX_TAP];    /* Button to report on tap events */
+    int click_action[MAX_CLICK];        /* Button to report on click with fingers */
+    Bool circular_scrolling;    /* Enable circular scrolling */
+    double scroll_dist_circ;    /* Scrolling angle radians */
+    int circular_trigger;       /* Trigger area for circular scrolling */
+    Bool palm_detect;           /* Enable Palm Detection */
+    int palm_min_width;         /* Palm detection width */
+    int palm_min_z;             /* Palm detection depth */
+    double coasting_speed;      /* Coasting threshold scrolling speed in scrolls/s */
+    double coasting_friction;   /* Number of scrolls per second per second to change coasting speed */
+    int press_motion_min_z;     /* finger pressure at which minimum pressure motion factor is applied */
+    int press_motion_max_z;     /* finger pressure at which maximum pressure motion factor is applied */
+    double press_motion_min_factor;     /* factor applied on speed when finger pressure is at minimum */
+    double press_motion_max_factor;     /* factor applied on speed when finger pressure is at minimum */
+    Bool grab_event_device;     /* grab event device for exclusive use? */
+    Bool tap_and_drag_gesture;  /* Switches the tap-and-drag gesture on/off */
+    unsigned int resolution_horiz;      /* horizontal resolution of touchpad in units/mm */
+    unsigned int resolution_vert;       /* vertical resolution of touchpad in units/mm */
+    int area_left_edge, area_right_edge, area_top_edge, area_bottom_edge;       /* area coordinates absolute */
+    int softbutton_areas[2][4]; /* soft button area coordinates, 0 => right, 1 => middle button */
+    int hyst_x, hyst_y;         /* x and y width of hysteresis box */
+} SynapticsParameters;
+
+struct _SynapticsPrivateRec {
+    int isSynaptics;
+    SynapticsParameters synpara;        /* Default parameter settings, read from
+                                           the X config file */
+    struct SynapticsProtocolOperations *proto_ops;
+    void *proto_data;           /* protocol-specific data */
+
+    struct SynapticsHwState *hwState;
+    struct SynapticsHwState *old_hw_state;      /* previous logical hw state */
+
+    const char *device;         /* device node */
+    CARD32 timer_time;          /* when timer last fired */
+    OsTimerPtr timer;           /* for tap processing, etc */
+
+    struct CommData comm;
+
+    struct SynapticsHwState *local_hw_state;    /* used in place of local hw state variables */
+
+    SynapticsMoveHistRec move_hist[SYNAPTICS_MOVE_HISTORY];     /* movement history */
+    int hist_index;             /* Last added entry in move_hist[] */
+    int hyst_center_x;          /* center x of hysteresis */
+    int hyst_center_y;          /* center y of hysteresis */
+    struct {
+        int last_x;             /* last x-scroll position */
+        int last_y;             /* last y-scroll position */
+        double delta_x;         /* accumulated horiz scroll delta */
+        double delta_y;         /* accumulated vert scroll delta */
+        double last_a;          /* last angle-scroll position */
+        CARD32 last_millis;     /* time last scroll event posted */
+        double coast_speed_x;   /* Horizontal coasting speed in scrolls/s */
+        double coast_speed_y;   /* Vertical coasting speed in scrolls/s */
+        double coast_delta_x;   /* Accumulated horizontal coast delta */
+        double coast_delta_y;   /* Accumulated vertical coast delta */
+        int packets_this_scroll;        /* Events received for this scroll */
+    } scroll;
+    int count_packet_finger;    /* packet counter with finger on the touchpad */
+    int button_delay_millis;    /* button delay for 3rd button emulation */
+    Bool prev_up;               /* Previous up button value, for double click emulation */
+    enum FingerState finger_state;      /* previous finger state */
+    CARD32 last_motion_millis;  /* time of the last motion */
+
+    enum TapState tap_state;    /* State of tap processing */
+    int tap_max_fingers;        /* Max number of fingers seen since entering start state */
+    int tap_button;             /* Which button started the tap processing */
+    enum TapButtonState tap_button_state;       /* Current tap action */
+    SynapticsMoveHistRec touch_on;      /* data when the touchpad is touched/released */
+
+    enum MovingState moving_state;      /* previous moving state */
+    Bool vert_scroll_edge_on;   /* Keeps track of currently active scroll modes */
+    Bool horiz_scroll_edge_on;  /* Keeps track of currently active scroll modes */
+    Bool vert_scroll_twofinger_on;      /* Keeps track of currently active scroll modes */
+    Bool horiz_scroll_twofinger_on;     /* Keeps track of currently active scroll modes */
+    Bool circ_scroll_on;        /* Keeps track of currently active scroll modes */
+    Bool circ_scroll_vert;      /* True: Generate vertical scroll events
+                                   False: Generate horizontal events */
+    double frac_x, frac_y;      /* absolute -> relative fraction */
+    enum MidButtonEmulation mid_emu_state;      /* emulated 3rd button */
+    int lastButtons;            /* last state of the buttons */
+    int prev_z;                 /* previous z value, for palm detection */
+    int prevFingers;            /* previous numFingers, for transition detection */
+    int avg_width;              /* weighted average of previous fingerWidth values */
+    double horiz_coeff;         /* normalization factor for x coordintes */
+    double vert_coeff;          /* normalization factor for y coordintes */
+
+    int minx, maxx, miny, maxy; /* min/max dimensions as detected */
+    int minp, maxp, minw, maxw; /* min/max pressure and finger width as detected */
+    int resx, resy;             /* resolution of coordinates as detected in units/mm */
+    Bool has_left;              /* left button detected for this device */
+    Bool has_right;             /* right button detected for this device */
+    Bool has_middle;            /* middle button detected for this device */
+    Bool has_double;            /* double click detected for this device */
+    Bool has_triple;            /* triple click detected for this device */
+    Bool has_pressure;          /* device reports pressure */
+    Bool has_width;             /* device reports finger width */
+    Bool has_scrollbuttons;     /* device has physical scrollbuttons */
+    Bool has_semi_mt;           /* device is only semi-multitouch capable */
+
+    enum TouchpadModel model;   /* The detected model */
+    unsigned short id_vendor;   /* vendor id */
+    unsigned short id_product;  /* product id */
+
+    int scroll_axis_horiz;      /* Horizontal smooth-scrolling axis */
+    int scroll_axis_vert;       /* Vertical smooth-scrolling axis */
+    ValuatorMask *scroll_events_mask;   /* ValuatorMask for smooth-scrolling */
+
+    Bool has_touch;             /* Device has multitouch capabilities */
+    int max_touches;            /* Number of touches supported */
+    int num_mt_axes;            /* Number of multitouch axes other than X, Y */
+    SynapticsTouchAxisRec *touch_axes;  /* Touch axis information other than X, Y */
+    int num_slots;              /* Number of touch slots allocated */
+    int *open_slots;            /* Array of currently open touch slots */
+    int num_active_touches;     /* Number of active touches on device */
+};
+
+#endif                          /* _SYNAPTICSSTR_H_ */
diff -urN xf86-input-evdev-2.8.2.old/src/synproto.c xf86-input-evdev-2.8.2/src/synproto.c
--- xf86-input-evdev-2.8.2.old/src/synproto.c	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/synproto.c	2013-12-06 19:11:54.542702019 +0900
@@ -0,0 +1,170 @@
+/*
+ * Copyright © 2012 Canonical, Ltd.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+#include "synproto.h"
+#include "synapticsstr.h"
+
+static int
+HwStateAllocTouch(struct SynapticsHwState *hw, SynapticsPrivate * priv)
+{
+    int num_vals;
+    int i = 0;
+
+    hw->num_mt_mask = priv->num_slots;
+    hw->mt_mask = malloc(hw->num_mt_mask * sizeof(ValuatorMask *));
+    if (!hw->mt_mask)
+        goto fail;
+
+    num_vals = 2;               /* x and y */
+    num_vals += 2;              /* scroll axes */
+    num_vals += priv->num_mt_axes;
+
+    for (; i < hw->num_mt_mask; i++) {
+        hw->mt_mask[i] = valuator_mask_new(num_vals);
+        if (!hw->mt_mask[i])
+            goto fail;
+    }
+
+    hw->slot_state = calloc(hw->num_mt_mask, sizeof(enum SynapticsSlotState));
+    if (!hw->slot_state)
+        goto fail;
+
+    return Success;
+
+ fail:
+    for (i--; i >= 0; i--)
+        valuator_mask_free(&hw->mt_mask[i]);
+    free(hw->mt_mask);
+    hw->mt_mask = NULL;
+    return BadAlloc;
+}
+
+struct SynapticsHwState *
+SynapticsHwStateAlloc(SynapticsPrivate * priv)
+{
+    struct SynapticsHwState *hw;
+
+    hw = calloc(1, sizeof(struct SynapticsHwState));
+    if (!hw)
+        return NULL;
+
+    if (HwStateAllocTouch(hw, priv) != Success) {
+        free(hw);
+        return NULL;
+    }
+
+    return hw;
+}
+
+void
+SynapticsHwStateFree(struct SynapticsHwState **hw)
+{
+    int i;
+
+    if (!*hw)
+        return;
+
+    free((*hw)->slot_state);
+    for (i = 0; i < (*hw)->num_mt_mask; i++)
+        valuator_mask_free(&(*hw)->mt_mask[i]);
+    free((*hw)->mt_mask);
+
+    free(*hw);
+    *hw = NULL;
+}
+
+void
+SynapticsCopyHwState(struct SynapticsHwState *dst,
+                     const struct SynapticsHwState *src)
+{
+    int i;
+
+    dst->millis = src->millis;
+    dst->x = src->x;
+    dst->y = src->y;
+    dst->z = src->z;
+    dst->cumulative_dx = src->cumulative_dx;
+    dst->cumulative_dy = src->cumulative_dy;
+    dst->numFingers = src->numFingers;
+    dst->fingerWidth = src->fingerWidth;
+    dst->left = src->left & BTN_EMULATED_FLAG ? 0 : src->left;
+    dst->right = src->right & BTN_EMULATED_FLAG ? 0 : src->right;
+    dst->up = src->up;
+    dst->down = src->down;
+    memcpy(dst->multi, src->multi, sizeof(dst->multi));
+    dst->middle = src->middle & BTN_EMULATED_FLAG ? 0 : src->middle;
+    for (i = 0; i < dst->num_mt_mask && i < src->num_mt_mask; i++)
+        valuator_mask_copy(dst->mt_mask[i], src->mt_mask[i]);
+    memcpy(dst->slot_state, src->slot_state,
+           dst->num_mt_mask * sizeof(enum SynapticsSlotState));
+}
+
+void
+SynapticsResetHwState(struct SynapticsHwState *hw)
+{
+    hw->millis = 0;
+    hw->x = INT_MIN;
+    hw->y = INT_MIN;
+    hw->z = 0;
+    hw->cumulative_dx = 0;
+    hw->cumulative_dy = 0;
+    hw->numFingers = 0;
+    hw->fingerWidth = 0;
+
+    hw->left = 0;
+    hw->right = 0;
+    hw->up = 0;
+    hw->down = 0;
+
+    hw->middle = 0;
+    memset(hw->multi, 0, sizeof(hw->multi));
+
+    SynapticsResetTouchHwState(hw, TRUE);
+}
+
+void
+SynapticsResetTouchHwState(struct SynapticsHwState *hw, Bool set_slot_empty)
+{
+    int i;
+
+    for (i = 0; i < hw->num_mt_mask; i++) {
+        int j;
+
+        /* Leave x and y valuators in case we need to restart touch */
+        for (j = 2; j < valuator_mask_num_valuators(hw->mt_mask[i]); j++)
+            valuator_mask_unset(hw->mt_mask[i], j);
+
+        switch (hw->slot_state[i]) {
+        case SLOTSTATE_OPEN:
+        case SLOTSTATE_OPEN_EMPTY:
+        case SLOTSTATE_UPDATE:
+            hw->slot_state[i] =
+                set_slot_empty ? SLOTSTATE_EMPTY : SLOTSTATE_OPEN_EMPTY;
+            break;
+
+        default:
+            hw->slot_state[i] = SLOTSTATE_EMPTY;
+            break;
+        }
+    }
+}
diff -urN xf86-input-evdev-2.8.2.old/src/synproto.h xf86-input-evdev-2.8.2/src/synproto.h
--- xf86-input-evdev-2.8.2.old/src/synproto.h	1970-01-01 09:00:00.000000000 +0900
+++ xf86-input-evdev-2.8.2/src/synproto.h	2013-12-06 19:11:54.542702019 +0900
@@ -0,0 +1,131 @@
+/*
+ * Copyright © 2004 Peter Osterlund
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of Red Hat
+ * not be used in advertising or publicity pertaining to distribution
+ * of the software without specific, written prior permission.  Red
+ * Hat makes no representations about the suitability of this software
+ * for any purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE AUTHORS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN
+ * NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
+ * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+ * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Authors:
+ *      Peter Osterlund (petero2@telia.com)
+ */
+
+#ifndef _SYNPROTO_H_
+#define _SYNPROTO_H_
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <xf86Xinput.h>
+#include <xisb.h>
+
+struct _SynapticsPrivateRec;
+typedef struct _SynapticsPrivateRec SynapticsPrivate;
+
+enum SynapticsSlotState {
+    SLOTSTATE_EMPTY = 0,
+    SLOTSTATE_OPEN,
+    SLOTSTATE_CLOSE,
+    SLOTSTATE_OPEN_EMPTY,
+    SLOTSTATE_UPDATE,
+};
+
+/* used to mark emulated hw button state */
+#define BTN_EMULATED_FLAG 0x80
+
+/*
+ * A structure to describe the state of the touchpad hardware (buttons and pad)
+ */
+struct SynapticsHwState {
+    CARD32 millis;              /* Timestamp in milliseconds */
+    int x;                      /* X position of finger */
+    int y;                      /* Y position of finger */
+    int z;                      /* Finger pressure */
+    int cumulative_dx;          /* Cumulative delta X for clickpad dragging */
+    int cumulative_dy;          /* Cumulative delta Y for clickpad dragging */
+    int numFingers;
+    int fingerWidth;
+
+    Bool left;
+    Bool right;
+    Bool up;
+    Bool down;
+
+    Bool multi[8];
+    Bool middle;                /* Some ALPS touchpads have a middle button */
+    
+    Bool trackpoint_middle;
+
+    int num_mt_mask;
+    ValuatorMask **mt_mask;
+    enum SynapticsSlotState *slot_state;
+};
+
+struct CommData {
+    XISBuffer *buffer;
+    unsigned char protoBuf[6];  /* Buffer for Packet */
+    unsigned char lastByte;     /* Last read byte. Use for reset sequence detection. */
+    int outOfSync;              /* How many consecutive incorrect packets we
+                                   have received */
+    int protoBufTail;
+
+    /* Used for keeping track of partial HwState updates. */
+    struct SynapticsHwState *hwState;
+    Bool oneFinger;
+    Bool twoFingers;
+    Bool threeFingers;
+};
+
+struct _SynapticsParameters;
+
+struct SynapticsProtocolOperations {
+    Bool (*DeviceOnHook) (InputInfoPtr pInfo,
+                          struct _SynapticsParameters * para);
+    Bool (*DeviceOffHook) (InputInfoPtr pInfo);
+    Bool (*QueryHardware) (InputInfoPtr pInfo);
+    Bool (*ReadHwState) (InputInfoPtr pInfo,
+                         struct CommData * comm,
+                         struct SynapticsHwState * hwRet);
+    Bool (*AutoDevProbe) (InputInfoPtr pInfo, const char *device);
+    void (*ReadDevDimensions) (InputInfoPtr pInfo);
+};
+
+#ifdef BUILD_PS2COMM
+extern struct SynapticsProtocolOperations psaux_proto_operations;
+extern struct SynapticsProtocolOperations alps_proto_operations;
+#endif                          /* BUILD_PS2COMM */
+#ifdef BUILD_EVENTCOMM
+extern struct SynapticsProtocolOperations event_proto_operations;
+#endif                          /* BUILD_EVENTCOMM */
+#ifdef BUILD_PSMCOMM
+extern struct SynapticsProtocolOperations psm_proto_operations;
+#endif                          /* BUILD_PSMCOMM */
+
+extern struct SynapticsHwState *SynapticsHwStateAlloc(SynapticsPrivate * priv);
+extern void SynapticsHwStateFree(struct SynapticsHwState **hw);
+extern void SynapticsCopyHwState(struct SynapticsHwState *dst,
+                                 const struct SynapticsHwState *src);
+extern void SynapticsResetHwState(struct SynapticsHwState *hw);
+extern void SynapticsResetTouchHwState(struct SynapticsHwState *hw,
+                                       Bool set_slot_empty);
+
+extern Bool SynapticsIsSoftButtonAreasValid(int *values);
+
+#endif                          /* _SYNPROTO_H_ */
